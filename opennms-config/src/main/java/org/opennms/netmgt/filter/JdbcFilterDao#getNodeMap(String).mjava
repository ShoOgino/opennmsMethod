    /**
     * {@inheritDoc}
     *
     * This method returns a map of all nodeids and nodelabels that match
     * the rule that is passed in, sorted by nodeid.
     * @exception FilterParseException
     *                if a rule is syntactically incorrect or failed in
     *                executing the SQL statement
     */
    @Override
    public SortedMap<Integer, String> getNodeMap(final String rule) throws FilterParseException {
    	final SortedMap<Integer, String> resultMap = new TreeMap<Integer, String>();
        String sqlString;

        LOG.debug("Filter.getNodeMap({})", rule);

        // get the database connection
        Connection conn = null;
        final DBUtils d = new DBUtils(getClass());
        try {
            conn = getDataSource().getConnection();
            d.watch(conn);

            // parse the rule and get the sql select statement
            sqlString = getNodeMappingStatement(rule);
            LOG.debug("Filter.getNodeMap({}): SQL statement: {}", rule, sqlString);

            // execute query
            final Statement stmt = conn.createStatement();
            d.watch(stmt);
            final ResultSet rset = stmt.executeQuery(sqlString);
            d.watch(rset);

            if (rset != null) {
                // Iterate through the result and build the map
                while (rset.next()) {
                    resultMap.put(Integer.valueOf(rset.getInt(1)), rset.getString(2));
                }
            }
        } catch (final FilterParseException e) {
            LOG.warn("Filter Parse Exception occurred getting node map.", e);
            throw new FilterParseException("Filter Parse Exception occurred getting node map: " + e.getLocalizedMessage(), e);
        } catch (final SQLException e) {
            LOG.warn("SQL Exception occurred getting node map.", e);
            throw new FilterParseException("SQL Exception occurred getting node map: " + e.getLocalizedMessage(), e);
        } catch (final Throwable e) {
            LOG.error("Exception getting database connection.", e);
            throw new UndeclaredThrowableException(e);
        } finally {
            d.cleanUp();
        }

        return Collections.unmodifiableSortedMap(resultMap);
    }

