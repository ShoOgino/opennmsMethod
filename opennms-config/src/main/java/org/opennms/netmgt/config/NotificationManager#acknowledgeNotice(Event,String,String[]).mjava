    /**
     * <p>acknowledgeNotice</p>
     *
     * @param event a {@link org.opennms.netmgt.xml.event.Event} object.
     * @param uei a {@link java.lang.String} object.
     * @param matchList an array of {@link java.lang.String} objects.
     * @return a {@link java.util.Collection} object.
     * @throws java.sql.SQLException if any.
     * @throws java.io.IOException if any.
     */
    public Collection<Integer> acknowledgeNotice(final Event event, final String uei, final String[] matchList) throws SQLException, IOException {
        List<Integer> notifIDs = new LinkedList<>();
        final DBUtils dbUtils = new DBUtils(getClass());

        try {
            // First get most recent event ID from notifications 
            // that match the matchList, then get all notifications
            // with this event ID

            // Verify if parameter matching is required
            boolean matchParameters = false;
            for (int i = 0; i < matchList.length; i++) {
                if (matchList[i].startsWith("parm[")) {
                    matchParameters = true;
                    break;
                }
            }

            final Map<String, String> eventParametersToMatch = new LinkedHashMap<>();
            final StringBuilder sql = new StringBuilder("SELECT n.eventid FROM notifications n ");
            if (matchParameters) {
                sql.append("INNER JOIN events as e on e.eventid = n.eventid ");
                for (int i = 0; i < matchList.length; i++) {
                    if (matchList[i].startsWith("parm[")) {
                        if (appendParameterNameAndValue(matchList[i], event, eventParametersToMatch)) {
                            sql.append(String.format("INNER JOIN event_parameters as ep%d on ep%d.eventid = n.eventid and ep%d.name=? and ep%d.value=? ",
                                    i, i, i, i));
                        } else {
                            // The given event does contain the specified parameter, so no match can be made
                            LOG.warn("No parameter matching {} was found on {}. No notices with UEI {} will be acknowledged.",
                                    matchList[i], event, uei);
                            // No DB connections have been acquired yet, so we can return immediately
                            return Collections.emptyList();
                        }
                    }
                }
                LOG.debug("Matching notices with UEI {} against event parameters: {}", uei, eventParametersToMatch);
            }
            sql.append("WHERE n.eventuei=? ");
            for (int i = 0; i < matchList.length; i++) {
                if (!matchList[i].startsWith("parm[")) {
                    sql.append("AND n.").append(matchList[i]).append("=? ");
                }
            }
            sql.append("ORDER BY eventid desc limit 1");

            Connection connection = getConnection();
            dbUtils.watch(connection);
            PreparedStatement statement = connection.prepareStatement(sql.toString());
            dbUtils.watch(statement);

            int offset = 1;
            for (Map.Entry<String, String> eventParameterToMatch : eventParametersToMatch.entrySet()) {
                statement.setString(offset++, eventParameterToMatch.getKey());
                statement.setString(offset++, eventParameterToMatch.getValue());
            }

            statement.setString(offset++, uei);

            for (int i = 0; i < matchList.length; i++) {
                if (matchList[i].equals("nodeid")) {
                    statement.setLong(offset++, event.getNodeid());
                } else if (matchList[i].equals("interfaceid")) {
                    statement.setString(offset++, event.getInterface());
                } else if (matchList[i].equals("serviceid")) {
                    statement.setInt(offset++, getServiceId(event.getService()));
                } else if (matchList[i].startsWith("parm[")) {
                    // Ignore
                } else {
                    LOG.warn("Unknown match statement {} for UEI {}.", matchList[i], uei);
                }
            }

            ResultSet results = statement.executeQuery();
            dbUtils.watch(results);
            if (results != null && results.next()) {
                int eventID = results.getInt(1);
                notifIDs = doAcknowledgeNotificationsFromEvent(connection, dbUtils, eventID);
            } else {
                LOG.debug("No matching DOWN eventID found");
            }
        } finally {
            dbUtils.cleanUp();
        }
        return notifIDs;
    }

