    /**
     * Adjusts 2 ordered ranges in the wrapped definition by determining if the nextRange is
     * either eclipsed, or overlapped by its previousRange.
     * 
     * @param previousRange
     * @param nextRange
     */
    private void optimizeAdjacentRanges(final Range previousRange, final Range nextRange) {
        MergeableRange range = new MergeableRange(previousRange);
        
        if (range.equals(nextRange)) {
            getConfigDef().removeRange(previousRange);
            
        } else if (range.eclipses(nextRange)) {
            
            //We have to do this because of the side effects of object references
            nextRange.setBegin(previousRange.getBegin());
            nextRange.setEnd(previousRange.getEnd());
            getConfigDef().removeRange(previousRange);
            
        } else if (range.isAdjacentToBegin(nextRange) || range.overlapsBegin(nextRange)){
            nextRange.setBegin(previousRange.getBegin());
            getConfigDef().removeRange(previousRange);
            
        } else if (range.isAdjacentToEnd(nextRange) || range.overlapsEnd(nextRange)) {
            
            //this "probably" should never happen
            nextRange.setEnd(previousRange.getEnd());
            getConfigDef().removeRange(previousRange);
        }
    }

