    /**
     * <p>getRanges</p>
     *
     * @return a {@link java.util.List} object.
     */
    public List<IPPollRange> getRanges() {
        final List<IPPollRange> includes = new LinkedList<IPPollRange>();

        getReadLock().lock();
        
        try {
            Long defaultTimeout = null;
            Integer defaultRetries = null;
            if (getConfiguration().hasTimeout()) defaultTimeout = getConfiguration().getTimeout();
            if (getConfiguration().hasRetries()) defaultRetries = getConfiguration().getRetries();
            
            for (final IncludeRange ir : getConfiguration().getIncludeRangeCollection()) {
        
                // Validate IP range; if invalid, then log and discard this range
                try {
                    InetAddressUtils.toIpAddrBytes(ir.getBegin());
                } catch (Throwable e) {
                    LogUtils.warnf(this, "Begin address of discovery range is invalid, discarding: %s", ir.getBegin());
                    continue;
                } 
                
                try {
                    InetAddressUtils.toIpAddrBytes(ir.getEnd());
                } catch (Throwable e) {
                    LogUtils.warnf(this, "End address of discovery range is invalid, discarding: %s", ir.getEnd());
                    continue;
                }

                long timeout = 800L;
                if (ir.hasTimeout()) {
                    timeout = ir.getTimeout();
                } else if (defaultTimeout != null) {
                    timeout = defaultTimeout;
                }
        
                int retries = 3;
                if (ir.hasRetries()) {
                    retries = ir.getRetries();
                } else if (defaultRetries != null) {
                    retries = defaultRetries;
                }
        
                try {
                    includes.add(new IPPollRange(ir.getBegin(), ir.getEnd(), timeout, retries));
                } catch (final UnknownHostException uhE) {
                    LogUtils.warnf(this, uhE, "Failed to convert address range (%s, %s)", ir.getBegin(), ir.getEnd());
                }
            }
        
            return includes;
        } finally {
            getReadLock().unlock();
        }
    }

