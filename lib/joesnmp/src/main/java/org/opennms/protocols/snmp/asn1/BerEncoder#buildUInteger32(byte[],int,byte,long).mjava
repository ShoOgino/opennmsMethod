    /**
     * 
     * The buildUInteger32() method is used to encode an ASN.1 32-bit unsigned
     * integer into the specified byte buffer.
     * 
     * @param buf
     *            The output buffer of encoded bytes.
     * @param startOffset
     *            The offset from the start of the buffer where the method
     *            should start writing the encoded data.
     * @param asnType
     *            The ASN.1 type to place in the buffer
     * @param asnUInt32
     *            The 32-bit unsigned integer to encode.
     * 
     * @return Returns the new offset for the next encoding routine. If
     *         startOffset is subtracted from the return value then the length
     *         of the encoded data can be determined.
     * 
     * @exception AsnEncodingException
     *                Thrown if an error occurs encoding the datatype.
     * 
     */
    public int buildUInteger32(byte[] buf, int startOffset, byte asnType, long asnUInt32) throws AsnEncodingException {
        //
        // NOTE: the value is a 'long' which is 64 bits long, but we only use
        // the lower order 32-bits! If the number is greater than 2^32 - 1
        // the upper order bits will be lost!

        //
        // Store a copy of the value to mask off the
        // unnecessary bits. There should not be any
        // sequence of 9 consecutive 1's or 0 bits
        //
        long mask = 0xff800000L;
        int intSz = 4; // int == 32-bits == 4 bytes in java
        boolean bAddNullByte = false;

        //
        // check to see if an additional (zero) byte is needed
        // Since an Integer is a signed 32-bit quantity, if the
        // passed long is greater than Integer.MAX_VALUE (2^31-1)
        // then it must have the high-bit (2^32) set!
        //
        // effectively checking to see if (asnUInt32 & 0x80000000L) != 0
        //
        if (asnUInt32 > (long) (Integer.MAX_VALUE)) {
            bAddNullByte = true;
            intSz++;
        }

        //
        // check for and remove any sequence of 9 consecutive zeros
        // from the head of the number
        //
        // NOTE: 10/9/00 Weave - This use to also mask off any set
        // of 9 consecutive 1's as well, but that didn't make
        // any sense because it's unsigned. What if you wanted
        // to send 0xffffffffL, masking off the ones would be
        // incorrect cause for unsigned there isn't going to
        // be a sign extension.
        //
        while ((asnUInt32 & mask) == 0 && intSz > 1) {
            --intSz;
            asnUInt32 = (asnUInt32 << 8);
        }

        //
        // build the header
        //
        startOffset = buildHeader(buf, startOffset, asnType, intSz);

        //
        // verify the buffer length
        //
        if ((buf.length - startOffset) < intSz)
            throw new AsnEncodingException("Buffer overflow error");

        //
        // Add the null byte if necessary
        //
        if (bAddNullByte) {
            buf[startOffset++] = (byte) 0;
            --intSz;
        }

        //
        // mask off and store the values
        //
        mask = 0xff000000L;
        while (intSz-- > 0) {
            byte b = (byte) ((asnUInt32 & mask) >>> 24);
            buf[startOffset++] = b;
            asnUInt32 = (asnUInt32 << 8);
        }

        //
        // return the result
        //
        return startOffset;
    }

