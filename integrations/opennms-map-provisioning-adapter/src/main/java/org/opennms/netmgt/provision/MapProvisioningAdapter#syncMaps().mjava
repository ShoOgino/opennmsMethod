    @SuppressWarnings("unchecked")
    private void syncMaps() throws ProvisioningAdapterException {

        try {
            m_template.execute(new TransactionCallback() {
                public Object doInTransaction(TransactionStatus arg0) {

                    log().info("syncMaps: acquiring lock...");
                    synchronized (m_lock) {
                        log().debug("syncMaps: lock acquired.  syncing maps...");

                        List<Cmap> cmaps = m_mapsAdapterConfig.getAllMaps();
                        m_mapNameMapSizeListMap = new ConcurrentHashMap<String, Integer>(cmaps.size());
                        Map<String,OnmsMap> mapNames= new ConcurrentHashMap<String,OnmsMap>(cmaps.size());
                        for (Cmap cmap: cmaps) {
                            OnmsMap onmsMap = new OnmsMap();
                            onmsMap.setName(cmap.getMapName());
                            onmsMap.setType(OnmsMap.AUTOMATICALLY_GENERATED_MAP);
                            mapNames.put(cmap.getMapName(),onmsMap);
                        }

                        Date now = new Date();
                        log().debug("syncMaps: sync automated and static maps in database with configuration");
                        
                        log().debug("syncMaps: deleting elements from automated existing map: ");
                        m_onmsMapElementDao.deleteElementsByMapType(OnmsMap.AUTOMATICALLY_GENERATED_MAP);
                        m_onmsMapElementDao.deleteElementsByType(OnmsMapElement.MAP_HIDE_TYPE);
                        m_onmsMapElementDao.deleteElementsByType(OnmsMapElement.NODE_HIDE_TYPE);                        
                        
                        for (OnmsMap onmsMap : m_onmsMapDao.findAutoAndSaveMaps()) {  
                            if ( mapNames.containsKey(onmsMap.getName()) || onmsMap.getType().equals(OnmsMap.AUTOMATIC_SAVED_MAP)) {
                                log().debug("syncMaps: fetching map from db: " +onmsMap.getName() + " type: " + onmsMap.getType());
                                mapNames.put(onmsMap.getName(), onmsMap);
                            } else {
                                log().debug("syncMaps: deleting old automated map: " + onmsMap.getName());
                                log().debug("syncMaps: removing as map Element from all maps.");
                                m_onmsMapElementDao.deleteElementsByElementIdAndType(onmsMap.getId(), OnmsMapElement.MAP_TYPE);
                                log().debug("syncMaps: removing from map table.");
                                m_onmsMapDao.delete(onmsMap);
                            }
                        }
                        
                        for (Cmap cmap: cmaps) {
                            OnmsMap onmsMap = mapNames.get(cmap.getMapName());

                            if (onmsMap.getType().equals(OnmsMap.AUTOMATICALLY_GENERATED_MAP)) {
                                log().debug("syncMaps: sync automated map: " + onmsMap.getName());
    
                                onmsMap.setOwner(cmap.getMapOwner());
                                onmsMap.setUserLastModifies(cmap.getMapOwner());
                                onmsMap.setMapGroup(cmap.getMapGroup());
                                onmsMap.setAccessMode(cmap.getMapAccess());
                                onmsMap.setBackground(cmap.getMapBG());
                                onmsMap.setHeight(cmap.getMapHeight());
                                onmsMap.setWidth(cmap.getMapWidth());
                                onmsMap.setLastModifiedTime(now);
    
                                m_onmsMapDao.saveOrUpdate(onmsMap);
                                m_mapNameMapSizeListMap.put(cmap.getMapName(),0);
                            } else {
                                log().debug("syncMaps: skipping not automated map: " + onmsMap.getName());
                                log().debug("syncMaps: map type: " + onmsMap.getType());
                            }
                        }
                        // adding nodes to auto maps
                        for(OnmsNode node: m_onmsNodeDao.findAllProvisionedNodes()) {
                            log().debug("syncMaps: try to sync automated maps for node element: '" + node.getLabel() +"'");
                            Map<String, Celement> mapNameCelements = m_mapsAdapterConfig.getElementByAddress(getSuitableIp(node));
                            for (String mapName: mapNameCelements.keySet()) {
                                Celement celement = mapNameCelements.get(mapName);
                                OnmsMap onmsMap = mapNames.get(mapName);
                                if (onmsMap.getType().equals(OnmsMap.AUTOMATICALLY_GENERATED_MAP)) {
                                    log().debug("syncMaps: adding node: " + node.getLabel() + " to map: " + mapName);
                                    int elementsize = m_mapNameMapSizeListMap.get(mapName);
                                    log().debug("syncMaps: mapElement is new: found last mapElement at position #" + elementsize + " on map: " + mapName);                    
                                    XY xy=getXY(onmsMap, elementsize);
                                    log().debug("syncMaps: mapElement is new: saved last mapElement at X position: " +  xy.getX());
                                    log().debug("syncMaps: mapElement is new: saved last mapElement at Y position: " +  xy.getY());
                                    m_onmsMapElementDao.save(
                                       new OnmsMapElement(onmsMap,node.getId(),OnmsMapElement.NODE_TYPE,getLabel(node.getLabel()),celement.getIcon(),xy.getX(),xy.getY())
                                    );
                                    m_mapNameMapSizeListMap.replace(mapName, ++elementsize);
                                } else  if (m_onmsMapElementDao.findElement(node.getId(), OnmsMapElement.NODE_TYPE, onmsMap) == null &&
                                            m_onmsMapElementDao.findElement(node.getId(), OnmsMapElement.NODE_HIDE_TYPE, onmsMap) == null) {
                                    m_onmsMapElementDao.save(
                                       new OnmsMapElement(onmsMap,node.getId(),OnmsMapElement.NODE_HIDE_TYPE,getLabel(node.getLabel()),celement.getIcon(),0,0)
                                    );   
                                }
                            }
                        }

                        Map<String,List<Csubmap>> submaps = m_mapsAdapterConfig.getsubMaps();
                        
                        for (String mapName : submaps.keySet()) {
                            OnmsMap onmsMap = mapNames.get(mapName);
                            log().debug("syncMaps: found container map: " + mapName + " type: " + onmsMap.getType());
                            Collection<OnmsMapElement> elements = new ArrayList<OnmsMapElement>();
                            boolean auto;
                            if (onmsMap.getType().equals(OnmsMap.AUTOMATICALLY_GENERATED_MAP)) {
                                auto = true;
                            } else if (onmsMap.getType().equals(OnmsMap.AUTOMATIC_SAVED_MAP)) {
                                elements = m_onmsMapElementDao.findElementsByMapIdAndType(onmsMap.getId(), OnmsMapElement.MAP_TYPE);
                                auto = false;
                            } else {
                                log().debug("syncMaps: cannot add submaps to map: " + mapName);
                                continue;
                            }
SUBMAP:                     for (Csubmap csubmap : submaps.get(mapName)) {
                                OnmsMap onmsSubMap = mapNames.get(csubmap.getName());
                                log().debug("syncMaps: add submap: " + csubmap.getName());
                                if ( (!csubmap.getAddwithoutelements()) &&
                                    m_mapNameMapSizeListMap.get(csubmap.getName())==0)
                                    continue;
                                log().debug("syncMaps: add submap: " + csubmap.getName() + "to map: " + mapName);
                                if (auto) {
                                    XY xy = new XY();
                                    if (csubmap.hasX() && csubmap.hasY()) {
                                        xy.setX(csubmap.getX());
                                        xy.setY(csubmap.getY());
                                    } else {
                                        int elementsize = m_mapNameMapSizeListMap.get(mapName);
                                        xy=getXY(onmsMap, elementsize);
                                        m_mapNameMapSizeListMap.replace(mapName, ++elementsize);
                                    }                                    
                                    m_onmsMapElementDao.save(new OnmsMapElement(onmsMap,onmsSubMap.getId(),OnmsMapElement.MAP_TYPE,csubmap.getLabel(),csubmap.getIcon(),xy.getX(),xy.getY()));                                    
                                } else {
                                    for (OnmsMapElement element: elements) {
                                        if (element.getElementId() == onmsSubMap.getId()) continue SUBMAP;
                                    }
                                    m_onmsMapElementDao.save(new OnmsMapElement(onmsMap,onmsSubMap.getId(),OnmsMapElement.MAP_HIDE_TYPE,csubmap.getLabel(),csubmap.getIcon(),0,0));                                                                        
                                }
                                
                            }
                            
                        }
                        log().debug("syncMaps: maps synchronized.  releasing lock...");
                    }
                    log().info("syncMaps: lock released.");
                    return null;
                }

            });
        } catch (Exception e) {
            log().error("syncMaps: Caught exception synchronizing maps: "+e, e);
            throw new ProvisioningAdapterException("syncMaps exception",e);
        }
    }    

