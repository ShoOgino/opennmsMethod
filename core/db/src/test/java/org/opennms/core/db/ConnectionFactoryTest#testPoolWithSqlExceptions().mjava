	public void testPoolWithSqlExceptions() throws Exception {
		DaoTestConfigBean bean = new DaoTestConfigBean();
		bean.afterPropertiesSet();

		AtomikosDataSourceFactory factory = makeFactory("opennms");
		factory.afterPropertiesSet();
		// Verify the default values
		assertEquals(30, factory.poolAvailableSize());
		assertEquals(30, factory.poolTotalSize());
		// Close the factory so that we can reregister another factory with the same name
		factory.close();

		final AtomikosDataSourceFactory factory2 = makeFactory("opennms");
		factory2.setPoolSize(50);
		factory2.afterPropertiesSet();
		// Verify the altered values
		assertEquals(50, factory2.poolAvailableSize());
		assertEquals(50, factory2.poolTotalSize());

		// Spawn a bunch of threads that generate continuous SQLExceptions
		for (int i = 0; i < 2000; i++) {
			new Thread() {
				public void run() {
					Connection conn = null;
					try {
						assertEquals(50, factory2.poolTotalSize());

						conn = factory2.getConnection();

						// Make sure that the total size of the pool stays at 50
						assertEquals(50, factory2.poolTotalSize());
						assertTrue(factory2.poolAvailableSize() > 0);
						// Fetching the current connection will push the available connections below 50
						assertTrue(factory2.poolAvailableSize() < 50);

						Statement stmt = conn.createStatement();
						stmt.execute("BEGIN");
						stmt.execute("SELECT * FROM doesnt_exist_in_the_database");
					} catch (SQLException e) {
						e.printStackTrace();
					} finally {
						if (conn != null) {
							try {
								Statement stmt = conn.createStatement();
								stmt.execute("ROLLBACK");
								conn.close();
							} catch (SQLException e) {
								fail("Exception thrown when trying to close connection");
							}
						}
					}
				}
			}.start();

			// Only sleep for a bit after spawning 10 threads so that we force some
			// contention.
			if (i % 10 == 0) Thread.sleep(200);
		}
	}

