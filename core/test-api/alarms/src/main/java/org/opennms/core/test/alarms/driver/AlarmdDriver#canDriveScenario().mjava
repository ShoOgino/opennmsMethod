    @Test
    public void canDriveScenario() {
        if (scenario.getActions().size() == 0) {
            return;
        }

        try {
            final Map<Long,List<Action>> actionsByTick = scenario.getActions().stream()
                    .collect(Collectors.groupingBy(a -> roundToTick(a.getTime())));

            final long start = Math.max(scenario.getActions().stream()
                    .min(Comparator.comparing(Action::getTime))
                    .map(e -> roundToTick(e.getTime()))
                    .get() - scenario.getTickLengthMillis(), 0);
            final long end = scenario.getActions().stream()
                    .max(Comparator.comparing(Action::getTime))
                    .map(e -> roundToTick(e.getTime()))
                    .get() + scenario.getTickLengthMillis();

            if (start > 0) {
                // Tick
                PseudoClock.getInstance().advanceTime(scenario.getTickLengthMillis(), TimeUnit.MILLISECONDS);
                m_droolsAlarmContext.getClock().advanceTime(scenario.getTickLengthMillis(), TimeUnit.MILLISECONDS);
                m_droolsAlarmContext.tick();
            }

            for (long now = start; now <= end; now += scenario.getTickLengthMillis()) {
                // Perform the actions
                final List<Action> actions = actionsByTick.get(now);
                if (actions != null) {
                    for (Action  a : actions) {
                        a.visit(this);
                    }
                }

                // Tick
                PseudoClock.getInstance().advanceTime(scenario.getTickLengthMillis(), TimeUnit.MILLISECONDS);
                m_droolsAlarmContext.getClock().advanceTime(scenario.getTickLengthMillis(), TimeUnit.MILLISECONDS);
                m_droolsAlarmContext.tick();
                results.addAlarms(now, m_transactionTemplate.execute((t) -> {
                            final List<OnmsAlarm> alarms = m_alarmDao.findAll();
                            alarms.forEach(a -> Hibernate.initialize(a.getAssociatedAlarms()));
                            return alarms;
                        }));
            }

            // Tick every 5 minutes for the next 24 hours
            tickAtRateUntil(TimeUnit.MINUTES.toMillis(5),
                    end,
                    end + TimeUnit.DAYS.toMillis(1));

            // Tick every hour for the next week
            tickAtRateUntil(TimeUnit.HOURS.toMillis(1),
                    end + TimeUnit.DAYS.toMillis(1),
                    end + TimeUnit.DAYS.toMillis(8));
        } catch (Exception e) {
            LOG.error("Error occurred: {}", e.getMessage(), e);
            throw e;
        }
    }

