    /**
     * <p>matches</p>
     *
     * @param address a {@link java.lang.String} object.
     * @param pattern a {@link java.lang.String} object.
     * @return a boolean.
     */
    public static boolean matches(String address, String pattern) {
        final AddressType addressType = classifyAddress(address);
        final AddressType patternType = classifyAddress(pattern);

        if (addressType != patternType) {
            // Different address types will never match
            return false;
        }

        final String[] addressFields;
        final String[] patternFields;
        final int expectedFieldCount;
        final RangeMatcher matcher;
        switch (addressType) {
            case IPv4: {
                addressFields = parseIPv4Address(address);
                patternFields = parseIPv4Address(pattern);
                expectedFieldCount = 4;
                matcher = new DecimalRangeMatcher();
                break;
            }

            case IPv6: {
                final IPv6Address parsedAddress = parseIPv6Address(address);
                final IPv6Address parsedPattern = parseIPv6Address(pattern);

                if (parsedPattern.scope != null) {
                    if (parsedAddress.scope == null) {
                        // Fail if scope is expected but does not exists
                        return false;
                    } else {
                        // Assume that scope identifiers are always decimal
                        if (!matchNumericListOrRange(parsedAddress.scope, parsedPattern.scope, new DecimalRangeMatcher())) {
                            return false;
                        }
                    }
                }

                addressFields = parsedAddress.fields;
                patternFields = parsedPattern.fields;
                expectedFieldCount = 8;
                matcher = new HexRangeMatcher();
                break;
            }

            default: throw new IllegalStateException();
        }

        if (addressFields.length != expectedFieldCount) {
            throw new IllegalArgumentException("Malformatted IP address: " + address);
        }

        if (patternFields.length != expectedFieldCount) {
            throw new IllegalArgumentException("Malformatted IPLIKE match expression: " + pattern);
        }

        for (int i = 0; i < expectedFieldCount; i++) {
            if (!matchNumericListOrRange(addressFields[i], patternFields[i], matcher)) {
                return false;
            }
        }

        return true;
    }

