    /**
     * Build the {@link ZonedDateTime} instance. The following fields
     * are required to generate a datestamp:
     * 
     * <ul>
     * <li>month</li>
     * <li>dayOfMonth</li>
     * </ul>
     * 
     * <p>If missing:</p>
     * 
     * <ul>
     * <li>year will be assumed to be within the last 12 months
     * or slightly in the future (if the current month is December)</li>
     * <li>hourOfDay, minute, second and nanosecond will be assumed to be zero</li>
     * <li>time zone will be assumed to be the system time zone
     * ({@link ZoneId#systemDefault()})</li>
     * </ul>
     * 
     * @return
     */
    public ZonedDateTime build() {
        if (m_month != null && m_dayOfMonth != null) {
            if (m_hourOfDay != null) {
                if (m_minute != null) {
                    if (m_second != null) {
                        if (m_nanosecond != null) {
                            return ZonedDateTime.of(getBestYear(), m_month, m_dayOfMonth, m_hourOfDay == null ? 0 : m_hourOfDay, m_minute, m_second, m_nanosecond, getBestZoneId());
                        } else {
                            return ZonedDateTime.of(getBestYear(), m_month, m_dayOfMonth, m_hourOfDay, m_minute, m_second, 0, getBestZoneId());
                        }
                    } else {
                        return ZonedDateTime.of(getBestYear(), m_month, m_dayOfMonth, m_hourOfDay, m_minute, 0, 0, getBestZoneId());
                    }
                } else {
                    return ZonedDateTime.of(getBestYear(), m_month, m_dayOfMonth, m_hourOfDay, 0, 0, 0, getBestZoneId());
                }
            } else {
                return ZonedDateTime.of(getBestYear(), m_month, m_dayOfMonth, 0, 0, 0, 0, getBestZoneId());
            }
        } else {
            throw new DateTimeException("Insufficient fields to produce a ZonedDateTime: month and dayOfMonth are required");
        }
    }

