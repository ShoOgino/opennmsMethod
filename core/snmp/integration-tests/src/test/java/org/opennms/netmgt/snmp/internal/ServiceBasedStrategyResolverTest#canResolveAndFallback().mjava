    /**
     * Validates all of the code paths in {@link ServiceBasedStrategyResolver#getStrategy}.
     */
    @Test
    public void canResolveAndFallback() {
          // Now create and bind a new mock strategy
        ServiceBasedStrategyResolver serviceBasedResolver = new ServiceBasedStrategyResolver();
        ServiceBasedStrategyResolver.register();
        SnmpStrategy strategy = serviceBasedResolver.getStrategy();
        SnmpStrategy mockStrategy = mock(SnmpStrategy.class);
        Map<String, String> props = new HashMap<>();
        props.put("implementation", "org.opennms.mock.MyMockStrategy");
        serviceBasedResolver.onBind(mockStrategy, props);

        try {
            // Grab the mock, as a fall-back
            strategy = serviceBasedResolver.getStrategy();
            assertEquals("Should fall back to using the first regitered strategy when the requested class is not registered"
                         , mockStrategy, strategy);

            // Now use the mock explicitly
            System.setProperty("org.opennms.snmp.strategyClass", "org.opennms.mock.MyMockStrategy");
            strategy = serviceBasedResolver.getStrategy();
            assertEquals(mockStrategy, strategy);

            // Unbind the mock
            serviceBasedResolver.onUnbind(mockStrategy, props);

            // Grabbing the strategy should fail now, we fall-back to the ClassBasedResolver
            // but it won't be able to instantiate our mock strategy
            try {
                serviceBasedResolver.getStrategy();
                fail("Should not be able to instantiate org.opennms.mock.MyMockStrategy");
            } catch (RuntimeException e) { }
        } finally {
            serviceBasedResolver.onUnbind(mockStrategy, props);
        }
    }

