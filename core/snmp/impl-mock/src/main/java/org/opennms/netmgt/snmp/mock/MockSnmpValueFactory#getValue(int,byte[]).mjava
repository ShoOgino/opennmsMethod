	@Override
	public SnmpValue getValue(int type, byte[] bytes) {
		if (bytes == null) return null;
		final ByteBuffer bb = ByteBuffer.allocate(bytes.length);
		bb.put(bytes);
		bb.flip();
		final String value = m_defaultCharset.decode(bb).toString();
		switch (type) {
			case SnmpValue.SNMP_COUNTER32:
				return SnmpUtils.parseMibValue("Counter32: " + value);
			case SnmpValue.SNMP_COUNTER64:
				return SnmpUtils.parseMibValue("Counter64: " + value);
			case SnmpValue.SNMP_END_OF_MIB:
				return MockSnmpValue.END_OF_MIB;
			case SnmpValue.SNMP_GAUGE32:
				return SnmpUtils.parseMibValue("Gauge32: " + value);
			case SnmpValue.SNMP_INT32:
				return SnmpUtils.parseMibValue("INTEGER: " + value);
			case SnmpValue.SNMP_IPADDRESS:
				return SnmpUtils.parseMibValue("IpAddress: " + value);
			case SnmpValue.SNMP_NO_SUCH_INSTANCE:
				return MockSnmpValue.NO_SUCH_INSTANCE;
			case SnmpValue.SNMP_NO_SUCH_OBJECT:
				return MockSnmpValue.NO_SUCH_OBJECT;
			case SnmpValue.SNMP_NULL:
				return MockSnmpValue.NULL_VALUE;
			case SnmpValue.SNMP_OBJECT_IDENTIFIER:
				return SnmpUtils.parseMibValue("OID: " + value);
			case SnmpValue.SNMP_OCTET_STRING:
				return SnmpUtils.parseMibValue("Hex-STRING: " + value);
			case SnmpValue.SNMP_TIMETICKS:
				return SnmpUtils.parseMibValue("Timeticks: " + value);
			case SnmpValue.SNMP_OPAQUE:
				throw new IllegalArgumentException("Unable to handle opaque types in MockSnmpValue");
			default:
		        throw new IllegalArgumentException("Unknown Snmp Type: "+type);
		}
	}

