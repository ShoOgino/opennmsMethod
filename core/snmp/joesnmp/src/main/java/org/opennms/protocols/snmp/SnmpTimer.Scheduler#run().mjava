        /**
         * Runs in an infinite loop waiting for new runnables to expire or for
         * the m_exit variable to be set true. The m_sync in the parent class is
         * used to synchronize this method
         * 
         */
        public void run() {
            LinkedList<Runnable> toRun = new LinkedList<Runnable>();
            while (true) {
                //
                // synchronize on the object
                //
                synchronized (m_sync) {
                    if (m_exit)
                        return;

                    //
                    // if there are no elements on the list
                    // then wait
                    //
                    if (m_list.size() == 0) {
                        try {
                            m_sync.wait();
                        } catch (InterruptedException err) {
                            return;
                        }

                        //
                        // restart the loop
                        //
                        continue;
                    }

                    //
                    // find the smallest time slice
                    // and run those in error
                    //
                    long now = System.currentTimeMillis();
                    boolean done = false;
                    long minTime = Long.MAX_VALUE;
                    ListIterator<TimeoutElement> iter = m_list.listIterator(0);

                    while (!done && iter.hasNext()) {
                        try {
                            //
                            // get the next timeout element
                            //
                            TimeoutElement elem = iter.next();
                            if (now > elem.m_when) {
                                //
                                // The element has expired
                                //
                                toRun.add(elem.m_toRun);
                                iter.remove();
                            } else {
                                //
                                // find out if this time is less
                                // than the one currently stored
                                //
                                if (elem.m_when < minTime)
                                    minTime = elem.m_when;
                            }
                        } catch (NoSuchElementException err) {
                            done = true;
                        } catch (ConcurrentModificationException err) {
                            done = true;
                        }
                    }

                    //
                    // if there are no elements to run
                    // then wait the minimum time until
                    // the synchronization object is signaled.
                    //
                    if (toRun.size() == 0) {
                        minTime -= now;
                        try {
                            if (minTime > 0)
                                m_sync.wait(minTime);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }

                } // end synchronization

                //
                // process the timeouts, if any
                //
                if (toRun.size() != 0) {
                    ListIterator<Runnable> iter = toRun.listIterator(0);
                    try {
                        while (true) {
                            Runnable runner = iter.next();
                            iter.remove();
                            runner.run();
                        }
                    } catch (NoSuchElementException err) {
                        // do nothing
                    } catch (Throwable err) {
                        //
                        // Bad, Bad Runnable!
                        //
                    }
                }

            } // end while loop

        }// end run method

