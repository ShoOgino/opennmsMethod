    /**
     * Transmits the specified SnmpRequest to the SnmpPeer defined. First the
     * SnmpPdu contained within the request is encoded using the peer
     * AsnEncoder, as defined by the SnmpParameters. Once the packet is encoded
     * it is transmitted to the agent defined by SnmpPeer. If an error occurs an
     * appropiate exception is generated.
     * 
     * @param peer
     *            The remote peer to send to.
     * @param pdu
     *            The pdu to transmit
     * 
     * @exception SnmpPduEncodingException
     *                Thrown if an encoding exception occurs at the session
     *                level
     * @exception org.opennms.protocols.snmp.asn1.AsnEncodingException
     *                Thrown if an encoding exception occurs in the AsnEncoder
     *                object.
     * @exception java.io.IOException
     *                Thrown if an error occurs sending the encoded datagram
     * @exception java.lang.IllegalStateException
     *                Thrown if the session has been closed.
     * 
     * @see SnmpRequest
     * @see SnmpParameters
     * @see SnmpPeer
     * 
     */
    public void send(SnmpPeer peer, SnmpPduPacket pdu) throws SnmpPduEncodingException, AsnEncodingException, java.io.IOException {
        if (m_portal.isClosed())
            throw new IllegalStateException("Illegal operation, the session has been closed");

        //
        // break down the pieces into usable variables
        //
        SnmpParameters parms = peer.getParameters();

        //
        // verify that for a SNMPV1 session that no
        // SNMPV2 packets are transmitted!
        //
        switch (pdu.getCommand()) {
        case SnmpPduPacket.V2TRAP:
            if (parms.getVersion() < SnmpSMI.SNMPV2) {
                throw new SnmpPduEncodingException("Cannot send pdu, invalid SNMP version");
            }
            break;

        default:
            throw new SnmpPduEncodingException("Invalid pdu, not a trap");
        }

        //
        // Get the encoder and start
        // the encoding process
        //
        AsnEncoder encoder = parms.getEncoder();

        //
        // get a suitable buffer (16k)
        //
        int offset = 0;
        byte[] buf = new byte[16 * 1024];

        //
        // encode the snmp version
        //
        SnmpInt32 version = new SnmpInt32(parms.getVersion());
        offset = version.encodeASN(buf, offset, encoder);

        //
        // get the correct community string. The
        // SET command uses the write community, all
        // others use the read community
        //
        SnmpOctetString community = new SnmpOctetString(parms.getReadCommunity().getBytes());

        //
        // encode the community strings
        //
        offset = community.encodeASN(buf, offset, encoder);
        offset = pdu.encodeASN(buf, offset, encoder);

        //
        // build the header, don't forget to mark the
        // pivot point
        //
        int pivot = offset;
        offset = encoder.buildHeader(buf, offset, (byte) (ASN1.SEQUENCE | ASN1.CONSTRUCTOR), pivot);

        //
        // rotate the buffer around the pivot point
        //
        SnmpUtil.rotate(buf, 0, pivot, offset);

        //
        // transmit the datagram
        //
        m_portal.send(peer, buf, offset);
    }

