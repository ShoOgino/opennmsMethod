    /**
     * 
     * The parseObjectId() method is used to decode an ASN.1 Object Identifer
     * from the specified buffer.
     * 
     * @param buf
     *            The input buffer
     * @param startOffset
     *            The offset to start decoding in the buffer
     * 
     * @return Returns an Object array that contains the new offset and ASN.1
     *         type, and ObjectId array. The first object is an Integer object
     *         and contains the new offset for the next object in buf. The
     *         second object is a Byte object that represents the decoded ASN.1
     *         Type. The third object is an array of primitive integers.
     * 
     * @exception AsnDecodingException
     *                Thrown if an error occurs decoding the buffer.
     */
    public Object[] parseObjectId(byte[] buf, int startOffset) throws AsnDecodingException {
        Object[] hdrVals = parseHeader(buf, startOffset);

        startOffset = ((Integer) hdrVals[0]).intValue();
        Byte asnType = (Byte) hdrVals[1];
        int asnLength = ((Integer) hdrVals[2]).intValue();

        //
        // check for sufficent data
        //
        if ((buf.length - startOffset) < asnLength)
            throw new AsnDecodingException("Buffer underflow error");

        //
        // if the length is zero then
        // silently create a ".0.0" object
        // id and return it!
        //
        if (asnLength == 0) {
            int[] ids = new int[2];
            ids[0] = ids[1] = 0;

            Object[] rVals = new Object[3];
            rVals[0] = new Integer(startOffset);
            rVals[1] = asnType;
            rVals[2] = ids;

            return rVals;
        }

        //
        // build a large buffer for the moment.
        // definately may need to srink the buffer
        // Use asnLength + 1 since the first byte
        // encode's two object ids
        //
        int idsOff = 0;
        int[] ids = new int[asnLength + 1];

        //
        // decode the first byte
        //
        {
            --asnLength;
            int oid = byteToInt(buf[startOffset++]);
            ids[idsOff++] = oid / 40;
            ids[idsOff++] = oid % 40;
        }

        //
        // decode the rest of the identifiers
        //
        while (asnLength > 0) {
            int oid = 0;
            boolean done = false;
            do {
                --asnLength;
                byte b = buf[startOffset++];
                oid = (oid << 7) | (int) (b & 0x7f);

                if ((b & HIGH_BIT) == 0)
                    done = true;
            } while (!done);
            ids[idsOff++] = oid;
        }

        //
        // now perpare the return value
        //
        int[] retOids;
        if (idsOff == ids.length) {
            retOids = ids;
        } else {
            retOids = new int[idsOff];
            copy(ids, // source
                 0, // source offset
                 retOids, // destination
                 0, // destination offset
                 idsOff); // number of items to copy
        }

        //
        // build the return objects
        //
        Object[] rVals = new Object[3];
        rVals[0] = new Integer(startOffset);
        rVals[1] = asnType;
        rVals[2] = retOids;

        return rVals;
    }

