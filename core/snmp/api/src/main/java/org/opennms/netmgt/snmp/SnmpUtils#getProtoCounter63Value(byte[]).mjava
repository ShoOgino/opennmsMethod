	/**
	 * <p>Enable the SNMP code to digest OCTET STRING values acting as proto-Counter64
	 * objects as seen in the FCMGMT-MIB with the following comment:</p>
	 * 
	 * <p>There is one and only one statistics table for each
	 * individual port. For all objects in statistics table, if the object is not
	 * supported by the conn unit then the high order bit is set to 1 with all other
	 * bits set to zero. The high order bit is reserved to indicate if the object
	 * if supported or not. All objects start at a value of zero at hardware
	 * initialization and continue incrementing till end of 63 bits and then
	 * wrap to zero.</p>
	 * 
	 * @see http://issues.opennms.org/browse/NMS-5423
	 */
	public static Long getProtoCounter63Value(byte[] valBytes) {
	    if (valBytes.length != 8) {
	        LOG.trace("Value should be 8 bytes long for a proto-Counter63 but this one is {} bytes.", valBytes);
	        return null;
	    } else if (Arrays.equals(valBytes, new byte[]{ (byte)0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 })) {
	        LOG.trace("Value has high-order bit set and all others zero, which indicates \"not supported\" in FCMGMT-MIB convention");
	        return null;
	    } else if ((valBytes[0] & 0x80) == 0x80) {
	        LOG.trace("Value has high-order bit set but proto-Counter63 should only be 63 bits");
	        return null;
	    }

	    // Check to see if each byte is an ASCII decimal digit. If all of the bytes are
	    // decimal digits, then do not interpret this value as a 64-bit counter and return
	    // null. It is probably not a 64-bit counter; it is most likely a decimal string
	    // value.
	    //
	    // @see http://issues.opennms.org/browse/NMS-6202
	    //
	    boolean onlyNumeric = true;
	    for (byte digit : valBytes) {
	        if (digit < 0x30 /* 0 */ || digit > 0x39 /* 9 */) {
	            onlyNumeric = false;
	            break;
	        }
	    }

	    if (onlyNumeric) {
	        LOG.trace("Value contains only ASCII decimal numbers so it should be interpreted as a decimal counter");
	        return null;
	    }

	    Long retVal = Long.decode(String.format("0x%02x%02x%02x%02x%02x%02x%02x%02x", valBytes[0], valBytes[1], valBytes[2], valBytes[3], valBytes[4], valBytes[5], valBytes[6], valBytes[7]));
	    LOG.trace("Converted octet-string {} as a proto-Counter63 of value {}", String.format("0x%02x%02x%02x%02x%02x%02x%02x%02x", valBytes[0], valBytes[1], valBytes[2], valBytes[3], valBytes[4], valBytes[5], valBytes[6], valBytes[7]), retVal);
	    return retVal;
	}

