    @Override
    public void process(Exchange exchange) throws Exception {
        @SuppressWarnings("unchecked")
        final CamelRpcRequest<RpcRequest,RpcResponse> wrapper = exchange.getIn().getBody(CamelRpcRequest.class);
        final JmsQueueNameFactory queueNameFactory = new JmsQueueNameFactory(CamelRpcConstants.JMS_QUEUE_PREFIX,
                wrapper.getModule().getId(), wrapper.getRequest().getLocation());
        exchange.getIn().setHeader(CamelRpcConstants.JMS_QUEUE_NAME_HEADER, queueNameFactory.getName());
        exchange.getIn().setHeader(CamelRpcConstants.CAMEL_JMS_REQUEST_TIMEOUT_HEADER, wrapper.getRequest().getTimeToLiveMs() != null ? wrapper.getRequest().getTimeToLiveMs() : CAMEL_JMS_REQUEST_TIMEOUT);
        if (wrapper.getRequest().getSystemId() != null) {
            exchange.getIn().setHeader(CamelRpcConstants.JMS_SYSTEM_ID_HEADER, wrapper.getRequest().getSystemId());
        }
        if(wrapper.getTracingInfo().size() > 0) {
            // Message mapping between camel and JMS ignores non-primitive headers there by need for marshalling.
            String tracingInfo = TracingInfoCarrier.marshalTracingInfo(wrapper.getTracingInfo());
            if(tracingInfo != null) {
                exchange.getIn().setHeader(CamelRpcConstants.JMS_TRACING_INFO, tracingInfo);
            }
        }
        final String request = wrapper.getModule().marshalRequest((RpcRequest)wrapper.getRequest());
        exchange.getIn().setBody(request);
        final Histogram rpcRequestSize = metrics.histogram(MetricRegistry.name(wrapper.getRequest().getLocation(), wrapper.getModule().getId(), RPC_REQUEST_SIZE));
        rpcRequestSize.update(request.getBytes().length);
    }

