        @Override
        public void run() {
            try {
                consumer.subscribe(Arrays.asList(topic));
                LOG.info("subscribed to topic {}", topic);
                while (!closed.get()) {
                    ConsumerRecords<String, byte[]> records = consumer.poll(java.time.Duration.ofMillis(Long.MAX_VALUE));
                    for (ConsumerRecord<String, byte[]> record : records) {  
                        try {
                            RpcMessageProtos.RpcMessage rpcMessage = RpcMessageProtos.RpcMessage
                                                                          .parseFrom(record.value());
                            String rpcId = rpcMessage.getRpcId();
                            long expirationTime = rpcMessage.getExpirationTime();
                            if (expirationTime < System.currentTimeMillis()) {
                                LOG.warn("ttl already expired for the request id = {}, won't process.", rpcMessage.getRpcId());
                                continue;
                            }
                            boolean hasSystemId = !Strings.isNullOrEmpty(rpcMessage.getSystemId());
                            String minionId = minionIdentity.getId();

                            if (hasSystemId && !(minionId.equals(rpcMessage.getSystemId()))) {
                                // directed RPC and not directed at this minion
                                continue;
                            }
                            if (hasSystemId) {
                                // directed RPC, there may be more than one request with same request Id, cache and allow only one.
                                boolean messageProcessed = handleDirectedRPC(rpcMessage);
                                if(messageProcessed) {
                                    continue;
                                }
                            }
                            ByteString rpcContent = rpcMessage.getRpcContent();
                            // For larger messages which get split into multiple chunks, cache them until all of them arrive.
                            if (rpcMessage.getTotalChunks() > 1) {
                                // Handle multiple chunks
                                boolean allChunksReceived = handleChunks(rpcMessage);
                                if(!allChunksReceived) {
                                    continue;
                                }
                                rpcContent = messageCache.get(rpcId);
                                //Remove rpcId from cache.
                                messageCache.remove(rpcId);
                                currentChunkCache.remove(rpcId);
                            }
                            //Build child span from rpcMessage and start minion span.
                            Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(rpcMessage);
                            Span minionSpan = spanBuilder.start();

                            RpcRequest request = module.unmarshalRequest(rpcContent.toStringUtf8());
                            setTagsOnMinion(rpcMessage, request, minionSpan);

                            CompletableFuture<RpcResponse> future = module.execute(request);
                            future.whenComplete((res, ex) -> {
                                final RpcResponse response;
                                if (ex != null) {
                                    // An exception occurred, store the exception in a new response
                                    LOG.warn("An error occured while executing a call in {}.", module.getId(), ex);
                                    response = module.createResponseWithException(ex);
                                    minionSpan.log(ex.getMessage());
                                    minionSpan.setTag(TAG_RPC_FAILED, "true");
                                } else {
                                    // No exception occurred, use the given response
                                    response = res;
                                }
                                // Finish minion Span
                                minionSpan.finish();
                                sendResponse(rpcId, response);
                            });
                        } catch (InvalidProtocolBufferException e) {
                             LOG.error("error while parsing the request", e);
                        }
                    }
                }
            } catch (WakeupException e) {
                // Ignore exception if closing
                if (!closed.get()) {
                    throw e;
                }
            } finally {
                consumer.close();
            }
        }

