        @Override
        public void sendResponse(String message) {
            // restore Logging context on callback.
            try (MDCCloseable mdc = Logging.withContextMapCloseable(loggingContext)) {
                // When message is not null, it's called from kafka consumer otherwise it is from timeout tracker.
                if (message != null) {
                    T response = rpcModule.unmarshalResponse(message);
                    if (response.getErrorMessage() != null) {
                        responseFuture.completeExceptionally(new RemoteExecutionException(response.getErrorMessage()));
                        span.log(response.getErrorMessage());
                        failedMeter.mark();
                    } else {
                        responseFuture.complete(response);
                    }
                    isProcessed = true;
                    responseSize.update(message.getBytes().length);
                } else {
                    responseFuture.completeExceptionally(new RequestTimedOutException(new TimeoutException()));
                    span.setTag(TAG_TIMEOUT, "true");
                    failedMeter.mark();
                    rpcResponseMap.remove(rpcId);
                    messageCache.remove(rpcId);
                    currentChunkCache.remove(rpcId);
                }
                rpcDuration.update(System.currentTimeMillis() - requestCreationTime);
                span.finish();
            } catch (Throwable e) {
                LOG.warn("Error while handling response for RPC module: {}. Response string: {}", rpcModule.getId(), message, e);
            }
        }

