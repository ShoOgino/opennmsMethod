        @Override
        public void sendResponse(String message) {
            // restore Logging context on callback.
            try (MDCCloseable mdc = Logging.withContextMapCloseable(loggingContext)) {
                // When message is not null, it's called from kafka consumer otherwise it is from timeout tracker.
                if (message != null) {
                   T response = rpcModule.unmarshalResponse(message);
                    if (response.getErrorMessage() != null) {
                        responseFuture.completeExceptionally(new RemoteExecutionException(response.getErrorMessage()));
                        span.log(response.getErrorMessage());
                    } else {
                        responseFuture.complete(response);
                    }
                    isProcessed = true;
                    final Histogram responseSize = metrics.histogram(MetricRegistry.name(rpcModule.getId(), "responseSize"));
                    responseSize.update(message.getBytes().length);
                } else {
                    responseFuture.completeExceptionally(new RequestTimedOutException(new TimeoutException()));
                    span.setTag(TAG_TIMEOUT, "true");
                    final Counter timeoutCounter = metrics.counter(MetricRegistry.name(rpcModule.getId(), "timedOutCount"));
                    timeoutCounter.inc();
                }
                final Histogram rpcDuration = metrics.histogram(MetricRegistry.name(rpcModule.getId(), "rpcDuration"));
                rpcDuration.update(System.currentTimeMillis() - requestCreationTime);
                span.finish();
                rpcResponseMap.remove(rpcId);
                messageCache.remove(rpcId);
            } catch (Exception e) {
                LOG.warn("error while handling response for RPC request id {}", rpcId, e);
            }
        }

