        @Override
        public void run() {
            Logging.putPrefix(RpcClientFactory.LOG_PREFIX);
            if (topics.isEmpty()) {
                // kafka consumer needs to subscribe to at least one topic for the consumer.poll to work.
                while (!topicAdded.get()) {
                    try {
                        firstTopicAdded.await(1, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        LOG.info("Interrupted before first topic was added. Terminating Kafka RPC consumer thread.");
                        return;
                    }
                }
                LOG.info("First topic is added, consumer will be started.");
            }
            while (!closed.get()) {
                if (topicAdded.get()) {
                    synchronized (topics) {
                        // Topic subscriptions are not incremental. This list will replace the current assignment (if there is one).
                        LOG.info("Subscribing Kafka RPC consumer to topics named: {}", topics);
                        consumer.subscribe(topics);
                        topicAdded.set(false);
                    }
                }
                try {
                    ConsumerRecords<String, byte[]> records = consumer.poll(Long.MAX_VALUE);
                    for (ConsumerRecord<String, byte[]> record : records) {
                        // Get Response callback from key and send rpc content to callback.
                        ResponseCallback responseCb = rpcResponseMap.get(record.key());
                        if (responseCb != null) {
                            RpcMessageProtos.RpcMessage rpcMessage = RpcMessageProtos.RpcMessage
                                                                         .parseFrom(record.value());
                            responseCb.sendResponse(rpcMessage.getRpcContent().toStringUtf8());
                        } else {
                            LOG.warn("Received a response for request with ID:{}, but no outstanding request was found with this id, The request may have timed out.",
                                    record.key());
                        }
                    }
                } catch (InvalidProtocolBufferException e) {
                    LOG.error("error while parsing response", e);
                } catch (WakeupException e) {
                    LOG.info(" consumer got wakeup exception, closed = {} ", closed.get(), e);
                }
            }
            // Close consumer when while loop is closed.
            consumer.close();
        }

