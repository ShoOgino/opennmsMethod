        @Override
        public void run() {
            Logging.putPrefix(RpcClientFactory.LOG_PREFIX);
            if (topics.isEmpty()) {
                // kafka consumer needs to subscribe to at least one topic for the consumer.poll to work.
                waitTillFirstTopicIsAdded();
                LOG.info("First topic is added, consumer will be started.");
            }

            while (!closed.get()) {
                try {
                    //Subscribe to new topics when added.
                    subscribeToTopics();

                    ConsumerRecords<String, byte[]> records = consumer.poll(java.time.Duration.ofMillis(Long.MAX_VALUE));

                    for (ConsumerRecord<String, byte[]> record : records) {
                        // Get Response callback from key and send rpc content to callback.
                        ResponseCallback responseCb = rpcResponseMap.get(record.key());
                        if (responseCb != null) {
                            RpcMessageProto rpcMessage = RpcMessageProto.parseFrom(record.value());
                            ByteString rpcContent = rpcMessage.getRpcContent();
                            String rpcId = rpcMessage.getRpcId();
                            // For larger messages which get split into multiple chunks, cache them until all of them arrive.
                            if (rpcMessage.getTotalChunks() > 1) {
                                boolean allChunksReceived = handleChunks(rpcMessage);
                                if (!allChunksReceived) {
                                    continue;
                                }
                                rpcContent = messageCache.get(rpcId);
                            }
                            if (LOG.isTraceEnabled()) {
                                LOG.trace("Received RPC response for id {}", rpcMessage.getRpcId());
                            }
                            final String rpcMessageContent = rpcContent.toStringUtf8();
                            responseHandlerExecutor.execute(() ->
                                    responseCb.sendResponse(rpcMessageContent));
                            // Remove rpcId from the maps so that duplicate response will not be handled.
                            rpcResponseMap.remove(rpcId);
                            messageCache.remove(rpcId);
                            currentChunkCache.remove(rpcId);
                        } else {
                            LOG.debug("Received a response for request with ID:{}, but no outstanding request was found with this id." +
                                    "The request may have timed out or the response may be a duplicate.", record.key());
                        }
                    }
                } catch (InvalidProtocolBufferException e) {
                    LOG.error("error while parsing response", e);
                } catch (WakeupException e) {
                    LOG.info("consumer got wakeup exception, closed = {} ", closed.get(), e);
                } catch (Throwable e) {
                    LOG.error("Unexpected error in kafka consumer.", e);
                }
            }
            // Close consumer when while loop is closed.
            consumer.close();
        }

