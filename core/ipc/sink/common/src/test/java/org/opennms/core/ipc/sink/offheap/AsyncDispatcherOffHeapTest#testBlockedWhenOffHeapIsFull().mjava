    @Test(timeout=6*30*1000)
    public void testBlockedWhenOffHeapIsFull() throws  Exception {
        ((MockModule)module).setBlocked(true);
        final AsyncDispatcher<MockMessage> asyncDispatcher = threadLockingDispatcherFactory.createAsyncDispatcher(module);

        final AtomicBoolean allThreadsLocked = new AtomicBoolean(false);
        ThreadLockingSyncDispatcher<MockMessage> threadLockingSyncDispatcher = threadLockingDispatcherFactory.getThreadLockingSyncDispatcher();
        threadLockingSyncDispatcher.waitForThreads(NUM_THREADS).thenRun(() -> {
            allThreadsLocked.set(true);
        });

        final List<CompletableFuture<MockMessage>> futures = new ArrayList<>();
        for (int i = 0; i < NUM_THREADS + QUEUE_SIZE; i++) {
            futures.add(asyncDispatcher.send(new MockMessage(Integer.toString(i))));
        }

        // All of the dispatcher thread should be locked, and
        await().atMost(30, SECONDS).until(() -> allThreadsLocked.get());
        // No additional thread should be waiting
        assertEquals(0, threadLockingSyncDispatcher.getNumExtraThreadsWaiting());
        // The queue should be full
        assertEquals(QUEUE_SIZE, asyncDispatcher.getQueueSize());
        AtomicInteger numOfMessagesDelivered = new AtomicInteger(0);
        // needs seperate thread as this blocks when offHeap is full
        Executors.newSingleThreadExecutor().execute(() -> {
                    for (int i = NUM_THREADS + QUEUE_SIZE; i < NUM_THREADS + QUEUE_SIZE + OFFHEAP_MESSAGES * 3; i++) {
                        CompletableFuture<MockMessage> future = asyncDispatcher.send(new MockMessage(Integer.toString(i)));
                        // This sleep is needed to get right size as the writes are committed every 1 sec by default
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            //pass
                        }
                        numOfMessagesDelivered.incrementAndGet();
                        futures.add(future);
                    }
                }
        );
        // Allow dispatcher to fill offheap
        await().atMost(30, SECONDS).until(() -> offHeapStore.getSize(), greaterThanOrEqualTo(40960L));
        // Release the threads!
        threadLockingSyncDispatcher.release();
        // Wait for the queue to be drained
        await().atMost(30, SECONDS).until(() -> numOfMessagesDelivered.get(), equalTo(OFFHEAP_MESSAGES*3));
        await().atMost(30, SECONDS).until(() -> asyncDispatcher.getQueueSize(), equalTo(0));
        await().atMost(30, SECONDS).until(() -> threadLockingDispatcherFactory.getNumMessageDispatched(),
                greaterThan(QUEUE_SIZE + OFFHEAP_MESSAGES*3 ));
        // All of our futures should be successfully resolved
        CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[]{}));
        asyncDispatcher.close();

    }

