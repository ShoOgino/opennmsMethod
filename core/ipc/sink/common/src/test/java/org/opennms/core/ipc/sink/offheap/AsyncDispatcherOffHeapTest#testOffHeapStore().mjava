    @Test(timeout=4*30*1000)
    public void testOffHeapStore() throws Exception {

        final AsyncDispatcher<MockMessage> asyncDispatcher = threadLockingDispatcherFactory.createAsyncDispatcher(module);

        final AtomicBoolean allThreadsLocked = new AtomicBoolean(false);
        ThreadLockingSyncDispatcher<MockMessage> threadLockingSyncDispatcher = threadLockingDispatcherFactory.getThreadLockingSyncDispatcher();
        threadLockingSyncDispatcher.waitForThreads(NUM_THREADS).thenRun(() -> {
            allThreadsLocked.set(true);
        });

        final List<CompletableFuture<MockMessage>> futures = new ArrayList<>();
        for (int i = 0; i < NUM_THREADS + QUEUE_SIZE; i++) {
            futures.add(asyncDispatcher.send(new MockMessage(Integer.toString(i))));
        }

        // All of the dispatcher thread should be locked, and
        await().atMost(30, SECONDS).until(() -> allThreadsLocked.get());
        // No additional thread should be waiting
        assertEquals(0, threadLockingSyncDispatcher.getNumExtraThreadsWaiting()); 
        // The queue should be full
        assertEquals(QUEUE_SIZE, asyncDispatcher.getQueueSize());
        int numOfMessagesInOffHeap = 0;
        for (int i = NUM_THREADS + QUEUE_SIZE; i < NUM_THREADS + QUEUE_SIZE + OFFHEAP_MESSAGES; i++) {
            CompletableFuture<MockMessage> future = asyncDispatcher.send(new MockMessage(Integer.toString(i)));
            // This sleep is needed to get right size as the writes are committed every 1 sec by default
            Thread.sleep(100);
            futures.add(future);
        }
        // Since one message will be read immediately without waiting, getNumOfMessages would be one less than num of offheap messages.
        assertThat(offHeapStore.getNumOfMessages(module.getId()), equalTo(OFFHEAP_MESSAGES -1));
        // Release the threads!
        threadLockingSyncDispatcher.release();
        // Wait for the queue to be drained
        await().atMost(30, SECONDS).until(() -> asyncDispatcher.getQueueSize(), equalTo(0));
        await().atMost(30, SECONDS).until(() -> threadLockingDispatcherFactory.getNumMessageDispatched(),
                greaterThan(QUEUE_SIZE + OFFHEAP_MESSAGES));

        // All of our futures should be successfully resolved
        CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[]{}));
        asyncDispatcher.close();
    }

