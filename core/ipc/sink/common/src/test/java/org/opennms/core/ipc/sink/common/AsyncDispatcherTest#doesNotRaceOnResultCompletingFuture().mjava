    @Test
    public void doesNotRaceOnResultCompletingFuture() throws Exception {
        int inMemorySize = 20000;
        int batchSize = 100;
        // Set up the dispatch queue
        DispatchQueueFactory dispatchQueueFactory = new QueueFileOffHeapDispatchQueueFactory(inMemorySize, batchSize,
                "100KB",
                folder.newFolder().toPath().toString());
        DispatchQueueServiceLoader.setDispatchQueue(dispatchQueueFactory);

        when(module.getAsyncPolicy()).thenReturn(new AsyncPolicy() {
            @Override
            public int getQueueSize() {
                return QUEUE_SIZE;
            }

            @Override
            public int getNumThreads() {
                return NUM_THREADS;
            }

            @Override
            public boolean isBlockWhenFull() {
                return true;
            }
        });

        final AsyncDispatcher<MyMessage> asyncDispatcher = blockableDispatcherFactory.createAsyncDispatcher(module);
        BlockableSyncDispatcher<MyMessage> blockableSyncDispatcher =
                blockableDispatcherFactory.getBlockableSyncDispatcher();

        // Release the threads!
        blockableSyncDispatcher.unblock();

        // Testing locally the race condition occured ~10% of send's so sending 10,000 times should virtually guarantee
        // it occurs.
        IntStream.range(0, 9999).parallel().forEach(i -> asyncDispatcher.send(new MyMessage(Integer.toString(i))));

        assertThat(((AsyncDispatcherImpl) asyncDispatcher).getMissedFutures(), equalTo(0L));

        asyncDispatcher.close();
    }

