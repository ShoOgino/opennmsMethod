    @Override
    public CompletableFuture<DispatchStatus> send(S message) {
        CompletableFuture<DispatchStatus> sendFuture = new CompletableFuture<>();

        if (!asyncPolicy.isBlockWhenFull() && atomicResultQueue.isFull()) {
            droppedCounter.inc();
            sendFuture.completeExceptionally(new RuntimeException("Dispatch queue full"));
            return sendFuture;
        }

        try {
            String newId = UUID.randomUUID().toString();
            atomicResultQueue.enqueue(message, newId, result -> {
                LOG.trace("Result of enqueueing for Id {} was {}", newId, result);

                if (result == DispatchQueue.EnqueueResult.DEFERRED) {
                    sendFuture.complete(DispatchStatus.QUEUED);
                } else {
                    futureMap.put(newId, sendFuture);
                }
            });
        } catch (WriteFailedException e) {
            sendFuture.completeExceptionally(e);
        }

        return sendFuture;
    }

