    @Override
    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String topic, T message) {
        try (MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {
            LOG.trace("dispatch({}): sending message {}", topic, message);

            final ProducerRecord<String, String> record = new ProducerRecord<>(topic, module.marshal(message));
            // Keep sending record till it delivers successfully.
            while(true) {
                try {
                    // From KafkaProducer's JavaDoc: The producer is thread safe and should generally be shared among all threads for best performance.
                    final Future<RecordMetadata> future = producer.send(record);
                    // The call to dispatch() is synchronous, so we block until the message was sent
                    future.get();
                    break;
                } catch (InterruptedException e) {
                    LOG.warn("Interrupted while sending message to topic {}.", topic, e);
                    Thread.currentThread().interrupt();
                    break;
                } catch (ExecutionException e) {
                    // Timeout typically happens when Kafka is Offline or it didn't initialize yet.
                    // For this case keep sending the message until it delivers, will cause sink messages to buffer.
                    if (e.getCause() != null && e.getCause() instanceof TimeoutException) {
                        LOG.warn("Timeout occured while sending message to topic {}, it will be attempted again.", topic);
                    } else {
                        LOG.error("Exception occured while sending message to topic {} ", e);
                        break;
                    }
                }
            }
        }
    }

