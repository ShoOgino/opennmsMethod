    /**
     * This method will divide message into chunks and send each chunk to kafka.
     * This will return false by default. If this is large buffer (total chunks > 1) and if different chunks have
     * been sent to different partitions, method will return true indicating partition change in between.
     * @param topic    The kafka topic message needs to be sent
     * @param messageId  The messageId message associated with
     * @param messageKey  The key used to route the message
     * @param sinkMessageContent  The sink message
     * @return partitionChanged  return true if partition changed in between else return false by default.
     */
    private boolean sendMessage(String topic, String messageId, String messageKey, byte[] sinkMessageContent) {
        int partitionNum = INVALID_PARTITION;
        boolean partitionChanged = false;
        int totalChunks = IntMath.divide(sinkMessageContent.length, maxBufferSize, RoundingMode.UP);
        for (int chunk = 0; chunk < totalChunks; chunk++) {
            byte[] messageInBytes = wrapMessageToProto(messageId, chunk, totalChunks, sinkMessageContent);
            final ProducerRecord<String, byte[]> record = new ProducerRecord<>(topic, messageKey, messageInBytes);
            // Add tags to tracer active span.
            Span activeSpan = getTracer().activeSpan();
            if (activeSpan != null && (chunk + 1 == totalChunks)) {
                activeSpan.setTag(TracerConstants.TAG_TOPIC, topic);
                activeSpan.setTag(TracerConstants.TAG_MESSAGE_SIZE, sinkMessageContent.length);
            }
            // Keep sending record till it delivers successfully.
            int partition = sendMessageChunkToKafka(topic, record);
            if (totalChunks > 1 && chunk == 0) {
                partitionNum = partition;
            } else if (totalChunks > 1 && partitionNum != partition) {
                partitionChanged = true;
                break;
            }
        }
        return partitionChanged;
    }

