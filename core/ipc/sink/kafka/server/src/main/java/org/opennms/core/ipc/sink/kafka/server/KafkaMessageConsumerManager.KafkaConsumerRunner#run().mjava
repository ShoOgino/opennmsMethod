        @Override
        public void run() {
            Logging.putPrefix(MessageConsumerManager.LOG_PREFIX);
            try {
                consumer.subscribe(Arrays.asList(topic));
                while (!closed.get()) {
                    ConsumerRecords<String, byte[]> records = consumer.poll(100);
                    for (ConsumerRecord<String, byte[]> record : records) {
                        try {
                            // Parse sink message content from protobuf.
                            SinkMessageProtos.SinkMessage sinkMessage = SinkMessageProtos.SinkMessage.parseFrom(record.value());
                            byte[] messageInBytes = sinkMessage.getContent().toByteArray();
                            String messageId = sinkMessage.getMessageId();
                            // Handle large message where there are multiple chunks of message.
                            if (sinkMessage.getTotalChunks() > 1) {

                                if (largeMessageCache == null || currentChunkCache == null) {
                                    LOG.error("LargeMessageCache config {}={} is invalid", MESSAGEID_CACHE_CONFIG,
                                            kafkaConfig.getProperty(MESSAGEID_CACHE_CONFIG));
                                    continue;
                                }
                                // Avoid duplicate chunks. discard if chunk is repeated.
                                if(currentChunkCache.getIfPresent(messageId) == null) {
                                    currentChunkCache.put(messageId, 0);
                                }
                                Integer chunkNum = currentChunkCache.getIfPresent(messageId);
                                if(chunkNum != null && chunkNum == sinkMessage.getCurrentChunkNumber()) {
                                    continue;
                                }
                                ByteString byteString = largeMessageCache.getIfPresent(messageId);
                                if(byteString != null) {
                                    largeMessageCache.put(messageId, byteString.concat(sinkMessage.getContent()));
                                } else {
                                    largeMessageCache.put(messageId, sinkMessage.getContent());
                                }
                                currentChunkCache.put(messageId, ++chunkNum);
                                // continue till all chunks arrive.
                                if (sinkMessage.getTotalChunks() != chunkNum) {
                                    continue;
                                }
                                byteString = largeMessageCache.getIfPresent(messageId);
                                if (byteString != null) {
                                    messageInBytes = byteString.toByteArray();
                                    largeMessageCache.invalidate(messageId);
                                    currentChunkCache.invalidate(messageId);
                                } else {
                                    continue;
                                }
                            }
                            // Update metrics.
                            messageSize.update(messageInBytes.length);
                            Tracer.SpanBuilder spanBuilder = buildSpanFromSinkMessage(sinkMessage);
                            // Tracing scope and Metrics Timer context will measure the time to dispatch.
                            try(Scope scope = spanBuilder.startActive(true);
                                Timer.Context context = dispatchTime.time()) {
                                scope.span().setTag(TracerConstants.TAG_MESSAGE_SIZE, messageInBytes.length);
                                scope.span().setTag(TracerConstants.TAG_TOPIC, topic);
                                scope.span().setTag(TracerConstants.TAG_THREAD, Thread.currentThread().getName());
                                dispatch(module, module.unmarshal(messageInBytes));
                            }

                        } catch (RuntimeException e) {
                            LOG.warn("Unexpected exception while dispatching message", e);
                        } catch (InvalidProtocolBufferException e) {
                            LOG.warn("Error parsing procotol buffer in message. The message will be dropped. \n" +
                                    "Ensure that all components are running the same version of the software.");
                        }
                    }
                }
            } catch (WakeupException e) {
                // Ignore exception if closing
                if (!closed.get()) {
                    throw e;
                }
            } finally {
                consumer.close();
            }
        }

