	private void registerWithOnmsRegistry(ServiceReference<?> reference) {
	        System.err.println("registerWithOnmsRegistry: " + reference.getBundle());

	        // skip this service if this should not be exported
		if (!isOnmsExported(reference)) return;
		
		// skip this service if its came from the opennms registry originally
		if (isOnmsSource(reference)) return;
		
		// if this service is already registered then skip it
		if (m_osgiReference2onmsRegistrationMap.containsKey(reference)) return;
		
		String[] classNames = (String[]) reference.getProperty(Constants.OBJECTCLASS);
		
		try {
			Class<?>[] providerInterfaces = findClasses(classNames);
			
			Object provider = m_bundleContext.getService(reference);
			
			Map<String, String> properties = new LinkedHashMap<String, String>();
			
			for(String key : reference.getPropertyKeys()) {
				Object val = reference.getProperty(key);
				StringBuilder buf = new StringBuilder();
				if (val instanceof Object[]) {
					Object[] a = (Object[])val;
					for(int i = 0; i < a.length; i++) {
						if (i != 0) buf.append(',');
						buf.append(a[i]);
					}
				} else {
					buf.append(val);
				}
				properties.put(key, buf.toString());
			}
			
			properties.put(REGISTRATION_SOURCE, OSGI_SOURCE);
			
	                System.err.println("registering...");

	                final Registration onmsRegistration = getRegistry().register(provider, properties, providerInterfaces);
			m_osgiReference2onmsRegistrationMap.put(reference, onmsRegistration);
			System.err.println("registered provider " + provider + " for interfaces: " + Arrays.toString(providerInterfaces) + " with properties: " + properties);
		} catch (final ClassNotFoundException e) {
			System.err.println("Unable to find class used by exported OSGi service");
			e.printStackTrace();
		}
	}

