    /**
     * Recovers a SnmpPduPacket or SnmpPduTrap from the passed datagram and
     * calls the appropriate method in the handler.
     * 
     * If an error occurs recovering the packet then an exception is generated.
     * The pdu can be one of SnmpPduRequest or SnmpPduBulk. The internal session
     * AsnEncoder defined in the SnmpParameters is used to recover the pdu.
     * 
     * @param pkt
     *            The datagram packet to be decoded
     * 
     * @exception SnmpPduEncodingException
     *                Thrown if a pdu or session level error occurs
     * @exception AsnDecodingException
     *                Thrown if the AsnEncoder encounters an error
     * 
     * @see SnmpPduTrap
     * @see SnmpPduPacket
     * @see SnmpPduRequest
     * @see SnmpPduBulk
     * @see SnmpParameters
     * @see org.opennms.protocols.snmp.asn1.AsnEncoder
     * 
     */
    void handlePkt(DatagramPacket pkt) throws SnmpPduEncodingException, AsnDecodingException {
        //
        // first decode the header
        //
        byte[] buf = pkt.getData();
        int offset = 0;

        //
        // Decode the ASN.1 header from the front
        // of the SNMP message.
        //
        Object[] rVals = m_encoder.parseHeader(buf, offset);

        //
        // get the return vals
        //
        offset = ((Integer) rVals[0]).intValue();
        byte asnType = ((Byte) rVals[1]).byteValue();
        int asnLength = ((Integer) rVals[2]).intValue();

        //
        // check the ASN.1 Type
        //
        if (asnType != (ASN1.SEQUENCE | ASN1.CONSTRUCTOR))
            throw new AsnDecodingException("Invalid SNMP ASN.1 type");

        //
        // Check the length of the datagram packet
        //
        if (asnLength > pkt.getLength() - offset) {
            throw new SnmpPduEncodingException("Insufficent data in packet");
        }

        //
        // get the snmp version.
        //
        SnmpInt32 int32 = new SnmpInt32();
        offset = int32.decodeASN(buf, offset, m_encoder);

        //
        // check the version
        //
        if (int32.getValue() != SnmpSMI.SNMPV1 && int32.getValue() != SnmpSMI.SNMPV2) {
            throw new SnmpPduEncodingException("Invalid protocol version");
        }

        //
        // need to get the community
        // Postpone the community check until the pdu
        // has been recovered to determine which community
        // string needs to be verified against.
        //
        SnmpOctetString community = new SnmpOctetString();
        offset = community.decodeASN(buf, offset, m_encoder);

        //
        // get the pdu header, but DO NOT modify the offset
        // in effect we are peeking into the remainder of the
        // packet
        //
        rVals = m_encoder.parseHeader(buf, offset);

        //
        // The command should be sign extended to a
        // negative number. Thus add 256 to wrap it
        //
        int cmd = ((Byte) rVals[1]).intValue() + 256;

        //
        // Now process the Protocol Data Unit
        //
        switch (cmd) {
        case SnmpPduPacket.SET:
        case SnmpPduPacket.GET:
        case SnmpPduPacket.GETNEXT:
        case SnmpPduPacket.RESPONSE:
        case SnmpPduPacket.INFORM:
        case SnmpPduPacket.V2TRAP:
        case SnmpPduPacket.REPORT: {
            SnmpPduPacket pdu = new SnmpPduRequest();
            offset = pdu.decodeASN(buf, offset, m_encoder);
            m_handler.processSnmpMessage(pkt.getAddress(), // From Who?
                                         pkt.getPort(), // What Port?
                                         int32, // What Version
                                         community, // Community
                                         cmd, // Snmp Command (Wrapped!)
                                         pdu); // The Protocol Data Unit
        }
            break;

        case SnmpPduPacket.GETBULK: {
            SnmpPduPacket pdu = new SnmpPduBulk();
            offset = pdu.decodeASN(buf, offset, m_encoder);
            m_handler.processSnmpMessage(pkt.getAddress(), // From Who?
                                         pkt.getPort(), // Port
                                         int32, // Version
                                         community, // Community
                                         cmd, // Command (positive wrapped)
                                         pdu); // Protocol Data Unit
        }
            break;

        case SnmpPduTrap.TRAP: {
            SnmpPduTrap trap = new SnmpPduTrap();
            offset = trap.decodeASN(buf, offset, m_encoder);
            m_handler.processSnmpTrap(pkt.getAddress(), pkt.getPort(), community, trap);
        }
            break;

        default:
            throw new SnmpPduEncodingException("No matching PDU type found");
        }
    }

