        /**
         * The run method is an infinite loop method that receives all datagrams
         * for the session. If an unrecoverable error occurs then the m_handler
         * is informed of the error
         * 
         * If a pdu is recovered from the channel then the associated handler is
         * invoked to process the pdu.
         * 
         * @see SnmpPacketHandler
         */
        public void run() {
            final int bufSz = setup();
            if (bufSz == 0) {
                return;
            }

            final LinkedList<DatagramPacket> fastReceiverQ = new LinkedList<DatagramPacket>();
            final LinkedList<byte[]> usedBuffers = new LinkedList<byte[]>();
            Thread fastReceiver = new Thread(new Runnable() {
                public void run() {
                    while (!m_isClosing && Thread.interrupted() == false) {
                        byte[] buf = null;
                        synchronized (usedBuffers) {
                            if (!usedBuffers.isEmpty())
                                buf = (byte[]) usedBuffers.removeFirst();
                        }

                        if (buf == null || buf.length != bufSz)
                            buf = new byte[bufSz];

                        try {
                            DatagramPacket pkt = new DatagramPacket(buf, buf.length);
                            m_comm.receive(pkt);
                            synchronized (fastReceiverQ) {
                                fastReceiverQ.addLast(pkt);
                                fastReceiverQ.notify();
                            }
                        } catch (InterruptedIOException ioe) {
                            synchronized (usedBuffers) {
                                usedBuffers.addLast(buf);
                            }
                            continue;
                        } catch (Exception e) {
                            if (!m_isClosing) {
                                boolean handled = true;
                                try {
                                    Class<?> loggerC = Class.forName("org.opennms.core.utils.ThreadCategory");

                                    Class<?>[] methodParmList = { Class.class };
                                    Method loggerM = loggerC.getMethod("getInstance", methodParmList);

                                    Object[] parmList = { this.getClass() };
                                    Object loggerI = loggerM.invoke(null, parmList);

                                    methodParmList = new Class[] { Object.class, Throwable.class };
                                    Method infoM = loggerC.getMethod("info", methodParmList);

                                    parmList = new Object[] { "An unknown error occured decoding the packet", e };
                                    infoM.invoke(loggerI, parmList);
                                } catch (Throwable t) {
                                    handled = false;
                                }

                                if (!handled) {
                                    System.out.println(new Date() + " - Exception: " + e.getMessage());
                                }
                                m_handler.processException(e);
                            }
                        }
                    }
                }
            }, Thread.currentThread().getName() + "-FastReceiver");
            fastReceiver.start();

            //
            // get a buffer for the datagrams
            //
            while (!m_isClosing) {
                DatagramPacket pkt = null;
                try {
                    //
                    // reset the packet's length
                    //
                    synchronized (fastReceiverQ) {
                        while (fastReceiverQ.isEmpty() && !m_isClosing)
                            fastReceiverQ.wait(300);

                        if (m_isClosing)
                            continue;

                        pkt = (DatagramPacket) fastReceiverQ.removeFirst();
                    }
                    handlePkt(pkt);
                } catch (SnmpPduEncodingException err) {
                    boolean handled = true;
                    try {
                        Class<?> loggerC = Class.forName("org.opennms.core.utils.ThreadCategory");

                        Class<?>[] methodParmList = { Class.class };
                        Method loggerM = loggerC.getMethod("getInstance", methodParmList);

                        Object[] parmList = { this.getClass() };
                        Object loggerI = loggerM.invoke(null, parmList);

                        methodParmList = new Class[] { Object.class, Throwable.class };
                        Method infoM = loggerC.getMethod("info", methodParmList);

                        parmList = new Object[] { "An error occured decoding the protocol data unit", err };
                        infoM.invoke(loggerI, parmList);

                        methodParmList = new Class[0];
                        Method debugEnabledM = loggerC.getMethod("isDebugEnabled", methodParmList);

                        parmList = new Object[0];
                        Boolean isEnabled = (Boolean) debugEnabledM.invoke(loggerI, parmList);

                        if (isEnabled.booleanValue()) {
                            methodParmList = new Class[] { Object.class };
                            Method debugM = loggerC.getMethod("debug", methodParmList);

                            OutputStream ostream = new ByteArrayOutputStream();
                            SnmpUtil.dumpHex(new PrintStream(ostream), pkt.getData(), 0, pkt.getLength());

                            parmList = new Object[] { ostream };
                            debugM.invoke(loggerI, parmList);
                        }
                    } catch (Throwable t) {
                        handled = false;
                    }

                    if (!handled) {
                        System.out.println(new Date() + " - SnmpPortal.Receiver.run: SnmpPduEncodingException: " + err.getMessage());
                        SnmpUtil.dumpHex(System.out, pkt.getData(), 0, pkt.getLength());
                    }
                    m_handler.processBadDatagram(pkt);
                } catch (AsnDecodingException err) {
                    boolean handled = true;
                    try {
                        Class<?> loggerC = Class.forName("org.opennms.core.utils.ThreadCategory");

                        Class<?>[] methodParmList = { Class.class };
                        Method loggerM = loggerC.getMethod("getInstance", methodParmList);

                        Object[] parmList = { this.getClass() };
                        Object loggerI = loggerM.invoke(null, parmList);

                        methodParmList = new Class[] { Object.class, Throwable.class };
                        Method infoM = loggerC.getMethod("info", methodParmList);

                        parmList = new Object[] { "An ASN.1 error occured decoding the packet", err };
                        infoM.invoke(loggerI, parmList);

                        methodParmList = new Class[0];
                        Method debugEnabledM = loggerC.getMethod("isDebugEnabled", methodParmList);

                        parmList = new Object[0];
                        Boolean isEnabled = (Boolean) debugEnabledM.invoke(loggerI, parmList);

                        if (isEnabled.booleanValue()) {
                            methodParmList = new Class[] { Object.class };
                            Method debugM = loggerC.getMethod("debug", methodParmList);

                            OutputStream ostream = new ByteArrayOutputStream();
                            SnmpUtil.dumpHex(new PrintStream(ostream), pkt.getData(), 0, pkt.getLength());

                            parmList = new Object[] { ostream };
                            debugM.invoke(loggerI, parmList);
                        }
                    } catch (Throwable t) {
                        handled = false;
                    }

                    if (!handled) {
                        System.out.println(new Date() + " - SnmpPortal.Receiver.run: AsnEncodingException: " + err.getMessage());
                        SnmpUtil.dumpHex(System.out, pkt.getData(), 0, pkt.getLength());
                    }
                    m_handler.processBadDatagram(pkt);
                } catch (Exception e) {
                    if (!m_isClosing) {
                        boolean handled = true;
                        try {
                            Class<?> loggerC = Class.forName("org.opennms.core.utils.ThreadCategory");

                            Class<?>[] methodParmList = { Class.class };
                            Method loggerM = loggerC.getMethod("getInstance", methodParmList);

                            Object[] parmList = { this.getClass() };
                            Object loggerI = loggerM.invoke(null, parmList);

                            methodParmList = new Class[] { Object.class, Throwable.class };
                            Method infoM = loggerC.getMethod("info", methodParmList);

                            parmList = new Object[] { "An unknown error occured decoding the packet", e };
                            infoM.invoke(loggerI, parmList);
                        } catch (Throwable t) {
                            handled = false;
                        }

                        if (!handled) {
                            System.out.println(new Date() + " - Exception: " + e.getMessage());
                        }
                        m_handler.processException(e);
                    }
                }

                // recycle the packet buffer if possible
                //
                if (pkt != null) {
                    synchronized (usedBuffers) {
                        // only keep 20 * 16k, or 520k worth
                        // of buffers around
                        //
                        if (usedBuffers.size() < 20)
                            usedBuffers.addLast(pkt.getData());
                    }
                }
            }
        } // end run()

