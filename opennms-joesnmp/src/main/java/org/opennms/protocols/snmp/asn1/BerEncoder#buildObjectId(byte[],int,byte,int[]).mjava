    /**
     * 
     * The buildObjectId() method is used to encode an ASN.1 object id value
     * into the specified byte buffer.
     * 
     * @param buf
     *            The output buffer of encoded bytes.
     * @param startOffset
     *            The offset from the start of the buffer where the method
     *            should start writing the encoded data.
     * @param asnType
     *            The ASN.1 type to place in the buffer
     * @param oids
     *            An array of integers to encode.
     * 
     * @return Returns the new offset for the next encoding routine. If
     *         startOffset is subtracted from the return value then the length
     *         of the encoded data can be determined.
     * 
     * @exception AsnEncodingException
     *                Thrown if an error occurs encoding the datatype.
     * 
     */
    public int buildObjectId(byte[] buf, int startOffset, byte asnType, int[] oids) throws AsnEncodingException {
        if ((buf.length - startOffset) < 1)
            throw new AsnEncodingException("Buffer overflow error");

        int[] toEncode = oids;
        int begin = startOffset; // used for rotate!

        //
        // silently create an oid = ".0.0" for arrays
        // less than 2 in length
        //
        if (oids.length < 2) {
            toEncode = new int[2];
            toEncode[0] = 0;
            toEncode[1] = 0;
        }

        //
        // verify that it is a valid object id!
        //
        if (toEncode[0] < 0 || toEncode[0] > 2)
            throw new AsnEncodingException("Invalid Object Identifier");

        if (toEncode[1] < 0 || toEncode[1] > 40)
            throw new AsnEncodingException("Invalid Object Identifier");

        //
        // add the first oid!
        //
        buf[startOffset++] = (byte) (toEncode[0] * 40 + toEncode[1]);
        int oidNdx = 2;

        //
        // encode the remainder
        //
        while (oidNdx < toEncode.length) {
            //
            // get the next object id
            //
            int oid = toEncode[oidNdx++];

            //
            // encode it
            //
            if (oid >= 0 && oid < 127) {
                if ((buf.length - startOffset) < 1)
                    throw new AsnEncodingException("Buffer overflow error");

                buf[startOffset++] = (byte) oid;
            } else // oid >= 127
            {
                int mask = 0, bits = 0; // avoids compiler whining!
                int tmask = 0, tbits = 0; // even if it may be right ;)

                //
                // figure out the number of bits required
                //
                tmask = 0x7f;
                tbits = 0;
                while (tmask != 0) {
                    if ((oid & tmask) != 0) {
                        mask = tmask;
                        bits = tbits;
                    }
                    tmask <<= 7;
                    tbits += 7;
                }

                while (mask != 0x7f) {
                    if ((buf.length - startOffset) < 1)
                        throw new AsnEncodingException("Buffer overflow error");

                    buf[startOffset++] = (byte) (((oid & mask) >>> bits) | HIGH_BIT);

                    mask = (mask >>> 7);
                    bits -= 7;

                    //
                    // fix an off-shift mask (4 bits --> 7 bits)
                    //
                    if (mask == 0x01e00000)
                        mask = 0x0fe00000;
                }

                //
                // add the last byte
                //
                if ((buf.length - startOffset) < 1)
                    throw new AsnEncodingException("Insufficent buffer space");

                buf[startOffset++] = (byte) (oid & mask);

            } // end else
        } // end while oids!

        //
        // mark the "pivot" of the rotation
        //
        int pivot = startOffset;

        //
        // encode the length
        //
        int asnLength = pivot - begin;
        int end = buildHeader(buf, pivot, asnType, asnLength);

        //
        // rotate the bytes around
        //
        try {
            rotate(buf, begin, pivot, end);
        } catch (ArrayIndexOutOfBoundsException err) {
            throw new AsnEncodingException("Insufficent buffer space");
        }

        return end;
    }

