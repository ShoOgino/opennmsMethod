    /**
     * Return the availability percentage for all managed services on the given
     * nodes from the given start time until the given end time. If there are no
     * managed services on these nodes, then a value of -1 is returned.
     *
     * @param nodeIds a {@link java.util.Set} object.
     * @param start a {@link java.util.Date} object.
     * @param end a {@link java.util.Date} object.
     * @return a {@link java.util.Map} object.
     * @throws java.sql.SQLException if any.
     */
    private static Map<Integer, Double> getNodeAvailability(Set<Integer> nodeIds, Date start, Date end) throws SQLException {
    	if(nodeIds==null || nodeIds.size()==0){
    		throw new IllegalArgumentException("Cannot take nodeIds null or with length 0.");
    	}
        if (start == null || end == null) {
            throw new IllegalArgumentException("Cannot take null parameters.");
        }

        if (end.before(start)) {
            throw new IllegalArgumentException("Cannot have an end time before the start time.");
        }

        if (end.equals(start)) {
            throw new IllegalArgumentException("Cannot have an end time equal to the start time.");
        }

        double avail = -1;
        int nodeid = 0;
        Map<Integer, Double> retMap = new TreeMap<Integer, Double>();

        final DBUtils d = new DBUtils(CategoryModel.class);
        try {
            Connection conn = DataSourceFactory.getInstance().getConnection();
            d.watch(conn);
        	StringBuffer sb = new StringBuffer("select nodeid, getManagePercentAvailNodeWindow(nodeid, ?, ?)  from node where nodeid in (");
        	Iterator<Integer> it = nodeIds.iterator();
        	while (it.hasNext()){
        		sb.append(it.next());
        		if (it.hasNext()) {
        			sb.append(", ");
        		}
        	}
        	sb.append(")");
            PreparedStatement stmt = conn.prepareStatement(sb.toString());
            d.watch(stmt);
            
            // yes, these are supposed to be backwards, the end time first
            stmt.setTimestamp(1, new Timestamp(end.getTime()));
            stmt.setTimestamp(2, new Timestamp(start.getTime()));

            ResultSet rs = stmt.executeQuery();
            d.watch(rs);

            while (rs.next()) {
            	nodeid = rs.getInt(1);
                avail = rs.getDouble(2);
                retMap.put(Integer.valueOf(nodeid), Double.valueOf(avail));
            }
        } catch (final SQLException e) {
            LOG.warn("Failed to get node availability for nodeIds {}", nodeIds, e);
        } finally {
            d.cleanUp();
        }

        return Collections.unmodifiableMap(retMap);
    }    

