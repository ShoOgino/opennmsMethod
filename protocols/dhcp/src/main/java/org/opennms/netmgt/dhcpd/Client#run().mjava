    /**
     * <p>run</p>
     */
    public void run() {
        ThreadCategory log = ThreadCategory.getInstance(this.getClass());
        boolean isOk = true;

        // get the input stream as a object stream
        //
        ObjectInputStream input = null;
        try {
            input = new ObjectInputStream(m_client.getInputStream());
        } catch (IOException ex) {
            log.warn("Failed to read client's input stream", ex);
            isOk = false;
        }

        // set the state
        //
        if (isOk) {
            synchronized (this) {
                m_status = RUNNING;
            }
        }

        // Roundy, Roundy, Round we go...
        //
        while (isOk && m_status == RUNNING) {
            try {
                Message msg = (Message) input.readObject();
                if (msg.getAddress().equals(NULL_ADDR)) {
                    if (log.isDebugEnabled())
                        log.debug("Got disconnect request from Poller corresponding to sending port " + m_sender.getLocalPort());
                    isOk = false;
                } else {
                    if (log.isDebugEnabled())
                        log.debug("Got request... adress = " + msg.getAddress());
                    byte[] dhcp = msg.getMessage().externalize();

                    DatagramPacket pkt = new DatagramPacket(dhcp, dhcp.length, msg.getAddress(), DHCP_TARGET_PORT);
                    try {
                        if (log.isDebugEnabled())
                           log.debug("sending request on port: " + m_sender.getLocalPort());
                        m_sender.send(pkt);
                    } catch (IOException ex) {
                    } // discard
                }
            } catch (ClassNotFoundException ex) {
                log.warn("Failed to read message, no class found", ex);
                isOk = false;
            } catch (IOException ex) {
                log.warn("Failed to read message, I/O error", ex);
                isOk = false;
            } catch (ClassCastException ex) {
                log.warn("Failed to read an appropriate message", ex);
                isOk = false;
            } catch (Throwable t) {
                log.warn("Undeclared throwable caught", t);
                isOk = false;
            }
        }

        synchronized (this) {
            m_status = STOP_PENDING;
        }

        // stop the unicast listener thread and wait for it to exit
        //
        m_keepListening = false;
        if (log.isDebugEnabled())
            log.debug("run: waiting for UnicastListener thread " + this.getName() + " to die...");
        try {
            m_unicastListener.join();
        } catch (InterruptedException e) {
            log.debug("run: interrupted while waiting for UnicastListener thread " + this.getName() + " to die", e);
        }
        if (log.isDebugEnabled())
            log.debug("run: UnicastListener thread " + this.getName() + " is dead...");

        // close the datagram socket
        //
        m_sender.close();

        // close the client's socket
        //
        try {
            input.close();
            m_client.close();
        } catch (IOException e) {
        }

        // Notify
        //
        notifyObservers();

        synchronized (this) {
            m_status = STOPPED;
        }

    } // end run() method

