    /**
     * <p>run</p>
     */
    @Override
    public void run() {
        boolean isOk = true;

        // get the input stream as a object stream
        //
        ObjectInputStream input = null;
        try {
            input = new ObjectInputStream(m_client.getInputStream());
        } catch (IOException ex) {
            LOG.warn("Failed to read client's input stream", ex);
            isOk = false;
        }

        // set the state
        //
        if (isOk) {
            synchronized (this) {
                m_status = RUNNING;
            }
        }

        // Roundy, Roundy, Round we go...
        //
        while (isOk && m_status == RUNNING) {
            try {
                Message msg = (Message) input.readObject();
                if (msg.getAddress().equals(NULL_ADDR)) {
                        LOG.debug("Got disconnect request from Poller corresponding to sending port {}", m_sender.getLocalPort());
                    isOk = false;
                } else {
                        LOG.debug("Got request... address = {}", msg.getAddress());
                    byte[] dhcp = msg.getMessage().serialize();

                    DatagramPacket pkt = new DatagramPacket(dhcp, dhcp.length, msg.getAddress(), DHCP_TARGET_PORT);
                    try {
                           LOG.debug("sending request on port: {}", m_sender.getLocalPort());
                        m_sender.send(pkt);
                    } catch (IOException ex) {
                    } // discard
                }
            } catch (ClassNotFoundException ex) {
                LOG.warn("Failed to read message, no class found", ex);
                isOk = false;
            } catch (IOException ex) {
                LOG.warn("Failed to read message, I/O error", ex);
                isOk = false;
            } catch (ClassCastException ex) {
                LOG.warn("Failed to read an appropriate message", ex);
                isOk = false;
            } catch (Throwable t) {
                LOG.warn("Undeclared throwable caught", t);
                isOk = false;
            }
        }

        synchronized (this) {
            m_status = STOP_PENDING;
        }

        // stop the unicast listener thread and wait for it to exit
        //
        m_keepListening = false;
            LOG.debug("run: waiting for UnicastListener thread {} to die...", this.getName());
        try {
            m_unicastListener.join();
        } catch (InterruptedException e) {
            LOG.debug("run: interrupted while waiting for UnicastListener thread {} to die", this.getName(), e);
        }
            LOG.debug("run: UnicastListener thread {} is dead...", this.getName());

        // close the datagram socket
        //
        m_sender.close();

        // close the client's socket
        //
        try {
            input.close();
            m_client.close();
        } catch (IOException e) {
        }

        // Notify
        //
        notifyObservers();

        synchronized (this) {
            m_status = STOPPED;
        }

    } // end run() method

