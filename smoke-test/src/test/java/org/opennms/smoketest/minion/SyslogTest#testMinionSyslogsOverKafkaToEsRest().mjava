    /**
     * This test will send syslog messages over the following message bus:
     * 
     * Minion -> Kafka -> OpenNMS Eventd -> Elasticsearch REST -> Elasticsearch
     */
    @Test(timeout=600000)
    @Ignore("This doesn't work yet because we need to use the Jest client to query for ES events")
    public void testMinionSyslogsOverKafkaToEsRest() throws Exception {
        Date startOfTest = new Date();
        int numMessages = 500;
        int packetsPerSecond = 100;

        InetSocketAddress minionSshAddr = minionSystem.getServiceAddress(ContainerAlias.MINION, 8201);
        InetSocketAddress esTransportAddr = minionSystem.getServiceAddress(ContainerAlias.ELASTICSEARCH_1, 9300);
        InetSocketAddress opennmsSshAddr = minionSystem.getServiceAddress(ContainerAlias.OPENNMS, 8101);
        InetSocketAddress kafkaAddress = minionSystem.getServiceAddress(ContainerAlias.KAFKA, 9092);
        InetSocketAddress zookeeperAddress = minionSystem.getServiceAddress(ContainerAlias.KAFKA, 2181);

        // Install the Kafka syslog and trap handlers on the Minion system
        installFeaturesOnMinion(minionSshAddr, kafkaAddress);

        // Install the Kafka and Elasticsearch features on the OpenNMS system
        installFeaturesOnOpenNMS(opennmsSshAddr, kafkaAddress, zookeeperAddress, true);

        final String sender = minionSystem.getContainerInfo(ContainerAlias.SNMPD).networkSettings().ipAddress();

        // Wait for the minion to show up
        await().atMost(90, SECONDS).pollInterval(5, SECONDS)
            .until(DaoUtils.countMatchingCallable(
                 this.daoFactory.getDao(MinionDaoHibernate.class),
                 new CriteriaBuilder(OnmsMinion.class)
                     .gt("lastUpdated", startOfTest)
                     .eq("location", "MINION")
                     .toCriteria()
                 ),
                 is(1)
             );

        // Create the indices manually. If we don't do this, some versions of 
        // ES will drop messages while the index is being auto-created.
        Calendar calendar = new GregorianCalendar();
        calendar.setTime(startOfTest);
        calendar.set(Calendar.MONTH, Calendar.MARCH);

        createElasticsearchIndex(esTransportAddr, startOfTest);
        createElasticsearchIndex(esTransportAddr, calendar.getTime());

        LOG.info("Warming up syslog routes by sending 1 packet");

        // Warm up the routes
        SyslogTest.sendMessage(sender, 1);

        for (int i = 0; i < 10; i++) {
            LOG.info("Slept for " + i + " seconds");
            Thread.sleep(1000);
        }

        LOG.info("Warming up syslog routes by sending 100 packets");

        // Warm up the routes
        SyslogTest.sendMessage(sender, 100);

        for (int i = 0; i < 10; i++) {
            LOG.info("Slept for " + i + " seconds");
            Thread.sleep(1000);
        }

        LOG.info("Resetting statistics");
        resetRouteStatistics(opennmsSshAddr, minionSshAddr);

        for (int i = 0; i < 20; i++) {
            LOG.info("Slept for " + i + " seconds");
            Thread.sleep(1000);
        }

        // Make sure that this evenly divides into the numMessages
        final int chunk = 500;
        final int logEvery = 50;

        int count = 0;
        long start = System.currentTimeMillis();

        // Send ${numMessages} syslog messages
        RateLimiter limiter = RateLimiter.create(packetsPerSecond);
        for (int i = 0; i < (numMessages / chunk); i++) {
            limiter.acquire(chunk);
            SyslogTest.sendMessage(sender, chunk);
            count += chunk;
            if (count % logEvery == 0) {
                long mid = System.currentTimeMillis();
                LOG.info(String.format("Sent %d packets in %d milliseconds", logEvery, mid - start));
                start = System.currentTimeMillis();
            }
        }

        // TODO: Use Jest API to perform this query

        // 100 warm-up messages plus ${numMessages} messages
        pollForElasticsearchEvents(esTransportAddr, 100 + numMessages);
    }

