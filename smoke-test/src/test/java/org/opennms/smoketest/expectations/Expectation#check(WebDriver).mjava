    public void check(final WebDriver webdriver) throws Exception {
        final Wait<WebDriver> wait = new WebDriverWait(webdriver, TimeUnit.SECONDS.convert(OpenNMSSeleniumTestCase.LOAD_TIMEOUT, TimeUnit.MILLISECONDS));
        
        final WebElement element;
        if (m_target.startsWith("link=")) {
            final String target = m_target.replaceFirst("link=", "");
            element = wait.until(visibilityOfElementLocated(By.linkText(target)));
        } else if (m_target.startsWith("css=")) {
            final String target = m_target.replaceFirst("css=", "");
            element = wait.until(visibilityOfElementLocated(By.cssSelector(target)));
        } else {
            element = wait.until(visibilityOfElementLocated(By.xpath(m_target)));
        }
        LOG.debug("found element: {}", element);
        element.click();

        if (m_textPresent.size() == 0) {
            return;
        }

        if (m_waitTime != null) {
            Thread.sleep(m_waitUnits.toMillis(m_waitTime));
        }

        final CompletionService<Boolean> completionService = new ExecutorCompletionService<>(m_executor);
        final List<Future<Boolean>> futures = Collections.synchronizedList(new ArrayList<Future<Boolean>>());

        for (final String tp : m_textPresent) {
            futures.add(completionService.submit(new Callable<Boolean>() {
                @Override public Boolean call() throws Exception {
                    return wait.until(pageContainsText(tp));
                }
            }));
        }

        if (m_matchType == Type.OR) {
            while (futures.size() > 0) {
                final Future<Boolean> future = completionService.take();
                futures.remove(future);
                if (future.get() == true) {
                    for (final Future<Boolean> f : futures) {
                        f.cancel(true);
                    }
                    // we passed, exit the matching
                    return;
                }
            }
            // we never received a true value
            throw new ExpectationFailed(this);
        } else if (m_matchType == Type.AND) {
            while (futures.size() > 0) {
                final Future<Boolean> future = completionService.take();
                futures.remove(future);
                if (future.get() == false) {
                    for (final Future<Boolean> f : futures) {
                        f.cancel(true);
                    }
                    throw new ExpectationFailed(this, "isTextPresent &= " + m_textPresent);
                }
            }
        }
    }

