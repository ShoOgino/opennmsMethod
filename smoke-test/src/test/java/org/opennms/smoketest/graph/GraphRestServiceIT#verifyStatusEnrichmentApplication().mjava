    @Test
    public void verifyStatusEnrichmentApplication() throws InterruptedException {
        final HibernateDaoFactory daoFactory = stack.postgres().getDaoFactory();
        final ApplicationDaoHibernate applicationDao = daoFactory.getDao(ApplicationDaoHibernate.class);
        final MonitoredServiceDao monitoredServiceDao = daoFactory.getDao(MonitoredServiceDaoHibernate.class);
        final PlatformTransactionManager transactionManager = new HibernateTransactionManager(applicationDao.getSessionFactory());
        final TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
        final OutageDaoHibernate outageDao = daoFactory.getDao(OutageDaoHibernate.class); // TODO: Patrick remove later
        final AlarmDao alarmDao = daoFactory.getDao(AlarmDaoHibernate.class); // TODO: Patrick remove later
        final EventDao eventDao = daoFactory.getDao(EventDaoHibernate.class); // TODO: Patrick remove later

        // Clean up
        applicationDao.findAll().forEach(applicationDao::delete);

        // Set up test data
        createRequisition();
        final OnmsApplication tmpApplication = transactionTemplate.execute(transactionStatus -> {
            final OnmsApplication theApplication = new OnmsApplication();
            theApplication.setName("OpenNMS Application");
            OnmsMonitoringLocation location = new OnmsMonitoringLocation();
            location.setLocationName("Default");
            Set<OnmsMonitoringLocation> locations = new HashSet<>();
            locations.add(location);
            theApplication.setPerspectiveLocations(locations);
            monitoredServiceDao.findAllServices().stream()
                    .filter(ms -> ms.getIpAddress().toString().contains("127.0.0.1"))
                    .forEach(service -> service.addApplication(theApplication));
            applicationDao.save(theApplication);
            return theApplication;
        });

        // Force fully initialized to prevent LazyLoad-Exceptions
        final OnmsApplication application = transactionTemplate.execute(status -> {
            final OnmsApplication initializedApplication = applicationDao.get(tmpApplication.getId());
            initializedApplication.getMonitoredServices().stream().forEach(OnmsMonitoredService::getNodeId);
            return initializedApplication;
        });

        final List<OnmsMonitoredService> services = Lists.newArrayList(application.getMonitoredServices());
        final int nodeId1 = services.get(0).getNodeId();
        final int nodeId2 = services.get(1).getNodeId();

        // Make sure all former outages have been resolved (can be a problem when test is run twice)
        restClient.sendEvent( new EventBuilder(EventConstants.PERSPECTIVE_NODE_REGAINED_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId1)
                .setInterface(InetAddressUtils.getInetAddress("127.0.0.1"))
                .setService("ICMP")
                .setParam("perspective", "Default")
                .setSeverity(OnmsSeverity.CLEARED.getLabel())
                .getEvent());
        restClient.sendEvent( new EventBuilder(EventConstants.PERSPECTIVE_NODE_REGAINED_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId2)
                .setInterface(InetAddressUtils.getInetAddress("127.0.0.1"))
                .setService("ICMP")
                .setParam("perspective", "Default")
                .setSeverity(OnmsSeverity.CLEARED.getLabel())
                .getEvent());

        // Force application provider to reload (otherwise we have to wait until cache is invalidated)
        awaitForApplicationStatus(application, "Normal");

        // Fetch data nothing down
        final JSONObject query = new JSONObject()
                .put("semanticZoomLevel", 1)
                .put("verticesInFocus", Lists.newArrayList(String.format("Application:%s", application.getId())));
        given().log().ifValidationFails()
                .body(query.toString())
                .contentType(ContentType.JSON)
                .post("{container_id}/{namespace}", "application", "application")
                .then()
                .log().ifValidationFails()
                .statusCode(200)
                .contentType(ContentType.JSON)
                .content("vertices", Matchers.hasSize(3))
                .content("vertices[0].status.severity", Matchers.is("Normal"))
                .content("vertices[1].status.severity", Matchers.is("Normal"))
                .content("vertices[2].status.severity", Matchers.is("Normal"))
                .content("vertices[0].status.count", Matchers.is(0))
                .content("vertices[1].status.count", Matchers.is(0))
                .content("vertices[2].status.count", Matchers.is(0));

        // Prepare simulated outages
        final Event nodeLostServiceEvent = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId1)
                .setInterface(InetAddressUtils.getInetAddress("127.0.0.1"))
                .setService("ICMP")
                .setParam("perspective", "Default")
                .setSeverity(OnmsSeverity.MINOR.getLabel())
                .getEvent();
        final Event nodeLostServiceEventApp2 = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId2)
                .setInterface(InetAddressUtils.getInetAddress("127.0.0.1"))
                .setService("ICMP")
                .setParam("perspective", "Default")
                .setSeverity(OnmsSeverity.CRITICAL.getLabel())
                .getEvent();

        // Take service down, reload graph and verify
        restClient.sendEvent(nodeLostServiceEvent);
        Thread.sleep(5000); // TODO: Patrick remove later

        transactionTemplate.execute(status -> { // TODO: Patrick remove later
            for(OnmsMonitoredService service : application.getMonitoredServices()) {
                Collection<OnmsOutage> outages = outageDao.currentOutagesForServiceFromPerspectivePoller(service);
                LOG.warn("OUTAGES for service: " + service + " " + outages);
            }
            LOG.warn("APPLICATION ALARMS: " + applicationDao.getAlarmStatus().stream()
                    .map(s -> s.getNodeId()+"::"+s.getServiceTypeId() +"::"+ s.getIpAddress().toString() + "=" + s.getSeverity())
                    .collect(Collectors.joining()));
            LOG.warn("ALL ALARMS: " + alarmDao.findAll().stream().map(a-> a.toString() + " last eventid=" + a.getLastEvent().getId()).collect(Collectors.joining(", ")));
            LOG.warn("ALL EVENTS: " + eventDao.findAll().stream().map(e -> "id="+e.getId()+", uei=" + e.getEventUei() + " severity=" + e.getEventSeverity() +"/"+ e.getSeverityLabel()).collect(Collectors.joining(", ")));
            return null;
        });

        awaitForApplicationStatus(application, "Minor");

        final Response response = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse = new ApplicationViewResponse(response);
        assertThat(applicationViewResponse.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse.getVertexByApplicationId(application.getId()), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId2), "Normal", 0);

        // Take service down with severity higher than Major
        restClient.sendEvent(nodeLostServiceEventApp2);
        awaitForApplicationStatus(application, "Critical");

        final Response response2 = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse2 = new ApplicationViewResponse(response2);
        assertThat(applicationViewResponse2.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse2.getVertexByApplicationId(application.getId()), "Critical", 2);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId2), "Critical", 1); // we expect the same severity as the interface with the highest severity

        // Finally clean up
        applicationDao.delete(application);
    }

