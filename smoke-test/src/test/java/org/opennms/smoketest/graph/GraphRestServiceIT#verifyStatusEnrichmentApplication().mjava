    @Test
    public void verifyStatusEnrichmentApplication() throws InterruptedException {
        final String applicationName = "StatusEnrichmentTest";

        final InetAddress localhost = InetAddressUtils.getInetAddress("127.0.0.1");
        final String perspectiveKey = "perspective";
        final String perspectiveName = "Default";

        final String testServiceName = "ICMP";
        final String clearedSeverity = OnmsSeverity.CLEARED.getLabel();
        final String minorSeverity = OnmsSeverity.MINOR.getLabel();
        final String criticalSeverity = OnmsSeverity.CRITICAL.getLabel();

        // Set up test data
        createRequisition();

        adminPage();
        findElementByLink("Manage Applications").click();

        // create the application
        waitForElement(By.name("newApplicationName"));
        enterText(By.name("newApplicationName"), applicationName);
        clickElement(By.cssSelector("form[action='admin/applications.htm'] > button"));

        // browse to the application page
        clickElement(By.linkText(applicationName));

        clickElement(By.linkText("Edit application"));
        // make sure the forms have loaded
        waitForElement(By.id("input_toAdd"));

        // add the services
        clickElement(By.xpath("//select[@id='input_toAdd']/option[contains(text(), 'Node A / 127.0.0.1 / ICMP')]"));
        clickElement(By.xpath("//select[@id='input_toAdd']/option[contains(text(), 'Node B / 127.0.0.1 / ICMP')]"));
        clickElement(By.id("input_addService"));

        // add the default location
        clickElement(By.xpath("//select[@id='input_locationAdd']/option[@value='Default']"));
        clickElement(By.id("input_addLocation"));

        // get the application
        final Optional<OnmsApplication> app = restClient.getApplications().stream().filter(a -> a.getName() == applicationName).findFirst();
        if (!app.isPresent()) {
            throw new IllegalStateException("Failed to retrieve application '" + applicationName + "'");
        }
        final OnmsApplication application = app.get();

        // Force application provider to reload (otherwise we have to wait until cache is invalidated)
        awaitForApplicationStatus(application, "Normal");

        final List<OnmsNode> nodes = restClient.getNodes();
        final int nodeId1 = nodes.stream().filter(n -> n.getLabel() == "Node A").findFirst().get().getId();
        final int nodeId2 = nodes.stream().filter(n -> n.getLabel() == "Node B").findFirst().get().getId();

        // Fetch data nothing down
        final JSONObject query = new JSONObject()
                .put("semanticZoomLevel", 1)
                .put("verticesInFocus", Lists.newArrayList(String.format("Application:%s", application.getId())));
        given().log().ifValidationFails()
                .body(query.toString())
                .contentType(ContentType.JSON)
                .post("{container_id}/{namespace}", "application", "application")
                .then()
                .log().ifValidationFails()
                .statusCode(200)
                .contentType(ContentType.JSON)
                .content("vertices", Matchers.hasSize(3))
                .content("vertices[0].status.severity", Matchers.is("Normal"))
                .content("vertices[1].status.severity", Matchers.is("Normal"))
                .content("vertices[2].status.severity", Matchers.is("Normal"))
                .content("vertices[0].status.count", Matchers.is(0))
                .content("vertices[1].status.count", Matchers.is(0))
                .content("vertices[2].status.count", Matchers.is(0));

        // Prepare simulated outages
        final Event nodeLostServiceEvent = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId1)
                .setInterface(localhost)
                .setService(testServiceName)
                .setParam(perspectiveKey, perspectiveName)
                .setSeverity(minorSeverity)
                .getEvent();
        final Event nodeLostServiceEventApp2 = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId2)
                .setInterface(localhost)
                .setService(testServiceName)
                .setParam(perspectiveKey, perspectiveName)
                .setSeverity(criticalSeverity)
                .getEvent();

        // Take service down, reload graph and verify
        restClient.sendEvent(nodeLostServiceEvent);
        awaitForApplicationStatus(application, "Minor");

        final Response response = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse = new ApplicationViewResponse(response);
        assertThat(applicationViewResponse.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse.getVertexByApplicationId(application.getId()), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId2), "Normal", 0);

        // Take service down with severity higher than Major
        restClient.sendEvent(nodeLostServiceEventApp2);
        awaitForApplicationStatus(application, "Critical");

        final Response response2 = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse2 = new ApplicationViewResponse(response2);
        assertThat(applicationViewResponse2.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse2.getVertexByApplicationId(application.getId()), "Critical", 2);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId2), "Critical", 1); // we expect the same severity as the interface with the highest severity

        /*
        final HibernateDaoFactory daoFactory = stack.postgres().getDaoFactory();
        final ApplicationDaoHibernate applicationDao = daoFactory.getDao(ApplicationDaoHibernate.class);
        final MonitoringLocationDaoHibernate locationDao = daoFactory.getDao(MonitoringLocationDaoHibernate.class);
        final MonitoredServiceDao monitoredServiceDao = daoFactory.getDao(MonitoredServiceDaoHibernate.class);
        final PlatformTransactionManager transactionManager = new HibernateTransactionManager(applicationDao.getSessionFactory());
        final TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
        final OutageDaoHibernate outageDao = daoFactory.getDao(OutageDaoHibernate.class); // TODO: Patrick remove later
        final AlarmDao alarmDao = daoFactory.getDao(AlarmDaoHibernate.class); // TODO: Patrick remove later
        final EventDao eventDao = daoFactory.getDao(EventDaoHibernate.class); // TODO: Patrick remove later

        final List<OnmsMonitoredService> services = Lists.newArrayList(application.getMonitoredServices());
        final int nodeId1 = services.get(0).getNodeId();
        final int nodeId2 = services.get(1).getNodeId();

        // Fetch data nothing down
        final JSONObject query = new JSONObject()
                .put("semanticZoomLevel", 1)
                .put("verticesInFocus", Lists.newArrayList(String.format("Application:%s", application.getId())));
        given().log().ifValidationFails()
                .body(query.toString())
                .contentType(ContentType.JSON)
                .post("{container_id}/{namespace}", "application", "application")
                .then()
                .log().ifValidationFails()
                .statusCode(200)
                .contentType(ContentType.JSON)
                .content("vertices", Matchers.hasSize(3))
                .content("vertices[0].status.severity", Matchers.is("Normal"))
                .content("vertices[1].status.severity", Matchers.is("Normal"))
                .content("vertices[2].status.severity", Matchers.is("Normal"))
                .content("vertices[0].status.count", Matchers.is(0))
                .content("vertices[1].status.count", Matchers.is(0))
                .content("vertices[2].status.count", Matchers.is(0));

        // Prepare simulated outages
        final Event nodeLostServiceEvent = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId1)
                .setInterface(localhost)
                .setService(testServiceName)
                .setParam(perspectiveKey, perspectiveName)
                .setSeverity(minorSeverity)
                .getEvent();
        final Event nodeLostServiceEventApp2 = new EventBuilder(EventConstants.PERSPECTIVE_NODE_LOST_SERVICE_UEI, getClass().getSimpleName())
                .setNodeid(nodeId2)
                .setInterface(localhost)
                .setService(testServiceName)
                .setParam(perspectiveKey, perspectiveName)
                .setSeverity(criticalSeverity)
                .getEvent();

        // Take service down, reload graph and verify
        restClient.sendEvent(nodeLostServiceEvent);
        Thread.sleep(10000); // TODO: Patrick remove later

        transactionTemplate.execute(status -> { // TODO: Patrick remove later
            for(final OnmsMonitoredService service : application.getMonitoredServices()) {
                final Collection<CurrentOutageDetails> currentOutages = outageDao.newestCurrentOutages(Arrays.asList(testServiceName));
                LOG.warn("NEW OUTAGES: " + service + " " + currentOutages);
                final Collection<OnmsOutage> perspectiveOutages = outageDao.currentOutagesForServiceFromPerspectivePoller(service);
                LOG.warn("OUTAGES for service: " + service + " " + perspectiveOutages);
            }
            LOG.warn("APPLICATION ALARMS: " + applicationDao.getAlarmStatus().stream()
                    .map(s -> s.getNodeId()+"::"+s.getServiceTypeId() +"::"+ s.getIpAddress().toString() + "=" + s.getSeverity())
                    .collect(Collectors.joining()));
            LOG.warn("ALL ALARMS: " + alarmDao.findAll().stream().map(a-> a.toString() + " last eventid=" + a.getLastEvent().getId()).collect(Collectors.joining(", ")));
            LOG.warn("ALL EVENTS: " + eventDao.findAll().stream().map(e -> "id="+e.getId()+", uei=" + e.getEventUei() + " severity=" + e.getEventSeverity() +"/"+ e.getSeverityLabel()).collect(Collectors.joining(", ")));
            return null;
        });

        awaitForApplicationStatus(application, "Minor");

        final Response response = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse = new ApplicationViewResponse(response);
        assertThat(applicationViewResponse.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse.getVertexByApplicationId(application.getId()), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse.getVertexByNodeId(nodeId2), "Normal", 0);

        // Take service down with severity higher than Major
        restClient.sendEvent(nodeLostServiceEventApp2);
        awaitForApplicationStatus(application, "Critical");

        final Response response2 = getApplicationViewResponse(query.toString());
        final ApplicationViewResponse applicationViewResponse2 = new ApplicationViewResponse(response2);
        assertThat(applicationViewResponse2.length(), Matchers.is(3));
        verifyStatus(applicationViewResponse2.getVertexByApplicationId(application.getId()), "Critical", 2);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId1), "Minor", 1);
        verifyStatus(applicationViewResponse2.getVertexByNodeId(nodeId2), "Critical", 1); // we expect the same severity as the interface with the highest severity

        // Finally clean up
        applicationDao.delete(application);

        */
    }

