	public void run() {
		input = "";

		try {
			// Get input from the client
			BufferedReader in = new BufferedReader(new InputStreamReader(server
					.getInputStream()));
			

			readingFromClient:while ((line = in.readLine()) != null) {
				input = input + "\n" + line;
				log.debug("Client wrote: " + line + " from "
						+ server.getInetAddress());

				if (status == STARTING_SESSION_STATUS) {
					if (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {
						if(sharedAsciiAuthString!=null){ 
							//authorization required
							streamToClient.println(AUTH_REQUIRED_ACK);
							log.debug("Starting authentication, sending "
									+ AUTH_REQUIRED_ACK + " to the client");
							status = AUTHENTICATING_STATUS;
						}else{
							//authorization not required
							streamToClient.println(AUTH_NOT_REQUIRED_ACK);
							log.debug("Starting authentication, sending "
									+ AUTH_NOT_REQUIRED_ACK + " to the client");
							status=AUTHENTICATED_STATUS;
						}
						continue readingFromClient;
					} else {
						// security reset (a malicious user may use DOS attack
						// before authentication)
						log.warn("Wrong client request");
						break readingFromClient;
					}
				}

				if (status == AUTHENTICATING_STATUS){
					if(sharedAsciiAuthString!=null){ 
						// authentication required (security check)
						if (line.equals(sharedAsciiAuthString)) {
							status = AUTHENTICATED_STATUS;
							log.debug("Authentication success!");
							streamToClient.println(AUTHENTICATION_SUCCESS);
							continue readingFromClient;
						} else {
							streamToClient.println(RESET_SIGNAL);
							log.warn("Authentication failure! Resetting session.");
							break readingFromClient;
						}
					}
				}

				if (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {
					if (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {
						log.debug("Sending alarms to the client");
						status=DATAFLOW_STATUS;
						synchronized (streamToClient) {
							streamToClient.println(ACTIVE_ALARM_BEGIN);
							
							BeanFactoryReference bf = BeanUtils.getBeanFactory("daoContext");
				            final EventDao eventDao = BeanUtils.getBean(bf, "eventDao",
				                    EventDao.class);
				             
				           
				            TransactionTemplate transTemplate = BeanUtils.getBean(bf,
				                    "transactionTemplate", TransactionTemplate.class);
				            final StringWriter sw =  (StringWriter) transTemplate.execute(
				            		new TransactionCallback() {
				    		        	public Object doInTransaction(final TransactionStatus status) {
				    		            	List<OnmsEvent> events = null;
				    		            	StringWriter sw=new StringWriter();
				    		            	try {
				    		            		//TODO to control the query
				    							final OnmsCriteria criteria = new OnmsCriteria(OnmsEvent.class);
				    							criteria.add(Restrictions.sqlRestriction("eventuei = '"+alarmUEI+"' and alarmid not in (select alarmid from events where eventuei = '"+clearAlarmUEI+"')"));
				    							events = eventDao.findMatching(criteria);
				    							if (log.isDebugEnabled())
				    								log.debug("Found "+events.size()+ " open event/s (alarms)");
				    							Iterator<OnmsEvent> ite = events.iterator();
				    							while(ite.hasNext()){ 
				    			            		OnmsEvent ev = ite.next();
				    			            		try {
		    			    		            		Event e=new Event();
		    			    		            		e.setDbid(ev.getId());
		    		    				            	e.setUei(ev.getEventUei());
		    		    				            	e.setSource(ev.getEventSource());
		    		    				            	if (ev.getNode() != null) 
		    		    				            		e.setNodeid(ev.getNode().getId());
		    		    				            	DateFormat dfInstance = DateFormat.getDateInstance(DateFormat.FULL);
		    		    				            	e.setTime(dfInstance.format(ev.getEventTime()));
		    		    				            	e.setHost(ev.getEventHost());
		    		    				            	e.setInterface(ev.getIpAddr());
		    		    				            	if(ev.getServiceType()!=null)
		    		    				            		e.setService(ev.getServiceType().getName());
		    		    				            	e.setDescr(ev.getEventDescr());
		    		    				            	Logmsg msg = new Logmsg();
		    		    				            	msg.setContent(ev.getEventLogMsg());
		    		    				            	e.setLogmsg(msg);
		    		    				            	e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));
		    		    				            	AlarmData ad = new AlarmData();
		    		    				            	OnmsAlarm onmsAlarm = ev.getAlarm();
		    		    				            	try {
															if(onmsAlarm!=null){
																ad.setReductionKey(onmsAlarm.getReductionKey());
																ad.setAlarmType(onmsAlarm.getAlarmType());
																ad.setClearKey(onmsAlarm.getClearKey());
																e.setAlarmData(ad);
															}
														} catch (ObjectNotFoundException e1) {
															log.warn("correlated alarm data not found "+e1);
															log.debug("correlated alarm data not found ",e1);
														}
														e.marshal(sw);
		    			    						} catch (Exception ex) {
		    			    							log.error("Error while getting event ",ex);
		    			    							return null;
		    			    						}
		    			    						sw.flush();
				    							}
				    						} catch (final RuntimeException e) {
				    							log.error("Error while getting events ",e);
				    							return null;
				    						}
				    						return sw;
				    						
				    		            }
				    		        	
				    		        });
						            if(sw!=null)
						            	streamToClient.print(sw.toString());
						            else
						            	break readingFromClient;
						            streamToClient.println(ACTIVE_ALARM_END);
									continue readingFromClient;
								}
							} else {
									if (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {
										log.debug("Closing session due client request.");
										break readingFromClient;
									}else{
										log.warn("Wrong client request");
										continue readingFromClient;
									}
							}
				}
			}

			log.debug("Overall message from "
					+ server.getInetAddress() + " is:" + input);
			log.debug("\nClosing session with "+server.getInetAddress()+"...\n\n");
			// close the session (socket) with the InsClient
			server.close();
		} catch (IOException ioe) {
			log.warn("IOException on socket listen: " + ioe,ioe);
		}
	}

