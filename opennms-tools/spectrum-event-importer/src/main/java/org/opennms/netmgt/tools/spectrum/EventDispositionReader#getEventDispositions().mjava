    public List<EventDisposition> getEventDispositions() throws IOException {
        List<EventDisposition> eventDispositions = new ArrayList<EventDisposition>();
        EventDisposition thisEventDisposition = null;
        TokenType lastToken = TokenType.none;
        
        boolean pastAlarmCause = false;
        boolean justHitEol = true;
        
        while (m_tokenizer.nextToken() != StreamTokenizer.TT_EOF) {
            //System.err.println(m_tokenizer);
            
            if (justHitEol && m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.matches(eventCodeExpr)) {
                LOG.debug("Found an event code {} on line {}, creating a new event-disposition", m_tokenizer.sval, m_tokenizer.lineno());
                thisEventDisposition = new EventDisposition(m_tokenizer.sval);
                lastToken = TokenType.eventCode;
                pastAlarmCause = false;
                justHitEol = false;
            }

            if (m_tokenizer.ttype == StreamTokenizer.TT_EOL) {
                LOG.trace("Hit EOL on line {}", m_tokenizer.lineno());
                if (thisEventDisposition != null) {
                    LOG.trace("At EOL on line {}, and the working event-disposition is non-null, adding it to the completed pile", m_tokenizer.lineno());
                    LOG.trace(thisEventDisposition.toString());
                    eventDispositions.add(thisEventDisposition);
                } else {
                    LOG.trace("At EOL on line {}, but the working event-disposition is null so not adding it", m_tokenizer.lineno());
                }
                justHitEol = true;
            }
            
            if (m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(logEventToken)) {
                if (lastToken != TokenType.eventCode) {
					LOG.error(
							"An event-log token [{}] must follow an event code directly, but the one on line {} of {} follows a {} token",
							logEventToken,
							m_tokenizer.lineno(),
							m_resource,
							lastToken.name());
                    throw new IllegalArgumentException("Found a log-event token [" + logEventToken + "] in an unexpected place on line " + m_tokenizer.lineno());
                }
                LOG.debug("Found a log-event token [{}] on line {}, setting log-event true", m_tokenizer.sval, m_tokenizer.lineno());
                thisEventDisposition.setLogEvent(true);
                lastToken = TokenType.logEvent;
            }
            
            if (lastToken == TokenType.logEvent) {
                if (m_tokenizer.nextToken() == StreamTokenizer.TT_WORD && m_tokenizer.sval.matches("^\\d+$")) {
					LOG.trace(
							"Found event severity {} for event-code {} on line {}",
							m_tokenizer.sval,
							thisEventDisposition.getEventCode(),
							m_tokenizer.lineno());
                    thisEventDisposition.setEventSeverity(Integer.valueOf(m_tokenizer.sval));
                    lastToken = TokenType.eventSeverity;
                } else {
					LOG.error(
							"Found a token [{}] following an event-severity token [{}] on line {} of {} that does not appear to be an event severity",
							m_tokenizer.sval,
							logEventToken,
							m_tokenizer.lineno(),
							m_resource);
                    throw new IllegalArgumentException("Found an out-of-place token [" + m_tokenizer.sval + "] on line " + m_tokenizer.lineno());
                }
            }
            
            if (m_tokenizer.ttype == StreamTokenizer.TT_WORD && (m_tokenizer.sval.equals(createAlarmToken) || m_tokenizer.sval.equals(clearAlarmToken))) {
				LOG.trace(
						"Found a create-alarm or clear-alarm token [{}] on line {}, checking that it's not out of order",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                if (lastToken != TokenType.eventCode && lastToken != TokenType.eventSeverity) {
					LOG.error(
							"Found a token [{}] NOT following an event-code [0xNNN...] or event-severity [e.g. 20] token on line {} of {} that does not appear to be an event severity",
							m_tokenizer.sval,
							m_tokenizer.lineno(),
							m_resource);
                    throw new IllegalArgumentException("Found an out-of-place token [" + m_tokenizer.sval + "] on line "+ m_tokenizer.lineno());
                }
            }
            
            if (m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(createAlarmToken)) {
                LOG.debug("Found a create-alarm token [{}] on line {}", m_tokenizer.sval, m_tokenizer.lineno());
				LOG.trace(
						"Found a create-alarm token [{}] on line {}, peeking ahead for the alarm severity",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                if (m_tokenizer.nextToken() != StreamTokenizer.TT_WORD || ! m_tokenizer.sval.matches("^[01234]$")) {
					LOG.error(
							"Found a create-alarm token [{}] on line {} of {} that's followed by an unexpected token [{}] instead of an alarm severity in range 0-4",
							createAlarmToken,
							m_tokenizer.lineno(),
							m_resource,
							m_tokenizer.sval);
                    throw new IllegalArgumentException("Found a create-alarm token [" + createAlarmToken + "] on line [" + m_tokenizer.lineno() + "] followed by unexpected token [" + m_tokenizer.sval + "] instead of an alarm severity in range 0-4");
                } else if (m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.matches("^[01234]$")) {
					LOG.debug(
							"Found alarm-severity token [{}] on line {}, using it to set alarm severity",
							m_tokenizer.sval,
							m_tokenizer.lineno());
                    thisEventDisposition.setCreateAlarm(true);
                    thisEventDisposition.setAlarmSeverity(Integer.valueOf(m_tokenizer.sval));
                    lastToken = TokenType.alarmSeverity;
                }
                
                if (m_tokenizer.nextToken() != ',') {
					LOG.error(
							"The alarm-severity value [{}] on line {} of {} is not followed by a comma",
							thisEventDisposition.getAlarmSeverity(),
							m_tokenizer.lineno(),
							m_resource);
                    throw new IllegalArgumentException("Alarm-severity [" + thisEventDisposition.getAlarmSeverity() + "] not followed by a comma on line "  + m_tokenizer.lineno());
                }
                lastToken = TokenType.alarmSeverityComma;
                continue;
            }
            
            if (m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(clearAlarmToken)) {
                LOG.debug("Found a clear-alarm token [{}] on line {}, setting clearAlarm to true", m_tokenizer.sval, m_tokenizer.lineno());
                thisEventDisposition.setClearAlarm(true);
                lastToken = TokenType.clearAlarm;
            }
            
            if (lastToken == TokenType.alarmSeverityComma || lastToken == TokenType.clearAlarm) {
                if (m_tokenizer.ttype != StreamTokenizer.TT_WORD) {
					LOG.error(
							"Expecting an alarm-cause token [e.g. 0xNNN...] after a {} on line {} of {} but got a non-word token of type {} instead",
							lastToken.name(),
							m_tokenizer.lineno(),
							m_resource,
							m_tokenizer.ttype);
                    throw new IllegalArgumentException("Expected an alarm-cause [e.g. 0xNNN...] after the " + lastToken.name() + " on line " + m_tokenizer.lineno() + " but got a non-word token instead");                    
                } else if (m_tokenizer.sval.matches(eventCodeExpr)) {
                    if (lastToken == TokenType.alarmSeverityComma) { 
                        LOG.debug("Found alarm-cause of [{}] on line {}, setting accordingly", m_tokenizer.sval, m_tokenizer.lineno());
                        thisEventDisposition.setAlarmCause(m_tokenizer.sval);
                    } else if (lastToken == TokenType.clearAlarm) {
                        LOG.debug("Found clear-alarm-cause of [{}] on line {}, setting accordingly", m_tokenizer.sval, m_tokenizer.lineno());
                        thisEventDisposition.setClearAlarmCause(m_tokenizer.sval);
                    }
                    lastToken = TokenType.alarmCause;
                }
            }
            
            if (lastToken == TokenType.alarmCause && m_tokenizer.ttype == ',') {
                lastToken = TokenType.alarmCauseComma;
                pastAlarmCause = true;
            }
            
            if (lastToken == TokenType.alarmCauseComma && m_tokenizer.ttype != StreamTokenizer.TT_WORD) {
				LOG.error(
						"Found an unexpected non-word token after the comma that follows alarm-cause or clear-alarm-cause [{}] on line {} of {}",
						thisEventDisposition.getAlarmCause(),
						m_tokenizer.lineno(),
						m_resource);
                throw new IllegalArgumentException("Unexpected token after the comma following alarm-cause or clear-alarm-cause [" + thisEventDisposition.getAlarmCause() + "] on line " + m_tokenizer.lineno());
            }
            
            if (pastAlarmCause && m_tokenizer.ttype == ',') {
				LOG.trace(
						"Ignoring a comma in post-(clear)-alarm-cause section of disposition for event-code {} on line {}",
						thisEventDisposition.getEventCode(),
						m_tokenizer.lineno());
            }
            
            if (pastAlarmCause && m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.matches("^\\d+$")) {
				LOG.debug(
						"Found a numeric token [{}] after the (clear)-alarm-cause on line {}, adding as a discriminator",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                thisEventDisposition.addDiscriminator(Integer.valueOf(m_tokenizer.sval));
            }
            
            if (pastAlarmCause && m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(uniqueAlarmToken)) {
				LOG.debug(
						"Found a unique-alarm token [{}] after the (clear)-alarm-cause on line {}, setting unique-alarm to true",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                thisEventDisposition.setUniqueAlarm(true);
            }

            if (pastAlarmCause && m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(notUserClearableToken)) {
				LOG.debug(
						"Found a not-user-clearable token [{}] after the (clear)-alarm-cause on line {}, setting user-clearable to false",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                thisEventDisposition.setUserClearable(false);
            }

            if (pastAlarmCause && m_tokenizer.ttype == StreamTokenizer.TT_WORD && m_tokenizer.sval.equals(notPersistentToken)) {
				LOG.debug(
						"Found a not-persistent token [{}] after the (clear)-alarm-cause on line {}, setting persistent to false",
						m_tokenizer.sval,
						m_tokenizer.lineno());
                thisEventDisposition.setPersistent(false);
            }

        }
        
        LOG.info("Loaded {} event-dispositions from [{}]", eventDispositions.size(), m_resource);
        return eventDispositions;
    }

