	/**
	 * This method maps an OSS/J AlarmValue to OpenNMS alarm
	 *
	 * @param onmsAlarm OnmsAlarm object to be populated
	 * @param alarmValue OSS/J AlarmValue data to use to populate OnmsAlarm
	 * @param almUpdateBehaviour - determines how to treat the node name of the new alarm must be of value;
	 * <code>USE_TYPE_INSTANCE</code> - populate nodeID with node having same asset type and instance data as alarm
	 * or <code>SPECIFY_OUTSTATION</code> -  populate nodeID with node having same nodeLabel as defaultUpdateNodeLabel
	 * @param defaultUpdateNodeLabel name of node to be updated if almUpdateBehaviour==SPECIFY_OUTSTATION
	 * @return the OnmsAlarm populated with OSS/J NotifyNewAlarmEvent data
	 * @throws java.lang.IllegalArgumentException if any.
	 * @throws javax.oss.UnsupportedAttributeException if any.
	 */
	public OnmsAlarm populateOnmsAlarmFromOssjAlarm(OnmsAlarm onmsAlarm, AlarmValue alarmValue, Integer almUpdateBehaviour, String defaultUpdateNodeLabel  )throws IllegalArgumentException, UnsupportedAttributeException {
		String logheader=this.getClass().getSimpleName()+"populateOnmsAlarmFromOssjAlarm():";

		try{
			String ossPrimaryKey=alarmValue.getAlarmKey().getAlarmPrimaryKey();
			String applicationDN=alarmValue.getAlarmKey().getApplicationDN();
			LOG.debug("{} AlarmPrimaryKey: {} ApplictionDN: {} alarmRaisedTime: {}", logheader, ossPrimaryKey, applicationDN, alarmValue.getAlarmRaisedTime());
			if ((applicationDN==null)||(applicationDN.equals("")) 
					|| (ossPrimaryKey==null)||(ossPrimaryKey.equals(""))) {
				LOG.error("{} ApplicatioDN or PrimaryKey not set", logheader);
			} else {
				LOG.debug("{} trying to find existing alarm using getCurrentAlarmForUniqueKey", logheader);

				onmsAlarm = ossDao.getCurrentAlarmForUniqueKey(applicationDN, ossPrimaryKey);
				if (onmsAlarm!=null) { // already an alarm with this unique id - log error
					LOG.error("{} Alarm Already exists with this Unique ID", logheader);
				} else {
					onmsAlarm=new OnmsAlarm();

					onmsAlarm.setUei(ossjAlarmTypeToUei(alarmValue.getAlarmType()));
					onmsAlarm.setX733AlarmType((alarmValue.getAlarmType()==null) ? "" : alarmValue.getAlarmType());
					onmsAlarm.setX733ProbableCause(alarmValue.getProbableCause());

					onmsAlarm.setTTicketState(null); // needed?
					onmsAlarm.setTTicketId(""); // needed?
					onmsAlarm.setQosAlarmState("");
					onmsAlarm.setSuppressedUser(""); // needed?
					onmsAlarm.setSuppressedUntil(new Date()); // needed?
					onmsAlarm.setSuppressedTime(new Date()); // needed?

					OnmsSeverity onmsseverity;
					try{
						onmsseverity= ossjSeveritytoOnmsSeverity(alarmValue.getPerceivedSeverity());
					} catch (IllegalArgumentException iae){
						LOG.error("{} problem setting severity used default:'WARNING'.", logheader, iae);
						onmsseverity=OnmsSeverity.WARNING;
					}
					onmsAlarm.setSeverity(onmsseverity); 

					OnmsServiceType service= new OnmsServiceType();
					service.setId(new Integer(-1));
					onmsAlarm.setServiceType(new OnmsServiceType()); // needed?


					onmsAlarm.setReductionKey(":managedObjectInstance:"+alarmValue.getManagedObjectInstance()+
							":managedObjectType:"+alarmValue.getManagedObjectClass()+
							":ossPrimaryKey:-"+ossPrimaryKey+
							":applicationDN:-"+applicationDN); // must be unique because of alarm_reductionkey_idx

					onmsAlarm.setOssPrimaryKey(ossPrimaryKey);
					onmsAlarm.setOperInstruct(alarmValue.getProposedRepairActions()); 

					// defaultvalue if search fails - will update node with ID 1
					OnmsNode node = new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); 
					node.setId(new Integer(1));  // node id cannot be null
					onmsAlarm.setNode(node); // 

					if (almUpdateBehaviour==null) {
						LOG.error("{} This receiver's alarmUpdateBehaviour is not set: defaulting to update nodeID:1", logheader);
					}
					else {
						LOG.debug("{} alarmUpdateBehaviour:{} {}", logheader, almUpdateBehaviour, getAlarmUpdateBehaviourForInt(almUpdateBehaviour));

						if (almUpdateBehaviour.equals(SPECIFY_OUTSTATION)) {
							// this will look for first match of node label to callingAer.getName()
							// and set node id to this value.

							LOG.debug("{} SPECIFY_OUTSTATION looking for node with nodelabel:{}", logheader, defaultUpdateNodeLabel);
							try {
								// TODO temp remove ?
								try {
									node =ossDao.findNodeByLabel(defaultUpdateNodeLabel);
								} catch (Throwable ex){
									LOG.error("{} alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node", logheader, ex);
								}

								if (node!=null) {
									LOG.debug("{} alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION): NODE FOUND for this name:{} setting node id to NodeLabel:{} NodeID:{}", logheader, defaultUpdateNodeLabel, node.getLabel(), node.getId());
									onmsAlarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType
								} else {
									LOG.error("{} alarmUpdateBehaviour.equals(SPECIFY_OUTSTATION): NODE NOT FOUND for this name:{} setting node id to default NodeID: 1", logheader, defaultUpdateNodeLabel);
									node=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode(); 
									node.setId(new Integer(1));  // node id cannot be null
									onmsAlarm.setNode(node); // 
								}
							} catch (Throwable ex){
								LOG.error("{} alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1", logheader, ex);
							}

						} 
						else if (almUpdateBehaviour.equals(USE_TYPE_INSTANCE)){
							// this will look for first match of node Managed object Instance and Managed Object type
							// and set node id to this value. 
							String managedObjectType=alarmValue.getManagedObjectClass();
							String managedObjectInstance=alarmValue.getManagedObjectInstance();

							LOG.debug("{} USE_TYPE_INSTANCE looking for node with managedObjectType:{} managedObjectInstance:{}", logheader, managedObjectType, managedObjectInstance);
							try {
								node =ossDao.findNodeByInstanceAndType(managedObjectInstance, managedObjectType);

								if (node!=null) {
									LOG.debug("{} alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE): NODE FOUND for this RX Name:{} setting node id to NodeLabel:{} NodeID:{}", logheader, defaultUpdateNodeLabel, node.getLabel(), node.getId());
									onmsAlarm.setNode(node); // maps into FIRST instance of node with the same managedObjectInstance and managedObjectType
								} else {
									LOG.error("{} alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE): NODE NOT FOUND for this managedObjectType:{} managedObjectInstance:{} setting node id to default NodeID: 1", logheader, managedObjectType, managedObjectInstance);
									node=new OnmsNode() ; // TODO remove ossDao.makeExtendedOnmsNode();
									node.setId(new Integer(1));  // node id cannot be null
									onmsAlarm.setNode(node); // 
								}
							} catch (Throwable ex){
								LOG.error("{} alarmUpdateBehaviour.equals(USE_TYPE_INSTANCE) Problem looking up Node for alarm Set to default nodeID:1", logheader, ex);
							}
						}		
						else {
							LOG.error("{} Invalid value for alarmUpdateBehaviour:{} {} defaulting to update nodeID:1", logheader, almUpdateBehaviour, getAlarmUpdateBehaviourForInt(almUpdateBehaviour));
						}
					}


					onmsAlarm.setMouseOverText(""); // needed?
					onmsAlarm.setManagedObjectType(alarmValue.getManagedObjectClass());
					onmsAlarm.setManagedObjectInstance(alarmValue.getManagedObjectInstance());
					onmsAlarm.setLogMsg(alarmValue.getSpecificProblem());

					// NOTE - this has no effect here as .setLastEvent nulls value
					// alarm.setLastEventTime(nnae.getEventTime());

//					TODO REMOVED - DO NOT CREATE EVENT WITH HIBERNATE AlarmDAo
//					OnmsEvent event= new OnmsEvent();
//					//event.setId(new Integer(1));  // This is NOT set since unique constraint in alarms table on Events table
//					onmsAlarm.setLastEvent(event); 

					onmsAlarm.setIpAddr(InetAddressUtils.getLocalHostAddress()); // needed?
					onmsAlarm.setId(null); // set null as updating alarm
					onmsAlarm.setFirstEventTime(alarmValue.getAlarmRaisedTime());
					onmsAlarm.setLastEventTime(alarmValue.getAlarmChangedTime());

//					TODO removed - do create distpoller with hibernate dao	
//					onmsAlarm.setDistPoller(new OnmsDistPoller("undefined","localhost")); //simple constructor
					onmsAlarm.setDistPoller(distPollerDao.get("localhost"));


					onmsAlarm.setDescription(alarmValue.getAdditionalText()); //TODO need Qosd Not to generate this if remote
					onmsAlarm.setCounter(new Integer(1));
					onmsAlarm.setApplicationDN(applicationDN);
					onmsAlarm.setAlarmType(new Integer(1)); // set to raise alarm
					//alarm.setAlarmAckUser(arg0);
					//alarm.setAlarmAckTime(arg0);

					LOG.debug("{} Creating Alarm", logheader);
				}
			}
		}
		catch(Throwable e){
			LOG.error("{} Error : ", logheader, e);
		}
		return onmsAlarm;

	}

