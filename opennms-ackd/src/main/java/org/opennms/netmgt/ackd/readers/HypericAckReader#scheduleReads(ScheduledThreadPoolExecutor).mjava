    private synchronized void scheduleReads(final ScheduledThreadPoolExecutor executor) {
        log().debug("scheduleReads: acquired lock, creating schedule...");

        executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
        executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
        m_future = executor.scheduleWithFixedDelay(
                this.getAckProcessor(),
                getSchedule().getInitialDelay(), 
                getSchedule().getInterval(), 
                getSchedule().getUnit()
        );
        log().debug("scheduleReads: exited lock, schedule updated.");
        log().debug("scheduleReads: schedule is:" +
                " attempts remaining: "+getSchedule().getAttemptsRemaining()+
                "; initial delay: "+getSchedule().getInitialDelay()+
                "; interval: "+getSchedule().getInterval()+
                "; unit: "+getSchedule().getUnit());

        log().debug("scheduleReads: executor details:"+
                " active count: "+executor.getActiveCount()+
                "; completed task count: "+executor.getCompletedTaskCount()+
                "; task count: "+executor.getTaskCount()+
                "; queue size: "+executor.getQueue().size());
    }

