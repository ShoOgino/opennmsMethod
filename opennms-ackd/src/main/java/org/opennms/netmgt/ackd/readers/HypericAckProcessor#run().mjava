    public void run() {
        int count = 0;

        // Parse Hyperic alert states
        try {
            log().info("run: Processing Hyperic acknowledgments..." );

            OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, "alarm");
            criteria.add(Restrictions.isNull("alarmAckUser"));
            // Restrict to Hyperic alerts
            criteria.add(Restrictions.eq("uei", "uei.opennms.org/external/hyperic/alert"));
            // TODO Figure out how to query by parameters

            Map<String,List<OnmsAlarm>> organizedAlarms = new TreeMap<String,List<OnmsAlarm>>();

            // Query list of outstanding alerts with remote platform identifiers
            List<OnmsAlarm> unAckdAlarms = m_alarmDao.findMatching(criteria);

            // Organize the alarms according to the Hyperic system where they originated
            for (OnmsAlarm alarm : unAckdAlarms) {
                String hypericSystem = alarm.getEventParms();
                // Figure out how to parse the event parms into a list, get the platform.agent.address or platform.id
                String key = "blah";
                List<OnmsAlarm> targetList = organizedAlarms.get(key);
                if (targetList == null) {
                    targetList = new ArrayList<OnmsAlarm>();
                    organizedAlarms.put(key, targetList);
                }
                targetList.add(alarm);
            }

            // Connect to each Hyperic system and query for the status of corresponding alerts 
            for (Map.Entry<String, List<OnmsAlarm>> alarmList : organizedAlarms.entrySet()) {
                String hypericSystem = alarmList.getKey();
                for (OnmsAlarm alarmsForSystem : alarmList.getValue()) {
                    // Construct a sane query for the Hyperic system
                }

                HttpClient httpClient = new HttpClient();
                HostConfiguration hostConfig = new HostConfiguration();
                GetMethod  getMethod = new GetMethod("/hqu/opennms/alertStatus/list.hqu");
                httpClient.getParams().setParameter(HttpClientParams.SO_TIMEOUT, 3000);
                httpClient.getParams().setParameter(HttpClientParams.USER_AGENT, "OpenNMS Ackd.HypericAckProcessor");
                // Change these parameters to be configurable
                hostConfig.setHost(HYPERIC_IP_ADDRESS, HYPERIC_PORT);
                // hostConfig.getParams().setParameter(HttpClientParams.VIRTUAL_HOST, "????");
                // if(ParameterMap.getKeyedBoolean(map, "http-1.0", false))
                // httpClient.getParams().setParameter(HttpClientParams.PROTOCOL_VERSION,HttpVersion.HTTP_1_0);

                if (HYPERIC_USER != null && !"".equals(HYPERIC_USER) && HYPERIC_PASSWORD != null && !"".equals(HYPERIC_PASSWORD)) {
                    httpClient.getParams().setAuthenticationPreemptive(true);
                    httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(HYPERIC_USER, HYPERIC_PASSWORD));
                }

                try {
                    log().debug("httpClient request with the following parameters: " + httpClient);
                    log().debug("hostConfig parameters: " + hostConfig);
                    log().debug("getMethod parameters: " + getMethod);
                    httpClient.executeMethod(hostConfig, getMethod);

                    Integer statusCode = getMethod.getStatusCode();
                    String statusText = getMethod.getStatusText();
                    String responseText = getMethod.getResponseBodyAsString();

                    // Instantiate a JAXB context to parse the alert status
                    JAXBContext context = JAXBContext.newInstance(new Class[] { HypericAckProcessor.HypericAlertStatus.class });
                    XMLInputFactory xmlif = XMLInputFactory.newInstance();
                    XMLEventReader xmler = xmlif.createXMLEventReader(new StringReader(responseText));
                    EventFilter filter = new EventFilter() {
                        public boolean accept(XMLEvent event) {
                            return event.isStartElement();
                        }
                    };
                    XMLEventReader xmlfer = xmlif.createFilteredReader(xmler, filter);
                    // Read up until the beginning of the root element
                    StartElement e = (StartElement)xmlfer.nextEvent();
                    // Fetch the root element name for {@link HypericAlertStatus} objects
                    String rootElementName = context.createJAXBIntrospector().getElementName(new HypericAlertStatus()).getLocalPart();
                    if (rootElementName.equals(e.getName().getLocalPart())) {
                        Unmarshaller unmarshaller = context.createUnmarshaller();
                        // Use StAX to pull parse the incoming alert statuses
                        while (xmlfer.peek() != null) {
                            Object object = unmarshaller.unmarshal(xmler);
                            if (object instanceof HypericAlertStatus) {
                                HypericAlertStatus alertStatus = (HypericAlertStatus)object;
                            }
                        }
                    } else {
                        // Formatting exception
                    }
                } catch (HttpException e) {
                    log().info(e);
                } catch (IOException e) {
                    log().info(e);
                } finally{
                    getMethod.releaseConnection();
                }
            }

            // Iterate and update any acknowledged or fixed alerts

            log().info("run: Finished processing Hyperic acknowledgments (" + count + " acks processed)" );
        } catch (Throwable e) {
            log().warn("run: threw exception: "+e);
        }
    }

