    public void run() {
        int count = 0;

        // Parse Hyperic alert states
        try {
            log().info("run: Processing Hyperic acknowledgments..." );

            OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, "alarm");
            criteria.add(Restrictions.isNull("alarmAckUser"));
            // Restrict to Hyperic alerts
            criteria.add(Restrictions.eq("uei", "uei.opennms.org/external/hyperic/alert"));
            // TODO Figure out how to query by parameters

            Map<String,List<OnmsAlarm>> organizedAlarms = new TreeMap<String,List<OnmsAlarm>>();

            // Query list of outstanding alerts with remote platform identifiers
            List<OnmsAlarm> unAckdAlarms = m_alarmDao.findMatching(criteria);

            // Organize the alarms according to the Hyperic system where they originated
            for (OnmsAlarm alarm : unAckdAlarms) {
                String hypericSystem = alarm.getEventParms();
                // Figure out how to parse the event parms into a list, get the platform.agent.address or platform.id
                String key = "blah";
                List<OnmsAlarm> targetList = organizedAlarms.get(key);
                if (targetList == null) {
                    targetList = new ArrayList<OnmsAlarm>();
                    organizedAlarms.put(key, targetList);
                }
                targetList.add(alarm);
            }

            // Connect to each Hyperic system and query for the status of corresponding alerts 
            for (Map.Entry<String, List<OnmsAlarm>> alarmList : organizedAlarms.entrySet()) {
                // TODO Match this string to the Hyperic URL via the config
                String hypericSystem = alarmList.getKey();

                List<OnmsAlarm> alarmsForSystem = alarmList.getValue();
                List<String> alertIdList = new ArrayList<String>();
                for (OnmsAlarm alarmForSystem : alarmList.getValue()) {
                    // Construct a sane query for the Hyperic system
                    String alertId = getAlertIdParmValue(alarmForSystem);
                    alertIdList.add(alertId);
                }

                // Call fetchHypericAlerts() for each system
                List<HypericAlertStatus> alertsForSystem = fetchHypericAlerts(alertIdList);

                // Iterate and update any acknowledged or fixed alerts
                List<OnmsAcknowledgment> acks = new ArrayList<OnmsAcknowledgment>();
                for (HypericAlertStatus alert : alertsForSystem) {
                    OnmsAlarm alarm = findAlarmForHypericAlert(alarmsForSystem, hypericSystem, alert);
                    // If the Hyperic alert has been ack'd and the local alarm is not yet ack'd, then ack it
                    if (alert.isAcknowledged() && alarm.getAckTime() == null) {
                        // TODO Get the ack time from Hyperic??
                        OnmsAcknowledgment ack = new OnmsAcknowledgment(alarm, "Ackd.HypericAckProcessor", new Date());
                        ack.setAckAction(AckAction.ACKNOWLEDGE);
                        ack.setLog("Acknowledged by Ackd.HypericAckProcessor");
                        acks.add(ack);
                    }

                    // If the Hyperic alert has been fixed and the local alarm is not yet marked as CLEARED, then clear it
                    if (alert.isFixed() && !OnmsSeverity.CLEARED.equals(alarm.getSeverity())) {
                        // TODO Get the ack time from Hyperic??
                        OnmsAcknowledgment ack = new OnmsAcknowledgment(alarm, "Ackd.HypericAckProcessor", new Date());
                        ack.setAckAction(AckAction.CLEAR);
                        ack.setLog("Cleared by Ackd.HypericAckProcessor");
                        acks.add(ack);
                    }
                }

                if (acks.size() > 0) {
                    m_ackService.processAcks(acks);
                }
            }

            log().info("run: Finished processing Hyperic acknowledgments (" + count + " acks processed)" );
        } catch (Throwable e) {
            log().warn("run: threw exception: "+e);
        }
    }

