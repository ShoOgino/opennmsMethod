    public void run() {
        List<OnmsAcknowledgment> acks = new ArrayList<OnmsAcknowledgment>();

        try {
            log().info("run: Processing Hyperic acknowledgments..." );

            // Query list of outstanding alerts with remote platform identifiers
            List<OnmsAlarm> unAckdAlarms = fetchUnackdHypericAlarms();

            Map<String,List<OnmsAlarm>> organizedAlarms = new TreeMap<String,List<OnmsAlarm>>();
            // Split the list of alarms up according to the Hyperic system where they originated
            for (OnmsAlarm alarm : unAckdAlarms) {
                // TODO Map by platform.agent.address or platform.id?
                // TODO If the platform.id doesn't match anything in our current config, just ignore it, maybe warn in the logs with a counter
                String key = getPlatformIdParmValue(alarm);
                List<OnmsAlarm> targetList = organizedAlarms.get(key);
                if (targetList == null) {
                    targetList = new ArrayList<OnmsAlarm>();
                    organizedAlarms.put(key, targetList);
                }
                targetList.add(alarm);
            }

            // Connect to each Hyperic system and query for the status of corresponding alerts 
            for (Map.Entry<String, List<OnmsAlarm>> alarmList : organizedAlarms.entrySet()) {
                String hypericSystem = alarmList.getKey();
                List<OnmsAlarm> alarmsForSystem = alarmList.getValue();

                // Match the platform.id to the Hyperic URL via the config
                String hypericUrl = getUrlForHypericPlatformId(hypericSystem);
                if (hypericUrl == null) {
                    log().warn("Could not find Hyperic host URL for the following platform ID: " + hypericSystem);
                    log().warn("Skipping processing of " + alarmsForSystem.size() + " alarms with that platform ID");
                    continue;
                }

                try {

                    List<String> alertIdList = new ArrayList<String>();
                    for (OnmsAlarm alarmForSystem : alarmList.getValue()) {
                        // Construct a sane query for the Hyperic system
                        String alertId = getAlertIdParmValue(alarmForSystem);
                        alertIdList.add(alertId);
                    }

                    // Call fetchHypericAlerts() for each system
                    List<HypericAlertStatus> alertsForSystem = fetchHypericAlerts(hypericUrl, alertIdList);

                    // Iterate and update any acknowledged or fixed alerts
                    for (HypericAlertStatus alert : alertsForSystem) {
                        OnmsAlarm alarm = findAlarmForHypericAlert(alarmsForSystem, hypericSystem, alert);

                        // If the Hyperic alert has been ack'd and the local alarm is not yet ack'd, then ack it
                        if (alert.isAcknowledged() && alarm.getAckTime() == null) {
                            // TODO Get the ack time from Hyperic??
                            OnmsAcknowledgment ack = new OnmsAcknowledgment(alarm, "Ackd.HypericAckProcessor", new Date());
                            ack.setAckAction(AckAction.ACKNOWLEDGE);
                            ack.setLog("Acknowledged by Ackd.HypericAckProcessor");
                            acks.add(ack);
                        }

                        // If the Hyperic alert has been fixed and the local alarm is not yet marked as CLEARED, then clear it
                        if (alert.isFixed() && !OnmsSeverity.CLEARED.equals(alarm.getSeverity())) {
                            // TODO Get the ack time from Hyperic??
                            OnmsAcknowledgment ack = new OnmsAcknowledgment(alarm, "Ackd.HypericAckProcessor", new Date());
                            ack.setAckAction(AckAction.CLEAR);
                            ack.setLog("Cleared by Ackd.HypericAckProcessor");
                            acks.add(ack);
                        }
                    }
                } catch (Throwable e) {
                    log().warn("run: threw exception when processing alarms for Hyperic system " + hypericSystem + ": " + e.getMessage());
                    log().warn("run: " + acks.size() + " acknowledgements processed successfully before exception");
                } finally {
                    if (acks.size() > 0) {
                        m_ackService.processAcks(acks);
                    }
                }
            }

            log().info("run: Finished processing Hyperic acknowledgments (" + acks.size() + " acks processed)" );
        } catch (Throwable e) {
            log().warn("run: threw exception: " + e.getMessage());
        }
    }

