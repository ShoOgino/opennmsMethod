    public void run() {
        int count = 0;

        // Parse Hyperic alert states
        try {
            log().info("run: Processing Hyperic acknowledgments..." );

            OnmsCriteria criteria = new OnmsCriteria(OnmsAlarm.class, "alarm");
            criteria.add(Restrictions.isNull("alarmAckUser"));
            // Restrict to Hyperic alerts
            criteria.add(Restrictions.eq("uei", "uei.opennms.org/external/hyperic/alert"));
            // TODO Figure out how to query by parameters

            Map<String,List<OnmsAlarm>> organizedAlarms = new TreeMap<String,List<OnmsAlarm>>();

            // Query list of outstanding alerts with remote platform identifiers
            List<OnmsAlarm> unAckdAlarms = m_alarmDao.findMatching(criteria);

            // Organize the alarms according to the Hyperic system where they originated
            for (OnmsAlarm alarm : unAckdAlarms) {
                String hypericSystem = alarm.getEventParms();
                // Figure out how to parse the event parms into a list, get the platform.agent.address or platform.id
                String key = "blah";
                List<OnmsAlarm> targetList = organizedAlarms.get(key);
                if (targetList == null) {
                    targetList = new ArrayList<OnmsAlarm>();
                    organizedAlarms.put(key, targetList);
                }
                targetList.add(alarm);
            }

            // Connect to each Hyperic system and query for the status of corresponding alerts 
            for (Map.Entry<String, List<OnmsAlarm>> alarmList : organizedAlarms.entrySet()) {
                String hypericSystem = alarmList.getKey();
                List<OnmsAlarm> alarmsForSystem = alarmList.getValue();
                for (OnmsAlarm alarmForSystem : alarmList.getValue()) {
                    // Construct a sane query for the Hyperic system
                }

                // Call fetchHypericAlerts() for each system
                List<HypericAlertStatus> alertsForSystem = new ArrayList<HypericAlertStatus>();

                // Iterate and update any acknowledged or fixed alerts
                List<OnmsAcknowledgment> acks = new ArrayList<OnmsAcknowledgment>();
                for (HypericAlertStatus alert : alertsForSystem) {
                    if (alert.isAcknowledged()) {
                        // OnmsAlarm alarm = getByPlatformIdAndAlertId(alarmsForSystem, hypericSystem, i);
                        OnmsAcknowledgment ack = new OnmsAcknowledgment(new Date(), "Ackd.HypericAckProcessor");
                        ack.setAckType(AckType.ALARM);
                        ack.setAckAction(AckAction.ACKNOWLEDGE);
                        ack.setLog("Acknowledged by Ackd.HypericAckProcessor");
                        acks.add(ack);
                    }
                    if (alert.isFixed()) {
                        // OnmsAlarm alarm = getByPlatformIdAndAlertId(alarmsForSystem, hypericSystem, i);
                        OnmsAcknowledgment ack = new OnmsAcknowledgment(new Date(), "Ackd.HypericAckProcessor");
                        ack.setAckType(AckType.ALARM);
                        ack.setAckAction(AckAction.CLEAR);
                        ack.setLog("Cleared by Ackd.HypericAckProcessor");
                        acks.add(ack);
                    }
                }

                if (acks.size() > 0) {
                    m_ackService.processAcks(acks);
                }
            }

            log().info("run: Finished processing Hyperic acknowledgments (" + count + " acks processed)" );
        } catch (Throwable e) {
            log().warn("run: threw exception: "+e);
        }
    }

