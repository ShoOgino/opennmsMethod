    /**
     * This method should be called if you want to put constraints on the node,
     * interface or service that is returned in the rule. This is useful to see
     * if a particular node, interface, or service matches in the rule, and is
     * primarily used to filter notices. A subselect is built containing joins
     * constrained by node, interface, and service if they are not null or
     * blank. This select is then anded with the filter rule to get the complete
     * SQL statement.
     *
     * @param nodeId
     *            a node id to constrain against
     * @param ipaddr
     *            an ipaddress to constrain against
     * @param service
     *            a service name to constrain against
     */
    public void setConstraintTranslation(long nodeId, String ipaddr, String service) {
        m_selectModifier = "DISTINCT";

        m_selectList.clear();

        String ipAddrColumn = addColumn("ipAddr");
        m_selectList.add(ipAddrColumn);

        StringBuffer constraint = new StringBuffer();
        boolean needAnd = false;
        if (nodeId != 0) {
            if (needAnd)
                constraint.append(" AND ");
            String nodeIDColumn = addColumn("nodeID");
            constraint.append(nodeIDColumn).append(" = ").append(nodeId);
            needAnd = true;
        }

        if (ipaddr != null && !ipaddr.equals("")) {
            if (needAnd)
                constraint.append(" AND ");
            constraint.append(ipAddrColumn).append(" = '").append(ipaddr).append('\'');
            needAnd = true;
        }

        if (service != null && !service.equals("")) {
            String serviceColumn = addColumn("serviceName");
            if (needAnd)
                constraint.append(" AND ");
            constraint.append(serviceColumn).append(" = '").append(service).append('\'');
            needAnd = true;
        }

        m_where.append(constraint).append(") AND (");

    }

