    /**
     * <p>init</p>
     *
     * @param dsName a {@link java.lang.String} object.
     * @throws java.io.IOException if any.
     * @throws org.exolab.castor.xml.MarshalException if any.
     * @throws org.exolab.castor.xml.ValidationException if any.
     * @throws java.lang.ClassNotFoundException if any.
     * @throws java.beans.PropertyVetoException if any.
     * @throws java.sql.SQLException if any.
     */
    public static synchronized void init(final String dsName) throws IOException, MarshalException, ValidationException, ClassNotFoundException, PropertyVetoException, SQLException {
        if (isLoaded(dsName)) {
            // init already called - return
            // to reload, reload() will need to be called
            return;
        }

        String factoryClass = null;
        final File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.OPENNMS_DATASOURCE_CONFIG_FILE_NAME);
        DataSourceConfiguration dsc = null;
        ConnectionPool connectionPool = null;
    	FileInputStream fileInputStream = null;
    	try {
    		fileInputStream = new FileInputStream(cfgFile);
    		dsc = CastorUtils.unmarshal(DataSourceConfiguration.class, fileInputStream, CastorUtils.PRESERVE_WHITESPACE);
    		connectionPool = dsc.getConnectionPool();
    		if (connectionPool != null) {
        		factoryClass = connectionPool.getFactory();
    		}
    	} finally {
    		IOUtils.closeQuietly(fileInputStream);
    	}

    	final String configPath = cfgFile.getPath();
    	ClosableDataSource dataSource = null;
		final String defaultClassName = DEFAULT_FACTORY_CLASS.getName();
    	try {
    		final Class<?> clazz = Class.forName(factoryClass);
    		final Constructor<?> constructor = clazz.getConstructor(new Class<?>[] { String.class, String.class });
    		dataSource = (ClosableDataSource)constructor.newInstance(new Object[] { configPath, dsName });
    	} catch (final Throwable t) {
    		LogUtils.debugf(DataSourceFactory.class, t, "Unable to load %s, falling back to the default dataSource (%s)", factoryClass, defaultClassName);
    		try {
				final Constructor<?> constructor = ((Class<?>) DEFAULT_FACTORY_CLASS).getConstructor(new Class<?>[] { String.class, String.class });
				dataSource = (ClosableDataSource)constructor.newInstance(new Object[] { configPath, dsName });
			} catch (final Throwable cause) {
				LogUtils.errorf(DataSourceFactory.class, cause, "Unable to load %s.", DEFAULT_FACTORY_CLASS.getName());
				throw new SQLException("Unable to load " + defaultClassName + ".", cause);
			}
    	}

    	final ClosableDataSource runnableDs = dataSource;
        m_closers.add(new Runnable() {
            public void run() {
                try {
                    runnableDs.close();
                } catch (final Throwable cause) {
                	LogUtils.infof(DataSourceFactory.class, cause, "Unable to close datasource %s.", dsName);
                }
            }
        });
        
    	if (connectionPool != null) {
    		dataSource.setIdleTimeout(connectionPool.getIdleTimeout());
    		dataSource.setLoginTimeout(connectionPool.getLoginTimeout());
    		dataSource.setMinPool(connectionPool.getMinPool());
    		dataSource.setMaxPool(connectionPool.getMaxPool());
    		dataSource.setMaxSize(connectionPool.getMaxSize());
    	}

    	// Springframework provided proxies that make working with transactions much easier
        final LazyConnectionDataSourceProxy lazyProxy = new LazyConnectionDataSourceProxy(dataSource);
        
        setInstance(dsName, lazyProxy);
    }

