    /** {@inheritDoc} */
    @Override
    public void visit(OnmsAttribute attribute) {
        if (!RrdGraphAttribute.class.isAssignableFrom(attribute.getClass())) {
            // Nothing to do if we can't cast to an RrdGraphAttribute
            return;
        }

        final Source source = new Source();
        source.setLabel("result");
        source.setResourceId(attribute.getResource().getId());
        source.setAttribute(attribute.getName());
        source.setAggregation(m_consolidationFunction.toUpperCase());

        final FetchResults results;
        try {
            results = m_fetchStrategy.fetch(m_startTime,
                                            m_endTime,
                                            1,
                                            0,
                                            null,
                                            null,
                                            Collections.singletonList(source));
        } catch (final Exception e) {
            LOG.warn("Failed to fetch statistic: {}", source, e);
            return;
        }

        if (results == null) {
            LOG.warn("No statistic found: {}", source);
            return;
        }

        final double[] statistics = results.getColumns().get(source.getLabel());
        if (statistics == null || statistics.length == 0) {
            LOG.warn("Statistic is empty: {}", source);
            return;
        }

        final Aggregator aggregator = Aggregators.valueOf(m_consolidationFunction.toUpperCase());

        Arrays.stream(statistics)
                .filter(v -> (! Double.isNaN(v)))
                .forEach(v -> {
                    LOG.debug("Aggregating: {}", v);
                    aggregator.aggregate(v);
                });

        double statistic = aggregator.getValue();
        
        LOG.debug("The value of {} is {}", attribute, statistic);
        
        /*
         * We don't want to do anything with NaN data, since
         * it means there is no data. We especially want to
         * stay away from it, because it will be sorted as
         * being higher than any numeric value, which will
         * leave our TopN report with most, if not all NaN
         * values at the top.
         */
        if (Double.isNaN(statistic)) {
            return;
        }
        
        m_statisticVisitor.visit(attribute, statistic);
    }

