    /**
     * <p>readTables</p>
     *
     * @param reader a {@link java.io.Reader} object.
     * @throws java.lang.Exception if any.
     */
    public void readTables(Reader reader) throws Exception {
        BufferedReader r = new BufferedReader(reader);
        String line;

        m_tables = new LinkedList<String>();
        m_seqmapping = new HashMap<String, String[]>();
        m_sequences = new LinkedList<String>();
        m_indexDao.reset();

        LinkedList<String> sql_l = new LinkedList<String>();

        Pattern seqmappingPattern = Pattern.compile("\\s*--#\\s+install:\\s*"
                + "(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*.*");
        Pattern createPattern = Pattern.compile("(?i)\\s*create\\b.*");
        Pattern criteriaPattern = Pattern.compile("\\s*--#\\s+criteria:\\s*(.*)");
        Pattern insertPattern = Pattern.compile("(?i)INSERT INTO "
                + "[\"']?([\\w_]+)[\"']?.*");
        Pattern dropPattern = Pattern.compile("(?i)DROP TABLE [\"']?"
                + "([\\w_]+)[\"']?.*");
        
        
        String criteria = null;
        while ((line = r.readLine()) != null) {
            Matcher m;

            if (line.matches("\\s*") || line.matches("\\s*\\\\.*")) {
                continue;
            }

            m = seqmappingPattern.matcher(line);
            if (m.matches()) {
                String[] a = { m.group(2), m.group(3) };
                m_seqmapping.put(m.group(1), a);
                continue;
            }
            
            m = criteriaPattern.matcher(line);
            if (m.matches()) {
                criteria = m.group(1);
                continue;
            }

            if (line.matches("--.*")) {
                continue;
            }

            if (createPattern.matcher(line).matches()) {
                m = Pattern.compile(
                                    "(?i)\\s*create\\s+((?:unique )?\\w+)"
                                            + "\\s+[\"']?(\\w+)[\"']?.*").matcher(
                                                                                  line);
                if (m.matches()) {
                    String type = m.group(1);
                    String name = m.group(2).replaceAll("^[\"']", "").replaceAll(
                                                                                 "[\"']$",
                                                                                 "");

                    if (type.toLowerCase().indexOf("table") != -1) {
                        m_tables.add(name);
                    } else if (type.toLowerCase().indexOf("sequence") != -1) {
                        m_sequences.add(name);
                    } else if (type.toLowerCase().indexOf("function") != -1) {
                        if (type.toLowerCase().indexOf("language 'c'") != -1) {
                            //m_cfunctions.add(name);
                        } else {
                            //m_functions.add(name);
                        }
                    } else if (type.toLowerCase().indexOf("trusted") != -1) {
                        m = Pattern.compile("(?i)\\s*create\\s+trusted "
                                            + "procedural language\\s+[\"']?"
                                            + "(\\w+)[\"']?.*").matcher(line);
                        if (!m.matches()) {
                            throw new Exception("Could not match name and "
                                                + "type of the trusted "
                                                + "procedural language in "
                                                + "this line: " + line);
                        }
                        //m_languages.add(m.group(1));
                    } else if (type.toLowerCase().matches(".*\\bindex\\b.*")) {
                        Index i = Index.findIndexInString(line);
                        if (i == null) {
                            throw new Exception("Could not match name and "
                                    + "type of the index " + "in this line: "
                                    + line);
                        }
                        m_indexDao.add(i);
                    } else {
                        throw new Exception("Unknown CREATE encountered: "
                                + "CREATE " + type + " " + name);
                    }
                } else {
                    throw new Exception("Unknown CREATE encountered: " + line);
                }

                sql_l.add(line);
                continue;
            }

            m = insertPattern.matcher(line);
            if (m.matches()) {
                String table = m.group(1);
                Insert insert = new Insert(table, line, criteria);
                criteria = null;
                if (!m_inserts.containsKey(table)) {
                    m_inserts.put(table, new LinkedList<Insert>());
                }
                m_inserts.get(table).add(insert);

                continue;
            }

            if (line.toLowerCase().startsWith("select setval ")) {
                String table = "select_setval";
                Insert insert = new Insert("select_setval", line, null);
                if (!m_inserts.containsKey(table)) {
                    m_inserts.put(table, new LinkedList<Insert>());
                }
                m_inserts.get(table).add(insert);

                sql_l.add(line);
                continue;
            }

            m = dropPattern.matcher(line);
            if (m.matches()) {
                m_drops.add(m.group(1));

                sql_l.add(line);
                continue;
            }

            // XXX should do something here so we can catch what we can't
            // parse
            // m_out.println("unmatched line: " + line);

            sql_l.add(line);
        }
        r.close();

        m_sql = cleanText(sql_l);
    }

