    @Override
    public synchronized void walked(int nodeid, Date now) {
 
        List<BridgeMacLink> bft = m_notYetParsedBFTMap.remove(nodeid);
        Set<String>incomingSet = new HashSet<String>();
        for (BridgeMacLink link: bft)
            incomingSet.add(link.getMacAddress());
        LOG.debug("walked: parsing BFT with {} incoming macs", incomingSet.size());
        BroadcastDomain bftdomain = null;
        for (BroadcastDomain domain: m_domains) {
            Set<String>retainedSet = new HashSet<String>(domain.getMacsOnDomain());
            LOG.debug("walked: checking against BroadcastDomain with macs size {}", retainedSet.size());
            retainedSet.retainAll(incomingSet);
            LOG.debug("walked: BFT and BroadcastDomain cross macs size {}", retainedSet.size());
            // should contain at list 50% of the all size
            if (retainedSet.size() < 10 && retainedSet.size() <= incomingSet.size()*0.1 ) {
                domain.removeBridge(nodeid);
                continue;          
            }
            LOG.info("walked: BFT and BroadcastDomain matches, saving bft to domain");
            bftdomain = domain;
            break;
        }
        if (bftdomain == null) {
            bftdomain = new BroadcastDomain();
            m_domains.add(bftdomain);
        }
        bftdomain.loadBFT(nodeid,bft,m_notYetParsedSTPMap.remove(nodeid),m_notYetParsedEleMap.remove(nodeid));
        bftdomain.setLastUpdate(nodeid,now);
        
        List<BroadcastDomain> domains = new ArrayList<BroadcastDomain>();
        for (BroadcastDomain domain: m_domains) {
            if (domain.isEmpty())
                continue;
            domains.add(domain);
        }
        m_domains = domains;

    }

