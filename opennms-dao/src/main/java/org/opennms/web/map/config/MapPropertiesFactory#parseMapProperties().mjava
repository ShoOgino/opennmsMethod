    /**
     * Parses the map.properties file into some mappings:
     *  -severitiesMap: severity label (String) to Severity
     *	-statusesMap: status (String) uei to Status
     * 	-availsMap: min (String) of avail to Avail
     *	-iconsMap: icon (String) label to String (icon filename)
     *	-iconsBySysoidMap: sysoid (String) to icon label (String)
     *	-bgImagesMap: background (String) image label to String (background image filename)
     *	-sourcesMap: source label (String) to DataSource
     *	-factoriesMap: factory label (String) to MapsFactory
     *
     * @throws java.io.FileNotFoundException if any.
     * @throws java.io.IOException if any.
     */
    protected void parseMapProperties() throws FileNotFoundException,
    IOException {
        LOG.debug("Parsing map.properties...");
        severitiesMap = new HashMap<String,Severity>();
        statusesMap = new HashMap<String,Status>();
        availsMap = new HashMap<String,Avail>();
        iconsMap = new HashMap<String,String>();
        iconsBySysoidMap = new HashMap<String,String>();
        bgImagesMap = new HashMap<String,String>();
        linksMap = new HashMap<Integer,Link>();
        linksBySnmpTypeMap = new HashMap<Integer,Set<Link>>();
        linkStatusesMap = new HashMap<String,LinkStatus>();

        // read the file
        Properties props = new Properties();
        props.load(new FileInputStream(mapPropertiesFile));

        //load context menu flag
        String cntxtmenu = props.getProperty("enable.contextmenu");
        if(cntxtmenu!=null && cntxtmenu.equalsIgnoreCase("false"))
            contextMenuEnabled=false;
        LOG.debug("enable.contextmenu={}", cntxtmenu);			
        // load context menu object only if context menu is enabled

        cmenu = new ContextMenu();
        if (contextMenuEnabled) {
            String commandList = props.getProperty("cmenu.commands");
            if(commandList!=null){
                String[] commands = BundleLists.parseBundleList(commandList);
                if(commands!=null){
                    for (int j = 0; j < commands.length;j++) {
                        String link = "-";
                        String params = "-";
                        if(!commands[j].equals("-")){
                            //load the link to open for the command
                            link = props.getProperty("cmenu."+commands[j]+".link");
                            LOG.debug("cmenu.{}.link={}", commands[j], link);
                            if(link==null){
                                LOG.warn("link is null! skipping..");
                                continue;
                            }
                            params = props.getProperty("cmenu."+commands[j]+".params");						
                            LOG.debug("cmenu.{}.params={}", commands[j], params);
                            if(params==null) params="";
                        }
                        cmenu.addEntry(commands[j], link, params);
                    }
                }
            }else{
                LOG.warn("Context Menu enabled but No command found!");
            }

        }

        //load double click flag
        String doubleclick = props.getProperty("enable.doubleclick");
        if(doubleclick!=null && doubleclick.equalsIgnoreCase("false"))
            doubleClickEnabled=false;
        LOG.debug("enable.doubleclick={}", doubleclick);			

        // load reload flag
        String reloadStr = props.getProperty("enable.reload");
        if(reloadStr!=null && reloadStr.equalsIgnoreCase("true"))
            reload=true;

        LOG.debug("enable.reload={}", reloadStr);			

        // look up severities and their properties
        severityMapAs=props.getProperty("severity.map", "avg");

        // look up severities and their properties

        String[] severities = BundleLists.parseBundleList(props
                                                          .getProperty("severities"));

        for (int i = 0; i < severities.length; i++) {
            String id = props.getProperty("severity." + severities[i] + ".id");
            String label = props.getProperty("severity." + severities[i]
                    + ".label");
            String color = props.getProperty("severity." + severities[i]
                    + ".color");
            String flash = props.getProperty("severity." + severities[i]
                    + ".flash");
            Severity sev = new Severity(Integer.parseInt(id), label, color);
            if (flash != null && flash.equalsIgnoreCase("true"))
                sev.setFlash(true);
            LOG.debug("found severity {} with id={}, label={}, color={}. Adding it.", severities[i], id, label, color);
            severitiesMap.put(label, sev);
        }
        orderedSeverities = new Severity[severitiesMap.size()];
        Iterator<Severity> it_sev = severitiesMap.values().iterator();
        int k = 0;
        while (it_sev.hasNext()) {
            orderedSeverities[k++] = it_sev.next();
        }
        Arrays.sort(orderedSeverities);

        String defaultid = props.getProperty("severity.default");
        if (defaultid == null) {
            throw new IllegalStateException(
                    "Required Default Severity not found.");
        }

        String sevid = props.getProperty("severity." + defaultid + ".id");
        String sevlabel = props.getProperty("severity." + defaultid + ".label");
        String sevcolor = props.getProperty("severity." + defaultid + ".color");
        defaultSeverity = new Severity(Integer.parseInt(sevid), sevlabel, sevcolor);


        String indeterminateId = props.getProperty("severity.indeterminate");
        if (indeterminateId == null) {
            throw new IllegalStateException(
                    "Required Indeterminate Severity not found.");
        }

        String indsevid = props.getProperty("severity." + indeterminateId + ".id");
        String indsevlabel = props.getProperty("severity." + indeterminateId
                                               + ".label");
        String indsevcolor = props.getProperty("severity." + indeterminateId
                                               + ".color");
        indeterminateSeverity = new Severity(Integer.parseInt(indsevid), indsevlabel, indsevcolor);

        //Links
        String[] links = BundleLists.parseBundleList(props
                                                     .getProperty("links"));

        String defaultLinkStr = props.getProperty("link.default");
        if(defaultLinkStr==null){
            LOG.error("Mandatory property 'link.default' not found!");
            throw new IllegalStateException("The property 'link.default' is mandatory");
        }
        defaultLink = Integer.parseInt(defaultLinkStr);

        for (int i = 0; i < links.length; i++) {
            String id = props.getProperty("link." + links[i] + ".id");
            String text = props.getProperty("link." + links[i]+ ".text");
            String speed = props.getProperty("link." + links[i]+ ".speed");
            String width = props.getProperty("link." + links[i]+ ".width");
            String dasharray = props.getProperty("link." + links[i]+ ".dash-array");			
            String snmptype = props.getProperty("link." + links[i]+ ".snmptype");			
            String multilinkwidth = props.getProperty("link." + links[i]+ ".multilink.width");
            String multilinkdasharray = props.getProperty("link." + links[i]+ ".multilink.dash-array");            
            if(id==null){
                LOG.error("param id for link cannot be null in map.properties: skipping link...");
                continue;
            }
            if(text==null){
                LOG.error("param text for link cannot be null in map.properties: skipping link...");
                continue;
            }
            if(width==null){
                LOG.error("param width for link cannot be null in map.properties: skipping link...");
                continue;
            }
            if(speed==null){
                LOG.info("param speed for link cannot be null in map.properties: skipping link...");
                speed="Unknown";
            }

            int dash_arr=-1;
            if(dasharray!=null)
                dash_arr=Integer.parseInt(dasharray);

            int snmp_type=-1;
            if(snmptype!=null)
                snmp_type=Integer.parseInt(snmptype);

            if (multilinkwidth==null) {
                multilinkwidth= width;
            }

            int multilink_dasharray=dash_arr;
            if (multilinkdasharray!=null) {
                multilink_dasharray=Integer.parseInt(multilinkdasharray);
            }

            Link lnk = new Link(Integer.parseInt(id), speed,text,width,dash_arr,snmp_type,multilinkwidth,multilink_dasharray);

            LOG.debug("found link {} with id={}, text={}, speed={}, width={}, dash-array={}, snmp-type={}. Adding it.", links[i], id, text, speed, width, dasharray, snmp_type);
            linksMap.put(Integer.valueOf(id), lnk);
            Set<Link> linkbysnmptypeSet = linksBySnmpTypeMap.get(Integer.valueOf(snmp_type));
            if(linkbysnmptypeSet==null)
                linkbysnmptypeSet=new HashSet<Link>();
            linkbysnmptypeSet.add(lnk);
            linksBySnmpTypeMap.put(Integer.valueOf(snmp_type), linkbysnmptypeSet);
        }



        //Links Statuses
        String[] linkStatuses = BundleLists.parseBundleList(props
                                                            .getProperty("linkstatuses"));
        for (int i = 0; i < linkStatuses.length; i++) {
            String color = props.getProperty("linkstatus." + linkStatuses[i] + ".color");
            String flash = props.getProperty("linkstatus." + linkStatuses[i]+ ".flash");
            if(color==null){
                LOG.error("param color for linkstatus cannot be null in map.properties: skipping linkstatus...");
                continue;
            }
            boolean flashBool = false;
            if(flash!=null && flash.equalsIgnoreCase("false"))
                flashBool=false;			
            LOG.debug("found linkstatus {} with color={}, flash={}. Adding it.", linkStatuses[i], color, flashBool);
            LinkStatus ls = new LinkStatus(linkStatuses[i],color,flashBool);
            linkStatusesMap.put(linkStatuses[i], ls);
        }		

        if(props.getProperty("summarylink.id")!=null){
            summaryLink = Integer.parseInt(props.getProperty("summarylink.id"));    
        }
        LOG.debug("found summarylink.id: {}", summaryLink);

        if(props.getProperty("summarylink.color")!=null){
            summaryLinkColor = props.getProperty("summarylink.color");    
        }
        LOG.debug("found summarylink.color: {}", summaryLinkColor);

        if(props.getProperty("max.links")!=null){
            maxLinks = Integer.parseInt(props.getProperty("max.links"));    
        }
        LOG.debug("found max.links: {}", maxLinks);


        if(props.getProperty("multilink.status")!=null){
            multilinkStatus = props.getProperty("multilink.status"); 	
        }
        if(!multilinkStatus.equals(MULTILINK_BEST_STATUS) && !multilinkStatus.equals(MULTILINK_IGNORE_STATUS) && !multilinkStatus.equals(MULTILINK_WORST_STATUS)){
            LOG.error("multilink.status property must be 'best' or 'worst' or 'ignore' ... using default ('best')");
            multilinkStatus=MULTILINK_BEST_STATUS;
        }
        LOG.debug("found multilink.status:{}", multilinkStatus);

        if(props.getProperty("multilink.ignore.color")!=null){
            multilinkIgnoreColor = props.getProperty("multilink.ignore.color");    
        }
        LOG.debug("found multilink.ignore.color:{}", multilinkIgnoreColor);

        // look up statuses and their properties
        String[] statuses = BundleLists.parseBundleList(props
                                                        .getProperty("statuses"));

        for (int i = 0; i < statuses.length; i++) {
            String id = props.getProperty("status." + statuses[i] + ".id");
            String uei = props.getProperty("status." + statuses[i] + ".uei");
            String color = props
                    .getProperty("status." + statuses[i] + ".color");
            String text = props.getProperty("status." + statuses[i] + ".text");
            LOG.debug("found status {} with id={}, uei={}, color={}, text={}. Adding it.", statuses[i], id, uei, color, text);
            Status status = new Status(Integer.parseInt(id), uei, color, text);
            statusesMap.put(uei, status);
        }

        orderedStatuses = new Status[statusesMap.size()];
        Iterator<Status> it_status = statusesMap.values().iterator();
        k = 0;
        while (it_status.hasNext()) {
            orderedStatuses[k++] = it_status.next();
        }
        Arrays.sort(orderedStatuses);

        String unknownid = props.getProperty("status.unknown.uei");
        if (unknownid == null) {
            throw new IllegalStateException(
                    "Required Unknown Uei Status not found.");
        }
        String stid = props.getProperty("status." + unknownid + ".id");
        String stuei = props.getProperty("status." + unknownid + ".uei");
        String stcolor = props.getProperty("status." + unknownid + ".color");
        String sttext = props.getProperty("status." + unknownid + ".text");
        unknownStatus = new Status(Integer.parseInt(stid), stuei, stcolor, sttext);

        String defaultstid = props.getProperty("status.default");
        if (defaultstid == null) {
            throw new IllegalStateException(
                    "Required Default Status not found.");
        }
        String staid = props.getProperty("status." + defaultstid + ".id");
        String stauei = props.getProperty("status." + defaultstid + ".uei");
        String stacolor = props.getProperty("status." + defaultstid + ".color");
        String statext = props.getProperty("status." + defaultstid + ".text");
        defaultStatus = new Status(Integer.parseInt(staid), stauei, stacolor, statext);

        // look up statuses and their properties
        String[] availes = BundleLists.parseBundleList(props
                                                       .getProperty("availabilities"));

        for (int i = 0; i < availes.length; i++) {
            String id = props.getProperty("avail." + availes[i] + ".id");
            String min = props.getProperty("avail." + availes[i] + ".min");
            String color = props.getProperty("avail." + availes[i] + ".color");
            String flash = props.getProperty("avail." + availes[i] + ".flash");
            LOG.debug("found avail {} with id={}, min={}, color={}. Adding it.", availes[i], id, min, color);
            Avail avail = new Avail(Integer.parseInt(id),
                                    Integer.parseInt(min), color);
            if (flash != null && flash.equalsIgnoreCase("true"))
                avail.setFlash(true);
            availsMap.put(min, avail);
        }

        orderedAvails = new Avail[availsMap.size()];
        Iterator<Avail> it_avail = availsMap.values().iterator();
        k = 0;
        while (it_avail.hasNext()) {
            orderedAvails[k++] = it_avail.next();
        }
        Arrays.sort(orderedAvails);

        String avid = props.getProperty("avail.undefined.id");
        String avmin = props.getProperty("avail.undefined.min");
        String avcolor = props.getProperty("avail.undefined.color");
        if (avid == null || avmin == null || avcolor == null) {
            throw new IllegalStateException(
                    "Required avail.undefined properties not found.");
        }
        undefinedAvail = new Avail(Integer.parseInt(avid), Integer.parseInt(avmin), avcolor);


        String enableAvail = props.getProperty("avail.enable");
        if (enableAvail != null && enableAvail.equalsIgnoreCase("false"))
            availEnabled=false;
        else availEnabled = true;

        String disableAvailId = props.getProperty("avail.enable.false.id");
        if (disableAvailId == null) {
            throw new IllegalStateException(
                    "Required Default Status not found.");
        }
        Iterator<Avail> ite = availsMap.values().iterator();
        while (ite.hasNext()) {
            Avail av = ite.next();
            if (av.getId() == Integer.parseInt(disableAvailId)){
                disabledAvail=av;
                break;
            }
        }

        // look up icons filenames

        String[] icons = BundleLists
                .parseBundleList(props.getProperty("icons"));

        for (int i = 0; i < icons.length; i++) {

            String baseProperty = "icon." + icons[i] + ".";

            String filename =  props.getProperty(baseProperty + "filename");
            LOG.debug("found icon {} with filename={}. Adding it.", icons[i], filename);
            iconsMap.put(icons[i], filename);
        }

        // look up sysoid icons
        if (props.getProperty("sysoids") != null && props.getProperty("sysoids") != "") {
            String[] sysoids = BundleLists.parseBundleList(props.getProperty("sysoids"));

            for (int i = 0; i < sysoids.length; i++) {
                String iconName = props.getProperty("sysoid." + sysoids[i] + ".iconName");
                LOG.debug("found sysoid {} with iconName={}. Adding it.", sysoids[i], iconName);
                iconsBySysoidMap.put(sysoids[i], iconName);
            }
        }

        defaultMapIcon = props.getProperty("icon.default.map");
        LOG.debug("default map icon: {}", defaultMapIcon);
        if (defaultMapIcon == null) {
            throw new IllegalStateException(
                    "Required Default Map Icon not found.");
        }
        defaultNodeIcon = props.getProperty("icon.default.node");
        if (defaultNodeIcon == null) {
            throw new IllegalStateException(
                    "Required Default Icon Node not found.");
        }
        LOG.debug("default node icon: {}", defaultNodeIcon);

        String defaultMapElementDimensionString = props.getProperty("icon.default.mapelementdimension");
        if (defaultMapElementDimensionString != null) {
            defaultMapElementDimension = Integer.parseInt(defaultMapElementDimensionString);
        }
        LOG.debug("default map element dimension: {}", defaultMapElementDimension);

        String useSemaphoreString = props.getProperty("use.semaphore");
        if (useSemaphoreString != null && useSemaphoreString.equalsIgnoreCase("false"))
            useSemaphore=false;
        else useSemaphore = true;
        LOG.debug("use semaphore: {}", useSemaphoreString);

        // look up background filenames
        String[] bg = BundleLists
                .parseBundleList(props.getProperty("bgimages"));

        for (int i = 0; i < bg.length; i++) {
            String filename = props.getProperty("bgimage." + bg[i]
                    + ".filename");
            LOG.debug("found bgimage {} with filename={}. Adding it.", bg[i], filename);
            bgImagesMap.put(bg[i], filename);
        }
    }

