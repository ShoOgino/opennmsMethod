	@Override
	public void afterTestMethod(final TestContext testContext) throws Exception {
		System.err.println(String.format("TemporaryDatabaseExecutionListener.afterTestMethod(%s)\n", testContext));

		final JUnitTemporaryDatabase jtd = findAnnotation(testContext);
		if (jtd == null) return;

		try {
			// DON'T REMOVE THE DATABASE, just rely on the ShutdownHook to remove them instead
			// otherwise you might remove the class-level database that is reused between tests.
			// {@link TemporaryDatabase#createTestDatabase()}
			if (m_createNewDatabases) {
				final DataSource dataSource = DataSourceFactory.getInstance();
				final TemporaryDatabase tempDb = findTemporaryDatabase(dataSource);
				if (tempDb != null) {
					tempDb.drop();
				}
			}
		} finally {
			// We must mark the application context as dirty so that the DataSourceFactoryBean is
			// correctly pointed at the next temporary database.
			//
			// If the next database is the same as the current database, then do not rewire.
			// NOTE: This does not work because the Hibernate objects need to be reinjected or they
			// will reject database operations because they think that the database rows already
			// exist even if they were rolled back after a previous test execution.
			//
			if (jtd.dirtiesContext()) {
				testContext.markApplicationContextDirty();
				testContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);
			} else {
				final DataSource dataSource = DataSourceFactory.getInstance();
				final TemporaryDatabase tempDb = findTemporaryDatabase(dataSource);
				if (tempDb != m_databases.peek()) {
					testContext.markApplicationContextDirty();
					testContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);
				}
			}
		}
	}

