    /*
     * On hybrid environments where some nodes have been discovered and other nodes are part of a requisition,
     * the top level resources are always going to be built using NodeResourceType only if storeByForeignSource
     * is disabled.
     * But, if storeByForeignSource is enabled, the resources associated with discovered nodes are going to be
     * built by NodeResourceType, and the resources associated with requisitioned nodes are going to be built by
     * NodeSourceResourceType.
     */
    private void execute_testFindTopLevelResources_hybridNodes(boolean storeByForeignSource) throws Exception {
        setStoreByForeignSource(storeByForeignSource);
        List<OnmsNode> nodes = new ArrayList<OnmsNode>();

        OnmsNode n1 = new OnmsNode(); // discovered node
        n1.setId(1);
        n1.setLabel("node1");
        OnmsIpInterface ip1 = new OnmsIpInterface();
        ip1.setId(11);
        ip1.setIpAddress(InetAddressUtils.addr("10.0.0.1"));
        ip1.setNode(n1);
        n1.addIpInterface(ip1);
        nodes.add(n1);

        OnmsNode n2 = new OnmsNode(); // requisitioned node
        n2.setId(2);
        n2.setLabel("node2");
        n2.setForeignSource("Junit");
        n2.setForeignId("node2");
        OnmsIpInterface ip2 = new OnmsIpInterface();
        ip2.setId(12);
        ip2.setIpAddress(InetAddressUtils.addr("10.0.0.2"));
        ip2.setNode(n2);
        n2.addIpInterface(ip2);
        nodes.add(n2);

        expect(m_dataCollectionConfigDao.getLastUpdate()).andReturn(new Date(System.currentTimeMillis())).times(3);
        expect(m_dataCollectionConfigDao.getConfiguredResourceTypes()).andReturn(new HashMap<String, ResourceType>());
        expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(n1.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));
        if (storeByForeignSource) {
            expect(m_nodeDao.findByForeignId(n2.getForeignSource(), n2.getForeignId())).andReturn(n2).times(1);
        } else {
            expect(m_locationMonitorDao.findStatusChangesForNodeForUniqueMonitorAndInterface(n2.getId())).andReturn(new ArrayList<LocationMonitorIpInterface>(0));
        }
        expect(m_nodeDao.get(n1.getId())).andReturn(n1).times(2); // TODO ResponseTimeResourceType is the responsible for this.
        expect(m_nodeDao.get(n2.getId())).andReturn(n2).times(2); // TODO ResponseTimeResourceType is the responsible for this.
        expect(m_nodeDao.findAll()).andReturn(nodes);

        File snmpDir = m_fileAnticipator.tempDir("snmp");

        File node1Dir = m_fileAnticipator.tempDir(snmpDir, n1.getId().toString());
        m_fileAnticipator.tempFile(node1Dir, "foo" + RrdUtils.getExtension());

        if (storeByForeignSource) {
            File fsDir = m_fileAnticipator.tempDir(snmpDir, "fs");
            File node2fsDir = m_fileAnticipator.tempDir(fsDir, n2.getForeignSource());
            File node2Dir = m_fileAnticipator.tempDir(node2fsDir, n2.getForeignId());
            m_fileAnticipator.tempFile(node2Dir, "foo" + RrdUtils.getExtension());
        } else {
            File node2Dir = m_fileAnticipator.tempDir(snmpDir, n2.getId().toString());
            m_fileAnticipator.tempFile(node2Dir, "foo" + RrdUtils.getExtension());
        }

        File responseDir = m_fileAnticipator.tempDir("response");
        File ip1Dir = m_fileAnticipator.tempDir(responseDir, ip1.getIpAddress().getHostAddress());
        m_fileAnticipator.tempFile(ip1Dir, "foo" + RrdUtils.getExtension());
        File ip2Dir = m_fileAnticipator.tempDir(responseDir, ip2.getIpAddress().getHostAddress());
        m_fileAnticipator.tempFile(ip2Dir, "foo" + RrdUtils.getExtension());

        m_easyMockUtils.replayAll();
        m_resourceDao.afterPropertiesSet();

        List<OnmsResource> resources = m_resourceDao.findTopLevelResources();
        Assert.assertNotNull(resources);
        Collections.sort(resources);
        Assert.assertEquals(2, resources.size());

        if (storeByForeignSource) {
            OnmsResource r1 = resources.get(0); // parent resource for the provisioned node 
            List<OnmsResource> children1 = r1.getChildResources();
            Collections.sort(children1);
            Assert.assertEquals("nodeSource[Junit%3Anode2]", r1.getId());
            Assert.assertEquals("nodeSource[Junit%3Anode2].responseTime[10.0.0.2]", children1.get(0).getId());
            Assert.assertEquals("nodeSource[Junit%3Anode2].nodeSnmp[]", children1.get(1).getId());

            OnmsResource r2 = resources.get(1); // parent resource for the discovered node
            Assert.assertEquals("node[1]", r2.getId());
            List<OnmsResource> children2 = r2.getChildResources();
            Collections.sort(children2);
            Assert.assertEquals(2, children2.size());
            Assert.assertEquals("node[1].responseTime[10.0.0.1]", children2.get(0).getId());
            Assert.assertEquals("node[1].nodeSnmp[]", children2.get(1).getId());

        } else {
            OnmsResource r1 = resources.get(1); // parent resource for the provisioned node 
            List<OnmsResource> children1 = r1.getChildResources();
            Collections.sort(children1);
            Assert.assertEquals("node[2]", r1.getId());
            Assert.assertEquals("node[2].responseTime[10.0.0.2]", children1.get(0).getId());
            Assert.assertEquals("node[2].nodeSnmp[]", children1.get(1).getId());

            OnmsResource r2 = resources.get(0); // parent resource for the discovered node
            Assert.assertEquals("node[1]", r2.getId());
            List<OnmsResource> children2 = r2.getChildResources();
            Collections.sort(children2);
            Assert.assertEquals(2, children2.size());
            Assert.assertEquals("node[1].responseTime[10.0.0.1]", children2.get(0).getId());
            Assert.assertEquals("node[1].nodeSnmp[]", children2.get(1).getId());
        }

        m_easyMockUtils.verifyAll();
    }

