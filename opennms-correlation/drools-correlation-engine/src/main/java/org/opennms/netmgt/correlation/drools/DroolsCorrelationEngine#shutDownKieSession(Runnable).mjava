    private synchronized void shutDownKieSession(Runnable postHaltPreDispose) {
        if (m_kieSession == null) {
            return;
        }
        m_shuttingDownStreamThread.set(true);
        m_kieSession.halt();
        if (postHaltPreDispose != null) {
            postHaltPreDispose.run();
        }

        try {
            LOG.debug("Disposing KieSession for engine: {}", m_name);
            // Calls to dispose have been known to cause us deadlocks - see NMS-12201
            // Wrap it with a timeout to make sure this doesn't happen
            s_timeLimiter.callWithTimeout(() -> {
                m_kieSession.dispose();
                m_kieSession.destroy();
                LOG.debug("Successfully disposed KieSession for engine: {}", m_name);
                return null;
            },  10, TimeUnit.SECONDS, true);
        }  catch (UncheckedTimeoutException e) {
            LOG.info("KieSession for engine named '{}' was not disposed within the given timeout.", m_name);
            if (m_streamThread != null) {
                // If we're streaming, interrupt the thread, this has been found to clean things up properly
                // when calling dispose() blocks.
                LOG.info("Interrupting the stream thread for engine: {}", m_name);
                m_streamThread.interrupt();
            }
        } catch (Exception e) {
            LOG.warn("Error occurred while disposing KieSession for engine: {}", m_name, e);
        }

        m_kieSession = null;
        m_streamThread = null;
    }

