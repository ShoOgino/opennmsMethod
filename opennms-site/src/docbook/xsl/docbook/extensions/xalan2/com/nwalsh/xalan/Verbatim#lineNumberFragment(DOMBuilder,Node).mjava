  /**
   * <p>Build a DocumentFragment with numbered lines.</p>
   *
   * <p>This is the method that actually does the work of numbering
   * lines in a verbatim environment. It recursively walks through a
   * tree of nodes, copying the structure into the rtf. Text nodes
   * are examined for new lines and modified as requested by the
   * global line numbering parameters.</p>
   *
   * <p>When called, rtf should be an empty DocumentFragment and node
   * should be the first child of the result tree fragment that contains
   * the existing, formatted verbatim text.</p>
   *
   * @param rtf The resulting verbatim environment with numbered lines.
   * @param node The root of the tree to copy.
   */
  private void lineNumberFragment(DOMBuilder rtf,
				  Node node) {
    try {
      if (node.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE
	  || node.getNodeType() == Node.DOCUMENT_NODE) {
	Node child = node.getFirstChild();
	while (child != null) {
	  lineNumberFragment(rtf, child);
	  child = child.getNextSibling();
	}
      } else if (node.getNodeType() == Node.ELEMENT_NODE) {
	String ns = node.getNamespaceURI();
	String localName = node.getLocalName();
	String name = ((Element) node).getTagName();

	rtf.startElement(ns, localName, name,
			 copyAttributes((Element) node));

	elementStack.push(node);

	Node child = node.getFirstChild();
	while (child != null) {
	  lineNumberFragment(rtf, child);
	  child = child.getNextSibling();
	}
      } else if (node.getNodeType() == Node.TEXT_NODE) {
	String text = node.getNodeValue();

	if (lineNumber == 0) {
	  // The first line is always numbered
	  formatLineNumber(rtf, ++lineNumber);
	}

	// Walk through the text node looking for newlines
	char chars[] = text.toCharArray();
	int pos = 0;
	for (int count = 0; count < text.length(); count++) {
	  if (text.charAt(count) == '\n') {
	    // This is the tricky bit; if we find a newline, make sure
	    // it doesn't occur inside any markup.

	    if (pos > 0) {
	      rtf.characters(chars, 0, pos);
	      pos = 0;
	    }

	    closeOpenElements(rtf);

	    // Copy the newline to the output
	    chars[pos++] = text.charAt(count);
	    rtf.characters(chars, 0, pos);
	    pos = 0;

	    // Add the line number
	    formatLineNumber(rtf, ++lineNumber);

	    openClosedElements(rtf);
	  } else {
	    chars[pos++] = text.charAt(count);
	  }
	}

	if (pos > 0) {
	  rtf.characters(chars, 0, pos);
	}
      } else if (node.getNodeType() == Node.COMMENT_NODE) {
	String text = node.getNodeValue();
	char chars[] = text.toCharArray();
	rtf.comment(chars, 0, text.length());
      } else if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
	rtf.processingInstruction(node.getNodeName(), node.getNodeValue());
      } else {
	System.out.println("Warning: unexpected node type in lineNumberFragment");
      }

      if (node.getNodeType() == Node.ELEMENT_NODE) {
	String ns = node.getNamespaceURI();
	String localName = node.getLocalName();
	String name = ((Element) node).getTagName();
	rtf.endElement(ns, localName, name);
	elementStack.pop();
      }
    } catch (SAXException e) {
      System.out.println("SAX Exception in lineNumberFragment");
    }
  }

