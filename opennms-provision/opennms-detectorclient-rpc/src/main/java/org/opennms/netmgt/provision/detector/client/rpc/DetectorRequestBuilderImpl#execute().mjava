    /**
     * Builds the {@link DetectorRequestDTO} and executes the requested detector
     * via the RPC client.
     */
    @Override
    public CompletableFuture<Boolean> execute() {
        if (address == null) {
            throw new IllegalArgumentException("Address is required.");
        } else if (className == null) {
            throw new IllegalArgumentException("Detector class name is required.");
        }

        final Map<String, String> interpolatedAttributes = Interpolator.interpolateStrings(attributes, new FallbackScope(
                this.client.getEntityScopeProvider().getScopeForNode(nodeId),
                this.client.getEntityScopeProvider().getScopeForInterface(nodeId, InetAddressUtils.toIpAddrString(address))
        ));

        // Retrieve the factory associated with the requested detector
        final ServiceDetectorFactory<?> factory = client.getRegistry().getDetectorFactoryByClassName(className);
        if (factory == null) {
            // Fail immediately if no suitable factory was found
            throw new IllegalArgumentException("No factory found for detector with class name '" + className + "'.");
        }

        // Store all of the request details in the DTO
        final DetectorRequestDTO detectorRequestDTO = new DetectorRequestDTO();
        detectorRequestDTO.setLocation(location);
        detectorRequestDTO.setSystemId(systemId);
        detectorRequestDTO.setClassName(className);
        detectorRequestDTO.setAddress(address);
        // Update ttl from metadata
        String timeToLive = interpolatedAttributes.get(MetadataConstants.TTL);
        if (!Strings.isNullOrEmpty(timeToLive)) {
            Long ttlFromMetadata = ParameterMap.getLongValue(MetadataConstants.TTL, interpolatedAttributes.get(MetadataConstants.TTL), null);
            detectorRequestDTO.setTimeToLiveMs(ttlFromMetadata);
            //Remove ttl from attributes as it is not a detector attribute.
            interpolatedAttributes.remove(MetadataConstants.TTL);
        }
        detectorRequestDTO.addDetectorAttributes(interpolatedAttributes);
        detectorRequestDTO.addTracingInfo(RpcRequest.TAG_CLASS_NAME, className);
        detectorRequestDTO.addTracingInfo(RpcRequest.TAG_IP_ADDRESS, InetAddressUtils.toIpAddrString(address));
        detectorRequestDTO.setSpan(span);
        detectorRequestDTO.setPreDetectCallback(preDetectCallback);
        // Attempt to extract the port from the list of attributes
        Integer port = null;
        final String portString = interpolatedAttributes.get(PORT);
        if (portString != null) {
            try {
                port = Integer.parseInt(portString);
            } catch (NumberFormatException nfe) {
                LOG.warn("Failed to parse port as integer from: ", portString);
            }
        }

        // Build the DetectRequest and store the runtime attributes in the DTO
        final DetectRequest request = factory.buildRequest(location, address, port, interpolatedAttributes);
        detectorRequestDTO.addRuntimeAttributes(request.getRuntimeAttributes());
        // Execute the request
        return client.getDelegate().execute(detectorRequestDTO)
            .thenApply(response -> {
                // Notify the factory that a request was successfully executed
                try {
                    factory.afterDetect(request, response, nodeId);
                } catch (Throwable t) {
                    LOG.error("Error while processing detect callback.", t);
                }
                return response.isDetected();
            });
    }

