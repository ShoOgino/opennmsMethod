    /**
     * Creates an instance of the JaxB annotated RequisionNode class.
     * 
     * @param rec
     * @return a populated RequisitionNode based on defaults and data from the A
     *         record returned from a DNS zone transfer query.
     */
    private RequisitionNode createRequisitionNode(DnsRequisitionRequest request, Record rec) {
        String addr = null;
        if ("A".equals(Type.string(rec.getType()))) {
            final ARecord arec = (ARecord) rec;
            addr = StringUtils.stripStart(arec.getAddress().toString(), "/");
        } else if ("AAAA".equals(Type.string(rec.getType()))) {
            final AAAARecord aaaarec = (AAAARecord) rec;
            addr = aaaarec.rdataToString();
        } else {
            throw new IllegalArgumentException(
                    "Invalid record type " + Type.string(rec.getType()) + ". A or AAAA expected.");
        }

        final RequisitionNode n = new RequisitionNode();

        final String host = rec.getName().toString();
        final String nodeLabel = StringUtils.stripEnd(StringUtils.stripStart(host, "."), ".");

        n.setBuilding(request.getForeignSource());

        if (!Strings.isNullOrEmpty(request.getLocation())) {
            if (request.getLocation().startsWith("~")) {
                final Pattern pattern = Pattern.compile(request.getLocation().substring(1));
                final Matcher matcher = pattern.matcher(host);
                if (matcher.groupCount() != 1) {
                    LOG.error("The pattern '{}' may contain only one capturing group.", pattern);
                } else {
                    if (matcher.find()) {
                        final String match = matcher.group(1);
                        if (!Strings.isNullOrEmpty(match)) {
                            n.setLocation(match);
                            LOG.debug("Node '{}' location set to {}", n.getNodeLabel(), n.getLocation());
                        }
                    }
                }
            } else {
                n.setLocation(request.getLocation());
                LOG.debug("Node '{}' location set to {}", n.getNodeLabel(), n.getLocation());
            }
        }

        switch (request.getForeignIdHashSource()) {
        case NODE_LABEL:
            n.setForeignId(computeHashCode(nodeLabel));
            LOG.debug("Generating foreignId from hash of nodelabel {}", nodeLabel);
            break;
        case IP_ADDRESS:
            n.setForeignId(computeHashCode(addr));
            LOG.debug("Generating foreignId from hash of ipAddress {}", addr);
            break;
        case NODE_LABEL_AND_IP_ADDRESS:
            n.setForeignId(computeHashCode(nodeLabel + addr));
            LOG.debug("Generating foreignId from hash of nodelabel+ipAddress {}{}", nodeLabel, addr);
            break;
        default:
            n.setForeignId(computeHashCode(nodeLabel));
            LOG.debug("Default case: Generating foreignId from hash of nodelabel {}", nodeLabel);
            break;
        }
        n.setNodeLabel(nodeLabel);

        final RequisitionInterface i = new RequisitionInterface();
        i.setDescr("DNS-" + Type.string(rec.getType()));
        i.setIpAddr(addr);
        i.setSnmpPrimary(PrimaryType.PRIMARY);
        i.setManaged(Boolean.TRUE);
        i.setStatus(Integer.valueOf(1));

        for (String service : request.getServices()) {
            service = service.trim();
            i.insertMonitoredService(new RequisitionMonitoredService(service));
            LOG.debug("Adding provisioned service {}", service);
        }

        n.putInterface(i);
        return n;
    }

