    /**
     * {@inheritDoc}
     *
     * Returns true if the protocol defined by this plugin is supported. If
     * the protocol is not supported then a false value is returned to the
     * caller. The qualifier map passed to the method is used by the plugin to
     * return additional information by key-name. These key-value pairs can be
     * added to service events if needed.
     */
    @Override
    public boolean isServiceDetected(InetAddress address, DetectorMonitor detectMonitor) {
        boolean detected = false;
        
        SnmpAgentConfig agentConfig = getAgentConfigFactory().getAgentConfig(address);
        
        configureAgentPTR(agentConfig);

        configureAgentVersion(agentConfig);
        
        try {
            /*
             * Get two maps one with all configured administration tags and one with 
             * operational status
             */
            Map<SnmpInstId, SnmpValue> tagResults = getTable(agentConfig, RTT_ADMIN_TAG_OID);
            if (tagResults == null || tagResults.isEmpty()) {
                LogUtils.warnf(this, "%s: No admin tags received!", getServiceName());
                return detected;
            }

            Map<SnmpInstId, SnmpValue> operStateResults = getTable(agentConfig,RTT_OPER_STATE_OID);
            if (operStateResults == null || operStateResults.isEmpty()) {
                LogUtils.warnf(this, "%s: No oper status received!", getServiceName());
                return detected;
            }
            
            // Iterate over the list of configured IP SLAs
            for (SnmpInstId ipslaInstance : tagResults.keySet()) {
                LogUtils.debugf(this, "%s detect: [%s] compared with [%s]", getServiceName(), tagResults.get(ipslaInstance), getVbvalue());
                /*
                 * Check if a configured IP SLA with specific tag exist and the
                 * the operational state ACTIVE(6), detected with first match.
                 */
                if (tagResults.get(ipslaInstance).toString().equals(getVbvalue())
                        && operStateResults.get(ipslaInstance).toInt() == RTT_MON_OPER_STATE.ACTIVE.value()) {
                    LogUtils.debugf(this, "%s: admin tag [%s] found and status is %d", getServiceName(), getVbvalue(), operStateResults.get(ipslaInstance).toInt());
                    detected = true;
                    break; // detected leave for()
                } else {
                    LogUtils.debugf(this, "%s: admin tag [%s] not found and status is %d", getServiceName(), getVbvalue(), operStateResults.get(ipslaInstance).toInt());
                    detected = false; // not detected, check next or return with not detected
                }
            }
        } catch (final NullPointerException e) {
            LogUtils.warnf(this, e, "SNMP not available or CISCO-RTT-MON-MIB not supported!");
        } catch (final NumberFormatException e) {
            LogUtils.warnf(this, e, "Number operator used on a non-number.");
        } catch (final IllegalArgumentException e) {
            LogUtils.warnf(this, e, "Invalid SNMP criteria.");
        } catch (final Throwable t) {
            LogUtils.warnf(this, t, "Unexpected exception during SNMP poll of interface %s", address.getHostAddress());
        }
        return detected; // return detected
    }

