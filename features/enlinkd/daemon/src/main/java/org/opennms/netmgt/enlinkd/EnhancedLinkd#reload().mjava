    public void reload() {
        LOG.info("reload: reload enlinkd daemon service");

        m_nodesTopologyUpdater.unschedule();
        m_nodesTopologyUpdater.unregister();
        NodesOnmsTopologyUpdater nodeupdater = NodesOnmsTopologyUpdater.clone(m_nodesTopologyUpdater);
        scheduleAndRegisterOnmsTopologyUpdater(nodeupdater);
        m_nodesTopologyUpdater = nodeupdater;

        if (m_linkdConfig.useOspfDiscovery()) {
            if (m_ospfTopologyUpdater.isRegistered()) {
                m_ospfTopologyUpdater.unschedule();
                m_ospfTopologyUpdater.unregister();
                OspfOnmsTopologyUpdater updater = OspfOnmsTopologyUpdater.clone(m_ospfTopologyUpdater);
                scheduleAndRegisterOnmsTopologyUpdater(updater);
                m_ospfTopologyUpdater = updater;
            } else {
                scheduleAndRegisterOnmsTopologyUpdater(m_ospfTopologyUpdater);
            }
        } else {
            unscheduleAndUnregisterOnmsTopologyUpdater(m_ospfTopologyUpdater);
        }

        if (m_linkdConfig.useLldpDiscovery()) {
            if (m_lldpTopologyUpdater.isRegistered()) {
                m_lldpTopologyUpdater.unschedule();
                m_lldpTopologyUpdater.unregister();
                LldpOnmsTopologyUpdater updater = LldpOnmsTopologyUpdater.clone(m_lldpTopologyUpdater);
                scheduleAndRegisterOnmsTopologyUpdater(updater);
                m_lldpTopologyUpdater = updater;
            } else {
                scheduleAndRegisterOnmsTopologyUpdater(m_lldpTopologyUpdater);
            }
        } else {
            unscheduleAndUnregisterOnmsTopologyUpdater(m_lldpTopologyUpdater);
        }
        
        if (m_linkdConfig.useIsisDiscovery()) {
            if (m_isisTopologyUpdater.isRegistered()) {
                m_isisTopologyUpdater.unschedule();
                m_isisTopologyUpdater.unregister();
                IsisOnmsTopologyUpdater updater = IsisOnmsTopologyUpdater.clone(m_isisTopologyUpdater);
                scheduleAndRegisterOnmsTopologyUpdater(updater);
                m_isisTopologyUpdater = updater;
            } else {
                scheduleAndRegisterOnmsTopologyUpdater(m_isisTopologyUpdater);
            }
        } else {
            unscheduleAndUnregisterOnmsTopologyUpdater(m_isisTopologyUpdater);
        }

        if (m_linkdConfig.useCdpDiscovery()) {
            if (m_cdpTopologyUpdater.isRegistered()) {
                m_cdpTopologyUpdater.unschedule();
                m_cdpTopologyUpdater.unregister();
                CdpOnmsTopologyUpdater updater = CdpOnmsTopologyUpdater.clone(m_cdpTopologyUpdater);
                scheduleAndRegisterOnmsTopologyUpdater(updater);
                m_cdpTopologyUpdater = updater;
            } else {
                scheduleAndRegisterOnmsTopologyUpdater(m_cdpTopologyUpdater);
            }
        } else {
            unscheduleAndUnregisterOnmsTopologyUpdater(m_cdpTopologyUpdater);
        }
        
        if (m_linkdConfig.useBridgeDiscovery()) {
            if (m_bridgeTopologyUpdater.isRegistered()) {
                m_bridgeTopologyUpdater.unschedule();
                m_bridgeTopologyUpdater.unregister();
                BridgeOnmsTopologyUpdater updater = BridgeOnmsTopologyUpdater.clone(m_bridgeTopologyUpdater);
                scheduleAndRegisterOnmsTopologyUpdater(updater);
                m_bridgeTopologyUpdater = updater;
            } else {
                scheduleAndRegisterOnmsTopologyUpdater(m_bridgeTopologyUpdater);
            }
        } else {
            unscheduleAndUnregisterOnmsTopologyUpdater(m_bridgeTopologyUpdater);
        }
        
        if (m_linkdConfig.useBridgeDiscovery()) {
            m_discoveryBridgeDomains.unschedule();
            m_discoveryBridgeDomains = DiscoveryBridgeDomains.clone(m_discoveryBridgeDomains);
            scheduleDiscoveryBridgeDomain();
        } else {
            unscheduleDiscoveryBridgeDomain();
        }

        synchronized (m_nodes) {
            final Set<Node> nodes = new HashSet<Node>();
            for (List<NodeCollector> list: m_nodes.values()) {
                list.stream().forEach(coll -> {
                    coll.unschedule(); 
                    nodes.add(coll.getNode());
                });
            }
            m_nodes.clear();
            nodes.stream().
                forEach(node -> m_nodes.put(node.getNodeId(), scheduleCollectionForNode(node)));
        }
    }

