    protected void runNodeDiscovery() {
        final Date now = new Date();

        SnmpAgentConfig peer = getSnmpAgentConfig();
        String community = peer.getReadCommunity();
        Map<Integer, String> vlanmap = getVtpVlanMap(peer);
        Map<Integer,SnmpAgentConfig> vlanSnmpAgentConfigMap = new HashMap<Integer, SnmpAgentConfig>();
        for (Integer vlanId: vlanmap.keySet()) {
            LOG.debug("run: node [{}], support cisco vtp: setting peer community for vlan: {}, vlanname: {}",
           		 getNodeId(),vlanId,vlanmap.get(vlanId));
            
            SnmpAgentConfig vlanpeer = getSnmpAgentConfig();
        	if (vlanpeer.isVersion3()) {
        		vlanpeer.setContextName("vlan-"+vlanId);
        	} else {
                vlanpeer.setReadCommunity(community + "@" + vlanId);
        	}
        	vlanSnmpAgentConfigMap.put(vlanId, vlanpeer);        	
        }
        
        if (vlanmap.isEmpty()) {
        	vlanSnmpAgentConfigMap.put(null, peer);
        	vlanmap.put(null, null);
        }
        
        List<BridgeForwardingTableEntry> bft = new ArrayList<BridgeForwardingTableEntry>();
        Map<Integer, Integer> bridgeifindex = new HashMap<Integer, Integer>();

        for (Entry<Integer, SnmpAgentConfig> entry : vlanSnmpAgentConfigMap.entrySet()) {
            Map<Integer,Integer> vlanbridgetoifindex = walkDot1dBasePortTable(entry.getValue());
            LOG.debug("run: node: [{}], vlan: {}, bridge ifindex map {}",
                      getNodeId(), vlanmap.get(entry.getKey()), vlanbridgetoifindex);
            bridgeifindex.putAll(vlanbridgetoifindex);
        }

        for (Entry<Integer, String> entry : vlanmap.entrySet()) {
            
            BridgeElement bridge = getDot1dBridgeBase(vlanSnmpAgentConfigMap.get(entry.getKey()));
            if (bridge != null) {
                bridge.setVlan(entry.getKey());
                bridge.setVlanname(vlanmap.get(entry.getKey()));
                m_bridgeTopologyService.store(getNodeId(), bridge);
            } else {
                LOG.debug("run: node: [{}], vlan {}. no dot1d bridge data found. skipping other operations",
                          getNodeId(), entry.getValue());
                continue;
            }

            if (!isValidStpBridgeId(bridge.getStpDesignatedRoot())) {
                LOG.debug("run: node: [{}], vlan {}. invalid designated root: spanning tree not supported.",
                         getNodeId(),entry.getValue());
            } else if (bridge.getBaseBridgeAddress().equals(getBridgeAddressFromStpBridgeId(bridge.getStpDesignatedRoot()))) {
                LOG.debug("run: node [{}]: vlan {}. designated root {} is itself. Skipping store.",
                		 getNodeId(),
                		 entry.getValue(),
                         bridge.getStpDesignatedRoot());
            } else {
                for (BridgeStpLink stplink: walkSpanningTree(vlanSnmpAgentConfigMap.get(entry.getKey()),
                                 bridge.getBaseBridgeAddress())) {
                    stplink.setVlan(entry.getKey());
                    stplink.setStpPortIfIndex(bridgeifindex.get(stplink.getStpPort()));
                    m_bridgeTopologyService.store(getNodeId(), stplink);
                }
            }
            bft = walkDot1dTpFdp(entry.getValue(),entry.getKey(), bridgeifindex, bft, vlanSnmpAgentConfigMap.get(entry.getKey()));
        }
        LOG.debug("run: node [{}]: deleting older the time {}", getNodeId(), now);
        m_bridgeTopologyService.reconcile(getNodeId(), now);
		
        bft = walkDot1qTpFdb(peer,bridgeifindex, bft);
        LOG.debug("run: node [{}]: bft size:{}", getNodeId(), bft.size());

        if (bft.size() > 0) {
            LOG.debug("run: node [{}]: updating topology", getNodeId());
        	m_bridgeTopologyService.store(getNodeId(), bft);
        }
        m_linkd.collectedBft(getNodeId());
    }

