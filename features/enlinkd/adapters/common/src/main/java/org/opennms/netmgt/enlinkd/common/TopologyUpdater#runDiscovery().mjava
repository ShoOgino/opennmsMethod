    @Override
    public synchronized void runDiscovery() {
        LOG.debug("run: start {}", getName());
        if (!m_runned) {
            try {
                m_topology = buildTopology();
                m_runned = true;
                m_topologyService.parseUpdates();
                m_topology.getVertices().stream().forEach(v -> update(v));
                m_topology.getEdges().stream().forEach(g -> update(g));
                LOG.debug("run: {} first run topology calculated", getName());
            } catch (Exception e) {
                LOG.error("run: {} first run: cannot build topology", getName(), e);
                return;
            }
        } else if (m_topologyService.parseUpdates() || m_forceRun) {
            m_forceRun = false;
            m_topologyService.refresh();
            LOG.debug("run: updates {}, recalculating topology ", getName());
            OnmsTopology topo;
            try {
                topo = buildTopology();
            } catch (Exception e) {
                LOG.error("cannot build topology", e);
                return;
            }
            m_topology.getVertices().stream().filter(v -> !topo.hasVertex(v.getId())).forEach(v -> delete(v));
            m_topology.getEdges().stream().filter(g -> !topo.hasEdge(g.getId())).forEach(g -> delete(g));

            topo.getVertices().stream().filter(v -> !m_topology.hasVertex(v.getId())).forEach(v -> update(v));
            topo.getEdges().stream().filter(g -> !m_topology.hasEdge(g.getId())).forEach(g -> update(g));
            m_topology = topo;
        }
        LOG.debug("run: end {}", getName());
    }

