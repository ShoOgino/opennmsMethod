    @Transactional(readOnly=true)
    @Override
    public PollerConfiguration getPollerConfigurationForLocation(final String location) {
        try {
            List<String> pollingPackageNames = getPackageNameForLocation(location);
            LOG.debug("Location {} has polling packages: {}", location, pollingPackageNames);

            List<SimplePollerConfiguration> addMe = new ArrayList<SimplePollerConfiguration>();
            for (String pollingPackageName : pollingPackageNames) {
                ConcurrentHashMap<String, SimplePollerConfiguration> cache = m_configCache.get();
                SimplePollerConfiguration pollerConfiguration = cache.get(pollingPackageName);
                if (pollerConfiguration == null) {
                    pollerConfiguration = createPollerConfiguration(pollingPackageName);
                    SimplePollerConfiguration configInCache = cache.putIfAbsent(pollingPackageName, pollerConfiguration);
                    // Make sure that we get the up-to-date value out of the ConcurrentHashMap
                    if (configInCache != null) {
                        pollerConfiguration = configInCache;
                    }
                }
                addMe.add(pollerConfiguration);
            }

            // construct a copy so the serverTime gets updated (and avoid threading issues)
            return new SimplePollerConfiguration(addMe.toArray(new SimplePollerConfiguration[0]));
        } catch (final Exception e) {
            LOG.warn("An error occurred retrieving the poller configuration for location {}", location, e);
            return new EmptyPollerConfiguration();
        }
    }

