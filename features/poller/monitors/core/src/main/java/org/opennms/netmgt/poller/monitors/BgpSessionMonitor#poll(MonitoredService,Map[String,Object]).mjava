    /**
     * {@inheritDoc}
     *
     * <P>
     * The poll() method is responsible for polling the specified address for
     * SNMP service availability.
     * </P>
     * @exception RuntimeException
     *                Thrown for any uncrecoverable errors.
     */
    @Override
    public PollStatus poll(MonitoredService svc, Map<String, Object> parameters) {   

        String returnValue = "";

        PollStatus status = PollStatus.unavailable();
        InetAddress ipaddr = svc.getAddress();

        // Initialize the messages if the session is down
        String adminStateMsg = "N/A";
        String peerStateMsg = "N/A";
        String remoteAsMsg = "N/A";
        String lastErrorMsg = "N/A";
        String estTimeMsg = "N/A";
        
        // Retrieve this interface's SNMP peer object
        //
        final SnmpAgentConfig agentConfig = getAgentConfig(svc, parameters);
        final String hostAddress = InetAddressUtils.str(ipaddr);
		LOG.debug("poll: setting SNMP peer attribute for interface {}", hostAddress);

        // Get configuration parameters
        //
        // This should never need to be overridden, but it can be in order to be used with similar tables.
        String bgpPeerIp = ParameterMap.getKeyedString(parameters, "bgpPeerIp", null);
        if (bgpPeerIp == null) {
            LOG.warn("poll: No BGP-Peer IP Defined! ");
            return status;
        }

        // set timeout and retries on SNMP peer object
        //
        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, "timeout", agentConfig.getTimeout()));
        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, "retry", ParameterMap.getKeyedInteger(parameters, "retries", agentConfig.getRetries())));
        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, "port", agentConfig.getPort()));
            
        // Establish SNMP session with interface
        //
        try {
            LOG.debug("poll: SnmpAgentConfig address: {}", agentConfig);
    
            // Get the BGP peer state
            SnmpObjId bgpPeerStateSnmpObject = SnmpObjId.get(BGP_PEER_STATE_OID + "." + bgpPeerIp);
            SnmpValue bgpPeerState = SnmpUtils.get(agentConfig, bgpPeerStateSnmpObject);
            
            // If no peer state is received or SNMP is not possible, service is down
            if (bgpPeerState == null) {
                LOG.warn("No BGP peer state received!");
                return status;
            } else {
                LOG.debug("poll: bgpPeerState: {}", bgpPeerState);
                peerStateMsg = resolvePeerState(bgpPeerState.toInt());
            }
            
            /*
             *  Do no unnecessary SNMP requests, if peer state is up, return with 
             *  service available and go away.
             */
            if (bgpPeerState.toInt() == BGP_PEER_STATE.ESTABLISHED.value()) {
                LOG.debug("poll: bgpPeerState: {}", BGP_PEER_STATE.ESTABLISHED.name());
                return PollStatus.available();
            }
            
            // Peer state is not established gather some information
            SnmpObjId bgpPeerAdminStateSnmpObject = SnmpObjId.get(BGP_PEER_ADMIN_STATE_OID + "." + bgpPeerIp);
            SnmpValue bgpPeerAdminState = SnmpUtils.get(agentConfig, bgpPeerAdminStateSnmpObject);
            // Check correct MIB-Support
            if (bgpPeerAdminState == null)
            {
                LOG.warn("Cannot receive bgpAdminState");
            } else {
                LOG.debug("poll: bgpPeerAdminState: {}", bgpPeerAdminState);
                adminStateMsg = resolveAdminState(bgpPeerAdminState.toInt());
            }
            
            SnmpObjId bgpPeerRemoteAsSnmpObject = SnmpObjId.get(BGP_PEER_REMOTEAS_OID + "." + bgpPeerIp);
            SnmpValue bgpPeerRemoteAs = SnmpUtils.get(agentConfig, bgpPeerRemoteAsSnmpObject);
            // Check correct MIB-Support
            if (bgpPeerRemoteAs == null)
            {
                LOG.warn("Cannot receive bgpPeerRemoteAs");
            } else {
                LOG.debug("poll: bgpPeerRemoteAs: {}", bgpPeerRemoteAs);
                remoteAsMsg = bgpPeerRemoteAs.toString();
            }

            SnmpObjId bgpPeerLastErrorSnmpObject = SnmpObjId.get(BGP_PEER_LAST_ERROR_OID + "." + bgpPeerIp);
            SnmpValue bgpPeerLastError = SnmpUtils.get(agentConfig, bgpPeerLastErrorSnmpObject);
            // Check correct MIB-Support
            if (bgpPeerLastError == null)
            {
                LOG.warn("Cannot receive bgpPeerLastError");
            } else {
                LOG.debug("poll: bgpPeerLastError: {}", bgpPeerLastError);
                lastErrorMsg = resolveBgpErrorCode(bgpPeerLastError.toHexString());
            }
            
            SnmpObjId bgpPeerFsmEstTimeSnmpObject = SnmpObjId.get(BGP_PEER_FSM_EST_TIME_OID + "." + bgpPeerIp);
            SnmpValue bgpPeerFsmEstTime = SnmpUtils.get(agentConfig, bgpPeerFsmEstTimeSnmpObject);
            // Check correct MIB-Support
            if (bgpPeerFsmEstTime == null)
            {
                LOG.warn("Cannot receive bgpPeerFsmEstTime");
            } else {
                LOG.debug("poll: bgpPeerFsmEsmTime: {}", bgpPeerFsmEstTime);
                estTimeMsg = bgpPeerFsmEstTime.toString();
            }
            
            returnValue = "BGP Session state to AS-" + remoteAsMsg
                + " via " + bgpPeerIp + " is " + peerStateMsg + "! Last peer "
                +"error message is " + lastErrorMsg + ". BGP admin state is "
                + adminStateMsg + ". BGP Session established time: " 
                + estTimeMsg;
            // Set service down and return gathered information            
            status = PollStatus.unavailable(returnValue);
                
        } catch (NullPointerException e) {
            String reason = "Unexpected error during SNMP poll of interface " + hostAddress;
            LOG.debug(reason, e);
            status = PollStatus.unavailable(reason);
        } catch (NumberFormatException e) {
            String reason = "Number operator used on a non-number " + e.getMessage();
            LOG.debug(reason);
            status = PollStatus.unavailable(reason);
        } catch (IllegalArgumentException e) {
            String reason = "Invalid SNMP Criteria: " + e.getMessage();
            LOG.debug(reason);
            status = PollStatus.unavailable(reason);
        } catch (Throwable t) {
            String reason = "Unexpected exception during SNMP poll of interface " + hostAddress;
            LOG.debug(reason, t);
            status = PollStatus.unavailable(reason);
        }

        // If matchAll is set to true, then the status is set to available above with a single match.
        // Otherwise, the service will be unavailable.
        return status;
    }

