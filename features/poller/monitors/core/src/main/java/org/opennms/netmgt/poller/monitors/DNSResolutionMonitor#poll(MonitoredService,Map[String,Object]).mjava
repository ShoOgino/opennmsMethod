    @Override
    public PollStatus poll(MonitoredService svc, Map<String, Object> parameters) {
        // Get the name to query for
        final Name name;
        final String lookup = resolveKeyedString(parameters, PARM_LOOKUP, svc.getNodeLabel());
        try {
            name = new Name(lookup);

        } catch (final TextParseException e) {
            return PollStatus.unavailable("Invalid record name '" + lookup + "': " + e.getMessage());
        }

        Set<Integer> recordTypes = new TreeSet<>();
        // Determine if records for IPv4 and/or IPv6 re required
        final String resolutionType = ParameterMap.getKeyedString(parameters, PARM_RESOLUTION_TYPE, PARM_RESOLUTION_TYPE_DEFAULT);
        final String recordTypesParam = ParameterMap.getKeyedString(parameters, PARM_RECORD_TYPES, "");
        Boolean matchAll = Boolean.TRUE;

        if ("".equals(recordTypesParam)) {
            if (PARM_RESOLUTION_TYPE_V4.equalsIgnoreCase(resolutionType) || PARM_RESOLUTION_TYPE_BOTH.equalsIgnoreCase(resolutionType) || PARM_RESOLUTION_TYPE_EITHER.equalsIgnoreCase(resolutionType)) {
                recordTypes.add(Type.A);
            }
            if (PARM_RESOLUTION_TYPE_V6.equalsIgnoreCase(resolutionType) || PARM_RESOLUTION_TYPE_BOTH.equalsIgnoreCase(resolutionType) || PARM_RESOLUTION_TYPE_EITHER.equalsIgnoreCase(resolutionType)) {
                recordTypes.add(Type.AAAA);
            }
            if (PARM_RESOLUTION_TYPE_EITHER.equals(resolutionType)) {
                matchAll = Boolean.FALSE;
            }
        } else {
            for (final String type : recordTypesParam.split(",")) {
                final Integer typeValue = Type.value(type);
                if (typeValue == -1) {
                    LOG.error("Invalid record type '{}' specified in record-types list.", type);
                } else {
                    recordTypes.add(typeValue);
                }
            }
        }

        // Build a resolver object used for lookups
        final String nameserver = resolveKeyedString(parameters, PARM_NAMESERVER, null);

        final Resolver resolver;
        try {
            if (nameserver == null) {
                // Use system-defined resolvers
                resolver = new ExtendedResolver();
            } else {
                if ("::1".equals(nameserver)) {
                    resolver = new SimpleResolver(nameserver);
                } else if (nameserver.matches("^\\[[\\d:]+\\]:\\d+$")) {
                    // IPv6 address with port number
                    final Integer pos = nameserver.lastIndexOf(":");
                    String hostname = nameserver.substring(0, pos);
                    hostname = hostname.substring(1, hostname.length() - 1);
                    final Integer port = Integer.valueOf(nameserver.substring(pos + 1));
                    LOG.debug("nameserver: hostname={}, port={}", hostname, port);
                    resolver = new SimpleResolver(hostname);
                    resolver.setPort(port);
                } else if (nameserver.matches("^\\S+:\\d+$")) {
                    // hostname with port number
                    final Integer pos = nameserver.lastIndexOf(":");
                    final String hostname = nameserver.substring(0, pos);
                    final Integer port = Integer.valueOf(nameserver.substring(pos + 1));
                    LOG.debug("nameserver: hostname={}, port={}", hostname, port);
                    resolver = new SimpleResolver(hostname);
                    resolver.setPort(port);

                } else {
                    // hostname or ip address
                    resolver = new SimpleResolver(nameserver);
                }
            }

        } catch (final UnknownHostException e) {
            return PollStatus.unavailable("Unable to resolve nameserver '" + nameserver + "': " + e.getMessage());
        }

        // Start resolving the records
        final long start = System.currentTimeMillis();

        // Resolve the name
        Set<String> foundTypes = new TreeSet<>();
        Set<String> notFoundTypes = new TreeSet<>();
        recordTypes.forEach((type) -> {
            if (resolve(name, resolver, type)) {
                foundTypes.add(Type.string(type));
            } else {
                LOG.warn("Unable to resolve host '{}' for type '{}'", name, Type.string(type));
                notFoundTypes.add(Type.string(type));
            }
        });

        // Resolving succeeded - checking results
        final long end = System.currentTimeMillis();

        LOG.debug("foundTypes: {}", foundTypes);
        LOG.debug("notFoundTypes: {}", notFoundTypes);
        // Check if result is valid
        if (foundTypes.isEmpty() && !notFoundTypes.isEmpty()) {
            return PollStatus.unavailable("Unable to resolve host '" + name + "'");

        } else if (!foundTypes.isEmpty() && !notFoundTypes.isEmpty() && matchAll) {
            return PollStatus.unavailable("'" + name + "' could be resolved to types [" + foundTypes + "], but not for types [" + notFoundTypes + "]");

        } else {
            return PollStatus.available((double) (end - start));
        }
    }

