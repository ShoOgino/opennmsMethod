    private void refreshNodeData() {
        if (getNodeDao() == null) {
            LOG.warn("No node DAO!  Can't refresh node data.");
            return;
        }

        LOG.debug("Refreshing node data.");

        final CriteriaBuilder cb = new CriteriaBuilder(OnmsNode.class);
        cb.alias("assetRecord", "asset");
        cb.orderBy("id").asc();

        final List<OnmsAssetRecord> updatedAssets = new ArrayList<OnmsAssetRecord>();
        final Map<Integer, NodeEntry> nodes = new HashMap<Integer, NodeEntry>();

        m_transaction.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(final TransactionStatus status) {
                for (final OnmsNode node : getNodeDao().findMatching(cb.toCriteria())) {
                    LOG.trace("processing node {}", node.getId());

                    // pass 1: get the nodes with asset data
                    final OnmsAssetRecord assets = node.getAssetRecord();
                    if (assets != null && assets.getGeolocation() != null) {
                        final OnmsGeolocation geolocation = assets.getGeolocation();
                        final String addressString = geolocation.asAddressString();

                        final Float longitude = geolocation.getLongitude();
                        final Float latitude = geolocation.getLatitude();

                        if (longitude != null && latitude != null) {
                            if (longitude == Float.NEGATIVE_INFINITY || latitude == Float.NEGATIVE_INFINITY) {
                                // we've already cached it as bad, skip it
                                continue;
                            } else {
                                // we've already got good coordinates, return the node
                                nodes.put(node.getId(), new NodeEntry(node));
                                continue;
                            }
                        } else if (addressString == null || "".equals(addressString)) {
                            // no real address info, skip it
                            continue;
                        } else {
                            LOG.debug("Node {} has an asset record with address \"{}\", but no coordinates.", new Object[]{node.getId(), addressString});
                            final Coordinates coordinates = getCoordinates(addressString);

                            if (coordinates == null) {
                                LOG.debug("Node {} has an asset record with address, but we were unable to find valid coordinates.", node.getId());
                                continue;
                            }

                            geolocation.setLongitude(coordinates.getLongitude());
                            geolocation.setLatitude(coordinates.getLatitude());
                            updatedAssets.add(assets);

                            if (coordinates.getLongitude() == Float.NEGATIVE_INFINITY || coordinates.getLatitude() == Float.NEGATIVE_INFINITY) {
                                // we got bad coordinates
                                LOG.debug("Node {} has an asset record with address, but we were unable to find valid coordinates.", node.getId());
                                continue;
                            } else {
                                // valid coordinates, add to the list
                                nodes.put(node.getId(), new NodeEntry(node));
                            }
                        }
                    } else {
                        // no asset information
                    }
                }

                int lastId = -1;
                int unackedCount = 0;

                // pass 2: get alarm data for anything that's been grabbed from the DB
                if (!nodes.isEmpty()) {
                    LOG.debug("getting alarms for nodes");
                    final CriteriaBuilder ab = new CriteriaBuilder(OnmsAlarm.class);
                    ab.alias("node", "node");
                    ab.ge("severity", OnmsSeverity.WARNING);
                    ab.in("node.id", nodes.keySet());
                    ab.orderBy("node.id").asc();
                    ab.orderBy("severity").desc();

                    for (final OnmsAlarm alarm : getAlarmDao().findMatching(ab.toCriteria())) {
                        final int nodeId = alarm.getNodeId();
                        LOG.debug("nodeId = {}, lastId = {}, unackedCount = {}", new Object[]{nodeId, lastId, unackedCount});
                        if (nodeId != lastId) {
                            LOG.debug("  setting severity for node {} to {}", new Object[]{nodeId, alarm.getSeverity().getLabel()});
                            final NodeEntry nodeEntry = nodes.get(nodeId);
                            nodeEntry.setSeverity(alarm.getSeverity());
                            if (lastId != -1) {
                                nodeEntry.setUnackedCount(unackedCount);
                                unackedCount = 0;
                            }
                        }
                        if (alarm.getAckUser() == null) {
                            unackedCount++;
                        }

                        lastId = nodeId;
                    }
                }

                if (lastId != -1) {
                    nodes.get(lastId).setUnackedCount(unackedCount);
                }

                // pass 3: save any asset updates to the database
                LOG.debug("saving {} updated asset records to the database", updatedAssets.size());
                for (final OnmsAssetRecord asset : updatedAssets) {
                    getAssetRecordDao().saveOrUpdate(asset);
                }
            }
        });


        m_activeNodes = nodes;
    }

