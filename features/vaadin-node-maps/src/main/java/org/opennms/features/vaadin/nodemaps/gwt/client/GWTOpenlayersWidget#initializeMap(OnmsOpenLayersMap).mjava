    private final native void initializeMap(final OnmsOpenLayersMap map) /*-{
        var me = this;
        var displayAllNodes = true;

        var onPopupClose = function(evt) {
            select.unselect(this.feature);
        };

        var getHighestSeverityAlarmForNode = function(nodeId) {
            var alarms = me.@org.opennms.features.vaadin.nodemaps.gwt.client.GWTOpenlayersWidget::m_alarms;
            if (alarms) {
                return alarms.getHighestSeverityAlarm(nodeId);
            } else {
                return null;
            }
        };

        var getUnackedCount = function(nodeId) {
            var alarms = me.@org.opennms.features.vaadin.nodemaps.gwt.client.GWTOpenlayersWidget::m_alarms;
            if (alarms) {
                return alarms.getUnackedCount(nodeId);
            } else {
                return 0;
            }
        };

        var onFeatureSelect = function(evt) {
            feature = evt.feature;
            var msg = "";
            if (feature.cluster.length > 1) {
                var nodes = [];
                for ( var i = 0; i < feature.cluster.length; i++) {
                    var n = feature.cluster[i].attributes;
                    nodes.push(n.nodeLabel + "(" + n.ipAddress + ") : " + n.severityLabel);
                }
                msg = "<h2># of nodes: " + feature.cluster.length + " (" + getNumUnacked(feature)  + " Unacknowledged Alarms)</h2><ul><li>" + nodes.join("</li><li>") + "</li></ul>";
            } else {
                var n = feature.cluster[0].attributes;
                var severity = getHighestSeverity(feature);
                msg = "<h2>Node " + n.nodeLabel + "</h2>" + "<p>Node ID: " + n.nodeId + "</br>" + "Foreign Source: " + n.foreignSource + "</br>" + "Foreign ID: " + n.foreignId + "</br>" + "IP Address: " + n.ipAddress + "</br>" + "Status: " + severity + "</br></p>";
            }
            popup = new $wnd.OpenLayers.Popup.FramedCloud(
                "nodePopup",
                feature.geometry.getBounds().getCenterLonLat(),
                new $wnd.OpenLayers.Size(100, 100), msg, null, false,
                onPopupClose
            );
            feature.popup = popup;
            popup.feature = feature;
            map.addPopup(popup);
        };

        var getHighestSeverity = function(feature) {
            if (!feature.cluster) return "Normal";
            var severity = 0;
            var severityLabel = "Normal";
            for ( var i = 0; i < feature.cluster.length; i++) {
                var n = feature.cluster[i].attributes;
                var nodeId = parseInt(n.nodeId);
                var alarm = getHighestSeverityAlarmForNode(nodeId);
                if (alarm) {
                    if (alarm.severity > severity) {
                        severity = alarm.severity;
                        severityLabel = alarm.severityLabel;
                    }
                }
                if (severity == 7) {
                    break;
                }
            }
            return severityLabel;
        };

        var getNumUnacked = function(feature) {
            if (!feature.cluster) return 0;
            var count = 0;
            for ( var i = 0; i < feature.cluster.length; i++) {
                var nodeId = parseInt(feature.cluster[i].attributes.nodeId);
                count += getUnackedCount(nodeId);
            }
            return count;
        };

        var onFeatureUnselect = function(evt) {
            feature = evt.feature;
            if (feature.popup) {
                popup.feature = null;
                map.removePopup(feature.popup);
                feature.popup.destroy();
                feature.popup = null;
            }
        }

        var applyFilters = function(btn) {
            btn.value = displayAllNodes ? 'Show All Nodes' : 'Show Down Nodes';
            displayAllNodes = !displayAllNodes;
            nodesLayer.redraw();
        };

        var nodeFillColors = {
            Critical : "#F5CDCD",
            Major : "#FFD7CD",
            Minor : "#FFEBCD",
            Warning : "#FFF5CD",
            Normal : "#D7E100" // was #D7E1CD
        };

        var nodeStrokeColors = {
            Critical : "#CC0000",
            Major : "#FF3300",
            Minor : "#FF9900",
            Warning : "#FFCC00",
            Normal : "#336600"
        };

        var nodeStyles = new $wnd.OpenLayers.Style(
                {
                    pointRadius : "${radius}",
                    graphicName : "${shape}",
                    label : "${label}",
                    display : "${display}",
                    fillColor : "${fillColor}",
                    fillOpacity : 0.8,
                    strokeColor : "${strokeColor}",
                    strokeOpacity : 0.8,
                    strokeWidth : 3,
                    fontFamily : "'Lucida Grande', Verdana, sans-serif",
                    fontSize : 10
                },
                {
                    context : {
                        // The Shape will change if the cluster contain several nodes or not.
                        shape : function(feature) {
                            return feature.cluster && feature.cluster.length > 1 ? "circle" : "square";
                        },
                        // The Radius will change according with the amount of nodes on the cluster.
                        radius : function(feature) {
                            return feature.cluster ? Math.min(parseInt(feature.attributes.count), 7) + 5 : 5;
                        },
                        // The label will display the amount of nodes only for clusters.
                        label : function(feature) {
                            return feature.cluster && feature.cluster.length > 1 ? feature.cluster.length : "";
                        },
                        display : function(feature) {
                            if (displayAllNodes) {
                                return 'display';
                            }
                            // Display only nodes with availability < 100
                            return getHighestSeverity(feature) == 'Normal' ? 'none' : 'display';
                        },
                        // It depends on the calculated severity
                        strokeColor : function(feature) {
                            return nodeStrokeColors[getHighestSeverity(feature)];
                        },
                        // It depends on the calculated severity
                        fillColor : function(feature) {
                            return nodeFillColors[getHighestSeverity(feature)];
                        }
                    }
                });

        // Nodes Layer

        var nodesLayer = new $wnd.OpenLayers.Layer.Vector("All Nodes", {
            strategies : [ new $wnd.OpenLayers.Strategy.Cluster() ],
            styleMap : new $wnd.OpenLayers.StyleMap({
                'default' : nodeStyles,
                'select' : {
                    fillColor : "#8aeeef",
                    strokeColor : "#32a8a9"
                }
            })
        });

        // Selection Features

        var select = new $wnd.OpenLayers.Control.SelectFeature(nodesLayer, {
            hover : false
        } // The user must click on the cluster to see the details of it.
        );
        map.addControl(select);
        select.activate();

        nodesLayer.events.on({
            'featureselected' : onFeatureSelect,
            'featureunselected' : onFeatureUnselect
        });

        // It is important to add the layer to the map before populate it with the nodes.

        map.addLayer(nodesLayer);

        // Updating Nodes Layer

        me.@org.opennms.features.vaadin.nodemaps.gwt.client.GWTOpenlayersWidget::m_vectorLayer = nodesLayer;
        me.@org.opennms.features.vaadin.nodemaps.gwt.client.GWTOpenlayersWidget::updateFeatureLayer()();
        map.zoomToExtent(nodesLayer.getDataExtent());
    }-*/;

