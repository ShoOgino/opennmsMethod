    @Override
    protected void init(final VaadinRequest vaadinRequest) {
        m_request = vaadinRequest;
        LOG.debug("initializing");

        final VaadinApplicationContextImpl context = new VaadinApplicationContextImpl();
        final UI currentUI = UI.getCurrent();
        context.setSessionId(currentUI.getSession().getSession().getId());
        context.setUiId(currentUI.getUIId());
        context.setUsername(vaadinRequest.getRemoteUser());

        Assert.notNull(m_alarmTable);
        Assert.notNull(m_nodeTable);

        final String searchString = vaadinRequest.getParameter("search");
        final Integer maxClusterRadius = Integer.getInteger("gwt.maxClusterRadius", 350);
        LOG.info("Starting search string: {}, max cluster radius: {}", searchString, maxClusterRadius);

        m_alarmTable.setVaadinApplicationContext(context);
        final EventProxy eventProxy = new EventProxy() {
            @Override public <T> void fireEvent(final T eventObject) {
                LOG.debug("got event: {}", eventObject);
                if (eventObject instanceof VerticesUpdateEvent) {
                    final VerticesUpdateEvent event = (VerticesUpdateEvent)eventObject;
                    final List<Integer> nodeIds = new ArrayList<Integer>();
                    for (final VertexRef ref : event.getVertexRefs()) {
                        if ("nodes".equals(ref.getNamespace()) && ref.getId() != null) {
                            nodeIds.add(Integer.valueOf(ref.getId()));
                        }
                    }
                    m_mapWidgetComponent.setSelectedNodes(nodeIds);
                    return;
                }
                LOG.warn("Unsure how to deal with event: {}", eventObject);
            }
            @Override public <T> void addPossibleEventConsumer(final T possibleEventConsumer) {
                LOG.debug("(ignoring) add consumer: {}", possibleEventConsumer);
                /* throw new UnsupportedOperationException("Not yet implemented!"); */
            }
        };

        m_alarmTable.setEventProxy(eventProxy);
        m_nodeTable.setEventProxy(eventProxy);

        createMapPanel(searchString, maxClusterRadius);
        createRootLayout();
        addRefresher();

        // Notify the user if no tileserver url or options are set
        if (!NodeMapConfiguration.isValid()) {
            new InvalidConfigurationWindow().open();
        }
        // Schedule refresh of node data
        m_executor.scheduleWithFixedDelay(() -> m_mapWidgetComponent.refreshNodeData(), 0, 5, TimeUnit.MINUTES);

        // If we do not shutdown the executor, the scheduler keeps refreshing the node data, even if the
        // UI may already been detached, resulting at one point in a OutOfMemory. See NMS-8589.
        vaadinRequest.getService().addSessionDestroyListener(new SessionDestroyListener() {
            @Override
            public void sessionDestroy(SessionDestroyEvent event) {
                m_executor.shutdown();
            }
        });
    }

