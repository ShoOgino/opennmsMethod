    @Override
    public void refresh() {
        if (m_markers == null) {
            logger.log(Level.INFO, "markers not initialized yet, skipping update");
            return;
        }
        if (m_markerClusterGroup == null) {
            logger.log(Level.INFO, "marker cluster not initialized yet, skipping update");
            return;
        }

        m_markers.refresh();

        logger.log(Level.INFO, "processing " + m_markers.size() + " markers for the node layer");
        // make the search control refresh with the new markers
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {
            @Override public void execute() {
                m_searchControl.refresh();
            }
        });

        // add new markers
        Scheduler.get().scheduleIncremental(new RepeatingCommand() {
            final ListIterator<NodeMarker> m_markerIterator = m_markers.listIterator();

            @Override
            public boolean execute() {
                if (m_markerIterator.hasNext()) {
                    final NodeMarker marker = m_markerIterator.next();
                    if(StatesData.inUs(marker.getLatLng().lat(), marker.getLatLng().lng(), StatesData.getUsShape())){
                    	int stateId = StatesData.getStateId(marker.getLatLng().lat(), marker.getLatLng().lng(), StatesData.getInstance());
                    	if(!m_stateClusterGroups[stateId].hasLayer(marker)){
                    		m_stateClusterGroups[stateId].addLayer(marker);
                    	}
                    }
                    
                    else{
                    	if (!m_markerClusterGroup.hasLayer(marker)) {
                    		m_markerClusterGroup.addLayer(marker);
                    	}
                    }
                    return true;
                }

                logger.log(Level.INFO, "finished adding visible markers");

                return false;
            }

        });

        // remove disabled markers
        Scheduler.get().scheduleIncremental(new RepeatingCommand() {
            final ListIterator<NodeMarker> m_markerIterator = m_markers.getDisabledMarkers().listIterator();

            @Override
            public boolean execute() {
                if (m_markerIterator.hasNext()) {
                    final NodeMarker marker = m_markerIterator.next();
                    marker.closePopup();
                    if(StatesData.inUs(marker.getLatLng().lat(), marker.getLatLng().lng(), StatesData.getUsShape())){
                    	int stateId = StatesData.getStateId(marker.getLatLng().lat(), marker.getLatLng().lng(), StatesData.getInstance());
                    	
                    		m_stateClusterGroups[stateId].removeLayer(marker);
                    	
                    }
                    
                    else{
                
                    	m_markerClusterGroup.removeLayer(marker);
                    	
                    }
                    return true;
                }

                logger.log(Level.INFO, "finished removing filtered markers");

                return false;
            }
        });

        // zoom on first run
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {
            @Override
            public void execute() {
                if (m_firstUpdate) {
                    final LatLngBounds bounds = new LatLngBounds();
                    for (final NodeMarker marker : m_markers.getMarkers()) {
                        bounds.extend(marker.getLatLng());
                    }
                    for (final NodeMarker marker : m_markers.getDisabledMarkers()) {
                        bounds.extend(marker.getLatLng());
                    }
                    //logger.log(Level.INFO, "first update, zooming to " + bounds.toBBoxString());
                    m_map.fitBounds(bounds);
                    m_firstUpdate = false;
                }

                logger.log(Level.INFO, "finished updating marker cluster layer");
            }
        });
    }

