    private void updateScheduledServicesForLocation(final OnmsMonitoringLocation location) {
        final List<String> pollingPackageNames = location.getPollingPackageNames();
        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();
        LOG.debug("Location '{}' has polling packages: {}", location.getLocationName(), pollingPackageNames);

        final Set<RemotePolledService> servicesToBeScheduled = new HashSet<>();

        for (final String pollingPackageName : pollingPackageNames) {
            servicesToBeScheduled.addAll(servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName)));
        }

        final Map<JobKey, RemotePolledService> mapOfScheduledServices = getMapOfScheduledServices(location.getLocationName());
        final Set<RemotePolledService> scheduledServices = mapOfScheduledServices.entrySet().stream().map(e -> e.getValue()).collect(Collectors.toSet());

        // remove services that will not be scheduled anymore
        for (final Map.Entry<JobKey, RemotePolledService> entry : mapOfScheduledServices.entrySet()) {
            if (!servicesToBeScheduled.contains(entry.getValue())) {
                try {
                    scheduler.deleteJob(entry.getKey());
                } catch (SchedulerException e) {
                    LOG.warn("Failed to delete job {} for service {}.", entry.getKey(), entry.getValue(), e);
                }
            }
        }

        // add missing services that are not scheduled yet
        for (final RemotePolledService polledService : servicesToBeScheduled) {
            if (!scheduledServices.contains(polledService)) {
                try {
                    scheduleService(location.getLocationName(), polledService);
                } catch (SchedulerException e) {
                    LOG.warn("Failed to schedule {}.", polledService, e);
                }
            }
        }
    }

