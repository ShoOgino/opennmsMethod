    private Optional<Set<RemotePolledService>> filterService(final ServiceTracker.Service service) {
        return this.sessionUtils.withReadOnlyTransaction(() -> {
            // Get the monitored service entity
            final OnmsMonitoredService monitoredService = this.monitoredServiceDao.get(service.nodeId, service.ipAddress, service.serviceName);
            if (monitoredService == null) {
                return Optional.empty();
            }

            final OnmsIpInterface ipInterface = monitoredService.getIpInterface();
            final OnmsNode node = ipInterface.getNode();

            // Get all perspective locations from which the service is monitored via its assigned applications
            final List<OnmsMonitoringLocation> perspectiveLocations = this.applicationDao.getPerspectiveLocationsForService(service.nodeId, service.ipAddress, service.serviceName);
            if (perspectiveLocations.isEmpty()) {
                return Optional.empty();
            }

            // Get the polling package for the service
            this.pollerConfig.rebuildPackageIpListMap();

            final Package pkg = this.pollerConfig.getPackages().stream()
                                                 .filter(p -> this.pollerConfig.isInterfaceInPackage(InetAddressUtils.str(service.ipAddress), p) &&
                                                              this.pollerConfig.isServiceInPackageAndEnabled(service.serviceName, p))
                                                 .reduce((prev, curr) -> curr) // Take the last filtered element
                                                 .orElse(null);
            if (pkg == null) {
                return Optional.empty();
            }

            // Find the service (and the pattern parameters) for the service name
            final Optional<Package.ServiceMatch> serviceMatch = pkg.findService(service.serviceName);
            if (!serviceMatch.isPresent()) {
                return Optional.empty();
            }

            // Find the monitor implementation for the service name
            final ServiceMonitor serviceMonitor = this.pollerConfig.getServiceMonitor(serviceMatch.get().service.getName());
            if (serviceMonitor == null) {
                return Optional.empty();
            }

            final Optional<String> rrdRepositoryDir = Optional.ofNullable(getServiceParameter(serviceMatch.get().service, "rrd-repository"));
            final Optional<RrdRepository> rrdRepository = rrdRepositoryDir.map(directory -> {
                final RrdRepository rrdRepositoryInstance = new RrdRepository();
                rrdRepositoryInstance.setStep(this.pollerConfig.getStep(pkg));
                rrdRepositoryInstance.setHeartBeat(rrdRepositoryInstance.getStep() * 2);
                rrdRepositoryInstance.setRraList(this.pollerConfig.getRRAList(pkg));
                rrdRepositoryInstance.setRrdBaseDir(new File(directory));
                return rrdRepositoryInstance;
            });

            // Create the thresholding session for this poller
            final Optional<ThresholdingSession> thresholdingSession = rrdRepository.flatMap(repository -> {
                try {
                    return Optional.of(this.thresholdingService.createSession(service.nodeId,
                            InetAddressUtils.str(service.ipAddress),
                            service.serviceName,
                            repository,
                            new ServiceParameters(Collections.emptyMap())));
                } catch (final ThresholdInitializationException ex) {
                    LOG.error("Failed to create thresholding session", ex);
                    return Optional.empty();
                }
            });

            // Build remote polled services for each location
            return Optional.of(perspectiveLocations.stream()
                                                   .map(OnmsMonitoringLocation::getLocationName)
                                                   .map(perspectiveLocation -> new RemotePolledService(service,
                                                                                                       node.getForeignSource(),
                                                                                                       node.getForeignId(),
                                                                                                       node.getLabel(),
                                                                                                       pkg,
                                                                                                       serviceMatch.get(),
                                                                                                       serviceMonitor,
                                                                                                       perspectiveLocation,
                                                                                                       node.getLocation().getLocationName(),
                                                                                                       rrdRepository.orElse(null),
                                                                                                       thresholdingSession.orElse(null)))
                                                   .collect(Collectors.toSet()));
        });
    }

