    /**
     * Initializes and starts the alarm poller.
     *
     * @param pollInterval the poller interval to be used
     */
    private void startPoller(final long pollInterval) {
        LOG.debug("Starting alarm poller (interval {}s).", pollInterval);

        m_alarmPoller = Executors.newScheduledThreadPool(1);

        m_alarmPoller.scheduleWithFixedDelay(new Runnable() {
            private Map<Boolean, Map<String, Integer>> oldAlarmCount = new HashMap<>();
            private Map<Boolean, Map<String, OnmsSeverity>> oldSeverity = new HashMap<>();

            {
                oldAlarmCount.put(Boolean.TRUE, new HashMap<>());
                oldAlarmCount.put(Boolean.FALSE, new HashMap<>());
                oldSeverity.put(Boolean.TRUE, new HashMap<>());
                oldSeverity.put(Boolean.FALSE, new HashMap<>());
            }

            private List<OnmsAlarm> filterAlarms(List<OnmsAlarm> alarms, TriggerPackage triggerPackage) {

                Stream<OnmsAlarm> stream = alarms.stream();

                if (triggerPackage.getOnlyUnacknowledged()) {
                    stream = stream.filter(alarm -> !alarm.isAcknowledged());
                }

                if (!Strings.isNullOrEmpty(triggerPackage.getCategoryFilter())) {
                    stream = stream
                            .filter(alarm -> alarm.getNodeId() != null)
                            .filter(alarm -> alarm.getNode().getCategories().stream()
                                    .anyMatch(category -> category.getName().matches(triggerPackage.getCategoryFilter())));
                }

                if (!Strings.isNullOrEmpty(triggerPackage.getReductionKeyFilter())) {
                    stream = stream
                            .filter(alarm -> !Strings.isNullOrEmpty(alarm.getReductionKey()))
                            .filter(alarm -> alarm.getReductionKey().matches(triggerPackage.getReductionKeyFilter()));
                }

                return stream.collect(Collectors.toList());
            }

            @Override
            public void run() {
                try {
                    final IfTttConfig ifTttConfig = m_fileReloadContainer.getObject();

                    if (ifTttConfig.getPollInterval() != pollInterval) {
                        restartPoller(ifTttConfig.getPollInterval());
                        return;
                    }

                    if (!ifTttConfig.getEnabled()) {
                        LOG.debug("Disabled - skipping alarm polling.");
                        return;
                    }

                    transactionOperations.execute(new TransactionCallbackWithoutResult() {
                        @Override
                        protected void doInTransactionWithoutResult(TransactionStatus status) {

                            // Retrieve the alarms with an associated node and filter for matching categories.

                            final CriteriaBuilder criteriaBuilder = new CriteriaBuilder(OnmsAlarm.class)
                                    .gt("severity", OnmsSeverity.NORMAL);

                            final List<OnmsAlarm> alarms = alarmDao.findMatching(criteriaBuilder.toCriteria());

                            for (final TriggerPackage triggerPackage : ifTttConfig.getTriggerPackages()) {

                                if (!oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).containsKey(triggerPackage.getFilterKey())) {
                                    oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).put(triggerPackage.getFilterKey(), OnmsSeverity.INDETERMINATE);
                                    oldAlarmCount.get(triggerPackage.getOnlyUnacknowledged()).put(triggerPackage.getFilterKey(), 0);
                                }

                                final List<OnmsAlarm> filteredAlarms = filterAlarms(alarms, triggerPackage);

                                // Compute the maximum severity.

                                final Optional<OnmsSeverity> maxAlarmsSeverity = filteredAlarms.stream()
                                        .map(OnmsAlarm::getSeverity)
                                        .max(Comparator.naturalOrder());

                                final OnmsSeverity newSeverity = maxAlarmsSeverity.orElse(OnmsSeverity.NORMAL);
                                final int newAlarmCount = filteredAlarms.size();

                                LOG.debug("Received {} filtered, {} new severity", newAlarmCount, newSeverity);

                                final DefaultVariableNameExpansion defaultVariableNameExpansion = new DefaultVariableNameExpansion(
                                        oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey()), newSeverity,
                                        oldAlarmCount.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey()), newAlarmCount
                                );

                                // Trigger IFTTT event if necessary.

                                if (!newSeverity.equals(oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey())) ||
                                        newAlarmCount != oldAlarmCount.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey())) {
                                    fireIfTttTriggerSet(ifTttConfig, triggerPackage.getFilterKey(), newSeverity, defaultVariableNameExpansion);
                                }

                                LOG.debug("Old severity: {}, new severity: {}, old alarm count: {}, new alarm count: {}",
                                        oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey()), newSeverity,
                                        oldAlarmCount.get(triggerPackage.getOnlyUnacknowledged()).get(triggerPackage.getFilterKey()), newAlarmCount
                                );

                                oldSeverity.get(triggerPackage.getOnlyUnacknowledged()).put(triggerPackage.getFilterKey(), newSeverity);
                                oldAlarmCount.get(triggerPackage.getOnlyUnacknowledged()).put(triggerPackage.getFilterKey(), newAlarmCount);
                            }
                        }
                    });
                } catch (Exception e) {
                    LOG.error("Error while polling alarm table.", e);
                } finally {
                    LOG.debug("Run complete. Next poll in {}s.", pollInterval);
                }
            }
        }, pollInterval, pollInterval, TimeUnit.SECONDS);
    }

