    /**
     * <P>
     * Returns the total task timeout in milliseconds for all IP ranges.
     * </P>
     */
    public int calculateTaskTimeout() {
        BigDecimal taskTimeOut = BigDecimal.ZERO;
        for(final IPPollRange range : m_ranges) {
            taskTimeOut = taskTimeOut.add(
                // Take the number of retries
                BigDecimal.valueOf(range.getRetries())
                // Add 1 for the original request
                .add(BigDecimal.ONE, DECIMAL64)
                // Multiply by the number of addresses
                .multiply(new BigDecimal(range.getAddressRange().size()), DECIMAL64)
                // Multiply by the timeout per retry
                .multiply(BigDecimal.valueOf(range.getTimeout()), DECIMAL64)
                // Multiply by the fudge factor
                .multiply(FUDGE_FACTOR, DECIMAL64),
                DECIMAL64
            );

            // Add a delay for the rate limiting done with the
            // m_packetsPerSecond field
            taskTimeOut = taskTimeOut.add(
                new BigDecimal(range.getAddressRange().size())
                .divide(BigDecimal.valueOf(m_packetsPerSecond), DECIMAL64)
                .multiply(BigDecimal.valueOf(1000), DECIMAL64),
                DECIMAL64
            );
        }
        // If the timeout is greater than Integer.MAX_VALUE, just return Integer.MAX_VALUE
        return taskTimeOut.compareTo(BigDecimal.valueOf(Integer.MAX_VALUE)) >= 0 ? Integer.MAX_VALUE : taskTimeOut.intValue();
    }

