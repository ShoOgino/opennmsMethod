    private void triggerNextJobAsync(String location, Queue<DiscoveryJob> jobs, AtomicInteger jobIndexTracker, int totalNumberOfJobs, int taskId, CompletableFuture<Void> future) {
        final DiscoveryJob job = jobs.poll();
        if (job == null) {
            future.complete(null);
            return;
        }

        // Build the request
        final PingSweepRequestBuilder builder = locationAwarePingClient.sweep()
            .withLocation(job.getLocation())
            .withPacketsPerSecond(job.getPacketsPerSecond());
        for(IPPollRange range : job.getRanges()) {
            try {
                InetAddress begin = InetAddress.getByAddress(range.getAddressRange().getBegin());
                InetAddress end = InetAddress.getByAddress(range.getAddressRange().getEnd());
                builder.withRange(begin, end, range.getRetries(), range.getTimeout(), TimeUnit.MILLISECONDS);
            } catch (UnknownHostException e) {
                LOG.error("Failed to retrieve addresses from range: {}. The range will be skipped.", e);
            }
        }

        final int jobIndex = jobIndexTracker.incrementAndGet();
        LOG.debug("Starting job {} of {} at location {} (on task #{}).", jobIndex, totalNumberOfJobs, location, taskId);
        builder.execute().whenComplete((summary, ex) -> {
            // When finished, used the calling thread to generate the newSuspect events
            Logging.withPrefix(Discovery.getLoggingCategory(), new Runnable() {
                @Override
                public void run() {
                    if (summary != null) {
                        // Perform detection if there are any detectors associated with these IP addresses.
                        CompletableFuture<List<DiscoveryResult>> resultsFuture = performDetection(job.getLocation(), summary, job.getConfig());

                        //Send new suspect events after detection completed for all the IP addresses in the job.
                        resultsFuture.whenComplete((results, throwable) -> {

                            LOG.debug("Job {} of {} at location {} (on task #{}) completed succesfully.",
                                    jobIndex, totalNumberOfJobs, location, taskId);
                            // Generate an event log containing a newSuspect event for every host
                            // that responded to our pings and succeeded detection if there are any detectors associated with an IP Address.
                            final Log eventLog = toNewSuspectEvents(job, results);
                            // Avoid forwarding an empty log
                            if (eventLog.getEvents() != null && eventLog.getEvents().getEventCount() >= 1) {
                                eventForwarder.sendNow(eventLog);
                            }
                            // Recurse until the queue is empty
                            triggerNextJobAsync(location, jobs, jobIndexTracker, totalNumberOfJobs, taskId, future);
                        });

                    } else {
                        LOG.error("An error occurred while processing job {} of {} at location {} (on task #{})."
                                + " No newSuspect events will be generated.", jobIndex, totalNumberOfJobs, location, taskId, ex);
                        // Recurse until the queue is empty
                        triggerNextJobAsync(location, jobs, jobIndexTracker, totalNumberOfJobs, taskId, future);
                    }
                }
            });
        });
    }

