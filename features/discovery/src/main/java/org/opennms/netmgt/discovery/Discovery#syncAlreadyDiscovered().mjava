    /**
     * <p>syncAlreadyDiscovered</p>
     */
    protected void syncAlreadyDiscovered() {
        m_transactionOperations.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
                /**
                 * Make a new list with which we'll replace the existing one, that way
                 * if something goes wrong with the DB we won't lose whatever was already
                 * in there
                 */
                Set<LocationIpAddressKey> newAlreadyDiscovered = Collections.synchronizedSet(new HashSet<>());
                // Fetch all non-deleted nodes
                CriteriaBuilder builder = new CriteriaBuilder(OnmsNode.class);
                builder.ne("type", String.valueOf(NodeType.DELETED.value()));
                for (OnmsNode node : m_nodeDao.findMatching(builder.toCriteria())) {
                    for (OnmsIpInterface iface : node.getIpInterfaces()) {
                        // Skip deleted interfaces
                        // TODO: Refactor the 'D' value with an enumeration
                        if ("D".equals(iface.getIsManaged())) {
                            continue;
                        }
                        // TODO: Refactor this to use {@link InetAddress}
                        newAlreadyDiscovered.add(new LocationIpAddressKey(node.getLocation().getLocationName(), iface.getIpAddressAsString()));
                    }
                }
                m_interfaceFilter.setManagedAddresses(newAlreadyDiscovered);
                LOG.info("syncAlreadyDiscovered initialized list of managed IP addresses with {} members", m_interfaceFilter.size());
            }
        });
    }

