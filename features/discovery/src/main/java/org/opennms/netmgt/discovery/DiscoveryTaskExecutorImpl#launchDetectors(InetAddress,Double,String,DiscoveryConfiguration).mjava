    /**
     * This method calls all the detectors in parallel for a given IP Address and combines the result of all detectors
     * into single future.
     */
    private CompletableFuture<DiscoveryResult> launchDetectors(InetAddress inetAddress, Double pingDuration, String location, DiscoveryConfiguration config) {

        CompletableFuture<DiscoveryResult> future = new CompletableFuture<>();
        DiscoveryConfigFactory configFactory = new DiscoveryConfigFactory(config);
        List<Detector> detectors = configFactory.getListOfDetectors(inetAddress, location);
        if (detectors.size() > 0) {
            // Run all the detectors.
            try {
                List<CompletableFuture<Boolean>> futures = detectors.stream().map(detector ->
                        detect(detector, inetAddress, location)).collect(Collectors.toList());
                // Combine all futures.
                CompletableFuture<Void> allFutures = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));
                CompletableFuture<List<Boolean>> futureList = allFutures.thenApply(result -> {
                    return futures.stream().map(CompletableFuture::join).collect(Collectors.toList());
                });
                future = futureList.thenApply((results) -> {
                    boolean allResult = results.stream().allMatch(result -> result);
                    return new DiscoveryResult(allResult, inetAddress, pingDuration);
                });
                return future;
            } catch (Exception e) {
                LOG.error("Exception while performing detection in discovery for IP Address {} at location {}",
                        inetAddress.getHostAddress(), location, e);
                future.complete(new DiscoveryResult(false, inetAddress, pingDuration));
            }
        }  else {
            //When there are no detectors, The discovery is just ping itself, make DiscoveryResult successful.
            future.complete(new DiscoveryResult(true, inetAddress, pingDuration));
        }
        return future;
    }

