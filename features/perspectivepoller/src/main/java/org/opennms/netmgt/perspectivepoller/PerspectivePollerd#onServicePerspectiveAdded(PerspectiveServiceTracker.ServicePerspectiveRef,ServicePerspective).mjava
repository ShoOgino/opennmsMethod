    @Override
    public void onServicePerspectiveAdded(final PerspectiveServiceTracker.ServicePerspectiveRef servicePerspective, final ServicePerspective entity) {
        final JobKey key = buildJobKey(servicePerspective);

        final OnmsMonitoredService service = entity.getService();
        final OnmsIpInterface ipInterface = service.getIpInterface();
        final OnmsNode node = ipInterface.getNode();

        // Get the polling package for the service
        this.pollerConfig.rebuildPackageIpListMap();

        final Package pkg = this.pollerConfig.getPackages().stream()
                                             .filter(p -> this.pollerConfig.isInterfaceInPackage(InetAddressUtils.str(service.getIpAddress()), p) &&
                                                          this.pollerConfig.isServiceInPackageAndEnabled(service.getServiceName(), p))
                                             .reduce((prev, curr) -> curr) // Take the last filtered element
                                             .orElse(null);
        if (pkg == null) {
            return;
        }

        // Find the service (and the pattern parameters) for the service name
        final Optional<Package.ServiceMatch> serviceMatch = pkg.findService(service.getServiceName());
        if (!serviceMatch.isPresent()) {
            return;
        }

        // Find the monitor implementation for the service name
        final ServiceMonitor serviceMonitor = this.pollerConfig.getServiceMonitor(serviceMatch.get().service.getName());
        if (serviceMonitor == null) {
            return;
        }

        final Optional<String> rrdRepositoryDir = Optional.ofNullable(getServiceParameter(serviceMatch.get().service, "rrd-repository"));
        final Optional<RrdRepository> rrdRepository = rrdRepositoryDir.map(directory -> {
            final RrdRepository rrdRepositoryInstance = new RrdRepository();
            rrdRepositoryInstance.setStep(this.pollerConfig.getStep(pkg));
            rrdRepositoryInstance.setHeartBeat(rrdRepositoryInstance.getStep() * 2);
            rrdRepositoryInstance.setRraList(this.pollerConfig.getRRAList(pkg));
            rrdRepositoryInstance.setRrdBaseDir(new File(directory));
            return rrdRepositoryInstance;
        });

        // Create the thresholding session for this poller
        final Optional<ThresholdingSession> thresholdingSession = rrdRepository.flatMap(repository -> {
            try {
                return Optional.of(this.thresholdingService.createSession(service.getNodeId(),
                        InetAddressUtils.str(service.getIpAddress()),
                        service.getServiceName(),
                        repository,
                        new ServiceParameters(Collections.emptyMap())));
            } catch (final ThresholdInitializationException ex) {
                LOG.error("Failed to create thresholding session", ex);
                return Optional.empty();
            }
        });

        // Build perspective polled services
        final PerspectivePolledService perspectivePolledService = new PerspectivePolledService(service.getNodeId(),
                                                                                               service.getIpAddress(),
                                                                                               service.getServiceName(),
                                                                                               node.getForeignSource(),
                                                                                               node.getForeignId(),
                                                                                               node.getLabel(),
                                                                                               pkg,
                                                                                               serviceMatch.get(),
                                                                                               serviceMonitor,
                                                                                               servicePerspective.getPerspectiveLocation(),
                                                                                               node.getLocation().getLocationName(),
                                                                                               rrdRepository.orElse(null),
                                                                                               thresholdingSession.orElse(null));

        // Build job for scheduler
        final JobDetail job = JobBuilder
                .newJob(PerspectivePollJob.class)
                .withIdentity(key)
                .setJobData(new JobDataMap(ImmutableMap.builder()
                                                       .put(PerspectivePollJob.SERVICE, perspectivePolledService)
                                                       .put(PerspectivePollJob.BACKEND, this)
                                                       .put(PerspectivePollJob.TRACER, this.tracerRegistry.getTracer())
                                                       .build()))
                .build();

        final Trigger trigger = TriggerBuilder
                .newTrigger()
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                                                   .withIntervalInMilliseconds(perspectivePolledService.getServiceConfig().getInterval())
                                                   .repeatForever())
                .build();

        LOG.debug("Scheduling service named {} at location {} with interval {}ms", perspectivePolledService.getServiceName(),
                  perspectivePolledService.getPerspectiveLocation(), perspectivePolledService.getServiceConfig().getInterval());

        try {
            this.scheduler.scheduleJob(job, trigger);
        } catch (final SchedulerException e) {
            LOG.error("Failed to schedule {} ({}).", perspectivePolledService, key, e);
        }
    }

