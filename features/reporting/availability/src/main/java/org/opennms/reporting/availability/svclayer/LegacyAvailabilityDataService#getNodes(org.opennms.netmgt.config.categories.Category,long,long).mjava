    /** {@inheritDoc} */
    @Override
    public List<Node> getNodes(final org.opennms.netmgt.config.categories.Category category, final long startTime, final long endTime) throws AvailabilityDataServiceException {
        try {
            return Logging.withPrefix(LOG4J_CATEGORY, new Callable<List<Node>>() {
                @Override public List<Node> call() throws Exception {
                    final DBUtils db = new DBUtils();
                    m_nodes = new ArrayList<Node>();

                    PreparedStatement ipInfoGetStmt = null;
                    PreparedStatement servicesGetStmt = null;
                    PreparedStatement outagesGetStmt = null;

                    String categoryName = category.getLabel();
                    try {
                        CategoryFactory.init();
                        m_catFactory = CategoryFactory.getInstance();
                    } catch (final Exception e) {
                        LOG.error("Failed to initialize CategoryFactory", e);
                        throw new AvailabilityDataServiceException("failed to init catFactory");
                    }

                    m_catFactory.getReadLock().lock();

                    try {
                        String commonRule = m_catFactory.getEffectiveRule(categoryName);

                        FilterDaoFactory.getInstance().flushActiveIpAddressListCache();
                        final List<InetAddress> nodeIPs = FilterDaoFactory.getInstance().getActiveIPAddressList(commonRule);
                        LOG.debug("Number of IPs satisfying rule: {}", nodeIPs.size());

                        final List<String> monitoredServices = new ArrayList<String>(category.getServiceCollection());
                        LOG.debug("categories in monitoredServices = {}", monitoredServices);

                        initialiseConnection();
                        db.watch(m_availConn);
                        // Prepare the statement to get service entries for each IP

                        // Prepared statement to get node info for an IP
                        ipInfoGetStmt = m_availConn.prepareStatement(AvailabilityConstants.DB_GET_INFO_FOR_IP);
                        db.watch(ipInfoGetStmt);

                        // Prepared statedment to get services info for an IP address
                        servicesGetStmt = m_availConn.prepareStatement(AvailabilityConstants.DB_GET_SVC_ENTRIES);
                        db.watch(servicesGetStmt);

                        // Prepared statement to get outages entries
                        outagesGetStmt = m_availConn.prepareStatement(AvailabilityConstants.DB_GET_OUTAGE_ENTRIES);
                        db.watch(outagesGetStmt);

                        /*
                         * For each of these IP addresses, get the details from the
                         * ifServices and services tables.
                         */
                        Iterator<InetAddress> ipIter = nodeIPs.iterator();
                        String ip = null;
                        ResultSet ipRS = null;

                        // Prepared statement to get node info for an IP
                        ipInfoGetStmt = m_availConn.prepareStatement(AvailabilityConstants.DB_GET_INFO_FOR_IP);
                        db.watch(ipInfoGetStmt);

                        while (ipIter.hasNext()) {
                            ip = str(ipIter.next());
                            LOG.debug("executing {} for {}", ip, AvailabilityConstants.DB_GET_INFO_FOR_IP);

                            // get node info for this ip
                            ipInfoGetStmt.setString(1, ip);

                            ipRS = ipInfoGetStmt.executeQuery();
                            db.watch(ipRS);

                            // now handle all the results from this
                            while (ipRS.next()) {
                                int nodeid = ipRS.getInt(1);
                                final String nodeName = ipRS.getString(2);

                                // get the services for this IP address
                                ResultSet svcRS = null;
                                servicesGetStmt.setString(1, ip);
                                servicesGetStmt.setLong(2, nodeid);
                                svcRS = servicesGetStmt.executeQuery();
                                db.watch(svcRS);

                                // create node objects for this nodeID/IP/service
                                while (svcRS.next()) {
                                    // read data from the resultSet
                                    final int svcid = svcRS.getInt(1);
                                    final String svcname = svcRS.getString(2);

                                    /*
                                     * If the list is empty, we assume all services are
                                     * monitored. If it has any, we use it as a filter
                                     */
                                    if (monitoredServices.isEmpty() || monitoredServices.contains(svcname)) {
                                        final OutageSvcTimesList outageSvcTimesList = new OutageSvcTimesList();
                                        getOutagesNodeIpSvc(nodeid, nodeName, ip, svcid, svcname, outageSvcTimesList, outagesGetStmt, startTime, endTime);
                                    }
                                }
                            }
                        }
                    } catch (final Exception e) {
                        LOG.debug("Failed to get nodes for category {}", category, e);
                        throw new AvailabilityDataServiceException("Failed to get nodes for category " + category, e);
                    } finally {
                        db.cleanUp();
                        m_availConn = null;
                        m_catFactory.getReadLock().unlock();
                    }

                    return m_nodes;
                }
            });
        } catch (final Exception e) {
            if (e instanceof AvailabilityDataServiceException) throw (AvailabilityDataServiceException)e;
            throw new AvailabilityDataServiceException(e);
        }

    }

