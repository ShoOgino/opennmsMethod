    /**
     * Constructor
     *
     * @param nodes
     *            List of nodes
     * @param endTime
     *            End time ( end of yesterday in milliseconds)
     * @param lastMonthEndTime
     *            Last months end time (end of the last day of last month in
     *            milliseconds)
     * @param monitoredServices
     *            Monitored services belonging to the category.
     * @param report
     *            Castor Report class.
     * @param offenders
     *            Map of all offenders -- percent/(list of node) pairs
     * @param format
     *            Value can be "SVG / all"
     * @param warning a double.
     * @param normal a double.
     * @param comments a {@link java.lang.String} object.
     * @param name a {@link java.lang.String} object.
     * @param monthFormat a {@link java.lang.String} object.
     * @param catIndex a int.
     * @param sectionIndex a int.
     */
    public AvailCalculations(List<Node> nodes, long endTime, long lastMonthEndTime, List<String> monitoredServices, Report report, TreeMap<Double, List<String>> offenders, double warning, double normal, String comments, String name, String format, String monthFormat, int catIndex, int sectionIndex) {
        m_sectionIndex = sectionIndex;
        org.opennms.reporting.availability.Category category = new org.opennms.reporting.availability.Category();
        category.setWarning(warning);
        category.setNormal(normal);
        category.setCatComments(comments);
        category.setCatName(name);
        category.setCatIndex(catIndex);
        category.setNodeCount(nodes.size());
        int ipaddrCount = 0;
        int serviceCount = 0;
        
        for(Node tmpNode : nodes) {
            if (tmpNode != null) {
                ipaddrCount += tmpNode.getInterfaceCount();
                serviceCount += tmpNode.getServiceCount();
            }
        }
        category.setIpaddrCount(ipaddrCount);
        category.setServiceCount(serviceCount);

        org.opennms.reporting.availability.Categories categories = report.getCategories();
        String oldPrefix = ThreadCategory.getPrefix();
        ThreadCategory.setPrefix(LOG4J_CATEGORY);
        log = ThreadCategory.getInstance(this.getClass());
        if (log.isDebugEnabled())
            log.debug("Inside AvailCalculations using endTime " + endTime);
        ThreadCategory.setPrefix(oldPrefix);

        m_monitoredServices = monitoredServices;
        m_endLastMonthTime = lastMonthEndTime;
        m_daysInLastMonth = getDaysForMonth(m_endLastMonthTime);
        m_report = report;

        m_nodes = nodes;

        m_endTime = endTime;
        String label;
        String descr;


        // Please node the following 4 formats are displayed on the graphical
        // report.
        // (i) last12MoAvail
        // (ii) LastMonthsDailyAvailability
        // (iii) MonthToDateDailyAvailability
        // (iv) lastMoTop20offenders

        if (log.isDebugEnabled())
            log.debug("Now computing last 12 months daily availability ");
        //
        // N Months Availability
        //
        label = AvailabilityConstants.NMONTH_TOTAL_LABEL;
        descr = AvailabilityConstants.NMONTH_TOTAL_DESCR;
        if (label == null || label.length() == 0)
            label = "The last 12 Months Availability";
        if (descr == null || descr.length() == 0)
            descr = "The last 12 Months Availability";
        CatSections catSections = new CatSections();
        lastNMonthsAvailability(NMONTHS, m_endLastMonthTime, catSections, label, descr);
        if (log.isDebugEnabled())
            log.debug("Computed lastNMonthsAvailability");

        //
        // Last Months Daily Availability
        //
        if (log.isDebugEnabled())
            log.debug("Now computing last months daily availability ");
        label = AvailabilityConstants.LAST_MONTH_DAILY_LABEL;
        descr = AvailabilityConstants.LAST_MONTH_DAILY_DESCR;
        if (label == null || label.length() == 0)
            label = "The last Months Daily Availability";
        if (descr == null || descr.length() == 0)
            descr = "Daily Average of svcs monitored and availability of svcs divided by the total svc minutes (last month)";
        if (monthFormat.equalsIgnoreCase("calendar")){
			lastCalMoDailyAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr, "LastMonthsDailyAvailability");
        }else {
        	lastMoDailyAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr, "LastMonthsDailyAvailability");
        }
		if (log.isDebugEnabled())
        log.debug("Computed lastNDaysDailyAvailability");

        //
        // Month To Date Daily Availability
        //
        if (log.isDebugEnabled())
            log.debug("Now computing  month to date daily availability ");
        label = AvailabilityConstants.LAST_MTD_DAILY_LABEL;
        descr = AvailabilityConstants.LAST_MTD_DAILY_DESCR;
        if (label == null || label.length() == 0)
            label = "Month To Date Daily Availability";
        if (descr == null || descr.length() == 0)
            descr = "Daily Average of svc monitored and availability of svcs div by total svc minutes of month frm 1st till date";
        Calendar calendar = new GregorianCalendar();
        calendar.setTime(new Date(m_endTime));
        int numDaysInMonth = calendar.get(Calendar.DAY_OF_MONTH);
		if (monthFormat.equalsIgnoreCase("calendar")){
			lastCalMTDDailyAvailability(numDaysInMonth, m_endTime, catSections, label, descr, "MonthToDateDailyAvailability");
		}else {
			lastMTDDailyAvailability(numDaysInMonth, m_endTime, catSections, label, descr, "MonthToDateDailyAvailability");
		}
        
        if (log.isDebugEnabled())
            log.debug("Computed lastNDaysDailyAvailability");

        //
        // Last Months Top Offenders
        //
        if (log.isDebugEnabled())
            log.debug("Now computing Last Months Top Offenders ");
        label = AvailabilityConstants.NOFFENDERS_LABEL;
        descr = AvailabilityConstants.NOFFENDERS_DESCR;
        if (label == null || label.length() == 0)
            label = "Last Months Top Offenders";
        if (descr == null || descr.length() == 0)
            descr = "This is the list of the worst available devices in the category for the last month";
        lastMoTopNOffenders(offenders, catSections, label, descr);
        if (log.isDebugEnabled())
            log.debug("Computed lastMoTopNOffenders ");

        //
        // Last N days Daily Availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_30_DAYS_DAILY_LABEL ");
            label = AvailabilityConstants.LAST_30_DAYS_DAILY_LABEL;
            descr = AvailabilityConstants.LAST_30_DAYS_DAILY_DESCR;
            if (label == null || label.length() == 0)
                label = "The last 30 Days Daily Availability";
            if (descr == null || descr.length() == 0)
                descr = "Daily average of svcs and dvcs monitored and their availability divided by total mins for 30days";
            lastNDaysDailyAvailability(THIRTY, m_endTime, catSections, label, descr, "Last30DaysDailyAvailability");
            if (log.isDebugEnabled())
                log.debug("Computed lastNDaysDailyAvailability");
        }

        //
        // N days total availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_30_DAYS_TOTAL_LABEL ");
            label = AvailabilityConstants.LAST_30_DAYS_TOTAL_LABEL;
            descr = AvailabilityConstants.LAST_30_DAYS_TOTAL_DESCR;
            if (label == null || label.length() == 0)
                label = "The last 30 Days Total Availability";
            if (descr == null || descr.length() == 0)
                descr = "Average of svcs monitored and availability of svcs divided by total svc minutes of the last 30 days";
            lastNDaysTotalAvailability(THIRTY, m_endTime, catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed lastNDaysTotalAvailability");
        }

        //
        // Last Months Total Availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_MONTH_TOTAL_LABEL ");
            label = AvailabilityConstants.LAST_MONTH_TOTAL_LABEL;
            descr = AvailabilityConstants.LAST_MONTH_TOTAL_DESCR;
            if (label == null || label.length() == 0)
                label = "The last Months Total Availability";
            if (descr == null || descr.length() == 0)
                descr = "Average of svcs monitored and availability of svcs divided by the total svc minutes of the month";
            lastMoTotalAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed lastNDaysDailyAvailability");
        }

        //
        // Month To Date Total Availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_MTD_TOTAL_LABEL ");
            label = AvailabilityConstants.LAST_MTD_TOTAL_LABEL;
            descr = AvailabilityConstants.LAST_MTD_TOTAL_DESCR;
            if (label == null || label.length() == 0)
                label = "Month To Date Total Availability";
            if (descr == null || descr.length() == 0)
                descr = "Average of svc monitored and availability of svcs dividedby total svc minutes of month frm 1st till date";
            lastMoTotalAvailability(numDaysInMonth, m_endTime, catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed MTDTotalAvailability");
        }

        m_services = new HashMap<String, Map<IfService, OutageSvcTimesList>>();
            
        for(Node node : nodes) {
            if (node != null) {
                for(Interface intf : node.getInterfaces()) {
                    if (intf != null) {
                        for(Service svc : intf.getServices()) {
                            if (svc != null) {
                                OutageSvcTimesList outages = svc.getOutages();
                                if (outages != null) {
                                    IfService ifservice = new IfService(node.getNodeID(), intf.getName(), -1, node.getName(), svc.getName());
                                    Map<IfService, OutageSvcTimesList> svcOutages = m_services.get(svc.getName());
                                    if (svcOutages == null)
                                        svcOutages = new HashMap<IfService, OutageSvcTimesList>();
                                    svcOutages.put(ifservice, outages);
                                    m_services.put(svc.getName(), svcOutages);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (log.isDebugEnabled())
            log.debug("Services " + m_services);
        m_nodes = null;
        //
        // N Days Daily Service Availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_30_DAYS_SVC_AVAIL_LABEL ");
            label = AvailabilityConstants.LAST_30_DAYS_SVC_AVAIL_LABEL;
            descr = AvailabilityConstants.LAST_30_DAYS_SVC_AVAIL_DESCR;
            if (label == null || label.length() == 0)
                label = "The last 30 days Daily Service Availability";
            if (descr == null || descr.length() == 0)
                descr = "The last 30 days Daily Service Availability is the daily average of services";
            lastNDaysDailyServiceAvailability(THIRTY, m_endTime, catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed lastNDaysDailyServiceAvailability");
        }

        //
        // Last Months Daily Service Availability
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing LAST_MONTH_SVC_AVAIL_LABE");
            label = AvailabilityConstants.LAST_MONTH_SVC_AVAIL_LABEL;
            descr = AvailabilityConstants.LAST_MONTH_SVC_AVAIL_DESCR;
            if (label == null || label.length() == 0)
                label = "The last Months Daily Service Availability";
            if (descr == null || descr.length() == 0)
                descr = "The last Months Daily Service Availability is the daily average of services and devices";
            lastNDaysDailyServiceAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed lastNDaysDailyServiceAvailability");
        }

        //
        // Top N Service Outages
        //
        if (!format.equals("SVG")) {
            if (log.isDebugEnabled())
                log.debug("Now computing TOP20_SVC_OUTAGES_LABEL");
            label = AvailabilityConstants.TOP20_SVC_OUTAGES_LABEL;
            descr = AvailabilityConstants.TOP20_SVC_OUTAGES_DESCR;
            if (label == null || label.length() == 0)
                label = "Last Month Top Service Outages for ";
            if (descr == null || descr.length() == 0)
                descr = "Last Month Top Service Outages for ";
            lastMonTopNServiceOutages(catSections, label, descr);
            if (log.isDebugEnabled())
                log.debug("Computed lastMonTopNServiceOutages");
        }

        m_services = null;
        category.addCatSections(catSections);
        categories.addCategory(category);

        m_report.setCategories(categories);
        report = m_report;

        if (log.isDebugEnabled())
            log.debug("Leaving AvailCalculations");
    }

