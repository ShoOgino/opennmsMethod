    /**
     * Constructor
     *
     * @param nodes
     *            List of nodes
     * @param endTime
     *            End time ( end of yesterday in milliseconds)
     * @param lastMonthEndTime
     *            Last months end time (end of the last day of last month in
     *            milliseconds)
     * @param monitoredServices
     *            Monitored services belonging to the category.
     * @param report
     *            Castor Report class.
     * @param offenders
     *            Map of all offenders -- percent/(list of node) pairs
     * @param format
     *            Value can be "SVG / all"
     * @param warning a double.
     * @param normal a double.
     * @param comments a {@link java.lang.String} object.
     * @param name a {@link java.lang.String} object.
     * @param monthFormat a {@link java.lang.String} object.
     * @param catIndex a int.
     * @param sectionIndex a int.
     */
    public AvailCalculations(final List<Node> nodes, final long endTime, final long lastMonthEndTime, final List<String> monitoredServices, final Report report, final TreeMap<Double, List<String>> offenders, final double warning, final double normal, final String comments, final String name, final String format, final String monthFormat, final int catIndex, final int sectionIndex) {
        Logging.withPrefix(LOG4J_CATEGORY, new Runnable() {
            @Override public void run() {
                m_sectionIndex = sectionIndex;
                org.opennms.reporting.availability.Category category = new org.opennms.reporting.availability.Category();
                category.setWarning(warning);
                category.setNormal(normal);
                category.setCatComments(comments);
                category.setCatName(name);
                category.setCatIndex(catIndex);
                category.setNodeCount(nodes.size());
                int ipaddrCount = 0;
                int serviceCount = 0;

                for(Node tmpNode : nodes) {
                    if (tmpNode != null) {
                        ipaddrCount += tmpNode.getInterfaceCount();
                        serviceCount += tmpNode.getServiceCount();
                    }
                }
                category.setIpaddrCount(ipaddrCount);
                category.setServiceCount(serviceCount);

                org.opennms.reporting.availability.Categories categories = report.getCategories();

                LOG.debug("Inside AvailCalculations using endTime {}", endTime);

                m_monitoredServices = monitoredServices;
                m_endLastMonthTime = lastMonthEndTime;
                m_daysInLastMonth = getDaysForMonth(m_endLastMonthTime);
                m_report = report;

                m_nodes = nodes;

                m_endTime = endTime;
                String label;
                String descr;


                // Please node the following 4 formats are displayed on the graphical
                // report.
                // (i) last12MoAvail
                // (ii) LastMonthsDailyAvailability
                // (iii) MonthToDateDailyAvailability
                // (iv) lastMoTop20offenders


                LOG.debug("Now computing last 12 months daily availability ");
                //
                // N Months Availability
                //
                label = AvailabilityConstants.NMONTH_TOTAL_LABEL;
                descr = AvailabilityConstants.NMONTH_TOTAL_DESCR;
                if (label == null || label.length() == 0)
                    label = "The last 12 Months Availability";
                if (descr == null || descr.length() == 0)
                    descr = "The last 12 Months Availability";
                CatSections catSections = new CatSections();
                lastNMonthsAvailability(NMONTHS, m_endLastMonthTime, catSections, label, descr);

                LOG.debug("Computed lastNMonthsAvailability");

                //
                // Last Months Daily Availability
                //

                LOG.debug("Now computing last months daily availability ");
                label = AvailabilityConstants.LAST_MONTH_DAILY_LABEL;
                descr = AvailabilityConstants.LAST_MONTH_DAILY_DESCR;
                if (label == null || label.length() == 0)
                    label = "The last Months Daily Availability";
                if (descr == null || descr.length() == 0)
                    descr = "Daily Average of svcs monitored and availability of svcs divided by the total svc minutes (last month)";
                if (monthFormat.equalsIgnoreCase("calendar")){
                    lastCalMoDailyAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr, "LastMonthsDailyAvailability");
                }else {
                    lastMoDailyAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr, "LastMonthsDailyAvailability");
                }

                LOG.debug("Computed lastNDaysDailyAvailability");

                //
                // Month To Date Daily Availability
                //

                LOG.debug("Now computing  month to date daily availability ");
                label = AvailabilityConstants.LAST_MTD_DAILY_LABEL;
                descr = AvailabilityConstants.LAST_MTD_DAILY_DESCR;
                if (label == null || label.length() == 0)
                    label = "Month To Date Daily Availability";
                if (descr == null || descr.length() == 0)
                    descr = "Daily Average of svc monitored and availability of svcs div by total svc minutes of month frm 1st till date";
                Calendar calendar = new GregorianCalendar();
                calendar.setTime(new Date(m_endTime));
                int numDaysInMonth = calendar.get(Calendar.DAY_OF_MONTH);
                if (monthFormat.equalsIgnoreCase("calendar")){
                    lastCalMTDDailyAvailability(numDaysInMonth, m_endTime, catSections, label, descr, "MonthToDateDailyAvailability");
                }else {
                    lastMTDDailyAvailability(numDaysInMonth, m_endTime, catSections, label, descr, "MonthToDateDailyAvailability");
                }


                LOG.debug("Computed lastNDaysDailyAvailability");

                //
                // Last Months Top Offenders
                //

                LOG.debug("Now computing Last Months Top Offenders ");
                label = AvailabilityConstants.NOFFENDERS_LABEL;
                descr = AvailabilityConstants.NOFFENDERS_DESCR;
                if (label == null || label.length() == 0)
                    label = "Last Months Top Offenders";
                if (descr == null || descr.length() == 0)
                    descr = "This is the list of the worst available devices in the category for the last month";
                lastMoTopNOffenders(offenders, catSections, label, descr);

                LOG.debug("Computed lastMoTopNOffenders ");

                //
                // Last N days Daily Availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_30_DAYS_DAILY_LABEL ");
                    label = AvailabilityConstants.LAST_30_DAYS_DAILY_LABEL;
                    descr = AvailabilityConstants.LAST_30_DAYS_DAILY_DESCR;
                    if (label == null || label.length() == 0)
                        label = "The last 30 Days Daily Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "Daily average of svcs and dvcs monitored and their availability divided by total mins for 30days";
                    lastNDaysDailyAvailability(THIRTY, m_endTime, catSections, label, descr, "Last30DaysDailyAvailability");

                    LOG.debug("Computed lastNDaysDailyAvailability");
                }

                //
                // N days total availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_30_DAYS_TOTAL_LABEL ");
                    label = AvailabilityConstants.LAST_30_DAYS_TOTAL_LABEL;
                    descr = AvailabilityConstants.LAST_30_DAYS_TOTAL_DESCR;
                    if (label == null || label.length() == 0)
                        label = "The last 30 Days Total Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "Average of svcs monitored and availability of svcs divided by total svc minutes of the last 30 days";
                    lastNDaysTotalAvailability(THIRTY, m_endTime, catSections, label, descr);

                    LOG.debug("Computed lastNDaysTotalAvailability");
                }

                //
                // Last Months Total Availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_MONTH_TOTAL_LABEL ");
                    label = AvailabilityConstants.LAST_MONTH_TOTAL_LABEL;
                    descr = AvailabilityConstants.LAST_MONTH_TOTAL_DESCR;
                    if (label == null || label.length() == 0)
                        label = "The last Months Total Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "Average of svcs monitored and availability of svcs divided by the total svc minutes of the month";
                    lastMoTotalAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr);

                    LOG.debug("Computed lastNDaysDailyAvailability");
                }

                //
                // Month To Date Total Availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_MTD_TOTAL_LABEL ");
                    label = AvailabilityConstants.LAST_MTD_TOTAL_LABEL;
                    descr = AvailabilityConstants.LAST_MTD_TOTAL_DESCR;
                    if (label == null || label.length() == 0)
                        label = "Month To Date Total Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "Average of svc monitored and availability of svcs dividedby total svc minutes of month frm 1st till date";
                    lastMoTotalAvailability(numDaysInMonth, m_endTime, catSections, label, descr);

                    LOG.debug("Computed MTDTotalAvailability");
                }

                m_services = new HashMap<String, Map<IfService, OutageSvcTimesList>>();

                for(Node node : nodes) {
                    if (node != null) {
                        for(Interface intf : node.getInterfaces()) {
                            if (intf != null) {
                                for(Service svc : intf.getServices()) {
                                    if (svc != null) {
                                        OutageSvcTimesList outages = svc.getOutages();
                                        if (outages != null) {
                                            IfService ifservice = new IfService(node.getNodeID(), intf.getName(), -1, node.getName(), svc.getName());
                                            Map<IfService, OutageSvcTimesList> svcOutages = m_services.get(svc.getName());
                                            if (svcOutages == null)
                                                svcOutages = new HashMap<IfService, OutageSvcTimesList>();
                                            svcOutages.put(ifservice, outages);
                                            m_services.put(svc.getName(), svcOutages);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                LOG.debug("Services {}", m_services);
                m_nodes = null;
                //
                // N Days Daily Service Availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_30_DAYS_SVC_AVAIL_LABEL ");
                    label = AvailabilityConstants.LAST_30_DAYS_SVC_AVAIL_LABEL;
                    descr = AvailabilityConstants.LAST_30_DAYS_SVC_AVAIL_DESCR;
                    if (label == null || label.length() == 0)
                        label = "The last 30 days Daily Service Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "The last 30 days Daily Service Availability is the daily average of services";
                    lastNDaysDailyServiceAvailability(THIRTY, m_endTime, catSections, label, descr);

                    LOG.debug("Computed lastNDaysDailyServiceAvailability");
                }

                //
                // Last Months Daily Service Availability
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing LAST_MONTH_SVC_AVAIL_LABE");
                    label = AvailabilityConstants.LAST_MONTH_SVC_AVAIL_LABEL;
                    descr = AvailabilityConstants.LAST_MONTH_SVC_AVAIL_DESCR;
                    if (label == null || label.length() == 0)
                        label = "The last Months Daily Service Availability";
                    if (descr == null || descr.length() == 0)
                        descr = "The last Months Daily Service Availability is the daily average of services and devices";
                    lastNDaysDailyServiceAvailability(m_daysInLastMonth, m_endLastMonthTime, catSections, label, descr);

                    LOG.debug("Computed lastNDaysDailyServiceAvailability");
                }

                //
                // Top N Service Outages
                //
                if (!format.equals("SVG")) {

                    LOG.debug("Now computing TOP20_SVC_OUTAGES_LABEL");
                    label = AvailabilityConstants.TOP20_SVC_OUTAGES_LABEL;
                    descr = AvailabilityConstants.TOP20_SVC_OUTAGES_DESCR;
                    if (label == null || label.length() == 0)
                        label = "Last Month Top Service Outages for ";
                    if (descr == null || descr.length() == 0)
                        descr = "Last Month Top Service Outages for ";
                    lastMonTopNServiceOutages(catSections, label, descr);

                    LOG.debug("Computed lastMonTopNServiceOutages");
                }

                m_services = null;
                category.addCatSections(catSections);
                categories.addCategory(category);

                m_report.setCategories(categories);

                LOG.debug("Leaving AvailCalculations");
            }
        });
    }

