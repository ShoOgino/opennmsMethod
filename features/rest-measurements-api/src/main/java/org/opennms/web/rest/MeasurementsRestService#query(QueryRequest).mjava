    /**
     * Retrieves the measurements of many resources and performs
     * arbitrary calculations on these.
     *
     * This a read-only query, however we use a POST instead of GET
     * since the request parameters are difficult to express in a query string.
     */
    @POST
    @Path("/")
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.APPLICATION_ATOM_XML})
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.APPLICATION_ATOM_XML})
    @Transactional(readOnly=true)
    public QueryResponse query(final QueryRequest request) {
        Preconditions.checkState(m_fetchStrategy != null);
        validateQueryRequest(request);

        LOG.debug("Executing query with {}", request);

        // Fetch the measurements
        FetchResults results;
        try {
            results = m_fetchStrategy.fetch(
                        request.getStart(),
                        request.getEnd(),
                        request.getStep(),
                        request.getMaxRows(),
                        request.getSources()
                        );
        } catch (Exception e) {
            throw getException(Status.INTERNAL_SERVER_ERROR, e, "Fetch failed");
        }

        // Return a 404 when null
        if (results == null) {
            throw getException(Status.NOT_FOUND, "Resource or attribute not found for {}", request);
        }

        // Apply the expression to the fetch results
        try {
            expressionEngine.applyExpressions(request, results);
        } catch (ExpressionException e) {
            throw getException(Status.BAD_REQUEST, e, "An error occured while evaluating an expression.");
        }

        final Map<String, double[]> columns = results.getColumns();

        // Remove any transient values belonging to sources
        for (final Source source : request.getSources()) {
            if (source.getTransient()) {
                columns.remove(source.getLabel());
            }
        }

        // Return a 204 if there are no columns
        if (columns.keySet().size() == 0) {
            throw getException(Status.NO_CONTENT, "No content.");
        }

        // Build the response
        final QueryResponse response = new QueryResponse();
        response.setStart(request.getStart());
        response.setEnd(request.getEnd());
        response.setStep(results.getStep());
        response.setTimestamps(results.getTimestamps());
        response.setColumns(columns);

        return response;
    }

