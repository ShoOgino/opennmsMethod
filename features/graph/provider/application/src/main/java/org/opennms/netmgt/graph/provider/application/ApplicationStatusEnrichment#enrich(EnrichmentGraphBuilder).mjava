    @Override
    public void enrich(EnrichmentGraphBuilder graphBuilder) {
        // The status for all child services (OnmsMonitoredServices)
        final Map<ApplicationStatusEntity.Key, StatusInfo> childStatusMap = new HashMap<>();

        // Mapping between each vertex to its status
        final Map<GenericVertex, StatusInfo> vertexStatusMap = new HashMap<>();

        // Get maximum alarm severities for all application (alarm status)
        final List<ApplicationStatusEntity> result = applicationDao.getAlarmStatus();
        for (ApplicationStatusEntity eachRow : result) {
            final StatusInfo statusInfo = StatusInfo.builder(eachRow.getSeverity()).count(eachRow.getCount()).build();
            childStatusMap.put(eachRow.getKey(), statusInfo);
        }

        // Prepare calculation
        final List<GenericVertex> allVertices = graphBuilder.getView().getVertices();
        final List<GenericVertex> rootVertices = graphBuilder.getView().getVertices().stream().map(ApplicationVertex::from).filter(v -> v.getApplicationId() != null).map(AbstractDomainVertex::asGenericVertex).collect(Collectors.toList());
        List<GenericVertex> childVertices = new ArrayList<>(allVertices);
        childVertices.removeAll(rootVertices);

        // The statusMap until now contains only status for all child vertices which have alarms
        // The others are now filled with NORMAL status entries
        for (GenericVertex eachVertex : childVertices) {
            final ApplicationStatusEntity.Key key = createKey(eachVertex);
            childStatusMap.putIfAbsent(key, DEFAULT_STATUS);
            vertexStatusMap.put(eachVertex, childStatusMap.get(key));
        }

        // The status of each Application (root vertices) is the maximum of its children
        final List<OnmsApplication> applications = rootVertices.stream().map(ApplicationVertex::from).map(v -> applicationDao.get(v.getApplicationId())).collect(Collectors.toList());
        final List<ApplicationStatus> applicationStatus = applicationDao.getApplicationStatus(applications);
        for (ApplicationStatus status : applicationStatus) {
            final String vertexId = ApplicationVertex.createVertexId(status.getApplication());
            final GenericVertex vertex = graphBuilder.getView().getVertex(vertexId);
            if (vertex != null) {
                vertexStatusMap.put(vertex, StatusInfo.builder(status.getSeverity()).build()); // TODO MVR count is missing
            }
        }

        // Update vertices
        vertexStatusMap.entrySet().forEach(entry -> graphBuilder.property(entry.getKey(), EnrichedProperties.STATUS, entry.getValue()));
    }

