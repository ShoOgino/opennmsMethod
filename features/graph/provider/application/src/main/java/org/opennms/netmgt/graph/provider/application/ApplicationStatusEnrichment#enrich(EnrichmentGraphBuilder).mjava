    @Override
    public void enrich(EnrichmentGraphBuilder graphBuilder) {
        // Prepare calculation
        final List<GenericVertex> allVertices = graphBuilder.getView().getVertices();
        final List<GenericVertex> rootVertices = graphBuilder.getView().getVertices().stream().map(ApplicationVertex::from).filter(v -> v.getApplicationId() != null).map(AbstractDomainVertex::asGenericVertex).collect(Collectors.toList());
        List<GenericVertex> childVertices = new ArrayList<>(allVertices);
        childVertices.removeAll(rootVertices);

        // The status for all child services (OnmsMonitoredServices)
        final Map<String, StatusInfo> childStatusMap = new HashMap<>();

        // Mapping between each vertex to its status
        final Map<GenericVertex, StatusInfo> vertexStatusMap = new HashMap<>();

        // Load applications
        final List<OnmsApplication> applications = rootVertices.stream().map(v -> ApplicationVertex.from(v).getApplicationId()).map(id -> applicationDao.get(id)).collect(Collectors.toList());

        // Get maximum alarm severities for all application (alarm status)
        final List<MonitoredServiceStatusEntity> result = applicationDao.getAlarmStatus(applications);
        for (MonitoredServiceStatusEntity eachRow : result) {
            final StatusInfo statusInfo = StatusInfo.builder(eachRow.getSeverity()).count(eachRow.getCount()).build();
            childStatusMap.put(toId(eachRow.getNodeId(), eachRow.getIpAddress().toString(), eachRow.getServiceTypeId()), statusInfo);
        }

        // The statusMap until now contains only status for all child vertices which have alarms
        // The others are now filled with NORMAL status entries
        for (GenericVertex eachVertex : childVertices) {
            childStatusMap.putIfAbsent(toId(eachVertex), DEFAULT_STATUS);
            vertexStatusMap.put(eachVertex, childStatusMap.get(toId(eachVertex)));
        }

        // The status of each Application (root vertices) is the maximum of its children or if all children have an alarm
        // a minimum of "major"
        for (GenericVertex eachRoot : rootVertices) {
            boolean allChildrenHaveActiveAlarms = true;
            final StatusInfo.StatusInfoBuilder rootStatusBuilder = StatusInfo.from(DEFAULT_STATUS);
            // Calculate max severity
            for (GenericEdge eachEdge : graphBuilder.getView().getConnectingEdges(eachRoot)) {
                final GenericVertex serviceVertex = graphBuilder.getView().resolveVertex(eachEdge.getTarget());
                final StatusInfo childStatus = childStatusMap.get(toId(serviceVertex));
                final Severity childSeverity = childStatus.getSeverity();

                // check if all children have alarms
                if(childSeverity == null || Severity.Normal.isEqual(childSeverity) || Severity.Unknown.isEqual(childSeverity)){
                    allChildrenHaveActiveAlarms = false;  // at least one child has no active alarm
                }

                // check for the highest severity
                if (rootStatusBuilder.getSeverity().isLessThan(childStatus.getSeverity())) {
                    rootStatusBuilder.severity(childStatus.getSeverity()).count(childStatus.getCount());
                }

                // sum up all alarm counts from children
                rootStatusBuilder.count(rootStatusBuilder.getCount() + childStatus.getCount());
            }

            // if all children have active alarms, the application status must be at least major
            if (allChildrenHaveActiveAlarms && rootStatusBuilder.getSeverity().isLessThan(Severity.Major)) {
                rootStatusBuilder.severity(Severity.Major);
            }
            vertexStatusMap.put(eachRoot, rootStatusBuilder.build());
        }

        // Update vertices
        vertexStatusMap.entrySet().forEach(entry -> graphBuilder.property(entry.getKey(), EnrichedProperties.STATUS, entry.getValue()));
    }

