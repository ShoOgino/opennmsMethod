    @Test
    public void canHandleAlarmSnapshots() {
        // Use some value N that is greater than the the size used for the composite aggregations in the query
        // in order to verify that the pagination is working properly
        final long N = QueryProvider.MAX_BUCKETS * 2;
        final long now = PseudoClock.getInstance().getTime();
        final List<OnmsAlarm> alarms = LongStream.range(0, N)
                .mapToObj(i -> createAlarm((int)i, now))
                .collect(Collectors.toList());

        // Trigger the snapshot
        issueSnapshotWithPreAndPostCalls(alarms);

        // Wait for the alarms to be indexed
        await().atMost(1, TimeUnit.MINUTES).until(() -> alarmHistoryRepo.getNumActiveAlarmsAt(now), equalTo(N));


        // Advance the clock
        PseudoClock.getInstance().advanceTime(1, TimeUnit.MINUTES);
        final long then = PseudoClock.getInstance().getTime();

        // Now trigger another snapshot with an empty list of alarms
        issueSnapshotWithPreAndPostCalls(Collections.emptyList());

        // Wait for the deletes to be indexed
        await().atMost(1, TimeUnit.MINUTES).until(() -> alarmHistoryRepo.getNumActiveAlarmsAt(then), equalTo(0L));
    }

