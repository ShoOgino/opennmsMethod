    @Test
    @Transactional
    public void testRemoveAlarmWithFeedback() {
        SituationFeedbackRestServiceImpl sut = new SituationFeedbackRestServiceImpl(alarmDao, alarmEntityNotifier, mockFeebackRepository, transactionTemplate);
        AlarmFeedback falsePositive = AlarmFeedback.newBuilder()
                .withSituationKey(situation.getReductionKey())
                .withSituationFingerprint("fingerprint")
                .withAlarmKey(linkDownAlarmOnR1.getReductionKey())
                .withFeedbackType(FeedbackType.FALSE_POSITIVE)
                .withReason("not related")
                .withUser("user")
                .build();
        List<AlarmFeedback> feedback = Collections.singletonList(falsePositive);

        OnmsAlarm prior = alarmDao.findByReductionKey(situation.getReductionKey());
        assertThat(prior.getRelatedAlarms().size(), is(2));

        int situationId = prior.getId();

        // Manually bind our test implementation
        sut.onBind(new AlarmFeedbackListenerImpl(), null);

        sut.setFeedback(situationId, feedback);

        // Our listener should have received the feedback
        assertThat(alarmFeedback, equalTo(feedback));

        // Note: the below check is not really useful as of HZN-1435
        // This could potentially be improved by verifying the feedback is sent out and a new situation Event is
        // received after the OCE has processed it (when that feature is complete)
        OnmsAlarm restrieved = alarmDao.findByReductionKey(situation.getReductionKey());
        // Since alarm feedback is not processed locally in the ReST API we expect the situation to remain unchanged
        assertThat(restrieved.getRelatedAlarms().size(), is(2));
        assertThat(restrieved.getRelatedAlarms(), Matchers.containsInAnyOrder(linkDownAlarmOnR1, linkDownAlarmOnR2));
    }

