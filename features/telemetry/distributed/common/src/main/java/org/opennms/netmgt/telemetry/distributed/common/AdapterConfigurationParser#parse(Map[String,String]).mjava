    /**
     * Groups properties for the same adapter together and wraps the properties behind a {@link MapBasedAdapterDef}.
     * Each key which is starting with <code>adapters.n.</code> where 1 is any single character,
     * @param properties The properties to parse. May contain protocol properties as well.
     * @return The Adapter definitions.
     */
    public List<Adapter> parse(Map<String, String> properties) {
        // Legacy Mode
        if (!hasAdaptersKey(properties)) {
            return Lists.newArrayList(new MapBasedAdapterDef(properties));
        }

        // New Mode, get all available adapters
        final Map<String, String> adapterConfigurations = MapUtils.filterKeysByPrefix(properties, "adapters.");

        // Each adapters key should be prefixed with a number, e.g. adapters.1., adapters.2., etc.
        final Set<String> numbers = adapterConfigurations.keySet()
                .stream()
                .map(key -> key.split("\\.")[0]) // We are only interested in the number indicator, e.g. 1, 2, etc.
                .collect(Collectors.toSet());
        final List<Adapter> adapters = new ArrayList<>();
        for (String eachAdapterPrefix : numbers) {
            final Map<String, String> stringStringMap = MapUtils.filterKeysByPrefix(adapterConfigurations, eachAdapterPrefix + ".");
            final MapBasedAdapterDef mapBasedAdapterDef = new MapBasedAdapterDef(stringStringMap);
            adapters.add(mapBasedAdapterDef);
        }

        return adapters;
    }

