    /**
     * Groups properties for the same adapter together and wraps the properties behind a {@link AdapterDefinition}.
     * Each key which is starting with <code>adapters.n.</code> where 1 is any single character.
     *
     * @param propertyTree The properties to parse. May contain queue properties as well.
     * @return The Adapter definitions.
     */
    public List<AdapterDefinition> parse(PropertyTree propertyTree) {
        Objects.requireNonNull(propertyTree);

        // Legacy Mode
        if (propertyTree.getMap("adapters").isEmpty()) {
            return Lists.newArrayList(new MapBasedAdapterDef(propertyTree));
        }

        // New Mode, get all available adapters
        final Map<String, PropertyTree> adapterConfigurations = propertyTree.getSubTrees("adapters");

        // Each adapters key should be prefixed with a number, e.g. adapters.1., adapters.2., etc.
        final List<String> keys = adapterConfigurations.keySet()
                .stream()
                .sorted()
                .collect(Collectors.toList());
        final List<AdapterDefinition> adapters = new ArrayList<>();
        for (String eachAdapterPrefix : keys) {
            final PropertyTree adapterconfig = adapterConfigurations.get(eachAdapterPrefix);
            final MapBasedAdapterDef mapBasedAdapterDef = new MapBasedAdapterDef(adapterconfig);
            adapters.add(mapBasedAdapterDef);
        }

        return adapters;
    }

