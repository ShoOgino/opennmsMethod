    @Override
    public void updated(String pid, Dictionary<String, ?> properties) {
        final TelemetryMessageConsumer existingConsumer = consumersById.get(pid);
        if (existingConsumer != null) {
            LOG.info("Updating existing consumer for pid: {}", pid);
            deleted(pid);
        } else {
            LOG.info("Creating new consumer for pid: {}", pid);
        }

        // Build the queue and adapter definitions
        final PropertyTree propertyTree = PropertyTree.from(properties);
        final QueueDefinition queueDefinition = new MapBasedQueueDef(propertyTree);
        final List<AdapterDefinition> adapterDefinitions = new AdapterDefinitionParser().parse(queueDefinition.getName(), propertyTree);

        // Register health checks
        healthChecksById.putIfAbsent(pid, new ArrayList<>());
        final List<AdapterHealthCheck> healthChecks = new ArrayList<>(); // we need this temporarily, to mark the health check as success or failed afterwards
        for (AdapterDefinition eachAdapter : adapterDefinitions) {
            final AdapterHealthCheck healthCheck = new AdapterHealthCheck(eachAdapter);
            healthChecks.add(healthCheck);

            final ServiceRegistration<HealthCheck> serviceRegistration = bundleContext.registerService(HealthCheck.class, healthCheck, null);
            healthChecksById.get(pid).add(serviceRegistration);
        }

        try {
            // Create the Module
            final TelemetrySinkModule sinkModule = new TelemetrySinkModule(queueDefinition);
            sinkModule.setDistPollerDao(distPollerDao);

            // Create the consumer
            final TelemetryMessageConsumer consumer = new TelemetryMessageConsumer(queueDefinition, adapterDefinitions, sinkModule);
            consumer.setRegistry(telemetryRegistry);
            consumer.init();
            messageConsumerManager.registerConsumer(consumer);
            consumersById.put(pid, consumer);

            // At this point the consumer should be up and running, so we mark the underlying health checks as success
            healthChecks.forEach(AdapterHealthCheck::markSucess);
        } catch (Exception e) {
            // In case of error, we mark the health checks as failure as well
            healthChecks.forEach(healthCheck -> healthCheck.markError(e));
            LOG.error("Failed to create {}", TelemetryMessageConsumer.class, e);
        }
    }

