    @Override
    public void updated(String pid, Dictionary<String, ?> properties) {
        if (this.entities.containsKey(pid)) {
            LOG.info("Updating existing listener/dispatcher for pid: {}", pid);
            deleted(pid);
        } else {
            LOG.info("Creating new listener/dispatcher for pid: {}", pid);
        }
        final PropertyTree definition = PropertyTree.from(properties);
        final MapBasedListenerDef listenerDef = new MapBasedListenerDef(definition);
        final ListenerHealthCheck healthCheck = new ListenerHealthCheck(listenerDef);

        final Entity entity = new Entity();
        entity.healthCheck = bundleContext.registerService(HealthCheck.class, healthCheck, null);

        try {
            // Create sink modules for all defined queues
            listenerDef.getParsers().stream()
                    .forEach(parserDef -> {
                        // Ensure that the queues have not yet been created
                        if (telemetryRegistry.getDispatcher(parserDef.getQueueName()) != null) {
                            throw new IllegalArgumentException("A queue with name " + parserDef.getQueueName() + " is already defined. Bailing.");
                        }

                        // Create sink module
                        final TelemetrySinkModule sinkModule = new TelemetrySinkModule(parserDef);
                        sinkModule.setDistPollerDao(distPollerDao);

                        // Create dispatcher
                        final AsyncDispatcher<TelemetryMessage> dispatcher = messageDispatcherFactory.createAsyncDispatcher(sinkModule);
                        final String queueName = Objects.requireNonNull(parserDef.getQueueName());
                        telemetryRegistry.registerDispatcher(queueName, dispatcher);

                        // Remember queue name
                        entity.queueNames.add(parserDef.getQueueName());
                    });

            // Start listener
            entity.listener = telemetryRegistry.getListener(listenerDef);
            entity.listener.start();

            // At this point the listener should be up and running,
            // so we mark the underlying health check as success
            healthCheck.markSucess();

            this.entities.put(pid, entity);
        } catch (Exception e) {
            LOG.error("Failed to build listener.", e);

            // In case of error, we mark the health check as failure as well
            healthCheck.markError(e);

            // Close all already started dispatcher
            stopQueues(entity.queueNames);
        }
        LOG.info("Successfully started listener/dispatcher for pid: {}", pid);
    }

