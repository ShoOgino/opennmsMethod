    @Override
    public CompletableFuture<?> parse(final ByteBuffer buffer,
                                      final InetSocketAddress remoteAddress,
                                      final InetSocketAddress localAddress) throws Exception {
        final SampleDatagram packet = new SampleDatagram(buffer);

        LOG.trace("Got packet: {}", packet);

        final CompletableFuture<TelemetryMessage> future = new CompletableFuture<>();
        executor.execute(() -> {
            enricher.enrich(packet).whenComplete((enrichment,ex) -> {
                if (ex != null) {
                    // Enrichment failed
                    future.completeExceptionally(ex);
                    return;
                }
                // Enrichment was successful

                // We're currently in the callback thread from the enrichment process
                // We want the remainder of the serialization and dispatching to be performed
                // from one of our executor threads so that we can put back-pressure on the listener
                // if we can't keep up
                final Runnable dispatch = () -> {
                    // Serialize
                    final BasicOutputBuffer output = new BasicOutputBuffer();
                    try (final BsonBinaryWriter bsonWriter = new BsonBinaryWriter(output)) {
                        bsonWriter.writeStartDocument();

                        bsonWriter.writeName("time");
                        bsonWriter.writeInt64(System.currentTimeMillis());

                        bsonWriter.writeName("data");
                        packet.version.datagram.writeBson(bsonWriter, enrichment);

                        bsonWriter.writeEndDocument();
                    }

                    // Build the message to be sent
                    final TelemetryMessage msg = new TelemetryMessage(remoteAddress, output.getByteBuffers().get(0).asNIO());
                    dispatcher.send(msg).whenComplete((any, exx) -> {
                        if (exx != null) {
                            // Dispatching failed
                            future.completeExceptionally(exx);
                        }
                        future.complete(any);
                    });
                };

                // It's possible that the callback thread is already a thread from the pool, if that's the case
                // execute within the current thread. This helps avoid deadlocks.
                if (Boolean.TRUE.equals(isParserThread.get())) {
                    dispatch.run();
                } else {
                    // We're not in one of the parsers threads, execute the dispatch in the pool
                    executor.execute(dispatch);
                }
            });
        });
        return future;
    }

