    public Inet6Header(final ByteBuffer buffer) throws InvalidPacketException {
        final long version_tc_fl = BufferUtils.uint32(buffer);
        if (version_tc_fl >> 28 != 0x06) {
            // First four bits must be 0x06
            throw new InvalidPacketException(buffer, "Expected IPv6 Header");
        }

        this.tos = (int) ((version_tc_fl >> 20) & ((1 << 8) -1));
        this.totalLength = BufferUtils.uint16(buffer) + 40;
        this.protocol = BufferUtils.uint8(buffer);
        BufferUtils.skip(buffer, 1); // Hop limit

        try {
            this.srcAddress = Inet6Address.getByAddress(BufferUtils.bytes(buffer, 16)).getHostAddress();
            this.dstAddress = Inet6Address.getByAddress(BufferUtils.bytes(buffer, 16)).getHostAddress();
        } catch (final UnknownHostException e) {
            // This only happens if byte array length is != 4
            throw Throwables.propagate(e);
        }

        // Almost all protocols have their port fields directly following the IP header
        switch (this.protocol) {
            case 6: // TCP
                this.srcPort = BufferUtils.uint16(buffer);
                this.dstPort = BufferUtils.uint16(buffer);
                BufferUtils.skip(buffer, 8); // SeqNum and AckNum
                this.tcpFlags = BufferUtils.uint16(buffer) & ((1 << 9) - 1);
                break;

            case 17: // UDP
            case 132: // SCTP
                this.srcPort = BufferUtils.uint16(buffer);
                this.dstPort = BufferUtils.uint16(buffer);
                this.tcpFlags = null;
                break;

            case 1: // ICMP
            case 58: // ICMP6
                this.srcPort = 0;
                this.dstPort = BufferUtils.uint16(buffer);
                this.tcpFlags = null;
                break;

            default:
                this.srcPort = null;
                this.dstPort = null;
                this.tcpFlags = null;
        }
    }

