    @Override
    public void handleMessageLog(TelemetryMessageLog messageLog) {
        LOG.debug("Received {} telemetry messages", messageLog.getMessageList().size());

        final List<P> flowPackets = new LinkedList<>();
        final List<Flow> flows = new LinkedList<>();
        try (Timer.Context ctx = logParsingTimer.time()) {
            for (TelemetryMessageLogEntry eachMessage : messageLog.getMessageList()) {
                LOG.trace("Parsing packet: {}", eachMessage);
                final P flowPacket = parse(eachMessage);
                if (flowPacket != null) {
                    flowPackets.add(flowPacket);
                    flows.addAll(converter.convert(flowPacket));
                }
            }
            packetsPerLogHistogram.update(flowPackets.size());
        }

        try {
            LOG.debug("Persisting {} packets, {} flows.", flowPackets.size(), flows.size());
            final FlowSource source = new FlowSource(messageLog.getLocation(),
                    messageLog.getSourceAddress(),
                    contextKey);
            flowRepository.persist(flows, source);
        } catch (DetailedFlowException ex) {
            LOG.error("Error while persisting flows: {}", ex.getMessage(), ex);
            for (final String logMessage: ex.getDetailedLogMessages()) {
                LOG.error(logMessage);
            }
        } catch(UnrecoverableFlowException ex) {
            LOG.error("Error while persisting flows. Cannot recover: {}. {} messages are lost.", ex.getMessage(), messageLog.getMessageList().size(), ex);
            return;
        } catch (FlowException ex) {
            LOG.error("Error while persisting flows: {}", ex.getMessage(), ex);
        }

        LOG.debug("Completed processing {} telemetry messages.",
                messageLog.getMessageList().size());
    }

