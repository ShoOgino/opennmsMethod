    @Override
    public Handler accept(final InetSocketAddress remoteAddress,
                          final InetSocketAddress localAddress) {
        return new Handler() {
            private static final int ADD_PATH_CAP = 69;
            private InetAddress bgpId;
            private Map<InetAddress, PeerInfo> peerInfoMap = new HashMap<>();

            private PeerAccessor peerAccessor = peerHeader -> {
                if (peerHeader == null || peerHeader.id == null) {
                    return Optional.empty();
                }
                return Optional.ofNullable(peerInfoMap.get(peerHeader.id));
            };

            @Override
            public Optional<CompletableFuture<?>> parse(ByteBuf buffer) throws Exception {
                buffer.markReaderIndex();

                final Header header;
                if (buffer.isReadable(Header.SIZE)) {
                    header = new Header(slice(buffer, Header.SIZE));
                } else {
                    buffer.resetReaderIndex();
                    return Optional.empty();
                }

                final Packet packet;
                if (buffer.isReadable(header.payloadLength())) {
                    packet = header.parsePayload(slice(buffer, header.payloadLength()), peerAccessor);
                } else {
                    buffer.resetReaderIndex();
                    return Optional.empty();
                }

                LOG.trace("Got packet: {}", packet);

                // Build the message from the received packet
                final Transport.Message.Builder message = Transport.Message.newBuilder()
                        .setVersion(header.version);

                packet.accept(new Serializer(message));

                packet.accept(new Packet.Visitor.Adapter() {
                    @Override
                    public void visit(InitiationPacket packet) {
                        packet.information.first(InformationElement.Type.BGP_ID)
                                .map(InetAddressUtils::addr)
                                .ifPresent(_bgpId -> bgpId = _bgpId);
                    }
                });

                packet.accept(new Packet.Visitor.Adapter() {
                    @Override
                    public void visit(PeerUpPacket packet) {
                        packet.sendOpenMessage.capabilities.stream().filter(c -> c.getCode() == ADD_PATH_CAP).forEach(c -> {
                            ByteBuf b = Unpooled.wrappedBuffer(c.getValue().toByteArray());
                            int afi = uint16(b);
                            int safi = uint8(b);
                            int sendReceive = uint8(b);
                            peerInfoMap.computeIfAbsent(packet.peerHeader.id, k -> new PeerInfo()).addPathCapability(afi, safi, sendReceive, true);
                        });

                        packet.recvOpenMessage.capabilities.stream().filter(c -> c.getCode() == ADD_PATH_CAP).forEach(c -> {
                            ByteBuf b = Unpooled.wrappedBuffer(c.getValue().toByteArray());
                            int afi = uint16(b);
                            int safi = uint8(b);
                            int sendReceive = uint8(b);
                            peerInfoMap.computeIfAbsent(packet.peerHeader.id, k -> new PeerInfo()).addPathCapability(afi, safi, sendReceive, false);
                        });
                    }
                });

                if (bgpId != null) {
                    message.setBgpId(BmpParser.address(bgpId));
                }

                // Enrich the message with resolved hostnames
                CompletableFuture<Transport.Message.Builder> enriched = CompletableFuture.completedFuture(message);
                if (BmpParser.this.dnsLookupsEnabled) {
                    enriched = enriched.thenCompose(BmpParser.this.resolvePeer(packet))
                            .thenCompose(BmpParser.this.resolveSysName(packet, remoteAddress.getAddress()));
                }

                // Dispatch the final message
                final CompletableFuture<AsyncDispatcher.DispatchStatus> dispatched = enriched.thenCompose(msg -> {
                    final ByteBuffer payload = ByteBuffer.wrap(msg.build().toByteArray());
                    final CompletableFuture<AsyncDispatcher.DispatchStatus> status = BmpParser.this.dispatcher.send(new TelemetryMessage(remoteAddress, payload));
                    BmpParser.this.recordsDispatched.mark();
                    return status;
                });

                return Optional.of(dispatched);
            }

            @Override
            public void active() {
                BmpParser.this.connections.add(remoteAddress.getAddress());
                BmpParser.this.sendHeartbeat(HeartbeatMode.CHANGE);
            }

            @Override
            public void inactive() {
                BmpParser.this.connections.remove(remoteAddress.getAddress());
                BmpParser.this.sendHeartbeat(HeartbeatMode.CHANGE);
            }
        };
    }

