    @Override
    public Handler accept(final InetSocketAddress remoteAddress,
                          final InetSocketAddress localAddress) {
        return new Handler() {
            private InetAddress bgpId;

            @Override
            public Optional<CompletableFuture<?>> parse(ByteBuf buffer) throws Exception {
                buffer.markReaderIndex();

                final Header header;
                if (buffer.isReadable(Header.SIZE)) {
                    header = new Header(slice(buffer, Header.SIZE));
                } else {
                    buffer.resetReaderIndex();
                    return Optional.empty();
                }

                final Packet packet;
                if (buffer.isReadable(header.payloadLength())) {
                    packet = header.parsePayload(slice(buffer, header.payloadLength()));
                } else {
                    buffer.resetReaderIndex();
                    return Optional.empty();
                }

                LOG.trace("Got packet: {}", packet);

                // Build the message from the received packet
                final Transport.Message.Builder message = Transport.Message.newBuilder()
                                                                           .setVersion(header.version);

                packet.accept(new Serializer(message));

                packet.accept(new Packet.Visitor.Adapter() {
                    @Override
                    public void visit(final InitiationPacket packet) {
                        packet.information.first(InformationElement.Type.BGP_ID)
                                          .map(InetAddressUtils::addr)
                                          .ifPresent(_bgpId -> bgpId = _bgpId);
                    }
                });

                if (bgpId != null) {
                    message.setBgpId(BmpParser.address(bgpId));
                }


                // Enrich the message with resolved hostnames
                CompletableFuture<Transport.Message.Builder> enriched = CompletableFuture.completedFuture(message);
                if (BmpParser.this.dnsLookupsEnabled) {
                    enriched = enriched.thenCompose(BmpParser.this.resolvePeer(packet))
                                       .thenCompose(BmpParser.this.resolveSysName(packet, remoteAddress.getAddress()));
                }

                // Dispatch the final message
                final CompletableFuture<AsyncDispatcher.DispatchStatus> dispatched = enriched.thenCompose(msg -> {
                    final ByteBuffer payload = ByteBuffer.wrap(msg.build().toByteArray());
                    return BmpParser.this.dispatcher.send(new TelemetryMessage(remoteAddress, payload));
                });

                BmpParser.this.recordsDispatched.mark();

                return Optional.of(dispatched);
            }

            @Override
            public void active() {
                BmpParser.this.connections.add(remoteAddress.getAddress());
                BmpParser.this.sendHeartbeat(HeartbeatMode.CHANGE);
            }

            @Override
            public void inactive() {
                BmpParser.this.connections.remove(remoteAddress.getAddress());
                BmpParser.this.sendHeartbeat(HeartbeatMode.CHANGE);
            }
        };
    }

