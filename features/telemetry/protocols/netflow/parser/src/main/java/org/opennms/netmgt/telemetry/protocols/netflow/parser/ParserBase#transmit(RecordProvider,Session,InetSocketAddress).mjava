    protected CompletableFuture<?> transmit(final RecordProvider packet, final Session session, final InetSocketAddress remoteAddress) {
        // Verify that flows sequences are in order
        if (!session.verifySequenceNumber(packet.getObservationDomainId(), packet.getSequenceNumber())) {
            SEQUENCE_ERRORS_LOGGER.warn("Error in flow sequence detected: from {}", session.getRemoteAddress());
            this.sequenceErrors.inc();
        }

        // The packets are coming in hot - performance here is critical
        //   LOG.trace("Got packet: {}", packet);
        // Perform the record enrichment and serialization in a thread pool allowing these to be parallelized
        final CompletableFuture<CompletableFuture[]> futureOfFutures = CompletableFuture.supplyAsync(() -> {
            return packet.getRecords().map(record -> {
                this.recordsReceived.mark();

                final CompletableFuture<Void> future = new CompletableFuture<>();
                final Timer.Context timerContext = recordEnrichmentTimer.time();
                // Trigger record enrichment (performing DNS reverse lookups for example)
                final RecordEnricher recordEnricher = new RecordEnricher(dnsResolver, getDnsLookupsEnabled());
                recordEnricher.enrich(record).whenComplete((enrichment, ex) -> {
                    timerContext.close();
                    if (ex != null) {
                        this.recordEnrichmentErrors.inc();

                        // Enrichment failed
                        future.completeExceptionally(ex);
                        return;
                    }
                    // Enrichment was successful

                    // We're currently in the callback thread from the enrichment process
                    // We want the remainder of the serialization and dispatching to be performed
                    // from one of our executor threads so that we can put back-pressure on the listener
                    // if we can't keep up
                    final Runnable dispatch = () -> {
                        // Let's serialize
                        final FlowMessage.Builder flowMessage;
                        try {
                            flowMessage = this.getMessageBuilder().buildMessage(record, enrichment);
                        } catch (final  Exception e) {
                            throw new RuntimeException(e);
                        }

                        // Check if the flow is valid (and maybe correct it)
                        final List<String> corrections = this.correctFlow(flowMessage);
                        if (!corrections.isEmpty()) {
                            this.invalidFlows.mark();

                            final Optional<Instant> instant = illegalFlowEventCache.getUnchecked(session.getRemoteAddress());

                            if (!instant.isPresent() || Duration.between(instant.get(), Instant.now()).getSeconds() > getIllegalFlowEventRate()) {
                                illegalFlowEventCache.put(session.getRemoteAddress(), Optional.of(Instant.now()));

                                eventForwarder.sendNow(new EventBuilder()
                                        .setUei(ILLEGAL_FLOW_EVENT_UEI)
                                        .setTime(new Date())
                                        .setSource(getName())
                                        .setInterface(session.getRemoteAddress())
                                        .setDistPoller(identity.getId())
                                        .addParam("monitoringSystemId", identity.getId())
                                        .addParam("monitoringSystemLocation", identity.getLocation())
                                        .setParam("cause", Joiner.on('\n').join(corrections))
                                        .setParam("protocol", protocol.name())
                                        .setParam("illegalFlowEventRate", (int) getIllegalFlowEventRate())
                                        .getEvent());

                                for (final String correction : corrections) {
                                    LOG.warn("Illegal flow detected from exporter {}: \n{}", session.getRemoteAddress().getAddress(), correction);
                                }
                            }
                        }

                        // Build the message to dispatch
                        final TelemetryMessage msg = new TelemetryMessage(remoteAddress, ByteBuffer.wrap(flowMessage.build().toByteArray()));

                        // Dispatch
                        dispatcher.send(msg).whenComplete((b, exx) -> {
                            if (exx != null) {
                                this.recordDispatchErrors.inc();
                                future.completeExceptionally(exx);
                            } else {
                                this.recordsCompleted.mark();
                                future.complete(null);
                            }
                        });

                        recordsDispatched.mark();
                    };

                    // It's possible that the callback thread is already a thread from the pool, if that's the case
                    // execute within the current thread. This helps avoid deadlocks.
                    if (Boolean.TRUE.equals(isParserThread.get())) {
                        dispatch.run();
                    } else {
                        // We're not in one of the parsers threads, execute the dispatch in the pool
                        executor.execute(dispatch);
                    }

                    this.recordsScheduled.mark();
                });
                return future;
            }).toArray(CompletableFuture[]::new);
        }, executor);

        // Return a future which is completed when all records are finished dispatching (i.e. written to Kafka)
        final CompletableFuture<Void> future = new CompletableFuture<>();
        futureOfFutures.whenComplete((futures,ex) -> {
            if (ex != null) {
                LOG.warn("Error preparing records for dispatch.", ex);
                future.completeExceptionally(ex);
                return;
            }
            // Dispatch was triggered for all the records, now wait for the dispatching to complete
            CompletableFuture.allOf(futures).whenComplete((any,exx) -> {
                if (exx != null) {
                    LOG.warn("One or more of the records were not successfully dispatched.", exx);
                    future.completeExceptionally(exx);
                    return;
                }
                // All of the records have been successfully dispatched
                future.complete(any);
            });
        });
        return future;
    }

