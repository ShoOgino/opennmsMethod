    protected CompletableFuture<?> transmit(final RecordProvider packet, final InetSocketAddress remoteAddress) {
        // The packets are coming in hot - performance here is critical
        //   LOG.trace("Got packet: {}", packet);
        // Perform the record enrichment and serialization in a thread pool allowing these to be parallelized
        final CompletableFuture<CompletableFuture[]> futureOfFutures = CompletableFuture.supplyAsync(() -> {
            return packet.getRecords().map(record -> {
                final CompletableFuture<AsyncDispatcher.DispatchStatus> future = new CompletableFuture<>();
                final Timer.Context timerContext = recordEnrichmentTimer.time();
                // Trigger record enrichment (performing DNS reverse lookups for example)
                final RecordEnricher recordEnricher = new RecordEnricher(dnsResolver, getDnsLookupsEnabled());
                recordEnricher.enrich(record).whenComplete((enrichment, ex) -> {
                    timerContext.close();
                    if (ex != null) {
                        // Enrichment failed
                        future.completeExceptionally(ex);
                        return;
                    }
                    // Enrichment was successful

                    // We're currently in the callback thread from the enrichment process
                    // We want the remainder of the serialization and dispatching to be performed
                    // from one of our executor threads so that we can put back-pressure on the listener
                    // if we can't keep up
                    final Runnable dispatch = () -> {
                        // Let's serialize
                        byte[] flowMessage = new byte[0];
                        try {
                            flowMessage = buildMessage(record, enrichment);
                        } catch (IllegalFlowException e) {
                            final Optional<Instant> instant = illegalFlowEventCache.getUnchecked(remoteAddress.getAddress());

                            if (!instant.isPresent() || Duration.between(instant.get(), Instant.now()).getSeconds() > getIllegalFlowEventRate()) {
                                illegalFlowEventCache.put(remoteAddress.getAddress(), Optional.of(Instant.now()));

                                eventForwarder.sendNow(new EventBuilder()
                                        .setUei(ILLEGAL_FLOW_EVENT_UEI)
                                        .setTime(new Date())
                                        .setSource(getName())
                                        .setInterface(remoteAddress.getAddress())
                                        .setDistPoller(identity.getId())
                                        .addParam("monitoringSystemId", identity.getId())
                                        .addParam("monitoringSystemLocation", identity.getLocation())
                                        .setParam("cause", e.getMessage())
                                        .setParam("protocol", protocol.name())
                                        .setParam("illegalFlowEventRate", (int) getIllegalFlowEventRate())
                                        .getEvent());

                                LOG.warn("Illegal flow detected from exporter {}", remoteAddress.getAddress(), e);
                            }

                            return;
                        }

                        // Build the message to dispatch
                        final TelemetryMessage msg = new TelemetryMessage(remoteAddress, ByteBuffer.wrap(flowMessage));

                        // Dispatch
                        dispatcher.send(msg).whenComplete((b, exx) -> {
                            if (exx != null) {
                                future.completeExceptionally(exx);
                                return;
                            }
                            future.complete(b);
                        });

                        recordsDispatched.mark();
                    };

                    // It's possible that the callback thread is already a thread from the pool, if that's the case
                    // execute within the current thread. This helps avoid deadlocks.
                    if (Boolean.TRUE.equals(isParserThread.get())) {
                        dispatch.run();
                    } else {
                        // We're not in one of the parsers threads, execute the dispatch in the pool
                        executor.execute(dispatch);
                    }
                });
                return future;
            }).toArray(CompletableFuture[]::new);
        }, executor);

        // Return a future which is completed when all records are finished dispatching (i.e. written to Kafka)
        final CompletableFuture<Void> future = new CompletableFuture<>();
        futureOfFutures.whenComplete((futures,ex) -> {
            if (ex != null) {
                LOG.warn("Error preparing records for dispatch.", ex);
                future.completeExceptionally(ex);
                return;
            }
            // Dispatch was triggered for all the records, now wait for the dispatching to complete
            CompletableFuture.allOf(futures).whenComplete((any,exx) -> {
                if (exx != null) {
                    LOG.warn("One or more of the records were not successfully dispatched.", exx);
                    future.completeExceptionally(exx);
                    return;
                }
                // All of the records have been successfully dispatched
                future.complete(any);
            });
        });
        return future;
    }

