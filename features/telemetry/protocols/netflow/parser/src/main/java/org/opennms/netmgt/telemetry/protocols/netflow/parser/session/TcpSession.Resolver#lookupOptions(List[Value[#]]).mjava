        @Override
        public List<Value<?>> lookupOptions(final List<Value<?>> values) {
            final LinkedHashMap<String, Value<?>> options = new LinkedHashMap<>();

            final Set<String> scoped = values.stream().map(Value::getName).collect(Collectors.toSet());

            for (final Map.Entry<TemplateKey, Map<Set<Value<?>>, List<Value<?>>>> e : Iterables.filter(TcpSession.this.options.entrySet(),
                                                                                               e -> e.getKey().observationDomainId == this.observationDomainId)) {
                final Template template = TcpSession.this.templates.get(e.getKey());

                final Set<String> scopes = template.scopes.stream().map(Scope::getName).collect(Collectors.toSet());

                if (scoped.containsAll(scopes)) {
                    // Found option template where scoped fields is subset of actual data fields

                    final Set<Value<?>> scopeValues = values.stream()
                            .filter(s -> scopes.contains(s.getName()))
                            .collect(Collectors.toSet());

                    for (final Value<?> value : e.getValue().getOrDefault(scopeValues, Collections.emptyList())) {
                        options.put(value.getName(), value);
                    }
                }
            }

            return new ArrayList<>(options.values());
        }

