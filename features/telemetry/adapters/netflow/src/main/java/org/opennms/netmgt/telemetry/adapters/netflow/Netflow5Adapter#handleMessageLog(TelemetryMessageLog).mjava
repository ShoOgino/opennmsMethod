    @Override
    public void handleMessageLog(TelemetryMessageLog messageLog) {
        LOG.debug("Received {} telemetry messages", messageLog.getMessageList().size());

        final List<NetflowPacket> flowPackets = new LinkedList<>();
        try (Timer.Context ctx = logParsingTimer.time()) {
            for (TelemetryMessage eachMessage : messageLog.getMessageList()) {
                LOG.trace("Parsing packet: {}", eachMessage);
                final NetflowPacket flowPacket = parse(eachMessage);
                if (flowPacket != null) {
                    flowPackets.add(flowPacket);
                }
            }
        }
        packetsPerLogHistogram.update(flowPackets.size());

        final List<NetflowDocument> flowDocuments;
        try (Timer.Context ctx = logEnrichementTimer.time()) {
            LOG.debug("Converting {} packets to flows.", flowPackets.size());
            flowDocuments = flowPackets.stream()
                    .map(pkts -> {
                        final List<NetflowDocument> docs = convert(pkts);
                        // Track the number of flows per packet
                        flowsPerPacketHistogram.update(docs.size());
                        return docs;
                    })
                    .flatMap(docs -> docs.stream())
                    .collect(Collectors.toList());
            LOG.debug("Enriching {} flows.", flowDocuments.size());
            enrich(flowDocuments, messageLog);
        }

        try (Timer.Context ctx = logPersistingTimer.time()) {
            LOG.debug("Persisting {}.", flowDocuments.size());
            persist(flowDocuments);
            flowsPersistedMeter.mark(flowDocuments.size());
        } catch (Exception e) {
            LOG.error("An error occurred while handling incoming flow packets: {}", e.getMessage(), e);
            throw new RuntimeException(e);
        }

        LOG.debug("Completed processing {} telemetry messages into {} flows.",
                messageLog.getMessageList().size(), flowDocuments.size());
    }

