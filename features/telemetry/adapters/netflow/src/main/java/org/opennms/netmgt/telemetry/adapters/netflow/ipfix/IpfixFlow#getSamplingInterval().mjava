    @Override
    public Integer getSamplingInterval() {
        final Integer deprecatedSamplingInterval = first(
                getInt64(this.document, "samplingInterval"),
                getInt64(this.document, "samplerRandomInterval"))
                .map(Long::intValue).orElse(null);

        if (deprecatedSamplingInterval != null) {
            return deprecatedSamplingInterval;
        }

        final Integer selectorAlgorithm = getInt64(this.document, "selectorAlgorithm").map(Long::intValue).orElse(null);

        if (selectorAlgorithm != null) {
            switch (FlowSelectorAlgorithm.fromId(selectorAlgorithm)) {
                case Unassigned: {
                    return null;
                }
                case SystematicCountBasedSampling: {
                    final Integer samplingInterval =
                            getInt64(this.document, "samplingFlowInterval")
                            .map(Long::intValue).orElse(null);
                    final Integer samplingSpacing =
                            getInt64(this.document, "samplingFlowSpacing")
                            .map(Long::intValue).orElse(null);

                    // TODO: Compute something funny...
                    return null;
                }
                case SystematicTimeBasedSampling: {
                    final Integer flowSamplingTimeInterval =
                            getInt64(this.document, "flowSamplingTimeInterval")
                            .map(Long::intValue).orElse(null);
                    final Integer flowSamplingTimeSpacing =
                            getInt64(this.document, "flowSamplingTimeSpacing")
                            .map(Long::intValue).orElse(null);

                    // TODO: Compute something funny...
                    return null;
                }
                case RandomNoutOfNSampling: {
                    final Integer samplingSize =
                            getInt64(this.document, "samplingSize")
                            .map(Long::intValue).orElse(null);
                    final Integer samplingPopulation =
                            getInt64(this.document, "samplingPopulation")
                            .map(Long::intValue).orElse(null);

                    // TODO: Compute something funny...
                    return null;
                }
                case UniformProbabilisticSampling: {
                    final Double samplingProbability =
                            getDouble(this.document, "samplingProbability")
                            .orElse(null);

                    // TODO: Compute something funny...
                    return null;
                }
                case PropertyMatchFiltering: {
                    // Information Element Value Range?
                    return null;
                }
                case HashBasedFilteringUsingBOB: {
                    final Integer hashInitialiserValue =
                            getInt64(this.document, "hashInitialiserValue")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashFlowDomain =
                            getInt64(this.document, "hashFlowDomain")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMin =
                            getInt64(this.document, "hashSelectedRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMax =
                            getInt64(this.document, "hashSelectedRangeMax")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMin =
                            getInt64(this.document, "hashOutputRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMax =
                            getInt64(this.document, "hashOutputRangeMax")
                                    .map(Long::intValue).orElse(null);
                    // TODO: Compute something funny...
                    return null;
                }
                case HashBasedFilteringUsingIPSX: {
                    final Integer hashInitialiserValue =
                            getInt64(this.document, "hashInitialiserValue")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashFlowDomain =
                            getInt64(this.document, "hashFlowDomain")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMin =
                            getInt64(this.document, "hashSelectedRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMax =
                            getInt64(this.document, "hashSelectedRangeMax")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMin =
                            getInt64(this.document, "hashOutputRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMax =
                            getInt64(this.document, "hashOutputRangeMax")
                                    .map(Long::intValue).orElse(null);
                    // TODO: Compute something funny...
                    return null;
                }
                case HashBasedFilteringUsingCRC: {
                    final Integer hashInitialiserValue =
                            getInt64(this.document, "hashInitialiserValue")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashFlowDomain =
                            getInt64(this.document, "hashFlowDomain")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMin =
                            getInt64(this.document, "hashSelectedRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashSelectedRangeMax =
                            getInt64(this.document, "hashSelectedRangeMax")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMin =
                            getInt64(this.document, "hashOutputRangeMin")
                                    .map(Long::intValue).orElse(null);
                    final Integer hashOutputRangeMax =
                            getInt64(this.document, "hashOutputRangeMax")
                                    .map(Long::intValue).orElse(null);
                    // TODO: Compute something funny...
                    return null;
                }
                case FlowStateDependentIntermediateFlowSelectionProcess: {
                    // No agreed parameters?
                    return null;
                }
            }
        }
        return null;
    }

