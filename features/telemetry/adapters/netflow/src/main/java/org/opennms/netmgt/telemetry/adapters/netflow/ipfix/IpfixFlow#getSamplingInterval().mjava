    @Override
    public Double getSamplingInterval() {
        final Double deprecatedSamplingInterval = first(
                getInt64(this.document, "samplingInterval"),
                getInt64(this.document, "samplerRandomInterval"))
                .map(Long::doubleValue).orElse(null);

        if (deprecatedSamplingInterval != null) {
            return deprecatedSamplingInterval;
        }

        final Integer selectorAlgorithm = getInt64(this.document, "selectorAlgorithm").map(Long::intValue).orElse(null);

        if (selectorAlgorithm != null) {
            switch (selectorAlgorithm) {
                case 0: {
                    return null;
                }
                case 1: {
                    final Double samplingInterval =
                            getInt64(this.document, "samplingFlowInterval")
                                    .map(Long::doubleValue).orElse(1.0);
                    final Double samplingSpacing =
                            getInt64(this.document, "samplingFlowSpacing")
                                    .map(Long::doubleValue).orElse(0.0);

                    return (samplingInterval + samplingSpacing) / samplingInterval;
                }
                case 2: {
                    final Double flowSamplingTimeInterval =
                            getInt64(this.document, "flowSamplingTimeInterval")
                                    .map(Long::doubleValue).orElse(1.0);
                    final Double flowSamplingTimeSpacing =
                            getInt64(this.document, "flowSamplingTimeSpacing")
                                    .map(Long::doubleValue).orElse(0.0);

                    return (flowSamplingTimeInterval + flowSamplingTimeSpacing) / flowSamplingTimeInterval;
                }
                case 3: {
                    final Double samplingSize =
                            getInt64(this.document, "samplingSize")
                                    .map(Long::doubleValue).orElse(1.0); // n
                    final Double samplingPopulation =
                            getInt64(this.document, "samplingPopulation")
                                    .map(Long::doubleValue).orElse(1.0); // N

                    return samplingPopulation / samplingSize;
                }
                case 4: {
                    final Double samplingProbability =
                            getDouble(this.document, "samplingProbability")
                                    .orElse(1.0);

                    return 1.0 / samplingProbability;
                }
                case 5:
                case 6:
                case 7: {
                    final UnsignedLong hashSelectedRangeMin =
                            getInt64(this.document, "hashSelectedRangeMin")
                                    .map(UnsignedLong::fromLongBits).orElse(UnsignedLong.ZERO);
                    final UnsignedLong hashSelectedRangeMax =
                            getInt64(this.document, "hashSelectedRangeMax")
                                    .map(UnsignedLong::fromLongBits).orElse(UnsignedLong.MAX_VALUE);
                    final UnsignedLong hashOutputRangeMin =
                            getInt64(this.document, "hashOutputRangeMin")
                                    .map(UnsignedLong::fromLongBits).orElse(UnsignedLong.ZERO);
                    final UnsignedLong hashOutputRangeMax =
                            getInt64(this.document, "hashOutputRangeMax")
                                    .map(UnsignedLong::fromLongBits).orElse(UnsignedLong.MAX_VALUE);

                    return (hashOutputRangeMax.minus(hashOutputRangeMin)).dividedBy(hashSelectedRangeMax.minus(hashSelectedRangeMin)).doubleValue();
                }
                case 8:
                case 9:
                default: {
                    LOG.warn("Unsupported sampling algorithm: {}", selectorAlgorithm);
                    return Double.NaN;
                }
            }
        }
        return 1.0;
    }

