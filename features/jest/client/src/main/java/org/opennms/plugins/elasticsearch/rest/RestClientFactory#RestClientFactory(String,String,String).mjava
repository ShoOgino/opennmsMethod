	/**
	 * Create a RestClientFactory.
	 *
	 * @param elasticSearchURL Elasticsearch URL, either a single URL or
	 *   multiple URLs that are comma-separated without spaces
	 * @param globalElasticUser Optional HTTP username
	 * @param globalElasticPassword Optional HTTP password
	 */
	public RestClientFactory(final String elasticSearchURL, final String globalElasticUser, final String globalElasticPassword ) throws MalformedURLException {
		final List<String> urls = parseUrl(elasticSearchURL);
		final String user = globalElasticUser != null && !globalElasticUser.isEmpty() ? globalElasticUser : null;
		final String password = globalElasticPassword != null && !globalElasticPassword.isEmpty() ? globalElasticPassword : null;

		// Ensure urls is set
		if (urls.isEmpty()) {
			throw new IllegalArgumentException("No urls have been provided");
		}

		// TODO MVR Fix the following hack:
		// This is a hack, due to our osgi-jetty-bridge: The annotation at the NetflowDocument
		// living in the api module (on the jetty side) are not accessible directly (only as proxy) by the Gson lirary
		// living in the osgi container (osgi-jest-complete module) and therefore @SerializedName annotations don't work.
		// So we instantiate a custom gson with a custom field name policy.
		final Gson gson = new GsonBuilder()
				.setDateFormat(AbstractJestClient.ELASTIC_SEARCH_DATE_FORMAT)
				.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
				.create();

		// If multiple URLs are specified in a comma-separated string, split them up
		clientConfigBuilder = new HttpClientConfig.Builder(urls)
					.multiThreaded(true)
					.defaultMaxTotalConnectionPerRoute(DEFAULT_MAX_TOTAL_CONNECTION_PER_ROUTE)
					.maxTotalConnection(DEFAULT_MAX_TOTAL_CONNECTION)
					.gson(gson);

		// Apply optional credentials
		if (user != null && password != null) {
			final URL targetUrl = new URL(urls.get(0));
			if (urls.size() > 1) {
				LOG.warn("Credentials have been defined, but multiple target hosts were found. " +
						"Each host will use the same credentials. Preemptive auth is only enabled for host {}", urls.get(0));
			}

			clientConfigBuilder.defaultCredentials(user, password);
			clientConfigBuilder.setPreemptiveAuth(new HttpHost(targetUrl.getHost(), targetUrl.getPort(), targetUrl.getProtocol()));
		}
	}

