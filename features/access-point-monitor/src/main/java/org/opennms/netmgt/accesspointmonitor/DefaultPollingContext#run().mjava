    @Override
    @Transactional
    public void run() {
        // Determine the list of interfaces to poll at runtime
        OnmsIpInterfaceList ifaces = getInterfaceList();

        // If the list of interfaces is empty, print a warning message
        if (ifaces.getIpInterfaces().isEmpty()) {
            LOG.warn("Package '{}' was scheduled, but no interfaces were matched.", getPackage().getName());
        }

        // Get the complete list of APs that we are responsible for polling
        OnmsAccessPointCollection apsDown = m_accessPointDao.findByPackage(getPackage().getName());
        LOG.debug("Found {} APs in package '{}'", apsDown.size(), getPackage().getName());

        // Keep track of all APs that we've confirmed to be ONLINE
        OnmsAccessPointCollection apsUp = new OnmsAccessPointCollection();

        Set<Callable<OnmsAccessPointCollection>> callables = new HashSet<Callable<OnmsAccessPointCollection>>();

        // Iterate over all of the matched interfaces
        for (final OnmsIpInterface iface : ifaces.getIpInterfaces()) {
            // Create a new instance of the poller
            final AccessPointPoller p = m_package.getPoller(m_pollerConfig.getMonitors());
            p.setInterfaceToPoll(iface);
            p.setAccessPointDao(m_accessPointDao);
            p.setPackage(m_package);
            p.setPropertyMap(m_parameters);

            // Schedule the poller for execution
            callables.add(p);
        }

        boolean succesfullyPolledAController = false;

        try {
            if (m_pool == null) {
                LOG.warn("run() called, but no thread pool has been initialized.  Calling init()");
                init();
            }

            // Invoke all of the pollers using the thread pool
            List<Future<OnmsAccessPointCollection>> futures = m_pool.invokeAll(callables);

            // Gather the list of APs that are ONLINE
            for (Future<OnmsAccessPointCollection> future : futures) {
                try {
                    apsUp.addAll(future.get().getObjects());
                    succesfullyPolledAController = true;
                } catch (ExecutionException e) {
                    LOG.error("An error occurred while polling", e);
                }
            }
        } catch (InterruptedException e) {
            LOG.error("I was interrupted", e);
        }

        // Remove the APs from the list that are ONLINE
        apsDown.removeAll(apsUp.getObjects());

        LOG.debug("({}) APs Online, ({}) APs offline in package '{}'", apsUp.size(), apsDown.size(), getPackage().getName());

        if (!succesfullyPolledAController) {
            LOG.warn("Failed to poll at least one controller in the package '{}'", getPackage().getName());
        }

        updateApStatus(apsUp, apsDown);

        // Reschedule the service
        LOG.debug("Re-scheduling the package '{}' in {}", getPackage().getName(), m_interval);
        m_scheduler.schedule(m_interval, getReadyRunnable());
    }

