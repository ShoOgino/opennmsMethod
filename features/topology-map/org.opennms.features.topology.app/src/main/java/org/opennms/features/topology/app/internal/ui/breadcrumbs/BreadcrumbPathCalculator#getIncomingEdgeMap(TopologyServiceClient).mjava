    static Map<VertexRef, EdgeRef> getIncomingEdgeMap(TopologyServiceClient topologyServiceClient) {
        // Convert to JUNG graph
        // We build one big graph out of all graph providers in order to determine the shortest path between each vertex
        // when we want to calculate the SHORTEST_PATH_TO_ROOT
        final DirectedSparseGraph<VertexRef, EdgeRef> sparseGraph = new DirectedSparseGraph<>();
        topologyServiceClient.getGraphProviders().stream()
                .map(eachProvider -> eachProvider.getCurrentGraph())
                .forEach(eachGraph -> {
                    for (Vertex eachVertex : eachGraph.getVertices()) {
                        sparseGraph.addVertex(eachVertex);
                    }
                    for (EdgeRef eachEdge : eachGraph.getEdges()) {
                        sparseGraph.addEdge(eachEdge, ((Edge) eachEdge).getSource().getVertex(), ((Edge) eachEdge).getTarget().getVertex());
                    }
                });

        // Link the layers
        final IdGenerator idGenerator = new IdGenerator();
        sparseGraph.getVertices().forEach(eachVertex -> {
            topologyServiceClient.getOppositeVertices(eachVertex).forEach(oppositeVertex -> {
                sparseGraph.addEdge(new AbstractEdge("$$outer-space$$", "" + idGenerator.nextId(), eachVertex, oppositeVertex), eachVertex, oppositeVertex);
            });
        });

        // Create dummy root
        sparseGraph.addVertex(rootVertex);
        for (Vertex eachVertex : topologyServiceClient.getDefaultGraphProvider().getCurrentGraph().getVertices()) {
            sparseGraph.addEdge(new AbstractEdge("$$outer-space$$", "" + idGenerator.nextId(), rootVertex, eachVertex), rootVertex, eachVertex);
        }

        // Build shortest path for graph
        final UnweightedShortestPath<VertexRef, EdgeRef> shortestPath = new UnweightedShortestPath<>(sparseGraph);
        Map<VertexRef, EdgeRef> incomingEdgeMap = shortestPath.getIncomingEdgeMap(rootVertex);
        return incomingEdgeMap;
    }

