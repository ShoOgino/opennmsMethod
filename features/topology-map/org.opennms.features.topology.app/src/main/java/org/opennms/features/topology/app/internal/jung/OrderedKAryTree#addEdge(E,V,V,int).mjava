    /**
     * Adds the specified {@code child} vertex and edge {@code e} to the graph
     * with the specified parent vertex {@code parent}.  If {@code index} is 
     * greater than or equal to 0, then the child is placed at position
     * {@code index}; if it is less than 0, the child is placed at the lowest
     * available position; if it is greater than or equal to the order of this
     * tree, an exception is thrown.
     * 
     * @see edu.uci.ics.jung.graph.Graph#addEdge(java.lang.Object, java.lang.Object, java.lang.Object)
     */
	public boolean addEdge(E e, V parent, V child, int index) 
    {
        if (e == null || child == null || parent == null)
            throw new IllegalArgumentException("Inputs may not be null");
    	if (!containsVertex(parent))
    		throw new IllegalArgumentException("Tree must already " +
    				"include parent: " + parent);
    	if (containsVertex(child))
    		throw new IllegalArgumentException("Tree must not already " +
    				"include child: " + child);
		if (parent.equals(child))
			throw new IllegalArgumentException("Input vertices must be distinct");
		if (index >= order)
		    throw new IllegalArgumentException("'index' must be in [0, [order-1]]");
    	
    	Pair<V> endpoints = new Pair<V>(parent, child);
    	if (containsEdge(e))
    		if (!endpoints.equals(edge_vpairs.get(e)))
    			throw new IllegalArgumentException("Tree already includes edge" + 
    					e + " with different endpoints " + edge_vpairs.get(e));
    		else
    			return false;

    	VertexData parent_data = vertex_data.get(parent);
    	List<E> outedges = parent_data.child_edges;
    	
    	if (outedges == null)
    	    outedges = new ArrayList<E>(this.order);

    	boolean edge_placed = false;
    	if (index >= 0)
    		if (outedges.get(index) != null)
        		throw new IllegalArgumentException("Parent " + parent + 
        				" already has a child at index " + index + " in this tree");
    		else
    			outedges.set(index, e);
    	for (int i = 0; i < order; i++)
    	{
    		if (outedges.get(i) == null)
    		{
    			outedges.set(i, e);
    			edge_placed = true;
    			break;
    		}
    	}
    	if (!edge_placed)
    		throw new IllegalArgumentException("Parent " + parent + " already" +
    				" has " + order + " children in this tree");
    	
    	// initialize VertexData for child; leave child's child_edges null for now
    	VertexData child_data = new VertexData(e, parent_data.depth + 1);
    	vertex_data.put(child, child_data);
    	
    	height = child_data.depth > height ? child_data.depth : height;
    	edge_vpairs.put(e, endpoints);
    	
    	return true;
    }

