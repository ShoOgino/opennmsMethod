    /**
     * Centers the view on a selection
     */
    public void centerSelection() {
        
        final D3 selection = D3.d3().selectAll(GWTVertex.SELECTED_VERTEX_CLASS_NAME);
        
        SVGMatrix viewportMatrix = getSVGViewPort().getCTM();
        int svgWidth = getSVGElement().getBoundingClientRect().getWidth();
        int svgHeight = getSVGElement().getBoundingClientRect().getHeight();

        double svgCenterX = Math.abs(getSVGElement().getCTM().getE() - svgWidth/2);
        double svgCenterY = Math.abs(getSVGElement().getCTM().getF() - svgHeight/2);
        
        final BoundingRect rect = new BoundingRect();
        
        selection.each(new Handler<GWTVertex>() {

            @Override
            public void call(GWTVertex vertex, int index) {
                SVGGElement vertexElem = D3.d3().getElement(selection, index).cast();
                
                SVGMatrix vertexCTM = vertexElem.getCTM();
                
                double vertexCenterX = vertexCTM.getE();
                double vertexCenterY = vertexCTM.getF();
                
                rect.addPoint(new Point(vertexCenterX, vertexCenterY));
                rect.addClientRect(vertexElem.getBoundingClientRect());
                
            }
        });
        
        double scaleFactor = viewportMatrix.getA();
        double percent = 100 / (scaleFactor * 100);
        double translateX = (svgCenterX - rect.getCenterX()) * percent;
        double translateY = (svgCenterY - rect.getCenterY()) * percent;
        
        D3.d3().select(getSVGViewPort()).attr("transform", matrixTransform(viewportMatrix.translate(translateX, translateY)));
        
        
        if(rect.getWidth() > svgWidth) {
            setMapScale( svgWidth / rect.getWidth() );
        }else if(rect.getHeight() > svgHeight) {
            setMapScale( svgHeight / rect.getHeight() );
        }
        
    }

