    protected static Func<String, GWTEdge> createPath() {
        return new Func<String, GWTEdge>(){

            @Override
            public String call(GWTEdge edge, int index) {
                final GWTVertex source = edge.getSource();
                final GWTVertex target = edge.getTarget();

                // Find the middle point of the line connecting the source and target vertices
                double sx = (source.getX() + target.getX()) / 2d;
                double sy = (source.getY() + target.getY()) / 2d;

                // Find the length of the line connecting p1 and p2
                double dy = (double)(target.getY() - source.getY());
                double dx = (double)(target.getX() - source.getX());
                double len = Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2));

                // Calculate the sign (i.e. direction) and distance we'll use to project to the control point
                double pathSign = getPathSign(edge.getLinkNum(), edge.getLinkCount());
                double pathMultiplier = getPathMultiplier(edge.getLinkNum(), edge.getLinkCount());
                // Use the largest offset from the source and target vertices
                int pathOffset = Math.max(edge.getSource().getEdgePathOffset(), edge.getTarget().getEdgePathOffset());
                // Slowly increase the distance as the points get further apart (this is a logistics growth model)
                double lengthMultiplier = Math.max(3 / (1 + 250*Math.exp((-1/200d)*len)), 1);
                double effectiveDistance = pathMultiplier * lengthMultiplier * pathOffset;

                // Now calculate the coordinates (qx,qy) of our control point
                double qx, qy;
                if (dy == 0) {
                    // Both vertices are on the same horizontal line, project out vertically
                    qx = sx;
                    qy = sy + pathSign * effectiveDistance;
                } else if (dx == 0) {
                    // Both vertices are on the same vertical line, project out horizontally
                    qx = sx + pathSign * effectiveDistance;
                    qy = sy;
                } else {
                    // Calculate the slope and intercept of the line that is perpendicular to the
                    // line connecting both vertices and passes through the middle point (sx, sy)
                    double m = dy / dx;
                    double invm = -1/m; // The conjugate slope is perpendicular
                    double b = sy - invm * sx;
                    // Now calculate the coordinates of the point that is on the line
                    // we found above, and *distance* units away from (sx, sy)
                    qx = sx + pathSign * Math.sqrt(Math.pow(effectiveDistance, 2) / (1 + Math.pow(invm, 2)));
                    qy = invm * qx + b;
                }

                return "M" + source.getX() + " " + source.getY() + " Q " + qx + " " + qy +
                            " " + target.getX() + " " + target.getY();
            }

        };
    }

