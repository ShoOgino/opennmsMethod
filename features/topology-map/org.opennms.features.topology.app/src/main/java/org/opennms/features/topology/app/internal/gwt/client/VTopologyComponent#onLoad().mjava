    @SuppressWarnings("serial")
    @Override
	protected void onLoad() {
		super.onLoad();
		consoleLog("onLoad");
		ServiceRegistry serviceRegistry = new DefaultServiceRegistry();
		serviceRegistry.register(vertexClickHandler(), new HashMap<String, String>(){{ put("handlerType", "vertexClick"); }}, Handler.class);
		serviceRegistry.register(vertexDblClickHandler(), new HashMap<String, String>(){{ put("handlerType", "vertexDblClick"); }}, Handler.class);
		serviceRegistry.register(vertexContextMenuHandler(), new HashMap<String, String>(){{ put("handlerType", "vertexContextMenu"); }}, Handler.class);
		serviceRegistry.register(vertexTooltipHandler(), new HashMap<String, String>(){{ put("handlerType", "vertexTooltip"); }}, Handler.class);
		
		serviceRegistry.register(edgeContextHandler(), new HashMap<String, String>(){{ put("handlerType", "edgeContextMenu"); }}, Handler.class);
		serviceRegistry.register(edgeTooltipHandler(), new HashMap<String, String>(){{ put("handlerType", "edgeTooltip"); }}, Handler.class);
		serviceRegistry.register(edgeClickHandler(), new HashMap<String, String>(){{ put("handlerType", "edgeClick"); }}, Handler.class);
		
		
		m_topologyView = new TopologyViewImpl();
		m_topologyView.setPresenter(this);
		m_componentHolder.setSize("100%", "100%");
		m_componentHolder.add(m_topologyView.asWidget());
		
		m_svgDragHandlerManager = new DragHandlerManager();
		m_svgDragHandlerManager.addDragBehaviorHandler(PanHandler.DRAG_BEHAVIOR_KEY, new PanHandler(this, serviceRegistry));
		m_svgDragHandlerManager.addDragBehaviorHandler(MarqueeSelectHandler.DRAG_BEHAVIOR_KEY, new MarqueeSelectHandler(this, m_topologyView));
		m_svgDragHandlerManager.setCurrentDragHandler(PanHandler.DRAG_BEHAVIOR_KEY);
		D3 svgElement = D3.d3().select(m_topologyView.getSVGElement());
        setupDragBehavior(m_topologyView.getSVGElement(), m_svgDragHandlerManager);
//        svgElement.on("dblclick", new Handler<Void>() {
//
//            @Override
//            public void call(Void t, int index) {
//                JsArrayInteger pos = D3.getMouse(m_topologyView.getSVGElement());
//                onBackgroundDoubleClick(m_topologyView.getPoint(pos.get(0), pos.get(1)));
//            }
//
//		})
		svgElement.on(D3Events.CONTEXT_MENU.event(), new Handler<Void>() {
			@Override
			public void call(Void aVoid, int index) {
				NativeEvent event = D3.getEvent();
				if(D3.eventDefaultPrevented()) {
					return;
				}
				if (!isMarqueeSelected()) {
					EventTarget target = event.getEventTarget();
					if (target.equals(m_topologyView.getSVGElement())) {
						onContextMenu(null, event.getClientX(), event.getClientY(), "map");
					}
				}
				event.preventDefault();
				event.stopPropagation();
			}
		});

		svgElement.on(D3Events.CLICK.event(), new Handler<Void>() {
			@Override
			public void call(Void aVoid, int index) {
				NativeEvent event = D3.getEvent();
				if (D3.eventDefaultPrevented()) {
					return;
				}
				if (!isMarqueeSelected()
					&& event.getButton() == NativeEvent.BUTTON_LEFT
						&& event.getEventTarget().equals(m_topologyView.getSVGElement())) {
					onBackgroundClick();
				}
				event.preventDefault();
				event.stopPropagation();
			}
		});

		svgElement.on(D3Events.MOUSE_WHEEL.event(), new Handler<Void>() {

            @Override
            public void call(Void t, int index) {
                double scrollVal = (double)D3.getEvent().getMouseWheelVelocityY()/ 30.0;
                SVGPoint centerPos = m_topologyView.getCenterPos(m_graph.getBoundingBox());
                onMouseWheel(scrollVal, (int)centerPos.getX(), (int)centerPos.getY());
            }
            
		});
		
		
		D3Behavior dragBehavior = new D3Behavior() {

			@Override
			public D3 run(D3 selection) {
				D3Drag drag = D3.getDragBehavior();
				drag.on(D3Events.DRAG_START.event(), vertexDragStartHandler());
				drag.on(D3Events.DRAG.event(), vertexDragHandler());
				drag.on(D3Events.DRAG_END.event(), vertexDragEndHandler());

				selection.call(drag);
				return selection;
			}

		};

		m_graphDrawer = new SVGGraphDrawer(dragBehavior, serviceRegistry);
		m_graphDrawerNoTransition = new SVGGraphDrawerNoTransition(dragBehavior, serviceRegistry);
		
		setTopologyViewRenderer(m_graphDrawer);

        m_windowResizeRegistration = Window.addResizeHandler(new ResizeHandler() {
			// Each size change will invoke a onResize(ResizeEvent).
			// This has a huge impact on performance.
			// Therefore the call is wrapped by a timer with a certain delay
			// to wait before making the request.
			final Timer resizeTimer = new Timer() {
				@Override
				public void run() {
					sendPhysicalDimensions();
				}
			};

            @Override
            public void onResize(ResizeEvent resizeEvent) {
				resizeTimer.schedule(250);
            }
        });
    }

