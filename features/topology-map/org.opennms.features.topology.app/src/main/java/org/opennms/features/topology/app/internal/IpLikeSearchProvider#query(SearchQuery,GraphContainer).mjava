    /**
     * This method processes the <SearchQuery> that the user has typed and returns a <SearchResult> list
     * of matching IP addresses as well as the query string itself, which is collapsible, to act
     * as a subnet container.
     * 
     */
    @Override
    public List<SearchResult> query(SearchQuery searchQuery, GraphContainer graphContainer) {
    	LOG.info("SearchProvider->query: called with search query: '{}'", searchQuery);

        List<SearchResult> results = new ArrayList<SearchResult>();
        
		String queryString = searchQuery.getQueryString();
		
		if (!isIpLikeQuery(queryString)) {
			LOG.debug("SearchProvider->query: query not IPLIKE compatible.");
			return results;
		}
    	
    	CriteriaBuilder bldr = new CriteriaBuilder(OnmsIpInterface.class);
    	
		bldr.iplike("ipAddress", queryString).orderBy("ipAddress", true);
		Criteria dbQueryCriteria = bldr.toCriteria();
		List<OnmsIpInterface> ips;
		
		//Here to catch query exceptions and avoid unnecessary exception messages in the Vaadin UI
		//Mainly do to not having yet found the perfect iplike regex that supports IPLIKE syntax 
		//for both IPv4 and IPv6 IPLIKE expressions in the isIpLikeQuery method.  The current Pattern
		//test currently fails not catching octets ending in '-' such as '10.7-.*.*' and only supports
		//IPv4 addresses.  This just lets us fail to the underlying IPLIKE stored procedure.  The IPLIKE
		//Utils class might be a good place to have a static method that validates the query string
		//since it seems to do something very similar in its matches method.
        try {
			ips = ipInterfaceProvider.findMatching(dbQueryCriteria);
            if (ips.size() == 0) {
                return results;
            } else {
                if (isIpLikeQuery(queryString)) {
                    LOG.debug("SearchProvider->query: adding IPLIKE search spec '{}' to the search results.", queryString);
                    SearchResult searchResult = new SearchResult(getSearchProviderNamespace(), queryString, queryString,
							queryString, SearchResult.COLLAPSIBLE, !SearchResult.COLLAPSED);
                    results.add(searchResult);
                }
            }

            Set<String> ipAddrs = new HashSet<String>();
            
            LOG.info("SearchProvider->query: creating IP address set.");
            for (OnmsIpInterface ip : ips) {
                String hostAddress = ip.getIpAddress().getHostAddress();
                LOG.debug("SearchProvider->query: adding '{}' to set of IPs.", hostAddress);
                ipAddrs.add(hostAddress);
            }
            
            LOG.info("SearchProvider->query: building search result from set of IPs.");
            IPLOOP: for (String ip : ipAddrs) {
                
                if (findCriterion(ip, graphContainer) != null) {
                    continue IPLOOP;

                } else {
                    results.add(createSearchResult(ip, queryString));

                }
            }
            LOG.info("SearchProvider->query: found: '{}' IP interfaces.", ips.size());
            
        } catch (Exception e) {
            LOG.error("SearchProvider-query: caught exception during iplike query: {}", e);
            
        }
		
		LOG.info("SearchProvider->query: built search result with {} results.", results.size());
		
        return results;
    }

