        private boolean loadVertexHopCriteria(VaadinRequest request) {
            final String nodeIds = request.getParameter(PARAMETER_FOCUS_NODES);
            String vertexIdInFocus = request.getParameter(TopologyLinkBuilder.PARAMETER_FOCUS_VERTICES);
            if (nodeIds != null && vertexIdInFocus != null) {
                LOG.warn("Usage of parameter '{1}' and '{2}'. This is not supported. Skipping parameter '{2}'", PARAMETER_FOCUS_NODES, TopologyLinkBuilder.PARAMETER_FOCUS_VERTICES);
            }
            if (nodeIds != null) {
                LOG.warn("Usage of deprecated parameter '{}'. Please use '{}' instead.", PARAMETER_FOCUS_NODES, TopologyLinkBuilder.PARAMETER_FOCUS_VERTICES);
                vertexIdInFocus = nodeIds;
            }
            if (vertexIdInFocus != null) {
                // Build the VertexRef elements
                final TreeSet<VertexRef> refs = new TreeSet<>();
                for (String vertexId : vertexIdInFocus.split(",")) {
                    String namespace = m_graphContainer.getTopologyServiceClient().getNamespace();
                    Vertex vertex = m_graphContainer.getTopologyServiceClient().getVertex(namespace, vertexId);
                    if (vertex == null) {
                        LOG.warn("Vertex with namespace {} and id {} do not exist in the selected Graph Provider {}",
                                namespace, vertexId, m_graphContainer.getTopologyServiceClient().getClass().getSimpleName());
                    } else {
                        refs.add(vertex);
                    }
                }
                // We have to update the vertices in focus (in our case only nodes) only if the focus has changed
                VertexHopCriteria criteria = CriteriaUtils.getWrappedVertexHopCriteria(m_graphContainer);
                if (!criteria.getVertices().equals(refs)) {
                    m_graphContainer.clearCriteria();
                    refs.forEach(vertexRef -> m_graphContainer.addCriteria(new DefaultVertexHopCriteria(vertexRef)));
                    m_graphContainer.setSemanticZoomLevel(1);
                }
                return true;
            }
            return false;
        }

