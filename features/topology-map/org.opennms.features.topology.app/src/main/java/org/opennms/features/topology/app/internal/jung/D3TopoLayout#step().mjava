    @Override
    public void step() {

        double currentForce;

        //guass-seidel relaxation for links
        for (E e : getGraph().getEdges()) {
            Pair<V> endPoints = getGraph().getEndpoints(e);
            VertexData srcVertexData = getVertexData(endPoints.getFirst());
            VertexData targetVertexData = getVertexData(endPoints.getSecond());

            double xDelta = targetVertexData.getX() - srcVertexData.getX();
            double yDelta = targetVertexData.getY() - srcVertexData.getY();
            double l = xDelta * xDelta + yDelta * yDelta;
            if (l != 0) {
                EdgeData edgeData = getEdgeData(e);
                double lSqrt = Math.sqrt(l);
                double distance = m_alpha * edgeData.getStrength() * (lSqrt - edgeData.getDistance()) / lSqrt;
                //double distance = edgeData.getStrength() * (lSqrt - edgeData.getDistance()) / lSqrt;

                xDelta *= distance;
                yDelta *= distance;

                currentForce = (double)srcVertexData.getWeight() / (double)(targetVertexData.getWeight() + srcVertexData.getWeight());
                //currentForce = 0.5;
                targetVertexData.offset(-(xDelta * currentForce), -(yDelta * currentForce));

                currentForce = 1 - currentForce;
                srcVertexData.offset(xDelta * currentForce, yDelta * currentForce);
            }

        }

        //Apply gravity forces
        currentForce = m_alpha * getGravity();
        if(currentForce != 0){
            double centerX = getSize().getWidth() / 2;
            double centerY = getSize().getHeight() / 2;

            for (V v : getGraph().getVertices()) {
                VertexData vData = getVertexData(v);
                vData.offset((centerX - vData.getX()) * currentForce, (centerY - vData.getY()) * currentForce);
            }
            
        }

        //Compute quad tree center of mass and apply charge force
        if(getDefaultCharge() != 0){

            for(V v1 : getGraph().getVertices()) {
                VertexData vData1 = getVertexData(v1); 
                for(V v2 : getGraph().getVertices()) {
                    VertexData vData2 = getVertexData(v2);
                    
                    double dx = vData2.getX() - vData1.getX();
                    double dy = vData2.getY() - vData1.getY();
                    double d = dx*dx + dy*dy;
                    
                    if (d > 0) {
                        double k = m_alpha * vData2.getCharge() / d;
                        double px = dx*k;
                        double py = dy*k;
                        
                        //vData1.offsetPrevious(px, py);
                        vData1.offset(px, py);
                    } else {
                        //vData1.offsetPrevious(0.5-Math.random(), 0.5-Math.random());
                        vData1.offset(0.5-Math.random(), 0.5-Math.random());
                    }
                    
                }
            }
        }
        
        
        // position verlet integration
        for(V v : getGraph().getVertices()) {
            VertexData vData = getVertexData(v);
            double tempX = vData.getX();
            double tempY = vData.getY();
            double x = vData.getX() + (vData.getPrevious().getX() - vData.getX())*getFriction();
            double y = vData.getY() + (vData.getPrevious().getY() - vData.getY())*getFriction();
            vData.setLocation(x, y);
            vData.setPrevious(tempX, tempY);
            Point2D location = transform(v);
            location.setLocation(vData.getX(), vData.getY());
        }
        
        m_alpha *= 0.99;


    }

