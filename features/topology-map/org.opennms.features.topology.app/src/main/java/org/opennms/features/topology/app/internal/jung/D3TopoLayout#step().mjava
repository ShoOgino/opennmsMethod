    @Override
    public void step() {

        double currentForce;

        //guass-seidel relaxation for links
        for (E e : getGraph().getEdges()) {
            Pair<V> endPoints = getGraph().getEndpoints(e);
            VertexData srcVertexData = getVertexData(endPoints.getFirst());
            VertexData targetVertexData = getVertexData(endPoints.getSecond());

            double xDelta = targetVertexData.getX() - srcVertexData.getX();
            double yDelta = targetVertexData.getY() - srcVertexData.getY();
            double l = xDelta * xDelta + yDelta * yDelta;
            if (l != 0) {
                EdgeData edgeData = getEdgeData(e);
                double lSqrt = Math.sqrt(l);
                double distance = m_alpha * edgeData.getStrength() * (lSqrt - edgeData.getDistance()) / lSqrt;

                xDelta *= distance;
                yDelta *= distance;

                currentForce = srcVertexData.getWeight() / (targetVertexData.getWeight() + srcVertexData.getWeight());
                targetVertexData.offset(-(xDelta * currentForce), -(yDelta * currentForce));

                currentForce = 1 - currentForce;
                srcVertexData.offset(xDelta * currentForce, yDelta * currentForce);

            }

        }

        //Apply gravity forces
        currentForce = m_alpha * getGravity();
        if(currentForce != 0){
            double centerX = getSize().getWidth() / 2;
            double centerY = getSize().getHeight() / 2;

            for (V v : getGraph().getVertices()) {
                VertexData vData = getVertexData(v);
                vData.offset((centerX - vData.getX()) * currentForce, (centerY - vData.getY()) * currentForce);
            }
            
        }

        //Compute quad tree center of mass and apply charge force
        if(getDefaultCharge() != 0){
            
            BoundingBox bounds = new BoundingBox();
            for(V v : getGraph().getVertices()) {
                VertexData vData = getVertexData(v);
                BoundingBox rounded = new BoundingBox((int)vData.getX(), (int)vData.getY(), 1, 1);
                bounds.addBoundingbox(rounded);
            }
            
            QuadTree<VertexData> quadTree = new QuadTree<VertexData>(bounds);
            for(V v : getGraph().getVertices()) {
                VertexData vData = getVertexData(v);
                quadTree.insert(vData, vData.getCharge(), vData);
            }

            for(V v: getGraph().getVertices()) {
                final VertexData vData = getVertexData(v);
                quadTree.visit(new Visitor<VertexData>() {

                    @Override
                    public boolean visitNode(Node<VertexData> n) {
                        
                        if (n.isLeaf() && vData == n.getValue()) return true;
                        
                        double dx = n.getX() - vData.getX();
                        double dy = n.getY() - vData.getY();
                        double dw = n.getWidth();
                        double dSquared = dx*dx + dy*dy;

                        if (dw*dw/m_thetaSquared < dSquared) {
                            double force = n.getCharge() / dSquared;
                            vData.offset(- (dx*force), - (dy*force));
                            return true;
                        }
                        
                        if (n.isLeaf()) {
                            double force = n.getCharge() / dSquared;
                            vData.offset(- (dx*force), - (dy*force));
                            return true;
                        }
                        
                        return false;
                        
                    }
                    
                });
            }
        }
        
        m_alpha *= 0.99;


    }

