    @Override
    public Graph getGraph(String metaTopologyId, String namespace, Criteria[] criteria, int semanticZoomLevel) {
        Objects.requireNonNull(metaTopologyId);
        Objects.requireNonNull(namespace);
        Objects.requireNonNull(metaTopologyId);
        Objects.requireNonNull(criteria);
        if (semanticZoomLevel < 0) {
            LOG.warn("Semantic Zoom Level was {}. Only values >= 0 are allowed, forcing it to be 1", semanticZoomLevel);
            semanticZoomLevel = 0;
        }
        final GraphProvider graphProvider = getGraphProvider(metaTopologyId, namespace);
        final CollapsibleGraph collapsibleGraph = new CollapsibleGraph(graphProvider.getCurrentGraph());

        // Determine visible vertices and edges
        final Collection<Vertex> displayVertices = collapsibleGraph.getVertices(semanticZoomLevel, criteria);
        final Collection<Edge> displayEdges = collapsibleGraph.getEdges(criteria);

        // Create graph object
        final DefaultGraph uiGraph = new DefaultGraph(displayVertices, displayEdges);

        // Calculate status
        final StatusProvider vertexStatusProvider = serviceLocator != null ? findVertexStatusProvider(graphProvider) : null;
        final EdgeStatusProvider edgeStatusProvider = serviceLocator != null ? findEdgeStatusProvider(graphProvider) : null;
        if (vertexStatusProvider != null) {
            uiGraph.setVertexStatus(vertexStatusProvider.getStatusForVertices(collapsibleGraph, new ArrayList<>(displayVertices), criteria));
        }
        if(edgeStatusProvider != null) {
            uiGraph.setEdgeStatus(edgeStatusProvider.getStatusForEdges(collapsibleGraph, new ArrayList<>(uiGraph.getDisplayEdges()), criteria));
        }
        return uiGraph;
    }

