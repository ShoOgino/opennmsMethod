	@Test
	public void testABunchOfGroupOperations() {

		m_topologyProvider.resetContainer();

		Vertex vertex1 = m_topologyProvider.addVertex(0, 0);
		Vertex group1 = m_topologyProvider.addGroup("NEW GROUP", null);

		GraphContainer graphContainer = EasyMock.createMock(GraphContainer.class);

		EasyMock.expect(graphContainer.getBaseTopology()).andReturn(m_topologyProvider).anyTimes();
		SelectionManager selectionManager = EasyMock.createNiceMock(SelectionManager.class);
		EasyMock.expect(selectionManager.isVertexRefSelected(EasyMock.anyObject(VertexRef.class))).andReturn(false).anyTimes();
		EasyMock.expect(graphContainer.getSelectionManager()).andReturn(selectionManager).anyTimes();
		graphContainer.redoLayout();
		EasyMock.expectLastCall().anyTimes();

		EasyMock.replay(graphContainer);
		EasyMock.replay(selectionManager);

		Collection<Vertex> vertices = m_topologyProvider.getVertices();
		assertEquals(2, vertices.size());
		assertEquals(0, m_topologyProvider.getChildren(group1).size());

		{
			AddVertexToGroupOperation operation = new AddVertexToGroupOperation();
			OperationContext context = getOperationContext(graphContainer);
			// Execute the operation on the single vertex
			operation.execute(Collections.singletonList((VertexRef)vertex1), context);

			// Even though we have executed the operation, it is waiting on a Window
			// operation to commit the change so make sure the vertex hasn't been
			// added yet.
			vertices = m_topologyProvider.getVertices();
			assertEquals(2, vertices.size());
			assertEquals(0, m_topologyProvider.getChildren(group1).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Grab the window, put a value into the form field, and commit the form to complete
			// the operation.
			UI window = context.getMainWindow();
			assertEquals(1, window.getWindows().size());
			Window prompt = window.getWindows().iterator().next();

			for (Iterator<Component> itr = prompt.iterator(); itr.hasNext();) {
				Component component = itr.next();
				try {
					Form form = (Form)component;
					Field field = form.getField("Group");
					field.setValue(group1.getId());
					// Make sure that the value was set, Vaadin will ignore the value
					// if, for instance, the specified value is not in the Select list
					assertEquals(group1.getId(), field.getValue());
					form.commit();
				} catch (ClassCastException e) {
					LoggerFactory.getLogger(this.getClass()).info("Not a Form: " + component.getClass());
				}
			}

			vertices = m_topologyProvider.getVertices();
			assertEquals(2, vertices.size());

			assertEquals(1, m_topologyProvider.getChildren(group1).size());

			// Verify that the semantic zoom level of the vertices is correct
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));
		}

		// Add a second group so that we can make sure that adding groups to other groups works also
		Vertex group2 = m_topologyProvider.addGroup("Another new group", null);
		vertices = m_topologyProvider.getVertices();
		assertEquals(3, vertices.size());
		assertEquals(1, m_topologyProvider.getChildren(group1).size());
		assertEquals(0, m_topologyProvider.getChildren(group2).size());

		assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
		assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group2));
		assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));

		{
			AddVertexToGroupOperation operation = new AddVertexToGroupOperation();
			OperationContext context = getOperationContext(graphContainer);
			// Execute the operation on the single vertex
			operation.execute(Collections.singletonList((VertexRef)group2), context);

			// Even though we have executed the operation, it is waiting on a Window
			// operation to commit the change so make sure the vertex hasn't been
			// added yet.
			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());
			assertEquals(1, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Grab the window, put a value into the form field, and commit the form to complete
			// the operation.
			UI window = context.getMainWindow();
			assertEquals(1, window.getWindows().size());
			Window prompt = window.getWindows().iterator().next();

			for (Iterator<Component> itr = prompt.iterator(); itr.hasNext();) {
				Component component = itr.next();
				try {
					Form form = (Form)component;
					Field field = form.getField("Group");
					field.setValue(group1.getId());
					// Make sure that the value was set, Vaadin will ignore the value
					// if, for instance, the specified value is not in the Select list
					assertEquals(group1.getId(), field.getValue());
					form.commit();
				} catch (ClassCastException e) {
					LoggerFactory.getLogger(this.getClass()).info("Not a Form: " + component.getClass());
				}
			}

			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());

			// Verify that the semantic zoom level of the vertices is correct
			assertEquals(2, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));
		}

		try {
			renameGroup(graphContainer, group2, "");
			fail("No exception thrown");
		} catch (InvalidValueException e) {
			// This should happen since a blank label is invalid
		}

		assertEquals("Another new group", group2.getLabel());

		try {
			renameGroup(graphContainer, group2, group1.getLabel());
			fail("No exception thrown");
		} catch (InvalidValueException e) {
			// This should happen since a group with the same label already exists
		}

		assertEquals("Another new group", group2.getLabel());

		try {
			renameGroup(graphContainer, group2, null);
			fail("No exception thrown");
		} catch (InvalidValueException e) {
			// This should happen since the label cannot be null
		}

		assertEquals("Another new group", group2.getLabel());

		renameGroup(graphContainer, group2, "Valid value");
		assertEquals("Valid value", group2.getLabel());
		renameGroup(graphContainer, group2, "Another new group");
		assertEquals("Another new group", group2.getLabel());

		// Now let's move the vertex down to szl 2
		{
			AddVertexToGroupOperation operation = new AddVertexToGroupOperation();
			OperationContext context = getOperationContext(graphContainer);
			// Execute the operation on the single vertex
			operation.execute(Collections.singletonList((VertexRef)vertex1), context);

			// Even though we have executed the operation, it is waiting on a Window
			// operation to commit the change so make sure the vertex hasn't been
			// added yet.
			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());
			assertEquals(2, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Grab the window, put a value into the form field, and commit the form to complete
			// the operation.
			UI window = context.getMainWindow();
			assertEquals(1, window.getWindows().size());
			Window prompt = window.getWindows().iterator().next();

			for (Iterator<Component> itr = prompt.iterator(); itr.hasNext();) {
				Component component = itr.next();
				try {
					Form form = (Form)component;
					Field field = form.getField("Group");
					field.setValue(group2.getId());
					// Make sure that the value was set, Vaadin will ignore the value
					// if, for instance, the specified value is not in the Select list
					assertEquals(group2.getId(), field.getValue());
					form.commit();
				} catch (ClassCastException e) {
					LoggerFactory.getLogger(this.getClass()).info("Not a Form: " + component.getClass());
				}
			}

			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());

			assertEquals(1, m_topologyProvider.getChildren(group1).size());
			assertEquals(1, m_topologyProvider.getChildren(group2).size());

			// Verify that the semantic zoom level of the vertices is correct
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(2, m_topologyProvider.getSemanticZoomLevel(vertex1));
		}

		// Now move it back to szl 1 by removing it from its parent group
		{
			RemoveVertexFromGroupOperation operation = new RemoveVertexFromGroupOperation();
			OperationContext context = getOperationContext(graphContainer);
			// Execute the operation on the single vertex
			operation.execute(Collections.singletonList((VertexRef)group2), context);

			// Even though we have executed the operation, it is waiting on a Window
			// operation to commit the change so make sure the vertex hasn't been
			// added yet.
			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());
			assertEquals(1, m_topologyProvider.getChildren(group1).size());
			assertEquals(1, m_topologyProvider.getChildren(group2).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(2, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Grab the window, put a value into the form field, and commit the form to complete
			// the operation.
			UI window = context.getMainWindow();
			assertEquals(1, window.getWindows().size());
			Window prompt = window.getWindows().iterator().next();

			for (Iterator<Component> itr = prompt.iterator(); itr.hasNext();) {
				Component component = itr.next();
				try {
					Form form = (Form)component;
					Field field = form.getField("Item");
					field.setValue(vertex1.getId());
					// Make sure that the value was set, Vaadin will ignore the value
					// if, for instance, the specified value is not in the Select list
					assertEquals(vertex1.getId(), field.getValue());
					form.commit();
				} catch (ClassCastException e) {
					LoggerFactory.getLogger(this.getClass()).info("Not a Form: " + component.getClass());
				}
			}

			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());

			assertEquals(2, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			// Verify that the semantic zoom level of the vertices is correct
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));
			assertEquals("NEW GROUP", m_topologyProvider.getVertex(vertex1.getParent()).getLabel());
			assertEquals("NEW GROUP", m_topologyProvider.getParent(vertex1).getLabel());
		}

		// Now move it back to szl 1 by removing it from its parent group
		{
			RemoveVertexFromGroupOperation operation = new RemoveVertexFromGroupOperation();
			OperationContext context = getOperationContext(graphContainer);
			// Execute the operation on the single vertex
			operation.execute(Collections.singletonList((VertexRef)group1), context);

			// Even though we have executed the operation, it is waiting on a Window
			// operation to commit the change so make sure the vertex hasn't been
			// added yet.
			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());
			assertEquals(2, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Grab the window, put a value into the form field, and commit the form to complete
			// the operation.
			UI window = context.getMainWindow();
			assertEquals(1, window.getWindows().size());
			Window prompt = window.getWindows().iterator().next();

			for (Iterator<Component> itr = prompt.iterator(); itr.hasNext();) {
				Component component = itr.next();
				try {
					Form form = (Form)component;
					Field field = form.getField("Item");
					field.setValue(vertex1.getId());
					// Make sure that the value was set, Vaadin will ignore the value
					// if, for instance, the specified value is not in the Select list
					assertEquals(vertex1.getId(), field.getValue());
					form.commit();
				} catch (ClassCastException e) {
					LoggerFactory.getLogger(this.getClass()).info("Not a Form: " + component.getClass());
				}
			}

			vertices = m_topologyProvider.getVertices();
			assertEquals(3, vertices.size());

			assertEquals(1, m_topologyProvider.getChildren(group1).size());
			assertEquals(0, m_topologyProvider.getChildren(group2).size());

			// Verify that the semantic zoom level of the vertices is correct
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(group1));
			assertEquals(1, m_topologyProvider.getSemanticZoomLevel(group2));
			assertEquals(0, m_topologyProvider.getSemanticZoomLevel(vertex1));

			// Make sure that the vertex is back at the top level of the hierarchy
			assertNull(vertex1.getParent());
			assertNull(m_topologyProvider.getVertex(vertex1.getParent()));
			assertNull(m_topologyProvider.getParent(vertex1));
		}

		EasyMock.verify(graphContainer, selectionManager);
	}

