	/**
	 * This method generates the layer hierarchy graphml file from the
	 * node asset information supplied in nodeInfoRepository
	 */
	public GraphML nodeInfoToTopology(Map<String, Map<String, String>> onmsNodeInfo, String menuLabelStr,
			List<String> layerHierarchy, String preferredLayout, boolean generateUnallocated, String id) {

		// print log info for graph definition
		StringBuffer msg = new StringBuffer("Creating topology "+menuLabelStr+" for layerHierarchy :");
		if(layerHierarchy.size()==0){
			msg.append("EMPTY");
		} else {
			for(String layer:layerHierarchy){
				msg.append(layer+",");
			}
		}
		LOG.info(msg.toString());

		GraphML graphmlType = createGraphML(menuLabelStr);

		if (layerHierarchy.size()==0){
			//create simple graph with all nodes if layerHierarchy is empty
			if( LOG.isDebugEnabled()) LOG.debug("creating a simple graph containing all nodes as layerHierarchy is empty");

			Integer semanticZoomLevel=0;
			String graphId ="all nodes";
			String descriptionStr="A simple graph containing all nodes created because layerHierarchy property is empty";
			GraphMLGraph graph = createGraphInGraphmlType(graphmlType, graphId, descriptionStr, preferredLayout, semanticZoomLevel, id);
			addOpenNMSNodes(graph, onmsNodeInfo);

		} else {
			// create graphs for all possible layers in hierarchy
			msg = new StringBuffer("create graphs from asset and layerHierarchy: ");

			List<GraphMLGraph> graphList = new ArrayList<GraphMLGraph>();
			Integer semanticZoomLevel=0;

			String descriptionStr="";
			// create graph for each layer in hierarchy
			for(String graphId:layerHierarchy){
				//(GraphmlType graphmlType, String graphId, String descriptionStr, String preferredLayout, Integer semanticZoomLevelInt)
				GraphMLGraph graph = createGraphInGraphmlType(graphmlType, graphId, descriptionStr, preferredLayout, semanticZoomLevel, id);
				graphList.add(graph);
				msg.append(graphId+",");
				semanticZoomLevel++;
			}

			//create graph for nodes layer (last layer in hierarchy)
			String graphId="nodes";
			GraphMLGraph nodegraph = createGraphInGraphmlType(graphmlType, graphId, descriptionStr, preferredLayout, semanticZoomLevel, id);
			graphList.add(nodegraph);
			msg.append(graphId);

			if( LOG.isDebugEnabled()) LOG.debug(msg.toString());

			// create graph hierarchy according to asset table contents

			// used to store all nodes which have been allocated to a graph layer
			Map<String, Map<String, String>> allocatedNodeInfo = new LinkedHashMap<String, Map<String, String>>();

			// add layer graphs for defined layerHierarchy
			String parentNodeId=null;
			recursivelyAddlayers(layerHierarchy, 0,   onmsNodeInfo,  allocatedNodeInfo,  graphmlType, graphList, parentNodeId);

			// add unallocated nodes into a default unallocated_Nodes graph
			Map<String, Map<String, String>> unAllocatedNodeInfo = new LinkedHashMap<String, Map<String, String>>();
			unAllocatedNodeInfo.putAll(onmsNodeInfo); //initialise with full list of nodes

			for (String allocatedNodeId:allocatedNodeInfo.keySet()){
				unAllocatedNodeInfo.remove(allocatedNodeId);
			}

			if(generateUnallocated){
				graphId="unallocated_Nodes";
				descriptionStr="A graph containing all nodes which cannot be placed in topology hierarchy";
				semanticZoomLevel=0;
				GraphMLGraph graph = createGraphInGraphmlType(graphmlType, graphId, descriptionStr, preferredLayout, semanticZoomLevel, id);
				addOpenNMSNodes(graph, unAllocatedNodeInfo);
			}
		}

		return graphmlType;
	}

