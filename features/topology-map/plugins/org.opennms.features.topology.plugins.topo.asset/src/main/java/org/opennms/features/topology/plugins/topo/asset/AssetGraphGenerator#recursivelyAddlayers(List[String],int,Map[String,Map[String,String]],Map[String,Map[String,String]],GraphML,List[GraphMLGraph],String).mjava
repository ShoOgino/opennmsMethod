	/**
	 * Recursive function to add OpenNMS nodes defined in nodeInfo into hierarchy of graphs created in the given graphmlType
	 * returns list of nodes added in the next layer for use in edges in this layer
	 * @param layerHierarchy static list of layer names which correspond to asset table keys defined in NodeParamLabels
	 * @param layerHierarchyIndex the current layer for which this function is called (initialise to 0) subsequent recursive calls will increment the number until layerHierarchy.size()
	 * @param nodeInfo nodeInfo map with values Map<nodeId, Map<nodeParamLabelKey, nodeParamValue>>
	 *        nodeParamLabelKey a node asset parameter key (from those defined in org.opennms.plugins.graphml.asset.NodeParamLabels)
	 *        nodeParamValue a node asset value ( e.g. key NodeParamLabels.ASSET_RACK ('asset-rack') value: rack1
	 * @param allocatedNodeInfo this contains all of the nodes which a recursive call to this method has added. i.e. once the function is finished,
	 * all of the nodes placed in a graph are included in this list. The list can then be used to determine the unallocated nodes.
	 * @param graphmlType the parent graphmltype into which all the created graphe muse be placed
	 * @param graphList a list of pre created graphs which are in the same order and should  be pre-named with the names in the layerHierarchy
	 * @param parentNodeId the nodeId of the parent node which the edges generated for the next layer must reference
	 * @return addedNodes returns list of nodes which have been added by this recursive call. These nodes are used to create the edges in the previous layer
	 */
	private Map<String, Map<String, String>> recursivelyAddlayers(List<String> layerHierarchy, int layerHierarchyIndex,  
			Map<String, Map<String, String>> nodeInfo, Map<String, Map<String, String>> allocatedNodeInfo, 
			GraphML graphmlType, List<GraphMLGraph> graphList, String parentNodeId){
		if(layerHierarchy==null||layerHierarchy.size()==0 ) throw new RuntimeException("AssetTopologyMapperImpl layerHierarchy must not be null or empty");

		// returns list of nodes added - either OpenNMS nodes or higher level graphs
		Map<String, Map<String, String>> addedNodes=null;

		if( LOG.isDebugEnabled()) LOG.debug("recursivelyAddlayers called for layerHierarchyIndex:"+layerHierarchyIndex+" parentNodeId="+parentNodeId);

		// add nodes to graph
		if(layerHierarchyIndex>=layerHierarchy.size()){
			// we are at bottom of hierarchy so add real opennms nodes and edges

			//get hierarchy name for the previous layer
			String layerNodeParamLabel= layerHierarchy.get(layerHierarchyIndex-1);

			// get graph for this layer
			if( LOG.isDebugEnabled()) LOG.debug("populating graph with OpenNMS nodes for layer="+layerNodeParamLabel);

			// this will return the nodes graph - the last graph in graphList
			GraphMLGraph graph = graphList.get(layerHierarchyIndex); 

			//add real opennms nodes to graph
			addOpenNMSNodes(graph, nodeInfo);

			// add these nodes to the allocated node set
			allocatedNodeInfo.putAll(nodeInfo);

			if (LOG.isDebugEnabled()) {
				StringBuffer msg= new StringBuffer("adding opennms nodes to graphId="+layerNodeParamLabel+ " nodes:");

				for (String targetNodeId:nodeInfo.keySet()){
					msg.append(targetNodeId+",");
				}
			}

			addedNodes=nodeInfo;

		} else {
			// else create and add the parent nodes for the next layer
			if( LOG.isDebugEnabled()) LOG.debug("populating parent graph for index "+layerHierarchyIndex);

			//get hierarchy name for this layer
			String layerNodeParamLabelKey= layerHierarchy.get(layerHierarchyIndex);
			if( LOG.isDebugEnabled()) LOG.debug("parent graph name="+layerNodeParamLabelKey);

			// get graph for this layer
			GraphMLGraph graph = graphList.get(layerHierarchyIndex);
			// this will return the nodes graph - the last  graph in graphList
			GraphMLGraph nextgraph = graphList.get(layerHierarchyIndex+1); 

			// find all values corresponding to nodeParamLabelKey in this layer
			Set<String> layerNodeParamLabelValues = new TreeSet<String>();
			for (String nodeId: nodeInfo.keySet()){
				String nodeParamValue = nodeInfo.get(nodeId).get(layerNodeParamLabelKey);
				if(nodeParamValue!=null){
					layerNodeParamLabelValues.add(nodeParamValue);
				}
			}

			if (LOG.isDebugEnabled()){
				StringBuffer msg=new StringBuffer("values corresponding to layerNodeParamLabelKey="+layerNodeParamLabelKey+ " in this layer :");
				for (String nodeParamValue:layerNodeParamLabelValues){
					msg.append(nodeParamValue+",");
				}
				LOG.debug(msg.toString());
			}

			// create added nodes to return. These are the nodes which have been added in this layer
			// and are used to populate the edges in the previous layer
			addedNodes = new LinkedHashMap<String, Map<String, String>>();

			// iterate over values in this layer
			for (String nodeParamLabelValue:layerNodeParamLabelValues){

				// create new node for each value in this layer
				String graphmlNodeId= (parentNodeId==null) ? nodeParamLabelValue : parentNodeId+"."+nodeParamLabelValue;
				GraphMLNode node = createNodeType(graphmlNodeId,nodeParamLabelValue);
				graph.addNode(node);

				StringBuffer msg=new StringBuffer("created childNode graphmlNodeId="+graphmlNodeId+" nodeParamLabelValue="+nodeParamLabelValue+ " in  graphId="+layerNodeParamLabelKey);

				// create sub list of nodes corresponding to param label 
				Map<String, Map<String, String>> nodeInfoSubList =createNodeInfoSubList(layerNodeParamLabelKey, nodeParamLabelValue, nodeInfo);

				// recursively add graphs and nodes until complete
				int nextLayerHierarchyIndex=layerHierarchyIndex+1;
				Map<String, Map<String, String>> nextLayerNodesAdded = recursivelyAddlayers(layerHierarchy, nextLayerHierarchyIndex, nodeInfoSubList, allocatedNodeInfo, graphmlType, graphList, graphmlNodeId );

				// we are now using data returned from a recursive call to recursivelyAddlayers
				// nextLayerNodesAdded contains the nodes added in the lower layer
				// and these can be used to populates edges in this layer

				// create edge for each node in returned nextLayerNodesAdded
				if (nextLayerHierarchyIndex<layerHierarchy.size()){
					// if not lowest layer then add edges pointing next layers
					msg.append(" edges added for next graph layer: " );
					for (String targetNodeId:nextLayerNodesAdded.keySet()){
						Map<String, String> nodeParamaters = nextLayerNodesAdded.get(targetNodeId);
						String labelStr = nodeParamaters.get(layerHierarchy.get(nextLayerHierarchyIndex));
						String childNodeLabelStr= graphmlNodeId+"."+labelStr;

						GraphMLNode childNode = nextgraph.getNodeById(childNodeLabelStr);						
						GraphMLEdge edge = addEdgeToGraph(graph, node, childNode);

						if (edge!=null) msg.append(edge.getId()+",");

						addedNodes.put(targetNodeId, nodeParamaters);
					}
				} else {
					// if lowest layer then add node ids (i.e. opennms node labels)
					msg.append(" edges added for opennms nodes: " );
					for (String targetNodeId:nextLayerNodesAdded.keySet()){
						Map<String, String> nodeParamaters = nextLayerNodesAdded.get(targetNodeId);
						String nodeLabelStr = nodeParamaters.get(NodeParamLabels.NODE_NODELABEL);

						GraphMLNode childNode = nextgraph.getNodeById(nodeLabelStr);
						GraphMLEdge edge = addEdgeToGraph(graph, node, childNode);

						if (edge!=null) msg.append(edge.getId()+",");

						addedNodes.put(targetNodeId, nodeParamaters);
					}
				}

				if( LOG.isDebugEnabled()){
					LOG.debug(msg.toString());
				}

			}

		}
		if( LOG.isDebugEnabled()) LOG.debug("returning from recursivelyAddlayers called for layerHierarchyIndex:"+layerHierarchyIndex);
		return addedNodes;
	}

