	public GraphML generateGraphs(GeneratorConfig config) {
		final LayerDefinitionRepository layerDefinitionRepository = new LayerDefinitionRepository();
		final List<LayerDefinition> layerDefinitions = layerDefinitionRepository.getDefinitions(config.getLayerHierarchies());
		final List<OnmsNode> nodes = nodeProvider.getNodes(layerDefinitions);

		// Define Layers
		final List<Layer> layers = layerDefinitions.stream().map(mapping -> mapping.getLayer()).collect(Collectors.toList());

		// Add last Layer for Nodes
		layers.add(new LayerBuilder()
				.withId("nodes")
				.withNamespace("nodes")
				.withLabel("Nodes")
				.withDescription("The nodes in the hierarchy of the topology")
				.withItemProvider(node -> node)
				.withIdGenerator(IdGenerator.SIMPLE)
				.withSemanticZoomLevel(0)
				.withVertexStatusProvider(true)
				.build()
		);

		// Ensure that all elements in the nodes do have values set
		layers.forEach(layer -> {
			List<OnmsNode> nodeWithNullValues = nodes.stream().filter(n -> layer.getItemProvider().getItem(n) == null).collect(Collectors.toList());
			if (!nodeWithNullValues.isEmpty()) {
				LOG.debug("Found nodes with null value for layer (id: {}, label: {}). Removing nodes {}",
						layer.getId(), layer.getLabel(),
						nodeWithNullValues.stream().map(n -> String.format("(id: %s, label: %s)", n.getId(), n.getLabel())).collect(Collectors.toList()));
				nodes.removeAll(nodeWithNullValues);
			}
		});

		// Apply additional filters
		final Map<String, Filter> filterMap = new FilterParser().parse(config.getFilters());
		final List<LayerDefinition> layersToFilter = layerDefinitionRepository.getDefinitions(filterMap.keySet());
		applyFilters(nodes,filterMap,layerDefinitionRepository);
		
		// Start generating the hierarchy
		// Overall graphml object
		final GraphML graphML = new GraphML();
		graphML.setProperty(GraphMLProperties.LABEL, config.getLabel());
		graphML.setProperty(GraphMLProperties.BREADCRUMB_STRATEGY, config.getBreadcrumbStrategy());

		// Build each Graph
		int index = 0;
		for (Layer layer : layers) {
			GraphMLGraph layerGraph = new GraphMLGraph();
			layerGraph.setId(config.getProviderId() + ":" + layer.getId());
			layerGraph.setProperty(GraphMLProperties.NAMESPACE, config.getProviderId() + ":" + layer.getNamespace());
			layerGraph.setProperty(GraphMLProperties.PREFERRED_LAYOUT, config.getPreferredLayout());
			layerGraph.setProperty(GraphMLProperties.LABEL, layer.getLabel());
            layerGraph.setProperty(GraphMLProperties.DESCRIPTION, layer.getDescription());
			layerGraph.setProperty(GraphMLProperties.FOCUS_STRATEGY, layer.getFocusStrategy().name());
			layerGraph.setProperty(GraphMLProperties.SEMANTIC_ZOOM_LEVEL, layer.getSemanticZoomLevel());
			layerGraph.setProperty(GraphMLProperties.VERTEX_STATUS_PROVIDER, layer.hasVertexStatusProvider());

			// Build layer for nodes
			for (OnmsNode eachNode : nodes) {
				final Object eachItem = layer.getItemProvider().getItem(eachNode);
				if (eachItem != null) {
					List<Layer> processedLayers = layers.subList(0, index);
					String id = layer.getIdGenerator().generateId(processedLayers, eachNode, layer.getNodeDecorator().getId(eachItem));
					if (layerGraph.getNodeById(id) == null) {
						GraphMLNode node = new GraphMLNode();
						node.setId(id);
						layer.getNodeDecorator().decorate(node, eachItem);
						layerGraph.addNode(node);
					}
				}
			}
			graphML.addGraph(layerGraph);
			index++;
		}

		// Now link all nodes, but only if there are at least 2 layers
		if (graphML.getGraphs().size() > 1) {
			nodes.forEach(n -> {
				List<GraphMLNode> path = getPath(n, graphML.getGraphs(), layers);
				if (path.size() != graphML.getGraphs().size() ) {
					throw new IllegalStateException("");
				}
				for (int i=0; i<path.size() - 1; i++) {
					GraphMLNode sourceNode = path.get(i);
					GraphMLNode targetNode = path.get(i+1);
					GraphMLGraph sourceGraph = graphML.getGraphs().get(i);
					String edgeId = String.format("%s_%s", sourceNode.getId(), targetNode.getId());
					if (sourceGraph.getEdgeById(edgeId) == null) {
						GraphMLEdge edge = new GraphMLEdge();
						edge.setId(edgeId);
						edge.setSource(sourceNode);
						edge.setTarget(targetNode);
						sourceGraph.addEdge(edge);
					}
				}
			});
		}
		return graphML;
	}

