	@Override
	public void updated(String pid, @SuppressWarnings("rawtypes") Dictionary properties) throws ConfigurationException {
		LOG.debug("updated(String, Dictionary) invoked");
		String location = (String)properties.get(TOPOLOGY_LOCATION);
		if (!m_providers.containsKey(pid)) {
			LOG.debug("Service with pid '{}' is new. Register {}", pid, GraphMLMetaTopologyProvider.class.getSimpleName());
			final Dictionary<String,Object> metaData = new Hashtable<>();
			metaData.put(Constants.SERVICE_PID, pid);
			if (properties.get(LABEL) != null) {
				metaData.put(LABEL, properties.get(LABEL));
			}

			// Expose the MetaTopologyProvider
			final GraphMLMetaTopologyProvider metaTopologyProvider = new GraphMLMetaTopologyProvider();
			metaTopologyProvider.setTopologyLocation(location);
			metaTopologyProvider.load();
			ServiceRegistration<MetaTopologyProvider> registration = m_bundleContext.registerService(MetaTopologyProvider.class, metaTopologyProvider, metaData);

			m_registrations.put(pid, registration);
			m_providers.put(pid, metaTopologyProvider);

			// Create and register a SearchProvider for each GraphMLTopologyProvider
			m_searchProviders.putIfAbsent(pid, Lists.newArrayList());

			Set<String> iconKeys = metaTopologyProvider.getGraphProviders().stream()
					.map(eachProvider -> eachProvider.getVertexNamespace())
					.flatMap(eachNamespace -> metaTopologyProvider.getRawTopologyProvider(eachNamespace).getVertices().stream())
					.map(eachVertex -> eachVertex.getIconKey())
					.filter(eachIconKey -> eachIconKey != null)
					.collect(Collectors.toSet());

			m_iconRepositories.put(pid, m_bundleContext.registerService(IconRepository.class, new GraphMLIconRepository(iconKeys), new Hashtable<>()));
			m_vertexStatusProviders.putIfAbsent(pid, Lists.newArrayList());

			metaTopologyProvider.getGraphProviders().forEach(it -> {
				GraphMLTopologyProvider rawTopologyProvider = metaTopologyProvider.getRawTopologyProvider(it.getVertexNamespace());

				GraphMLSearchProvider searchProvider = new GraphMLSearchProvider(rawTopologyProvider);
				ServiceRegistration<SearchProvider> searchProviderServiceRegistration = m_bundleContext.registerService(SearchProvider.class, searchProvider, new Hashtable<>());
				m_searchProviders.get(pid).add(searchProviderServiceRegistration);

				// Only add status provider if explicitly set in graphml document
				if (rawTopologyProvider.requiresStatusProvider()) {
					GraphMLVertexStatusProvider statusProvider = new GraphMLVertexStatusProvider(
							rawTopologyProvider.getVertexNamespace(),
							(nodeIds) -> alarmDao.getNodeAlarmSummariesIncludeAcknowledgedOnes(nodeIds));
					ServiceRegistration<StatusProvider> statusProviderRegistration = m_bundleContext.registerService(StatusProvider.class, statusProvider, new Hashtable<>());
					m_vertexStatusProviders.get(pid).add(statusProviderRegistration);
				}

			});
		} else {
			// TODO we set the new location, but a reload is never triggered
			LOG.debug("Service with pid '{}' updated. Updating properties.", pid);
			m_providers.get(pid).setTopologyLocation(location);
			ServiceRegistration<MetaTopologyProvider> registration = m_registrations.get(pid);
			Dictionary<String,Object> metaData = new Hashtable<>();
			metaData.put(Constants.SERVICE_PID, pid);
			if (properties.get(LABEL) != null) {
				metaData.put(LABEL, properties.get(LABEL));
			}
			registration.setProperties(metaData);
		}
	}

