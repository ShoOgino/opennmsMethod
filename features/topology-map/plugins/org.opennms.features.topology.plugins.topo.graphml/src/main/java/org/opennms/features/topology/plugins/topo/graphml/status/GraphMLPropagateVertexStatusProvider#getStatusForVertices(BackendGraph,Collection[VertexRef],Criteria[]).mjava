    @Override
    public Map<? extends VertexRef, ? extends Status> getStatusForVertices(final BackendGraph graph,
                                                                           final Collection<VertexRef> vertices,
                                                                           final Criteria[] criteria) {
        final List<Criteria> criteriaList = Lists.newArrayList(criteria);

        final LoopDetectionCriteria loopDetectionCriteria = Iterables.tryFind(criteriaList,
                                                                              c -> c instanceof LoopDetectionCriteria)
                                                                     .transform(c -> (LoopDetectionCriteria) c)
                                                                     .or(LoopDetectionCriteria::new);

        // Build map from namespace to opposite vertices
        final Multimap<String, VertexRef> oppositeVertices = HashMultimap.create();
        for (final VertexRef sourceVertex : vertices) {
            // Filter out loops
            if (loopDetectionCriteria.contains(sourceVertex)) {
                LOG.error("Loop detected with: {}:{}", sourceVertex.getNamespace(), sourceVertex.getId());
                continue;
            }

            for (VertexRef targetVertex : this.provider.getOppositeVertices(sourceVertex)) {
                oppositeVertices.put(targetVertex.getNamespace(), targetVertex);
            }
        }

        // Replace loop detection criteria with extended one
        criteriaList.remove(loopDetectionCriteria);
        criteriaList.add(loopDetectionCriteria.with(vertices));

        // Find and call status provider for each namespace and get result per opposite vertex
        final Map<VertexRef, Status> targetStatuses = Maps.newHashMap();
        try {
            final Collection<ServiceReference<StatusProvider>> statusProviderReferences = this.bundleContext.getServiceReferences(StatusProvider.class, null);
            for (final ServiceReference<StatusProvider> statusProviderReference : statusProviderReferences) {
                try {
                    final StatusProvider statusProvider = bundleContext.getService(statusProviderReference);

                    for (final Map.Entry<String, Collection<VertexRef>> e : oppositeVertices.asMap().entrySet()) {
                        if (statusProvider.contributesTo(e.getKey())) {
                            targetStatuses.putAll(statusProvider.getStatusForVertices(
                                                  this.provider.getGraphProviderBy(e.getKey()).getCurrentGraph(),
                                                  e.getValue(),
                                                  criteriaList.toArray(new Criteria[0])));
                        }
                    }

                } finally {
                    bundleContext.ungetService(statusProviderReference);
                }
            }
        } catch (final InvalidSyntaxException e) {
        }

        // Merge statuses from targets to sources
        final Map<VertexRef, GraphMLVertexStatus> statuses = Maps.newHashMap();
        for (final VertexRef sourceVertex : vertices) {
            GraphMLVertexStatus mergedStatus = new GraphMLVertexStatus();

            for (VertexRef targetVertex : this.provider.getOppositeVertices(sourceVertex)) {
                if (targetStatuses.containsKey(targetVertex)) {
                    mergedStatus = GraphMLVertexStatus.merge(mergedStatus, (GraphMLVertexStatus) targetStatuses.get(targetVertex));
                }
            }
            statuses.put(sourceVertex, mergedStatus);
        }

        return statuses;
    }

