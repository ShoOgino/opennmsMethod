    private void load(final URI source, final WrappedGraph graph) {
        String namespace = graph.m_namespace == null ? TOPOLOGY_NAMESPACE_SIMPLE : graph.m_namespace;
        if (getVertexNamespace() != namespace) { 
            LoggerFactory.getLogger(this.getClass()).info("Creating new vertex provider with namespace {}", namespace);
            m_vertexProvider = new SimpleVertexProvider(namespace);
        }
        if (getEdgeNamespace() != namespace) { 
            LoggerFactory.getLogger(this.getClass()).info("Creating new edge provider with namespace {}", namespace);
            m_edgeProvider = new SimpleEdgeProvider(namespace);
        }
        resetContainer();
        for (WrappedVertex vertex : graph.m_vertices) {
            if (vertex.namespace == null) {
                vertex.namespace = getVertexNamespace();
                LoggerFactory.getLogger(this.getClass()).warn("Setting namespace on vertex to default: {}", vertex);
            } 

            if (vertex.id == null) {
                LoggerFactory.getLogger(this.getClass()).warn("Invalid vertex unmarshalled from {}: {}", source.toString(), vertex);
            }
            AbstractVertex newVertex;
            if (vertex.group) {
                newVertex = new SimpleGroup(vertex.namespace, vertex.id);
                if (vertex.x != null) newVertex.setX(vertex.x);
                if (vertex.y != null) newVertex.setY(vertex.y);
            } else {
                newVertex = new SimpleLeafVertex(vertex.namespace, vertex.id, vertex.x, vertex.y);
            }
            newVertex.setIconKey(vertex.iconKey);
            newVertex.setIpAddress(vertex.ipAddr);
            newVertex.setLabel(vertex.label);
            newVertex.setLocked(vertex.locked);
            if (vertex.nodeID != null) newVertex.setNodeID(vertex.nodeID);
            if (!newVertex.equals(vertex.parent)) newVertex.setParent(vertex.parent);
            newVertex.setSelected(vertex.selected);
            newVertex.setStyleName(vertex.styleName);
            newVertex.setTooltipText(vertex.tooltipText);
            addVertices(newVertex);
        }
        
        for (WrappedEdge edge : graph.m_edges) {
            if (edge.namespace == null) {
                edge.namespace = getEdgeNamespace();
                LoggerFactory.getLogger(this.getClass()).warn("Setting namespace on edge to default: {}", edge);
            } 

            if (edge.id == null) {
                LoggerFactory.getLogger(this.getClass()).warn("Invalid edge unmarshalled from {}: {}", source.toString(), edge);
            } else if (edge.id.startsWith(SIMPLE_EDGE_ID_PREFIX)) {
                try {
                    /*
                     * This code will be necessary if we allow edges to be created
                    
                    // Find the highest index group number and start the index for new groups above it
                    int edgeNumber = Integer.parseInt(edge.getId().substring(SIMPLE_EDGE_ID_PREFIX.length()));
                    
                    if (m_edgeCounter <= edgeNumber) {
                        m_edgeCounter = edgeNumber + 1;
                    }
                    */
                } catch (NumberFormatException e) {
                    // Ignore this edge ID since it doesn't conform to our pattern for auto-generated IDs
                }
            }
            AbstractEdge newEdge = connectVertices(edge.id, edge.source, edge.target, edge.namespace);
            newEdge.setLabel(edge.label);
            newEdge.setTooltipText(edge.tooltipText);
            //addEdges(newEdge);
        }

        for (WrappedVertex vertex: graph.m_vertices) {
            if (vertex.parent != null && !vertex.equals(vertex.parent)) {
                LoggerFactory.getLogger(this.getClass()).debug("Setting parent of " + vertex + " to " + vertex.parent);
                setParent(vertex, vertex.parent);
            }
        }
    }

