    @Override
    protected void addAdditionalCriteriaOptions(Criteria criteria, Page page, boolean doOrder) {

        // filter out relevant selectedIds. They can be either of type application or service. This works since all ids
        // are unique.
        Collection<Integer> selectedIds = criteria.getRestrictions().stream()
                .filter(r -> r.getType().equals(Restriction.RestrictionType.IN))
                .map(r-> ((InRestriction)r).getValues())
                .flatMap(Collection::stream)
                .map(o-> (Integer)o)
                .collect(Collectors.toList());

        // remove id restriction since we don't want to see the application itself but its outages
        Collection<Restriction> restrictionsWithoutIdFilter = criteria.getRestrictions().stream()
                .filter(r -> !r.getType().equals(Restriction.RestrictionType.IN))
                .collect(Collectors.toList());
        criteria.setRestrictions(restrictionsWithoutIdFilter);

        // show only unresolved outages
        criteria.addRestriction(Restrictions.isNull("ifRegainedService"));

        // show only outages detected by a perspective poller
        criteria.addRestriction(Restrictions.isNotNull("perspective"));

        // find all relevant services by
        Set<OnmsMonitoredService> services = new HashSet<>();

        // a.) services of selected applications
        List<OnmsApplication> applications;
        if(selectedIds.isEmpty()) {
            applications = Collections.emptyList();
        } else {
            Criteria appCriteria = new CriteriaBuilder(OnmsApplication.class).in("id", selectedIds).toCriteria();
            applications = this.applicationDao.findMatching(appCriteria);
        }
        for(OnmsApplication application : applications) {
            services.addAll(application.getMonitoredServices());
        }

        // b.) directly selected interfaces
        for(int serviceId : selectedIds) {
            OnmsMonitoredService service = new OnmsMonitoredService();
            service.setId(serviceId);
            services.add(service);
        }

        if(services.isEmpty()) {
            criteria.addRestriction(Restrictions.sql("1=2")); // we don't want to find anything
        } else {
            criteria.addRestriction(Restrictions.in("monitoredService", services));
        }

        // set aliases so that the columns can be found
        criteria.setAliases(Arrays.asList(
                new Alias("monitoredService.ipInterface.node", "nodeLabel", Alias.JoinType.LEFT_JOIN),
                new Alias("monitoredService.ipInterface", "ipAddress", Alias.JoinType.LEFT_JOIN),
                new Alias("monitoredService.serviceType", "serviceName", Alias.JoinType.LEFT_JOIN),
                new Alias("perspective", "perspective", Alias.JoinType.LEFT_JOIN)));
    }

