    private void getBridgeLinks(){

        Multimap<String, BridgeMacTopologyLink> multimap = HashMultimap.create();
        List<BridgeMacTopologyLink> macLinks = m_bridgeMacLinkDao.getAllBridgeLinksToIpAddrToNodes();
        if (macLinks != null && macLinks.size() > 0) {
            for (BridgeMacTopologyLink macLink : macLinks) {
                multimap.put(String.valueOf(macLink.getSrcNodeId()) + "|" +String.valueOf(macLink.getBridgePort()), macLink);
            }
        }

        //if multimap entry has more than one item, check bridgeBridgeLink and add cloud vertex
        for (String key : multimap.keySet()){
            Collection<BridgeMacTopologyLink> links = multimap.get(key);
            if (links.size() > 1) {
                //process link with cloud
                processMultipleBridgeLinks(key, links);
            } else{
                //add single connection
                BridgeMacTopologyLink link = links.iterator().next();
                String id = Math.min(link.getSrcNodeId(), link.getTargetNodeId()) + "|" + Math.max(link.getSrcNodeId(), link.getTargetNodeId());
                Vertex source = getVertex(getVertexNamespace(), link.getSrcNodeId().toString());
                if (source == null) {
                    source = getDefaultVertex(link.getSrcNodeId(),
                                       link.getSrcSysoid(),
                                       link.getSrcLabel(),
                                     link.getSrcLocation(),
                                     link.getSrcNodeType());
                    addVertices(source);
                }
                Vertex target = getVertex(getVertexNamespace(), link.getTargetNodeId().toString());
                if (target == null) {
                    target = getDefaultVertex(link.getTargetNodeId(),
                                       link.getTargetSysoid(),
                                       link.getTargetLabel(),
                                     link.getTargetLocation(),
                                     link.getTargetNodeType());
                    addVertices(target);
                }
                BridgeLinkDetail detail = new BridgeLinkDetail(id, EnhancedLinkdTopologyProvider.TOPOLOGY_NAMESPACE_LINKD,source, link.getId(), target, link.getId());
                AbstractEdge edge = connectVertices(detail.getId(), detail.getSource(), detail.getTarget(), BRIDGE_EDGE_NAMESPACE);
                edge.setTooltipText(getEdgeTooltipText(detail));
            }

        }
        
        List<BridgeBridgeLink> links = m_bridgeBridgeLinkDao.findAll();
        if (links != null && links.size() > 0) {
            for (BridgeBridgeLink link : links) {
                String id = Math.min(link.getNode().getId(), link.getDesignatedNode().getId()) + "|" + Math.max(link.getNode().getId(), link.getDesignatedNode().getId());
                Vertex source = getVertex(getVertexNamespace(), link.getNode().getId().toString());
                if (source==null) {
                    source = getDefaultVertex(link.getNode().getId(), link.getNode().getSysObjectId(), link.getNode().getLabel(),link.getNode().getSysDescription(),link.getNode().getType());
                    addVertices(source);
               }
                Vertex target = getVertex(getVertexNamespace(), link.getDesignatedNode().getId().toString());
                if (target == null) {
                    target = getDefaultVertex(link.getDesignatedNode().getId(), link.getDesignatedNode().getSysObjectId(), link.getDesignatedNode().getLabel(),link.getDesignatedNode().getSysDescription(),link.getDesignatedNode().getType());
                    addVertices(target);
                }
                BridgeLinkDetail detail = new BridgeLinkDetail(id, EnhancedLinkdTopologyProvider.TOPOLOGY_NAMESPACE_LINKD,source,link.getId()
                            , target, link.getId());
               AbstractEdge edge = connectVertices(detail.getId(), detail.getSource(), detail.getTarget(), BRIDGE_EDGE_NAMESPACE);
               edge.setTooltipText(getEdgeTooltipText(detail));
            }
        }
    }

