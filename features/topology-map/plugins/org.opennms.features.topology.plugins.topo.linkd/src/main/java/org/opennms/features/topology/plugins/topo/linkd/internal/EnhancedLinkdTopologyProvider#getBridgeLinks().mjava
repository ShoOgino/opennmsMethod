    private void getBridgeLinks(){
        //List<BridgeBridgeLink> bridgeBridgeLinks = getBridgeBridgeLinks();

        List<BridgeMacTopologyLink> bridgeMacLinks = m_bridgeMacLinkDao.getAllBridgeLinksToIpAddrToNodes();

        Multimap<String, BridgeMacTopologyLink> multimap = HashMultimap.create();
        for (BridgeMacTopologyLink macLink : bridgeMacLinks) {
            multimap.put(String.valueOf(macLink.getNodeId()) + "|" +String.valueOf(macLink.getBridgePort()), macLink);
        }

        //if multimap entry has more than one item, check bridgeBridgeLink and add cloud vertex
        for (String key : multimap.keySet()){
            Collection<BridgeMacTopologyLink> links = multimap.get(key);
            if (links.size() > 1) {
                //process link with cloud
                processMultipleBridgeLinks(key, links);
            } else{
                //add single connection
                BridgeMacTopologyLink topoLink = links.iterator().next();
                String id = Math.min(topoLink.getNodeId(), topoLink.getTargetNodeId()) + "|" + Math.max(topoLink.getNodeId(), topoLink.getTargetNodeId());
                BridgeLinkDetail detail = new BridgeLinkDetail(id, EnhancedLinkdTopologyProvider.TOPOLOGY_NAMESPACE_LINKD,
                        getVertex(m_nodeDao.get(topoLink.getNodeId())), topoLink.getId(), getVertex(m_nodeDao.get(topoLink.getTargetNodeId())), topoLink.getId());

                AbstractEdge edge = connectVertices(detail.getId(), detail.getSource(), detail.getTarget(), BRIDGE_EDGE_NAMESPACE);
                //TODO: fix tooltip for bridge topology
                edge.setTooltipText(getEdgeTooltipText(detail));
            }

        }
    }

