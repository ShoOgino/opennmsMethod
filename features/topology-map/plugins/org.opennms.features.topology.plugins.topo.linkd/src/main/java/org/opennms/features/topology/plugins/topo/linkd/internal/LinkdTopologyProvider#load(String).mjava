    //@Transactional
    @Override
    public void load(String filename) throws MalformedURLException, JAXBException {
        if (filename != null) {
            LoggerFactory.getLogger(LinkdTopologyProvider.class).warn("Filename that was specified for linkd topology will be ignored: " + filename + ", using " + m_configurationFile + " instead");
        }
        log("loadtopology: Clear " + VertexProvider.class.getSimpleName());
        clearVertices();
        log("loadtopology: Clear " + EdgeProvider.class.getSimpleName());
        clearEdges();

        Map<String, Vertex> vertexes = new HashMap<String,Vertex>();
        List<Edge> edges = new ArrayList<Edge>();
        for (DataLinkInterface link: m_dataLinkInterfaceDao.findAll()) {
            log("loadtopology: parsing link: " + link.getDataLinkInterfaceId());

            OnmsNode node = m_nodeDao.get(link.getNode().getId());
            log("loadtopology: found source node: " + node.getLabel());
            String sourceId = node.getNodeId();
            Vertex source;
            if (vertexes.containsKey(sourceId)) {
                source = vertexes.get(sourceId);
            } else {
                log("loadtopology: adding source node as vertex: " + node.getLabel());
                source = getVertex(node);
                vertexes.put(sourceId, source);
            }

            OnmsNode parentNode = m_nodeDao.get(link.getNodeParentId());
            log("loadtopology: found target node: " + parentNode.getLabel());
            String targetId = parentNode.getNodeId();
            Vertex target;
            if (vertexes.containsKey(targetId)) {
                target = vertexes.get(targetId);
            } else {
                log("loadtopology: adding target as vertex: " + parentNode.getLabel());
                target = getVertex(parentNode);
                vertexes.put(targetId, target);
            }
            
            // Create a new edge that connects the vertices
            // TODO: Make sure that all properties are set on this object
            AbstractEdge edge = new AbstractEdge(TOPOLOGY_NAMESPACE_LINKD, link.getDataLinkInterfaceId(), source, target); 
            edge.setTooltipText(getEdgeTooltipText(link, source, target));
            edges.add(edge);
        }
        
        log("loadtopology: adding nodes without links: " + isAddNodeWithoutLink());
        if (isAddNodeWithoutLink()) {
            for (OnmsNode onmsnode: m_nodeDao.findAll()) {
                String nodeId = onmsnode.getNodeId();
                if (!vertexes.containsKey(nodeId)) {
                    log("loadtopology: adding link-less node: " + onmsnode.getLabel());
                    vertexes.put(nodeId, getVertex(onmsnode));
                }
            }
        }
        
        log("Found " + vertexes.size() + " vertices");
        log("Found " + edges.size() + " edges");

        addVertices(vertexes.values().toArray(new Vertex[0]));
        addEdges(edges.toArray(new Edge[0]));
 
        File configFile = new File(m_configurationFile);

        if (configFile.exists() && configFile.canRead()) {
            log("loadtopology: loading topology from configuration file: " + m_configurationFile);
            m_groupCounter = 0;
            WrappedGraph graph = getGraphFromFile(configFile);

            // Add all groups to the topology
            int numberOfGroups = 0;
            for (WrappedVertex vertex: graph.m_vertices) {
                if (!vertex.leaf) {
                    log("loadtopology: adding group to topology: " + vertex.id);
                    if (vertex.namespace == null) {
                        vertex.namespace = TOPOLOGY_NAMESPACE_LINKD;
                        LoggerFactory.getLogger(this.getClass()).warn("Setting namespace on vertex to linkd default: {}", vertex);
                    } 

                    if (vertex.id == null) {
                        LoggerFactory.getLogger(this.getClass()).warn("Invalid vertex unmarshalled from {}: {}", m_configurationFile, vertex);
                    } else if (vertex.id.startsWith(LINKD_GROUP_ID_PREFIX)) {
                        try {
                            // Find the highest index group number and start the index for new groups above it
                            int groupNumber = Integer.parseInt(vertex.id.substring(LINKD_GROUP_ID_PREFIX.length()));
                            if (m_groupCounter <= groupNumber) {
                                m_groupCounter = groupNumber + 1;
                            }
                        } catch (NumberFormatException e) {
                            // Ignore this group ID since it doesn't conform to our pattern for auto-generated IDs
                        }
                    }
                    AbstractVertex newVertex = addGroup(vertex.id, vertex.iconKey, vertex.label);
                    newVertex.setIpAddress(vertex.ipAddr);
                    newVertex.setLocked(vertex.locked);
                    if (vertex.nodeID != null) newVertex.setNodeID(vertex.nodeID);
                    newVertex.setParent(vertex.parent);
                    newVertex.setSelected(vertex.selected);
                    newVertex.setStyleName(vertex.styleName);
                    newVertex.setTooltipText(vertex.tooltipText);
                    if (vertex.x != null) newVertex.setX(vertex.x);
                    if (vertex.y != null) newVertex.setY(vertex.y);
                    numberOfGroups++;
                }
            }
            
            for (Vertex vertex: getVertices()) {
                if (vertex.getParent() != null) {
                    log("loadtopology: setting parent of " + vertex + " to " + vertex.getParent());
                    setParent(vertex, vertex.getParent());
                }
            }
            log("Found " + numberOfGroups + " groups");
        } else {
            log("loadtopology: could not load topology configFile:" + m_configurationFile);
        }
    }

