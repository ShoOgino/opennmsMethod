    //@Transactional
    private void loadtopology() throws MalformedURLException, JAXBException {
        log("loadtopology: Clear " + VertexProvider.class.getSimpleName());
        clearVertices();
        log("loadtopology: Clear " + EdgeProvider.class.getSimpleName());
        clearVertices();

        Map<String, Vertex> vertexes = new HashMap<String,Vertex>();
        List<Edge> edges = new ArrayList<Edge>();
        for (DataLinkInterface link: m_dataLinkInterfaceDao.findAll()) {
            log("loadtopology: parsing link: " + link.getDataLinkInterfaceId());

            OnmsNode node = m_nodeDao.get(link.getNode().getId());
            //OnmsNode node = link.getNode();
            log("loadtopology: found node: " + node.getLabel());
            String sourceId = node.getNodeId();
            Vertex source;
            if ( vertexes.containsKey(sourceId)) {
                source = vertexes.get(sourceId);
            } else {
                log("loadtopology: adding source as vertex: " + node.getLabel());
                source = getVertex(node);
                vertexes.put(sourceId, source);
            }

            OnmsNode parentNode = m_nodeDao.get(link.getNodeParentId());
            log("loadtopology: found parentnode: " + parentNode.getLabel());
                       String targetId = parentNode.getNodeId();
            Vertex target;
            if (vertexes.containsKey(targetId)) {
                target = vertexes.get(targetId);
            } else {
                log("loadtopology: adding target as vertex: " + parentNode.getLabel());
                target = getVertex(parentNode);
                vertexes.put(targetId, target);
            }
            AbstractEdge edge = new AbstractEdge(TOPOLOGY_NAMESPACE_LINKD, link.getDataLinkInterfaceId(),source,target); 
            edge.setTooltipText(getEdgeTooltipText(link,source,target));
            edges.add(edge);
        }
        
        log("loadtopology: isAddNodeWithoutLink: " + isAddNodeWithoutLink());
        if (isAddNodeWithoutLink()) {
            for (OnmsNode onmsnode: m_nodeDao.findAll()) {
                log("loadtopology: parsing link less node: " + onmsnode.getLabel());
                String nodeId = onmsnode.getNodeId();
                if (!vertexes.containsKey(nodeId)) {
                    log("loadtopology: adding link less node: " + onmsnode.getLabel());
                    vertexes.put(nodeId,getVertex(onmsnode));
                }                
            }
        }
        
        log("Found " + vertexes.size() + " vertices");
        log("Found " + edges.size() + " edges");

        addVertices(vertexes.values().toArray(new Vertex[0]));
        addEdges(edges.toArray(new Edge[0]));
 
        log("loadtopology: loading topology: configFile:" + m_configurationFile);
        File configFile = new File(m_configurationFile);

        if (configFile.exists() && configFile.canRead()) {
            log("loadtopology: loading topology from configuration file: " + m_configurationFile);
            m_groupCounter = 0;
            WrappedGraph graph = getGraphFromFile(configFile);

            String namespace = graph.m_namespace == null ? TOPOLOGY_NAMESPACE_LINKD : graph.m_namespace;
            if (getVertexNamespace() != namespace) { 
                LoggerFactory.getLogger(this.getClass()).info("Creating new vertex provider with namespace {}", namespace);
                m_vertexProvider = new SimpleVertexProvider(namespace);
            }
            if (getEdgeNamespace() != namespace) { 
                LoggerFactory.getLogger(this.getClass()).info("Creating new edge provider with namespace {}", namespace);
                m_edgeProvider = new SimpleEdgeProvider(namespace);
            }

            // Add all groups to the topology
            int numberOfGroups = 0;
            for (WrappedVertex vertex: graph.m_vertices) {
                if (!vertex.leaf) {
                    log("loadtopology: adding group to topology: " + vertex.id);
                    // Find the highest index group number and start the index for new groups above it
                    try {
                        int groupNumber = Integer.parseInt(vertex.id.substring(LINKD_GROUP_ID_PREFIX.length()));
                        if (m_groupCounter <= groupNumber) {
                            m_groupCounter = groupNumber + 1;
                        }
                    } catch (NumberFormatException e) {
                        // Ignore this group ID since it doesn't conform to our pattern for auto-generated IDs
                    }
                    AbstractVertex newVertex = addGroup(vertex.id, vertex.iconKey, vertex.label);
                    newVertex.setIpAddress(vertex.ipAddr);
                    newVertex.setLocked(vertex.locked);
                    if (vertex.nodeID != null) newVertex.setNodeID(vertex.nodeID);
                    newVertex.setParent(vertex.parent);
                    newVertex.setSelected(vertex.selected);
                    newVertex.setStyleName(vertex.styleName);
                    newVertex.setTooltipText(vertex.tooltipText);
                    if (vertex.x != null) newVertex.setX(vertex.x);
                    if (vertex.y != null) newVertex.setY(vertex.y);
                    numberOfGroups++;
                }
            }
            
            for (Vertex vertex: getVertices()) {
                if (vertex.getParent() != null) {
                    log("loadtopology: setting parent of " + vertex + " to " + vertex.getParent());
                    setParent(vertex, vertex.getParent());
                }
            }
            log("Found " + numberOfGroups + " groups");
        }
    }

