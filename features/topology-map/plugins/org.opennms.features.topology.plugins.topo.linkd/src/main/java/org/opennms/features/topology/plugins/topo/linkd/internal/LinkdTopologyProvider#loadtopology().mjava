    //@Transactional
    private void loadtopology() {
        log("loadtopology: loading topology: configFile:" + m_configurationFile);
        
        log("loadtopology: Clear " + VertexProvider.class.getSimpleName());
        clearVertices();
        log("loadtopology: Clear " + EdgeProvider.class.getSimpleName());
        clearVertices();

        Map<String, Vertex> vertexes = new HashMap<String,Vertex>();
        List<Edge> edges = new ArrayList<Edge>();
        for (DataLinkInterface link: m_dataLinkInterfaceDao.findAll()) {
            log("loadtopology: parsing link: " + link.getDataLinkInterfaceId());

            OnmsNode node = m_nodeDao.get(link.getNode().getId());
            //OnmsNode node = link.getNode();
            log("loadtopology: found node: " + node.getLabel());
            String sourceId = node.getNodeId();
            Vertex source;
            if ( vertexes.containsKey(sourceId)) {
                source = vertexes.get(sourceId);
            } else {
                log("loadtopology: adding source as vertex: " + node.getLabel());
                source = getVertex(node);
                vertexes.put(sourceId, source);
            }

            OnmsNode parentNode = m_nodeDao.get(link.getNodeParentId());
            log("loadtopology: found parentnode: " + parentNode.getLabel());
                       String targetId = parentNode.getNodeId();
            Vertex target;
            if (vertexes.containsKey(targetId)) {
                target = vertexes.get(targetId);
            } else {
                log("loadtopology: adding target as vertex: " + parentNode.getLabel());
                target = getVertex(parentNode);
                vertexes.put(targetId, target);
            }
            AbstractEdge edge = new AbstractEdge(TOPOLOGY_NAMESPACE_LINKD, link.getDataLinkInterfaceId(),source,target); 
            edge.setTooltipText(getEdgeTooltipText(link,source,target));
            edges.add(edge);
        }
        
        log("loadtopology: isAddNodeWithoutLink: " + isAddNodeWithoutLink());
        if (isAddNodeWithoutLink()) {
            for (OnmsNode onmsnode: m_nodeDao.findAll()) {
                log("loadtopology: parsing link less node: " + onmsnode.getLabel());
                String nodeId = onmsnode.getNodeId();
                if (!vertexes.containsKey(nodeId)) {
                    log("loadtopology: adding link less node: " + onmsnode.getLabel());
                    vertexes.put(nodeId,getVertex(onmsnode));
                }                
            }
        }
        
        log("Found " + vertexes.size() + " vertices");
        log("Found " + edges.size() + " edges");

                
        addVertices(vertexes.values().toArray(new Vertex[] {}));
        addEdges(edges.toArray(new Edge[] {}));
 
        File configFile = new File(m_configurationFile);

        int numberOfGroups = 0;
        if (configFile.exists() && configFile.canRead()) {
            log("loadtopology: loading topology from configuration file: " + m_configurationFile);
            m_groupCounter = 0;
            WrappedGraph graph = getGraphFromFile(configFile);
            // Add all groups to the topology
            for (WrappedVertex vertex: graph.m_vertices) {
                if (!vertex.leaf) {
                    log("loadtopology: adding group to topology: " + vertex.id);
                    // Find the highest index group number and start the index for new groups above it
                    try {
                        int groupNumber = Integer.parseInt(vertex.id.substring(LINKD_GROUP_ID_PREFIX.length()));
                        if (m_groupCounter <= groupNumber) {
                            m_groupCounter = groupNumber + 1;
                        }
                    } catch (NumberFormatException e) {
                        // Ignore this group ID since it doesn't conform to our pattern for auto-generated IDs
                    }
                    addGroup(vertex.id, vertex.iconKey, vertex.label);
                    numberOfGroups++;
                }
            }
            
            for (WrappedVertex vertex: graph.m_vertices) {
                log("loadtopology: setting parent of " + vertex + " to " + vertex.parent);
                setParent(vertex, vertex.parent);
            }

        }
        log("Found " + numberOfGroups + " groups");
    }

