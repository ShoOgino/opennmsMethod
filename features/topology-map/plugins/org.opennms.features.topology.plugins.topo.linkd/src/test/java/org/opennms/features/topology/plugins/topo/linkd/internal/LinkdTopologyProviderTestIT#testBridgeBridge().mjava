    /**
     * We expect the following topology:
     *
     *                      bridge0
     *                         |
     *           ----------------------------------------
     *           |          |          |        |       |
     *        bridge1    bridge3    bridge4  bridge5  Macs/Ip
     *           |          |                         no node
     *        -------    --------
     *        |          |      |
     *     Segment     host8    host9
     *   -----------
     *   |         |
     * Macs/Ip  bridge2
     * no node     |
     *          Segment
     */

    @Test
    @Transactional
    public void testBridgeBridge() throws Exception {
        // The testing of bridge topologies is a bit different thean for the other protocols since we have a hierarchical
        // topology with different node types.


        // 1.) Generate Topology
        TopologySettings settings = TopologySettings.builder()
                .protocol(TopologyGenerator.Protocol.bridge)
                .amountNodes(10)
                .build();
        generateTopologyAndRefreshCaches(settings);
        assertEquals(settings.getAmountNodes(), linkdTopologyProvider.getVerticesWithoutGroups().size());

        // 2.) map the nodes by it's label name.
        final Map<String, Vertex> vertices = new HashMap<>();
        for(Vertex vertex : linkdTopologyProvider.getVerticesWithoutGroups()) {
            String label = vertex.getLabel();
            if("Segment".equals(label)) { // enhance Segment to make it unique
                label = StringUtils.substringAfter(vertex.getTooltipText(), "nodeid:["); // Shared Segment': nodeid:[13561], bridgeport
                label = StringUtils.substringBefore(label, "]");
                label = "Segment[nodeid:"+label+"]";
            } else if (label.contains("without node")) {
                // shared addresses: ([000000000007, 000000000008]ip:[0.0.0.1 ], mac:[000000000005]ip:[0.0.0.2 ], mac:[000000000006])(Unknown/Not an OpenNMS Node)
                label = StringUtils.substringAfter(vertex.getTooltipText(), "shared addresses: ([");
                label = StringUtils.substringBefore(label, ",");
                label = "NoNode["+label+"]";
            }
            vertices.put(label, vertex);
        }


        // 3.) Linking between hosts and bridges
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("node1"));
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("node3"));
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("node4"));
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("node5"));

        verifyLinkingBetweenNodes(vertices.get("node3"), vertices.get("node8"));
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("node9"));

        // 4. Linking with Segments, Unknown nodes
        verifyLinkingBetweenNodes(vertices.get("node0"), vertices.get("NoNode[000000000007]"));
        verifyLinkingBetweenNodes(vertices.get("Segment[nodeid:13561]"), vertices.get("NoNode[00000000000e]"));
    }

