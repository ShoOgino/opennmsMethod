    private void load(final URI source, final WrappedGraph graph) {
        String namespace = graph.m_namespace == null ? TOPOLOGY_NAMESPACE_VMWARE : graph.m_namespace;
        if (getVertexNamespace() != namespace) {
            m_vmwareLog.info("Creating new vertex provider with namespace {}", namespace);
            m_vertexProvider = new SimpleVertexProvider(namespace);
        }
        if (getEdgeNamespace() != namespace) {
            m_vmwareLog.info("Creating new edge provider with namespace {}", namespace);
            m_edgeProvider = new SimpleEdgeProvider(namespace);
        }

        clearVertices();
        for (WrappedVertex vertex : graph.m_vertices) {
            if (vertex.namespace == null) {
                vertex.namespace = getVertexNamespace();
                m_vmwareLog.warn("Setting namespace on vertex to default: {}", vertex);
            }

            if (vertex.id == null) {
                m_vmwareLog.warn("Invalid vertex unmarshalled from {}: {}", source.toString(), vertex);
            } else if (vertex.id.startsWith(SIMPLE_GROUP_ID_PREFIX)) {
                try {
                    // Find the highest index group number and start the index for new groups above it
                    int groupNumber = Integer.parseInt(vertex.id.substring(SIMPLE_GROUP_ID_PREFIX.length()));
                    if (m_groupCounter <= groupNumber) {
                        m_groupCounter = groupNumber + 1;
                    }
                } catch (NumberFormatException e) {
                    // Ignore this group ID since it doesn't conform to our pattern for auto-generated IDs
                }
            }
            AbstractVertex newVertex;
            if (vertex.group) {
                newVertex = new SimpleGroup(vertex.namespace, vertex.id);
                if (vertex.x != null) {
                    newVertex.setX(vertex.x);
                }
                if (vertex.y != null) {
                    newVertex.setY(vertex.y);
                }
            } else {
                newVertex = new SimpleLeafVertex(vertex.namespace, vertex.id, vertex.x, vertex.y);
            }
            newVertex.setIconKey(vertex.iconKey);
            newVertex.setIpAddress(vertex.ipAddr);
            newVertex.setLabel(vertex.label);
            newVertex.setLocked(vertex.locked);
            if (vertex.nodeID != null) {
                newVertex.setNodeID(vertex.nodeID);
            }
            newVertex.setParent(vertex.parent);
            newVertex.setSelected(vertex.selected);
            newVertex.setStyleName(vertex.styleName);
            newVertex.setTooltipText(vertex.tooltipText);
            addVertices(newVertex);
        }

        clearEdges();
        for (WrappedEdge edge : graph.m_edges) {
            if (edge.namespace == null) {
                edge.namespace = getEdgeNamespace();
                m_vmwareLog.warn("Setting namespace on edge to default: {}", edge);
            }

            if (edge.id == null) {
                m_vmwareLog.warn("Invalid edge unmarshalled from {}: {}", source.toString(), edge);
            } else if (edge.id.startsWith(SIMPLE_EDGE_ID_PREFIX)) {
                try {
                    /*
                     * This code will be necessary if we allow edges to be created

                    // Find the highest index group number and start the index for new groups above it
                    int edgeNumber = Integer.parseInt(edge.getId().substring(SIMPLE_EDGE_ID_PREFIX.length()));

                    if (m_edgeCounter <= edgeNumber) {
                        m_edgeCounter = edgeNumber + 1;
                    }
                    */
                } catch (NumberFormatException e) {
                    // Ignore this edge ID since it doesn't conform to our pattern for auto-generated IDs
                }
            }
            AbstractEdge newEdge = connectVertices(edge.id, edge.source, edge.target);
            newEdge.setLabel(edge.label);
            newEdge.setTooltipText(edge.tooltipText);
            //addEdges(newEdge);
        }

        for (WrappedVertex vertex : graph.m_vertices) {
            if (vertex.parent != null) {
                m_vmwareLog.debug("Setting parent of " + vertex + " to " + vertex.parent);
                setParent(vertex, vertex.parent);
            }
        }
    }

