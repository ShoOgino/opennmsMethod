	@SuppressWarnings("unchecked") // Because Aries Blueprint cannot handle generics
	public NodeTable(String caption, OnmsDaoContainer container) {
		super(caption, container);

		addListener(new HeaderClickListener() {
			public void headerClick(HeaderClickEvent event) {
				NodeDaoContainer nodeContainer = (NodeDaoContainer)getContainerDataSource();
				String column = (String)event.getPropertyId();
				if ("primaryInterface".equals(column)) {
					if (nodeContainer.additionalSorting.size() == 0) {
						nodeContainer.additionalSorting.add(new PrimaryInterfaceAddressComparator());
						setTableSortContainerPropertyId(NodeTable.this, "primaryInterface", true);
					} else if (nodeContainer.additionalSorting.size() == 1) {
						Comparator<OnmsNode> comparator = nodeContainer.additionalSorting.get(0);
						if (comparator instanceof PrimaryInterfaceAddressComparator) {
							nodeContainer.additionalSorting.set(0, new ReverseComparator<OnmsNode>(comparator));
							setTableSortContainerPropertyId(NodeTable.this, "primaryInterface", false);
						} else {
							nodeContainer.additionalSorting.set(0, new PrimaryInterfaceAddressComparator());
							setTableSortContainerPropertyId(NodeTable.this, "primaryInterface", true);
						}
					} else {
						// Unexpected number of comparators in the list...
						nodeContainer.additionalSorting.clear();
						nodeContainer.additionalSorting.add(new PrimaryInterfaceAddressComparator());
						setTableSortContainerPropertyId(NodeTable.this, "primaryInterface", true);
					}
				} else {
					nodeContainer.additionalSorting.clear();
				}

				// We need to refresh the rows even if we are clearing the additionalSorting because 
				// the sorting for the other columns seems to be applied before this listener is fired.
				refreshRowCache();
			}
		});
	}

