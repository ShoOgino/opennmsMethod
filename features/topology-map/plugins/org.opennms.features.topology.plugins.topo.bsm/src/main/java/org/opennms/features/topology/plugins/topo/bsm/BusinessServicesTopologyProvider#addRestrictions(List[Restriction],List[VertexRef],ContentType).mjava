    @Override
    public void addRestrictions(List<Restriction> restrictionList, List<VertexRef> selectedVertices, ContentType container) {
        // only consider vertices of our namespace and of the correct type
        final Set<AbstractBusinessServiceVertex> filteredSet = selectedVertices.stream()
                .filter(e -> TOPOLOGY_NAMESPACE.equals(e.getNamespace()))
                .filter(e -> e instanceof AbstractBusinessServiceVertex)
                .map(e -> (AbstractBusinessServiceVertex) e)
                .collect(Collectors.toSet());
        if (filteredSet.isEmpty()) {
            return;
        }
        switch (container) {
            case Alarm:
                // show alarms with reduction keys associated with the current selection.
                final Set<String> reductionKeys = filteredSet.stream()
                        .map(vertex -> vertex.getReductionKeys())
                        .flatMap(rkSet -> rkSet.stream())
                        .collect(Collectors.toSet());
                if (reductionKeys.isEmpty()) {
                    restrictionList.add(Restrictions.eq("reductionKey", "-1"));
                } else {
                    restrictionList.add(Restrictions.in("reductionKey", reductionKeys));
                }
                break;
            case BusinessService:
                final Set<Long> businessServiceIds = Sets.newHashSet();

                // Business Service
                filteredSet.stream()
                        .filter(v -> v.getType() == Type.BusinessService)
                        .forEach(v -> businessServiceIds.add(((BusinessServiceVertex) v).getServiceId()));

                // Ip Service or Reduction Key
                filteredSet.stream()
                        .filter(v -> v.getType() == Type.IpService
                                || v.getType() == Type.ReductionKey)
                        .forEach(v -> ((BusinessServiceVertex) v.getParent()).getServiceId());

                if (businessServiceIds.isEmpty()) {
                    restrictionList.add(Restrictions.eq("id", -1L));
                } else {
                    restrictionList.add(Restrictions.in("id", businessServiceIds));
                }
                break;
            case Node:
                final Set<Integer> nodeIds = filteredSet.stream()
                        .filter(v -> v.getType() == Type.IpService)
                        .map(v -> businessServiceManager.getIpServiceById(((IpServiceVertex) v).getIpServiceId()).getNodeId())
                        .collect(Collectors.toSet());
                if (nodeIds.isEmpty()) {
                    restrictionList.add(Restrictions.eq("id", -1));
                } else {
                    restrictionList.add(Restrictions.in("id", nodeIds));
                }
                break;
            default:
                throw new IllegalArgumentException(getClass().getSimpleName() + " does not support filtering vertices for vaadin container " + container);
        }
    }

