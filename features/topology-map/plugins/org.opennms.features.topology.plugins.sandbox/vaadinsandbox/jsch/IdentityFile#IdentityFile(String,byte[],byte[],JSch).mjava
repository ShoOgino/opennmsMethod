  private IdentityFile(String name, byte[] prvkey, byte[] pubkey, JSch jsch) throws JSchException{
    this.identity=name;
    this.jsch=jsch;

    // prvkey from "ssh-add" command on the remote.
    if(pubkey==null &&
       prvkey!=null && 
       (prvkey.length>11 &&
        prvkey[0]==0 && prvkey[1]==0 && prvkey[2]==0 && prvkey[3]==7)){

      Buffer buf=new Buffer(prvkey);
      String _type = new String(buf.getString()); // ssh-rsa

      if(_type.equals("ssh-rsa")){
        type=RSA;
        n_array=buf.getString();
        e_array=buf.getString();
        d_array=buf.getString();
        buf.getString();
        buf.getString();
        buf.getString();
        this.identity += new String(buf.getString());
      }
      else if(_type.equals("ssh-dss")){
        type=DSS;
        P_array=buf.getString();
        Q_array=buf.getString();
        G_array=buf.getString();
        pub_array=buf.getString();
        prv_array=buf.getString();
        this.identity += new String(buf.getString());
      }
      else{
        throw new JSchException("privatekey: invalid key "+new String(prvkey, 4, 7));
      }
      encoded_data=prvkey;
      encrypted=false;
      keytype=OPENSSH;
      return;
    }

    /* TODO: IdentityFile should use KeyPair.
     * The following logic exists also in KeyPair. It is redundant.
     */
    try{
      Class c;
      c=Class.forName((String)jsch.getConfig("3des-cbc"));
      cipher=(Cipher)(c.newInstance());
      key=new byte[cipher.getBlockSize()];   // 24
      iv=new byte[cipher.getIVSize()];       // 8
      c=Class.forName((String)jsch.getConfig("md5"));
      hash=(HASH)(c.newInstance());
      hash.init();

      byte[] buf=prvkey;
      int len=buf.length;

      int i=0;

      while(i<len){
        if(buf[i] == '-' && i+4<len && 
           buf[i+1] == '-' && buf[i+2] == '-' && 
           buf[i+3] == '-' && buf[i+4] == '-'){
          break;
        }
        i++;
      }

      while(i<len){
        if(buf[i]=='B'&& i+3<len && buf[i+1]=='E'&& buf[i+2]=='G'&& buf[i+3]=='I'){
          i+=6;	    
          if(buf[i]=='D'&& buf[i+1]=='S'&& buf[i+2]=='A'){ type=DSS; }
	  else if(buf[i]=='R'&& buf[i+1]=='S'&& buf[i+2]=='A'){ type=RSA; }
	  else if(buf[i]=='S'&& buf[i+1]=='S'&& buf[i+2]=='H'){ // FSecure
	    type=UNKNOWN;
	    keytype=FSECURE;
	  }
	  else{
            //System.err.println("invalid format: "+identity);
	    throw new JSchException("invalid privatekey: "+identity);
	  }
          i+=3;
	  continue;
	}
        if(buf[i]=='A'&& i+7<len && buf[i+1]=='E'&& buf[i+2]=='S'&& buf[i+3]=='-' && 
           buf[i+4]=='2'&& buf[i+5]=='5'&& buf[i+6]=='6'&& buf[i+7]=='-'){
          i+=8;
          if(Session.checkCipher((String)jsch.getConfig("aes256-cbc"))){
            c=Class.forName((String)jsch.getConfig("aes256-cbc"));
            cipher=(Cipher)(c.newInstance());
            key=new byte[cipher.getBlockSize()];
            iv=new byte[cipher.getIVSize()];
          }
          else{
            throw new JSchException("privatekey: aes256-cbc is not available "+identity);
          }
          continue;
        }
        if(buf[i]=='A'&& i+7<len && buf[i+1]=='E'&& buf[i+2]=='S'&& buf[i+3]=='-' && 
           buf[i+4]=='1'&& buf[i+5]=='9'&& buf[i+6]=='2'&& buf[i+7]=='-'){
          i+=8;
          if(Session.checkCipher((String)jsch.getConfig("aes192-cbc"))){
            c=Class.forName((String)jsch.getConfig("aes192-cbc"));
            cipher=(Cipher)(c.newInstance());
            key=new byte[cipher.getBlockSize()];
            iv=new byte[cipher.getIVSize()];
          }
          else{
            throw new JSchException("privatekey: aes192-cbc is not available "+identity);
          }
          continue;
        }
        if(buf[i]=='A'&& i+7<len && buf[i+1]=='E'&& buf[i+2]=='S'&& buf[i+3]=='-' && 
           buf[i+4]=='1'&& buf[i+5]=='2'&& buf[i+6]=='8'&& buf[i+7]=='-'){
          i+=8;
          if(Session.checkCipher((String)jsch.getConfig("aes128-cbc"))){
            c=Class.forName((String)jsch.getConfig("aes128-cbc"));
            cipher=(Cipher)(c.newInstance());
            key=new byte[cipher.getBlockSize()];
            iv=new byte[cipher.getIVSize()];
          }
          else{
            throw new JSchException("privatekey: aes128-cbc is not available "+identity);
          }
          continue;
        }
        if(buf[i]=='C'&& i+3<len && buf[i+1]=='B'&& buf[i+2]=='C'&& buf[i+3]==','){
          i+=4;
	  for(int ii=0; ii<iv.length; ii++){
            iv[ii]=(byte)(((a2b(buf[i++])<<4)&0xf0)+
			  (a2b(buf[i++])&0xf));
  	  }
	  continue;
	}
	if(buf[i]==0x0d && i+1<len && buf[i+1]==0x0a){
	  i++;
	  continue;
	}
	if(buf[i]==0x0a && i+1<len){
	  if(buf[i+1]==0x0a){ i+=2; break; }
	  if(buf[i+1]==0x0d &&
	     i+2<len && buf[i+2]==0x0a){
	     i+=3; break;
	  }
	  boolean inheader=false;
	  for(int j=i+1; j<len; j++){
	    if(buf[j]==0x0a) break;
	    //if(buf[j]==0x0d) break;
	    if(buf[j]==':'){inheader=true; break;}
	  }
	  if(!inheader){
	    i++; 
	    encrypted=false;    // no passphrase
	    break;
	  }
	}
	i++;
      }

      if(type==ERROR){
	throw new JSchException("invalid privatekey: "+identity);
      }

      int start=i;
      while(i<len){
        if(buf[i]==0x0a){
	  boolean xd=(buf[i-1]==0x0d);
          System.arraycopy(buf, i+1, 
			   buf, 
			   i-(xd ? 1 : 0), 
			   len-i-1-(xd ? 1 : 0)
			   );
	  if(xd)len--;
          len--;
          continue;
        }
        if(buf[i]=='-'){  break; }
        i++;
      }
      encoded_data=Util.fromBase64(buf, start, i-start);

      if(encoded_data.length>4 &&            // FSecure
	 encoded_data[0]==(byte)0x3f &&
	 encoded_data[1]==(byte)0x6f &&
	 encoded_data[2]==(byte)0xf9 &&
	 encoded_data[3]==(byte)0xeb){

	Buffer _buf=new Buffer(encoded_data);
	_buf.getInt();  // 0x3f6ff9be
	_buf.getInt();
	byte[]_type=_buf.getString();
	//System.err.println("type: "+new String(_type)); 
	byte[] _cipher=_buf.getString();
	String cipher=Util.byte2str(_cipher);
	//System.err.println("cipher: "+cipher); 
	if(cipher.equals("3des-cbc")){
  	   _buf.getInt();
	   byte[] foo=new byte[encoded_data.length-_buf.getOffSet()];
	   _buf.getByte(foo);
	   encoded_data=foo;
	   encrypted=true;
	   throw new JSchException("unknown privatekey format: "+identity);
	}
	else if(cipher.equals("none")){
  	   _buf.getInt();
  	   //_buf.getInt();

           encrypted=false;

	   byte[] foo=new byte[encoded_data.length-_buf.getOffSet()];
	   _buf.getByte(foo);
	   encoded_data=foo;
	}

      }

      if(pubkey==null){
        return;
      }
      
      buf=pubkey;
      len=buf.length;

      if(buf.length>4 &&             // FSecure's public key
	 buf[0]=='-' && buf[1]=='-' && buf[2]=='-' && buf[3]=='-'){
	i=0;
	do{i++;}while(len>i && buf[i]!=0x0a);
	if(len<=i) return;
	while(i<len){
	  if(buf[i]==0x0a){
	    boolean inheader=false;
	    for(int j=i+1; j<len; j++){
	      if(buf[j]==0x0a) break;
	      if(buf[j]==':'){inheader=true; break;}
	    }
	    if(!inheader){
	      i++; 
	      break;
	    }
	  }
	  i++;
	}
	if(len<=i) return;

	start=i;
	while(i<len){
	  if(buf[i]==0x0a){
	    System.arraycopy(buf, i+1, buf, i, len-i-1);
	    len--;
	    continue;
	  }
	  if(buf[i]=='-'){  break; }
	  i++;
	}
	publickeyblob=Util.fromBase64(buf, start, i-start);

	if(type==UNKNOWN && publickeyblob.length>8){
	  if(publickeyblob[8]=='d'){
	    type=DSS;
	  }
	  else if(publickeyblob[8]=='r'){
	    type=RSA;
	  }
	}
      }
      else{
	if(buf[0]!='s'|| buf[1]!='s'|| buf[2]!='h'|| buf[3]!='-') return;
	i=0;
	while(i<len){ if(buf[i]==' ')break; i++;} i++;
	if(i>=len) return;
	start=i;
	while(i<len){ if(buf[i]==' ' || buf[i]=='\n')break; i++;}
	publickeyblob=Util.fromBase64(buf, start, i-start);
        if(publickeyblob.length<4+7){  // It must start with "ssh-XXX".
          if(JSch.getLogger().isEnabled(Logger.WARN)){
            JSch.getLogger().log(Logger.WARN, 
                                 "failed to parse the public key");
          }
          publickeyblob=null;
        }
      }
    }
    catch(Exception e){
      //System.err.println("IdentityFile: "+e);
      if(e instanceof JSchException) throw (JSchException)e;
      if(e instanceof Throwable)
        throw new JSchException(e.toString(), (Throwable)e);
      throw new JSchException(e.toString());
    }
  }

