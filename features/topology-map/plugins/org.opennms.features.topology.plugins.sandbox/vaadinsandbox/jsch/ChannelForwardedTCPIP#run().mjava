  public void run(){
    try{ 
      if(lport==-1){
        Class c=Class.forName(target);
        daemon=(ForwardedTCPIPDaemon)c.newInstance();

        PipedOutputStream out=new PipedOutputStream();
        io.setInputStream(new PassiveInputStream(out
                                                 , 32*1024
                                                 ), false);

        daemon.setChannel(this, getInputStream(), out);
        Object[] foo=getPort(getSession(), rport);
        daemon.setArg((Object[])foo[3]);

        new Thread(daemon).start();
      }
      else{
        socket=(factory==null) ? 
           Util.createSocket(target, lport, TIMEOUT) : 
          factory.createSocket(target, lport);
        socket.setTcpNoDelay(true);
        io.setInputStream(socket.getInputStream());
        io.setOutputStream(socket.getOutputStream());
      }
      sendOpenConfirmation();
    }
    catch(Exception e){
      sendOpenFailure(SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);
      close=true;
      disconnect();
      return; 
    }

    thread=Thread.currentThread();
    Buffer buf=new Buffer(rmpsize);
    Packet packet=new Packet(buf);
    int i=0;
    try{
      Session _session = getSession();
      while(thread!=null && 
            io!=null && 
            io.in!=null){
        i=io.in.read(buf.buffer, 
                     14, 
                     buf.buffer.length-14
                     -Session.buffer_margin
                     );
        if(i<=0){
          eof();
          break;
        }
        packet.reset();
        buf.putByte((byte)Session.SSH_MSG_CHANNEL_DATA);
        buf.putInt(recipient);
        buf.putInt(i);
        buf.skip(i);
        synchronized(this){
          if(close)
            break;
          _session.write(packet, this, i);
        }
      }
    }
    catch(Exception e){
      //System.err.println(e);
    }
    //thread=null;
    //eof();
    disconnect();
  }

