  /**
   * List files specified by the remote <code>path</code>.
   * Each files and directories will be passed to
   * <code>LsEntrySelector#select(LsEntry)</code> method, and if that method
   * returns <code>LsEntrySelector#BREAK</code>, the operation will be
   * canceled immediately.
   *
   * @see #LsEntrySelector
   * @since 0.1.47
   */
   public void ls(String path, LsEntrySelector selector) throws SftpException{
     //System.out.println("ls: "+path);
     try{
       ((MyPipedInputStream)io_in).updateReadSide();

       path=remoteAbsolutePath(path);
       byte[] pattern=null;
       java.util.Vector v=new java.util.Vector();

       int foo=path.lastIndexOf('/');
       String dir=path.substring(0, ((foo==0)?1:foo));
       String _pattern=path.substring(foo+1);
       dir=Util.unquote(dir);

       // If pattern has included '*' or '?', we need to convert
       // to UTF-8 string before globbing.
       byte[][] _pattern_utf8=new byte[1][];
       boolean pattern_has_wildcard=isPattern(_pattern, _pattern_utf8);

       if(pattern_has_wildcard){
         pattern=_pattern_utf8[0];
       }
       else{
         String upath=Util.unquote(path);
         //SftpATTRS attr=_lstat(upath);
         SftpATTRS attr=_stat(upath);
         if(attr.isDir()){
           pattern=null;
           dir=upath;
         }
         else{
           /*
             // If we can generage longname by ourself,
             // we don't have to use openDIR.
           String filename=Util.unquote(_pattern);
           String longname=...
           v.addElement(new LsEntry(filename, longname, attr));
           return v;
           */

           if(fEncoding_is_utf8){
             pattern=_pattern_utf8[0];
             pattern=Util.unquote(pattern);
           }
           else{
             _pattern=Util.unquote(_pattern);
             pattern=Util.str2byte(_pattern, fEncoding);
           }

         }
       }

       sendOPENDIR(Util.str2byte(dir, fEncoding));

       Header header=new Header();
       header=header(buf, header);
       int length=header.length;
       int type=header.type;

       fill(buf, length);

       if(type!=SSH_FXP_STATUS && type!=SSH_FXP_HANDLE){
         throw new SftpException(SSH_FX_FAILURE, "");
       }
       if(type==SSH_FXP_STATUS){
         int i=buf.getInt();
         throwStatusError(buf, i);
       }

       int cancel = LsEntrySelector.CONTINUE;
       byte[] handle=buf.getString();         // handle

       while(cancel==LsEntrySelector.CONTINUE){

         sendREADDIR(handle);

         header=header(buf, header);
         length=header.length;
         type=header.type;
         if(type!=SSH_FXP_STATUS && type!=SSH_FXP_NAME){
           throw new SftpException(SSH_FX_FAILURE, "");
         }
         if(type==SSH_FXP_STATUS){ 
           fill(buf, length);
           int i=buf.getInt();
           if(i==SSH_FX_EOF)
             break;
           throwStatusError(buf, i);
         }

         buf.rewind();
         fill(buf.buffer, 0, 4); length-=4;
         int count=buf.getInt();

         byte[] str;
         int flags;

         buf.reset();
         while(count>0){
           if(length>0){
             buf.shift();
             int j=(buf.buffer.length>(buf.index+length)) ? 
               length : 
               (buf.buffer.length-buf.index);
             int i=fill(buf.buffer, buf.index, j);
             buf.index+=i;
             length-=i;
           }
           byte[] filename=buf.getString();
           byte[] longname=null;
           if(server_version<=3){
             longname=buf.getString();
           }
           SftpATTRS attrs=SftpATTRS.getATTR(buf);

           if(cancel==LsEntrySelector.BREAK){
             count--; 
             continue;
           }

           boolean find=false;
           String f=null;
           if(pattern==null){
             find=true;
           }
           else if(!pattern_has_wildcard){
             find=Util.array_equals(pattern, filename);
           }
           else{
             byte[] _filename=filename;
             if(!fEncoding_is_utf8){
               f=Util.byte2str(_filename, fEncoding);
               _filename=Util.str2byte(f, UTF8);
             }
             find=Util.glob(pattern, _filename);
           }

           if(find){
             if(f==null){
               f=Util.byte2str(filename, fEncoding);
             }
             String l=null;
             if(longname==null){
               // TODO: we need to generate long name from attrs
               //       for the sftp protocol 4(and later).
               l=attrs.toString()+" "+f;
             }
             else{
               l=Util.byte2str(longname, fEncoding);
             }

             cancel = selector.select(new LsEntry(f, l, attrs));
           }

           count--; 
         }
       }
       _sendCLOSE(handle, header);

       /*
       if(v.size()==1 && pattern_has_wildcard){
         LsEntry le=(LsEntry)v.elementAt(0);
         if(le.getAttrs().isDir()){
           String f=le.getFilename();
           if(isPattern(f)){
             f=Util.quote(f);
           }
           if(!dir.endsWith("/")){
             dir+="/";
           }
           v=null;
           return ls(dir+f);
         }
       }
       */

     }
     catch(Exception e){
       if(e instanceof SftpException) throw (SftpException)e;
       if(e instanceof Throwable)
         throw new SftpException(SSH_FX_FAILURE, "", (Throwable)e);
       throw new SftpException(SSH_FX_FAILURE, "");
     }
   }

