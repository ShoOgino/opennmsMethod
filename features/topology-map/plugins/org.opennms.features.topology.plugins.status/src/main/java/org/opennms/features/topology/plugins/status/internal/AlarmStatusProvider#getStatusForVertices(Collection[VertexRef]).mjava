    @Override
    public Map<VertexRef, Status> getStatusForVertices(Collection<VertexRef> vertices) {
        Map<VertexRef, Status> returnMap = new HashMap<VertexRef, Status>();

        // split nodes from groups and others
        List<VertexRef> nodeRefs = getNodeVertexRefs(vertices); // nodes
        List<VertexRef> otherRefs = getOtherVertexRefs(vertices);  // groups

        Map<Integer, VertexRef> nodeIdMap = extractNodeIds(nodeRefs);
        Map<Integer, AlarmSummary> nodeIdToAlarmSummaryMap = getAlarmSummaries(nodeIdMap.keySet()); // calculate status for ALL nodes

        // status for all known node ids
        for (Integer eachNodeId : nodeIdMap.keySet()) {
            AlarmSummary summary = nodeIdToAlarmSummaryMap.get(eachNodeId);
            AlarmStatus status = summary == null ? createIndeterminateStatus() : createStatus(summary);
            VertexRef ref = nodeIdMap.get(eachNodeId);
            returnMap.put(ref, status);

            LoggerFactory.getLogger(getClass()).debug("Status for node '{}' with id '{}' is: {}", ref.getLabel(), ref.getId(), status);
        }

        // calculate status for groups and nodes which are neither grop nor node
        for (VertexRef eachRef : otherRefs) {
            if (isGroup(eachRef)) {
                List<AlarmSummary> alarmSummariesForGroup = new ArrayList<AlarmSummary>();
                List<Vertex> children = getVertexProvider().getChildren(eachRef);
                for (Vertex eachChildren : children) {
                    AlarmSummary eachChildrenAlarmSummary = nodeIdToAlarmSummaryMap.get(eachChildren.getNodeID());
                    if (eachChildrenAlarmSummary != null) {
                        alarmSummariesForGroup.add(eachChildrenAlarmSummary);
                    }
                }

                AlarmStatus groupStatus = calculateAlarmStatusForGroup(alarmSummariesForGroup);
                returnMap.put(eachRef, groupStatus);
            } else {
                returnMap.put(eachRef, createIndeterminateStatus());
            }
        }

        return returnMap;
    }

