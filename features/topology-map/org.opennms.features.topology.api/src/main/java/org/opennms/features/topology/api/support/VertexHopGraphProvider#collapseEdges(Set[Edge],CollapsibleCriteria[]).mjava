	/**
	 * This function assumes that all criteria passed in are marked as collapsed.
	 * @param edges
	 * @param criteria
	 * @return
	 */
	public static Set<Edge> collapseEdges(Set<Edge> edges, CollapsibleCriteria[] criteria) {

		// Make a map of all of the vertices to their new collapsed representations
		Map<VertexRef,Set<Vertex>> vertexToCollapsedVertices = getMapOfVerticesToCollapsedVertices(criteria);

		if (vertexToCollapsedVertices.size() > 0) {
			Set<Edge> retval = new HashSet<Edge>();
			for (Edge edge : edges) {
				// Add the original edge to retval unless we replace it with an edge that points to a
				// collapsed vertex
				boolean addOriginalEdge = true;
	
				// If the source vertex is in the collapsed list...
				Set<Vertex> collapsedVertices = vertexToCollapsedVertices.get(edge.getSource().getVertex());
				if (collapsedVertices != null) {
					for (VertexRef collapsedEndpoint : collapsedVertices) {
						// Add a new edge with the source as the collapsed vertex
						Edge newCollapsedEdge = edge.clone();
						newCollapsedEdge.getSource().setVertex(collapsedEndpoint);
						retval.add(newCollapsedEdge);
					}
					// Since we just added a replacement edge, don't add the original
					addOriginalEdge = false;
				} 
	
				collapsedVertices = vertexToCollapsedVertices.get(edge.getTarget().getVertex());
				if (collapsedVertices != null) {
					for (VertexRef collapsedEndpoint : collapsedVertices) {
						// Add a new edge with the target as the collapsed vertex
						Edge newCollapsedEdge = edge.clone();
						newCollapsedEdge.getTarget().setVertex(collapsedEndpoint);
						retval.add(newCollapsedEdge);
					}
					// Since we just added a replacement edge, don't add the original
					addOriginalEdge = false;
				}
	
				// Add the original edge if it wasn't replaced with an edge to a collapsed vertex
				if (addOriginalEdge) {
					retval.add(edge);
				}
			}
			return retval;
		} else {
			return edges;
		}
	}

