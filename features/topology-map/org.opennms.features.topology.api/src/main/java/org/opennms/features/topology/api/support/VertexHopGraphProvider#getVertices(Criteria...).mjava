	@Override
	public List<Vertex> getVertices(Criteria... criteria) {

		Set<VertexRef> focusNodes = getFocusNodes(criteria);
		int maxSemanticZoomLevel = getMaxSemanticZoomLevel(criteria);
		
		// Clear the existing semantic zoom level values
		m_semanticZoomLevels.clear();
		int semanticZoomLevel = 0;

		// If we didn't find any matching nodes among the focus nodes...
		if (focusNodes.size() < 1) {
			// ...then return an empty list of vertices
			return Collections.emptyList();
		}
		

		Map<VertexRef, Set<VertexRef>> neighborMap = new HashMap<VertexRef, Set<VertexRef>>();
		List<Edge> edges = m_delegate.getEdges(criteria);
		for(Edge edge : edges) {
			VertexRef src = edge.getSource().getVertex();
			VertexRef tgt = edge.getTarget().getVertex();
			Set<VertexRef> srcNeighbors = neighborMap.get(src);
			if (srcNeighbors == null) {
				srcNeighbors = new HashSet<VertexRef>();
				neighborMap.put(src, srcNeighbors);
			}
			srcNeighbors.add(tgt);
			
			Set<VertexRef> tgtNeighbors = neighborMap.get(tgt);
			if (tgtNeighbors == null) {
				tgtNeighbors = new HashSet<VertexRef>();
				neighborMap.put(tgt, tgtNeighbors);
			}
			tgtNeighbors.add(src);
		}
		
		Set<Vertex> processed = new HashSet<Vertex>();
		Set<VertexRef> neighbors = new HashSet<VertexRef>();
		Set<VertexRef> workingSet = new HashSet<VertexRef>(focusNodes);
		// Put a limit on the SZL in case we infinite loop for some reason
		while (semanticZoomLevel < maxSemanticZoomLevel && workingSet.size() > 0) {
			System.err.printf("SZL: %d, hops: %d\n", semanticZoomLevel, workingSet.size());
			neighbors.clear();

			for(VertexRef vertexRef : workingSet) {
				if (m_semanticZoomLevels.containsKey(vertexRef)) {
					throw new IllegalStateException("Calculating semantic zoom level for vertex that has already been calculated: " + vertexRef.toString());
				}
				m_semanticZoomLevels.put(vertexRef, semanticZoomLevel);
                Set<VertexRef> refs = neighborMap.get(vertexRef);
                neighbors.addAll(refs);
				processed.add(getVertex(vertexRef));
			}

			neighbors.removeAll(processed);
			
			workingSet.clear();
			workingSet.addAll(neighbors);

			// Increment the semantic zoom level
			semanticZoomLevel++;
		}

		return new ArrayList<Vertex>(processed);
	}

