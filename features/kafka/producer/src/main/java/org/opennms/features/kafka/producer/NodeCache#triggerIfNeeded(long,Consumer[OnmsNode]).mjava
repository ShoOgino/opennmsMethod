    /**
     * Calls the given consumer with a OnmsNode object corresponding to the given nodeId
     * if no call has been made for this node within the configured timeout.
     *
     * The given node object may be null if no node exists with the given node id.
     * The callback will be done within the context of a read-only transaction.
     * If multiple threads use this function with the same node id, it is possible
     * that multiple callbacks occur before the timeout.
     *
     * @param nodeId db id of the node to query
     * @param consumer callback to issue with the node, if the timeout has not expired since the last callback
     */
    public void triggerIfNeeded(long nodeId, Consumer<OnmsNode> consumer) {
        final long now = System.currentTimeMillis();
        final Long lastUpdated = lastUpdatedByNodeId.get(nodeId);
        if (lastUpdated != null && now - lastUpdated <= timeoutInMs) {
            // No update required
            return;
        }

        sessionUtils.withReadOnlyTransaction(() -> {
            // Lookup the node
            final OnmsNode node = nodeDao.get((int)nodeId);

            // Use the timestamp we gather at the beginning of the function, instead
            // of making another call to System.currentTimeMillis(), even though
            // some time may have passed since
            lastUpdatedByNodeId.put(nodeId, now);

            // We got a node, trigger the consumer while holding the transaction
            // in order to allow relationships to be loaded
            consumer.accept(node);
            return null;
        });
    }

