    private void synchronizeAlarmsWithDB() {
        LOG.debug("Performing alarm synchronization with ktable.");
        try {
            // Retrieve the map of alarms by reduction key from the ktable
            final Map<String, OpennmsModelProtos.Alarm> alarmsInKtableByReductionKey = getAlarms();

            // Perform the synchronization in a single transaction context
            final Long numUpdates = transactionOperations.execute(status -> {
                final Set<String> reductionKeysInKtable = alarmsInKtableByReductionKey.keySet();

                final Map<String, OnmsAlarm> alarmsInDb = alarmDao.findAll().stream()
                        .collect(Collectors.toMap(OnmsAlarm::getReductionKey, a -> a));
                final Set<String> reductionKeysInDb = alarmsInDb.keySet();

                // Push deletes for keys that are in the ktable, but not in the database
                final Set<String> reductionKeysNotInDb = Sets.difference(reductionKeysInKtable, reductionKeysInDb);
                reductionKeysNotInDb.forEach(kafkaProducer::handleDeletedAlarm);

                // Push new entries for keys that are in the database, but not in the ktable
                final Set<String> reductionKeysNotInKtable = Sets.difference(reductionKeysInDb, reductionKeysInKtable);
                reductionKeysNotInKtable.forEach(rkey -> kafkaProducer.handleNewOrUpdatedAlarm(alarmsInDb.get(rkey)));

                // Handle Updates
                final AtomicLong numCommonAlarmsUpdated = new AtomicLong();
                final Set<String> commonReductionKeys = Sets.intersection(reductionKeysInKtable, reductionKeysInDb);
                commonReductionKeys.forEach(rkey -> {
                    final OnmsAlarm dbAlarm = alarmsInDb.get(rkey);
                    final OpennmsModelProtos.Alarm mappedDbAlarm = protobufMapper.toAlarm(dbAlarm).build();
                    final OpennmsModelProtos.Alarm alarmFromKtable = alarmsInKtableByReductionKey.get(rkey);
                    if (!Objects.equals(mappedDbAlarm, alarmFromKtable)) {
                        kafkaProducer.handleNewOrUpdatedAlarm(dbAlarm);
                        numCommonAlarmsUpdated.incrementAndGet();
                    }
                });
                return reductionKeysNotInDb.size() + reductionKeysNotInKtable.size() + numCommonAlarmsUpdated.get();
            });
            LOG.debug("Done performing alarm synchronization with the ktable. Executed {} updates.", numUpdates);
        } catch (Exception e) {
            LOG.error("An error occurred while performing alarm synchronization with the ktable. Will try again after {} ms.",
                    alarmSyncIntervalMs, e);
        }
    }

