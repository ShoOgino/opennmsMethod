    @Override
    public void reload() {
        // Reset existing data
        ruleClassifierMap.clear();
        rulePortList.clear();
        invalidRules.clear();
        portClassifiersCache.invalidateAll();

        // Load all rules and validate them
        final List<Rule> validRules = Lists.newArrayList();
        ruleProvider.getRules().forEach(rule -> {
            try {
                new CombinedClassifier(rule, filterService);
                validRules.add(rule);
            } catch (Exception ex) {
                LoggerFactory.getLogger(getClass()).error("Rule {} is not valid. Ignoring rule.", rule, ex);
                invalidRules.add(rule);
            }
        });

        // Expand omnidirectional rules to reversed ones
        final List<RuleDefinition> rules = validRules.stream()
                .flatMap(rule -> rule.isOmnidirectional() && (rule.hasSrcPortDefinition() || rule.hasSrcAddressDefinition() || rule.hasDstPortDefinition() || rule.hasDstAddressDefinition())
                        ? Stream.of(rule, reverseRule(rule))
                        : Stream.of(rule))
                .collect(Collectors.toList());

        // Rules which are not bound to a src OR dst port are stored here temporarily
        final List<RuleDefinition> anyPortRules = new ArrayList<>();

        // Initialize each element
        for (int i=Rule.MIN_PORT_VALUE; i<=Rule.MAX_PORT_VALUE; i++) {
            rulePortList.add(new ArrayList<>());
        }

        // Technically there are 2^16 * 2^16 combinations, but it is possible to correctly pre-sort the rules
        // by sorting them to all possible ports (2^16 possibilities).
        // In case only src OR dst port is defined, the rule is sorted in the according port.
        // In case src AND dst port are defined, the rule is only sorted by dst port.
        // In case neither src NOR dst port are defined, the rule is applied to ALL ports.
        for (RuleDefinition eachRule : rules) {
            // src AND dst port are defined, only map rule to dst port
            if (eachRule.hasSrcPortDefinition() && eachRule.hasDstPortDefinition()) {
                for (Integer eachPort : new PortValue(eachRule.getDstPort()).getPorts()) {
                    final List<RuleDefinition> portRules = rulePortList.get(eachPort);
                    if (!portRules.contains(eachRule)) {
                        portRules.add(eachRule);
                    }
                }
            } else if (eachRule.hasSrcPortDefinition() || eachRule.hasDstPortDefinition()) {
                // either src or dst is defined
                final PortValue portValue = new PortValue(eachRule.hasDstPortDefinition() ? eachRule.getDstPort() : eachRule.getSrcPort());
                for (Integer eachPort : portValue.getPorts()) {
                    rulePortList.get(eachPort).add(eachRule);
                }
            } else if (!eachRule.hasDstPortDefinition() && !eachRule.hasSrcPortDefinition()) {
                // Special treatment for rules which don't define a src or dst port, which are added ONCE
                // to all ports
                anyPortRules.add(eachRule);
            }
        }

        // Add rules with no port mapping to ALL ports, if not already added
        for (final List<RuleDefinition> theRules : rulePortList) {
            theRules.addAll(anyPortRules);
        }

        // Reduce memory pressure
        anyPortRules.clear();
        rules.clear();

        // Sort rules by position
        for (int i=0; i<rulePortList.size(); i++) {
            final List<RuleDefinition> portRules = rulePortList.get(i);
            portRules.sort(ruleComparator);
        }

        // pre-populate cache
        for (int i=0; i<rulePortList.size(); i++) {
            getClassifiers(i);
        }
    }

