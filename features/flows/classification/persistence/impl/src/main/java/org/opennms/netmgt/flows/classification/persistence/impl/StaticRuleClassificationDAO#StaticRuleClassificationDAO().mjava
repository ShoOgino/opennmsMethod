    public StaticRuleClassificationDAO() throws IOException {
        final InputStream inputStream = StaticRuleClassificationDAO.class.getResourceAsStream("/services");
        final List<String> lines = readFromInputStream(inputStream);

        // key: service/port, value: list of protocols (e.g. tcp, udp)
        final Map<Object[], List<String>> servicePortProtocolMap = new HashMap<>();

        // Parse the documents
        for (String eachLine : lines) {
            LOG.debug("Parsing line '{}'", eachLine);

            // Parse line
            List<String> columns = StreamSupport.stream(Arrays.spliterator(eachLine.split("[ |\t]")), false)
                .filter(column -> !Strings.isNullOrEmpty(column))
                .collect(Collectors.toList())
                .subList(0, 2);

            // If there is a comment in the last column, there was an empty service name
            // (e.g. 24/udp # any private mail system)
            // We skip those for now
            if (columns.get(columns.size()-1).equals("#")) {
                LOG.debug("Skipping line '{}' as it defines an empty service name", eachLine);
                continue;
            }

            // Parse
            final String service = columns.get(0);
            final int port = Integer.parseInt(columns.get(1).split("/")[0]);
            final String protocol = columns.get(1).split("/")[1];

            // Remember
            final Object[] key = new Object[]{service, port};
            servicePortProtocolMap.putIfAbsent(key, new ArrayList<>());
            servicePortProtocolMap.get(key).add(protocol);
        }

        // Convert to rules
        for (Map.Entry<Object[], List<String>> entry :  servicePortProtocolMap.entrySet()) {
            Rule rule = new RuleBuilder()
                    .withName((String) entry.getKey()[0])
                    .withPort((int) entry.getKey()[1])
                    .withProtocol(entry.getValue().stream().collect(Collectors.joining(",")))
                    .build();
            rules.add(rule);
        }
    }

