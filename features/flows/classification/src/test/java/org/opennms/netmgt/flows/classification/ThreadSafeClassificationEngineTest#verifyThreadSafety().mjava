    // Spawn n threads and ensure that each reload()-invocation blocks other threads.
    // The idea is, that n threads are kicked off to reload the engine.
    // The reloading takes about a defined amount of delay in ms.
    // If thread safety is implemented properly, the execution time should be roughly delay * n in ms.
    @Test
    public void verifyThreadSafety() throws InterruptedException, ExecutionException {
        // A reload will always put one rule in place, which simulates heavy loading
        final ClassificationRuleDAO classificationRuleDAO = () -> {
            try {
                Thread.sleep(DELAY_IN_MS);
            } catch (InterruptedException e) {
                throw new RuntimeException("Thread interrupted.", e);
            }
            return Collections.emptyList();
        };

        // Create a thread safe classification engine
        final ClassificationEngine original = new DefaultClassificationEngine(classificationRuleDAO);
        final ClassificationEngine classificationEngine = new ThreadSafeClassificationEngine(original);

        // Kick off the threads
        final ExecutorService executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS);
        final long startTime = System.currentTimeMillis();
        final List<Future> futures = new ArrayList<>();
        for (int i = 0; i < NUMBER_OF_THREADS; i++) {
            final Future<?> future = executor.submit(() -> classificationEngine.reload());
            futures.add(future);
        }

        // Wait for each future to be finished. Also have it throw exception on errors, because the ThreadExecutor otherwise just swallows errors
        for (Future f : futures) {
            f.get();
        }

        // Verify that we actually took as long as we expected (otherwise the threads would not have been blocked accordingly)
        long expectedExecutionTime = DELAY_IN_MS * NUMBER_OF_THREADS;
        executor.awaitTermination(expectedExecutionTime * 2, TimeUnit.MILLISECONDS);
        long executionTime = System.currentTimeMillis() - startTime;
        assertThat(executionTime, Matchers.greaterThanOrEqualTo(expectedExecutionTime));
    }

