    protected static List<Filter> getFiltersFromQueryString(MultivaluedMap<String, String> queryParams) {
        final List<Filter> filters = new ArrayList<>();

        final String start = queryParams.getFirst("start");
        long startMs;
        if (start != null) {
            startMs = Long.parseLong(start);
        } else {
            // 4 hours ago
            startMs = -TimeUnit.HOURS.toMillis(4);
        }

        final String end = queryParams.getFirst("end");
        long endMs;
        if (end != null) {
            endMs = Long.parseLong(end);
        } else {
            // Now
            endMs = System.currentTimeMillis();
        }
        endMs = getEffectiveEnd(endMs);
        startMs = getEffectiveStart(startMs, endMs);
        filters.add(new TimeRangeFilter(startMs, endMs));

        final String ifIndexStr = queryParams.getFirst("ifIndex");
        if (ifIndexStr != null) {
            int ifIndex = Integer.parseInt(ifIndexStr);
            filters.add(new SnmpInterfaceIdFilter(ifIndex));
        }

        final String exporterNodeCriteria = queryParams.getFirst("exporterNode");
        if (exporterNodeCriteria != null) {
            try {
                filters.add(new ExporterNodeFilter(new NodeCriteria(exporterNodeCriteria)));
            } catch (IllegalArgumentException e) {
                throw new BadRequestException("Invalid node criteria: " + exporterNodeCriteria);
            }
        }

        final List<String> tosStr = queryParams.get("tos");
        if (isNotEmpty(tosStr)) {
            filters.add(new TosFilter(tosStr.stream().map(Integer::parseInt).collect(Collectors.toList())));
        }

        final List<String> dscpStr = queryParams.get("dscp");
        if (isNotEmpty(dscpStr)) {
            filters.add(new DscpFilter(dscpStr.stream().map(Integer::parseInt).collect(Collectors.toList())));
        }

        final List<String> ecnStr = queryParams.get("ecn");
        if (isNotEmpty(ecnStr)) {
            filters.add(new EcnFilter(ecnStr.stream().map(Integer::parseInt).collect(Collectors.toList())));
        }

        return filters;
    }

