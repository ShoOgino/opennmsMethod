    private CompletableFuture<Table<Directional<String>, Long, Double>> getSeriesFor(Set<String> entities,
                                                                                     String groupByTerm,
                                                                                     long step,
                                                                                     boolean includeOther,
                                                                                     List<Filter> filters) {
        Objects.requireNonNull(groupByTerm);

        if (entities == null || entities.isEmpty()) {
            return CompletableFuture.completedFuture(null);
        }

        final TimeRangeFilter timeRangeFilter = getRequiredTimeRangeFilter(filters);
        final String seriesFromQuery = searchQueryProvider.getSeriesFromQuery(entities, step,
                timeRangeFilter.getStart(), timeRangeFilter.getEnd(), groupByTerm, filters);
        CompletableFuture<ImmutableTable.Builder<Directional<String>, Long, Double>> seriesFuture;

        seriesFuture = searchAsync(seriesFromQuery, timeRangeFilter)
                .thenApply(res -> {
                    final ImmutableTable.Builder<Directional<String>, Long, Double> builder = ImmutableTable.builder();
                    toTable(builder, res);
                    return builder;
                });

        if (includeOther) {
            // We also want to gather series for all other terms
            final String seriesFromOthersQuery = searchQueryProvider.getSeriesFromOthersQuery(entities, step,
                    timeRangeFilter.getStart(), timeRangeFilter.getEnd(), groupByTerm, false, filters);
            seriesFuture = seriesFuture.thenCombine(searchAsync(seriesFromOthersQuery, timeRangeFilter),
                    (builder, res) -> processOthersResult(res, builder));
        }

        return seriesFuture.thenApply(builder -> builder.build());
    }

