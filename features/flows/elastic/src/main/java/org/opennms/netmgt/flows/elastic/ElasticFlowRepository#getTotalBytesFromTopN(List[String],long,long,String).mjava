    private CompletableFuture<List<TrafficSummary<String>>> getTotalBytesFromTopN(List<String> topN, long start, long end, String groupByTerm) {
        final String query = searchQueryProvider.getTotalBytesFromTopNQuery(topN, start, end, groupByTerm);
        return searchAsync(query).thenApply(res -> {
            // Build the traffic summaries from the search results
            final Map<String, TrafficSummary<String>> summaries = new HashMap<>();
            final MetricAggregation aggs = res.getAggregations();
            final TermsAggregation groupedBy = aggs.getTermsAggregation("grouped_by");
            for (TermsAggregation.Entry bucket : groupedBy.getBuckets()) {
                final TrafficSummary<String> trafficSummary = new TrafficSummary<>(bucket.getKey());
                final TermsAggregation directionAgg = bucket.getTermsAggregation("direction");
                for (TermsAggregation.Entry directionBucket : directionAgg.getBuckets()) {
                    final boolean isInitiator = Boolean.valueOf(directionBucket.getKeyAsString());
                    final SumAggregation sumAgg = directionBucket.getSumAggregation("total_bytes");
                    final Double sum = sumAgg.getSum();
                    if (!isInitiator) {
                        trafficSummary.setBytesOut(sum.longValue());
                    } else {
                        trafficSummary.setBytesIn(sum.longValue());
                    }
                }
                summaries.put(bucket.getKey(), trafficSummary);
            }
            // Now build a list in the same order as the given top N list
            final List<TrafficSummary<String>> topNRes = new ArrayList<>(topN.size());
            for (String topNEntry : topN) {
                final TrafficSummary<String> summary = summaries.get(topNEntry);
                if (summary != null) {
                    topNRes.add(summary);
                }
            }
            return topNRes;
        });
    }

