    /** use the convert the results of the proportional_sum aggregation (provided by our ES plugin) to a table */
    private static <T> CompletableFuture<Void> toTableFromBuckets(ImmutableTable.Builder<Directional<T>, Long, Double> builder, Function<String, CompletableFuture<T>> keyToEntity, SearchResult res) {
        final MetricAggregation aggs = res.getAggregations();
        if (aggs == null) {
            // No results
            CompletableFuture.completedFuture(null);
        }
        final TermsAggregation byKeyAgg = aggs.getTermsAggregation("by_key");
        if (byKeyAgg == null) {
            // No results
            CompletableFuture.completedFuture(null);
        }

        final List<CompletableFuture<Void>> buckets = new ArrayList<>();

        for (TermsAggregation.Entry bucket : byKeyAgg.getBuckets()) {
            final ProportionalSumAggregation bytesInAgg = bucket.getAggregation("bytes_in", ProportionalSumAggregation.class);
            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesInAgg.getBuckets()) {
                buckets.add(keyToEntity.apply(bucket.getKey()).thenApply(entity -> {
                    builder.put(new Directional<>(entity, true), dateHistogram.getTime(), dateHistogram.getValue());
                    return null;
                }));
            }
            final ProportionalSumAggregation bytesOutAgg = bucket.getAggregation("bytes_out", ProportionalSumAggregation.class);
            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesOutAgg.getBuckets()) {
                buckets.add(keyToEntity.apply(bucket.getKey()).thenApply(entity -> {
                    builder.put(new Directional<>(entity, false), dateHistogram.getTime(), dateHistogram.getValue());
                    return null;
                }));
            }
        }

        return transpose(buckets, Collectors.reducing(null, (a, b) -> null));
    }

