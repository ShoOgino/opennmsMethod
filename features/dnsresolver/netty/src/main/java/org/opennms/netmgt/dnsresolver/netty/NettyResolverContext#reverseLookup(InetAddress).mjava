    @Override
    public CompletableFuture<Optional<String>> reverseLookup(InetAddress inetAddress) {
        final CompletableFuture<Optional<String>> future = new CompletableFuture<>();
        final String name = ReverseMap.fromAddress(inetAddress).toString();
        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> requestFuture = resolver.query(new DefaultDnsQuestion(name, DnsRecordType.PTR, DnsRecord.CLASS_IN));
        requestFuture.addListener(responseFuture -> {
            try {
                final AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = (AddressedEnvelope<DnsResponse, InetSocketAddress>) responseFuture.get();
                // This shouldn't happen, but just to be safe
                if (envelope == null) {
                    future.completeExceptionally(new Exception("Got a null envelope!"));
                }

                try {
                    final DnsResponse response = envelope.content();
                    if (response.code() != DnsResponseCode.NOERROR) {
                        future.complete(Optional.empty());
                        return;
                    }

                    final DnsPtrRecord ptrRecord = response.recordAt(DnsSection.ANSWER);
                    if (ptrRecord == null) {
                        future.complete(Optional.empty());
                        return;
                    }

                    final String hostname = ptrRecord.hostname();
                    // Strip of the trailing dot
                    final String trimmedHostname = hostname.substring(0, hostname.length() - 1);
                    future.complete(Optional.of(trimmedHostname));
                } finally {
                    envelope.release();
                }
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            } catch (Exception e) {
                if (e.getCause() != null) {
                    // Pass the cause if we can
                    future.completeExceptionally(e.getCause());
                } else {
                    future.completeExceptionally(e);
                }
            }
        });
        return future;
    }

