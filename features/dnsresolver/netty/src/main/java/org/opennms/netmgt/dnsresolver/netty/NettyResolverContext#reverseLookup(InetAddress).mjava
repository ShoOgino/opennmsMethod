    @Override
    public CompletableFuture<Optional<String>> reverseLookup(InetAddress inetAddress) {
        final CompletableFuture<Optional<String>> future = new CompletableFuture<>();
        final String name = ReverseMap.fromAddress(inetAddress).toString();

        // Netty does not perform caching when we query directly for DNS questions i.e. PTR requests
        // so we perform the caching logic ourselves
        final List<? extends DnsCacheEntry> entries = cache.get(name, null);
        if (entries != null) {
            // We've got a hit, so we have some cached result for this entry
            // Try and find a hostname, or return an empty optional if none was found
            final Optional<String> cachedHostname = entries.stream()
                    .filter(e -> e instanceof ExtendedDnsCacheEntry)
                    .map(e -> ((ExtendedDnsCacheEntry)e).hostnameFromPtrRecord())
                    .filter(Objects::nonNull)
                    .findFirst();
            if (cachedHostname.isPresent()) {
                // We found a cached hostname
                return CompletableFuture.completedFuture(Optional.of(removeTrailingDot(cachedHostname.get())));
            } else {
                // No hostname found return an empty result
                return CompletableFuture.completedFuture(Optional.empty());
            }
        }

        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> requestFuture = resolver.query(new DefaultDnsQuestion(name, DnsRecordType.PTR, DnsRecord.CLASS_IN));
        requestFuture.addListener(responseFuture -> {
            try {
                final AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = (AddressedEnvelope<DnsResponse, InetSocketAddress>) responseFuture.get();
                final DnsResponse response = envelope.content();
                if (response.code() != DnsResponseCode.NOERROR) {
                    // Cache the failure (will only be cached if negative-ttl is > 0)
                    cache.cache(name, null, new Exception("Request failed with response code: " + response.code()), group.next());
                    future.complete(Optional.empty());
                    return;
                }

                final DnsPtrRecord ptrRecord = envelope.content().recordAt(DnsSection.ANSWER);
                if (ptrRecord == null) {
                    // Cache the failure (will only be cached if negative-ttl is > 0)
                    cache.cache(name, null, new Exception("No PTR record found."), group.next());
                    future.complete(Optional.empty());
                    return;
                }

                // Cache the result
                cache.cache(name, ptrRecord, group.next());

                final String hostname = ptrRecord.hostname();
                // Strip of the trailing dot
                final String trimmedHostname = removeTrailingDot(hostname);
                future.complete(Optional.of(trimmedHostname));
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            } catch (ExecutionException e) {
                if (e.getCause() != null) {
                    // Pass the cause if we can
                    future.completeExceptionally(e.getCause());
                } else {
                    future.completeExceptionally(e);
                }
            }
        });
        return future;
    }

