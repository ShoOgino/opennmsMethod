    @Override
    public CompletableFuture<Optional<String>> reverseLookup(InetAddress inetAddress) {
        final CompletableFuture<Optional<String>> future = new CompletableFuture<>();
        final String name = ReverseMap.fromAddress(inetAddress).toString();

        // Netty does not perform caching when we query directly for DNS questions i.e. PTR requests
        // so we perform the caching logic ourselves
        final List<? extends DnsCacheEntry> entries = cache.get(name, null);
        if (entries != null) {
            // We've got a hit, so we have some cached result for this entry
            // Try and find a hostname, or return an empty optional if none was found
            final Optional<String> cachedHostname = entries.stream()
                    .filter(e -> e instanceof ExtendedDnsCacheEntry)
                    .map(e -> ((ExtendedDnsCacheEntry)e).hostnameFromPtrRecord())
                    .filter(Objects::nonNull)
                    .findFirst();
            if (cachedHostname.isPresent()) {
                // We found a cached hostname
                return CompletableFuture.completedFuture(Optional.of(removeTrailingDot(cachedHostname.get())));
            } else {
                // No hostname found return an empty result
                return CompletableFuture.completedFuture(Optional.empty());
            }
        }

        // Limit # of concurrent calls using the bulkhead
        bulkhead.acquirePermission();
        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> requestFuture = resolver.query(new DefaultDnsQuestion(name, DnsRecordType.PTR, DnsRecord.CLASS_IN));
        requestFuture.addListener(responseFuture -> {
            try {
                final AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = (AddressedEnvelope<DnsResponse, InetSocketAddress>) responseFuture.get();
                // This shouldn't happen, but just to be safe
                if (envelope == null) {
                    future.completeExceptionally(new Exception("Got a null envelope!"));
                }

                try {
                    final DnsResponse response = envelope.content();
                    if (response.code() != DnsResponseCode.NOERROR) {
                        // Cache the failure (will only be cached if negative-ttl is > 0)
                        cache.cache(name, null, new Exception("Request failed with response code: " + response.code()), group.next());
                        future.complete(Optional.empty());
                        return;
                    }

                    final DnsPtrRecord ptrRecord = response.recordAt(DnsSection.ANSWER);
                    if (ptrRecord == null) {
                        // Cache the failure (will only be cached if negative-ttl is > 0)
                        cache.cache(name, null, new Exception("No PTR record found."), group.next());
                        future.complete(Optional.empty());
                        return;
                    }

                    // Cache the result
                    cache.cache(name, ptrRecord, group.next());

                    final String hostname = ptrRecord.hostname();
                    // Strip of the trailing dot
                    final String trimmedHostname = hostname.substring(0, hostname.length() - 1);
                    future.complete(Optional.of(trimmedHostname));
                } finally {
                    envelope.release();
                }
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            } catch (Exception e) {
                if (e.getCause() != null) {
                    // Pass the cause if we can
                    future.completeExceptionally(e.getCause());
                } else {
                    future.completeExceptionally(e);
                }
            } finally {
                bulkhead.releasePermission();
            }
        });
        return future;
    }

