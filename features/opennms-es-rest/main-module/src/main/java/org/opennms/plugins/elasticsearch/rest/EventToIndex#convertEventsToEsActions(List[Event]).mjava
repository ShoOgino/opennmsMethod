	/** 
	 * <p>This method converts events into a sequence of Elasticsearch index/update commands.
	 * Three types of actions are possible:</p>
	 * <ul>
	 * <li>Updating an alarm document based on an {@link #ALARM_NOTIFICATION_UEI_STEM} event</li>
	 * <li>Indexing the {@link #ALARM_NOTIFICATION_UEI_STEM} events</li>
	 * <li>Indexing all other events</li>
	 * </ul>
	 * 
	 * @param events
	 */
	private List<BulkableAction<DocumentResult>> convertEventsToEsActions(List<Event> events) {

		final List<BulkableAction<DocumentResult>> retval = new ArrayList<>();

		for (Event event : events) {

			maybeRefreshCache(event);

			final String uei = event.getUei();

			// if alarm change notification then handle change
			// change alarm index and add event to alarm change event index
			if(uei.startsWith(ALARM_NOTIFICATION_UEI_STEM)) {
				if (STICKY_MEMO_EVENT.equals(uei)|| JOURNAL_MEMO_EVENT.equals(uei) ){
					// handle memo change events
					// TODO may want to create a sticky and journal memo field in alarms index and update accordingly
					// currently we just save the event as an event to ES with no other processing
					if (LOG.isDebugEnabled()) LOG.debug("Sending Alarm MEMO Event to ES:"+event.toString());

				} else {
					// handle alarm change events

					if (LOG.isDebugEnabled()) {
						if (ALARM_CREATED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Created Event to ES:"+event.toString());
						} else if( ALARM_DELETED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Deleted Event to ES:"+event.toString());
						} else if (ALARM_SEVERITY_CHANGED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Changed Severity Event to ES:"+event.toString());
						} else if (ALARM_CLEARED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Cleared Event to ES:"+event.toString());
						} else if (ALARM_ACKNOWLEDGED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Acknowledged Event to ES:"+event.toString());
						} else if (ALARM_UNACKNOWLEDGED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Unacknowledged Event to ES:"+event.toString());
						} else if (ALARM_SUPPRESSED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Suppressed Event to ES:"+event.toString());
						} else if (ALARM_UNSUPPRESSED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Unsuppressed Event to ES:"+event.toString());
						} else if (ALARM_TROUBLETICKET_STATE_CHANGE_EVENT.equals(uei)){
							LOG.debug("Sending Alarm TroubleTicked state changed Event to ES:"+event.toString());
						} else if (ALARM_CHANGED_EVENT.equals(uei)){
							LOG.debug("Sending Alarm Changed Event to ES:"+event.toString());
						}
					}

					if(archiveAlarms){
						// if an alarm change event, use the alarm change fields to update the alarm index
						Update alarmUpdate = populateAlarmIndexBodyFromAlarmChangeEvent(event, INDEX_NAMES.get(Indices.ALARMS), INDEX_TYPES.get(Indices.ALARMS));
						retval.add(alarmUpdate);
					}
				}

				// save all Alarm Change Events including memo change events
				if(archiveAlarmChangeEvents){
					Index eventIndex = populateEventIndexBodyFromEvent(event, INDEX_NAMES.get(Indices.ALARM_EVENTS), INDEX_TYPES.get(Indices.ALARM_EVENTS));
					retval.add(eventIndex);
				}

			} else {
				// Handle all other event types
				if(archiveRawEvents){
					// only send events to ES if they are persisted to database or logAllEvents is set to true
					if(logAllEvents || (event.getDbid()!=null && event.getDbid()!=0)) {
						Index eventIndex = populateEventIndexBodyFromEvent(event, INDEX_NAMES.get(Indices.EVENTS), INDEX_TYPES.get(Indices.EVENTS));
						retval.add(eventIndex);
					} else {
						if (LOG.isDebugEnabled()) LOG.debug("Not Sending Event to ES: null event.getDbid()="+event.getDbid()+ " Event="+event.toString());
					}
				}
			}
		}

		return retval;
	}

