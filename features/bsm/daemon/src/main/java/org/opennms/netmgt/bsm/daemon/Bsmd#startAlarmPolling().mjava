    private void startAlarmPolling() {
        final long pollInterval = getPollInterval();
        m_alarmPoller = Executors.newScheduledThreadPool(1);
        m_alarmPoller.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                try {
                    LOG.debug("Polling alarm table.");
                    m_template.execute(new TransactionCallbackWithoutResult() {
                        @Override
                        protected void doInTransactionWithoutResult(TransactionStatus status) {
                            final List<AlarmWrapper> alarms = m_alarmDao.findAll().stream()
                                .map(AlarmWrapperImpl::new)
                                .collect(Collectors.toList());
                            if (LOG.isDebugEnabled()) {
                                LOG.debug("Handling {} alarms.", alarms.size());
                                LOG.trace("Handling alarms: {}", alarms);
                            }
                            m_stateMachine.handleAllAlarms(alarms);
                        }
                    });
                } catch (Exception ex) {
                    LOG.error("Error while polling alarm table.", ex);
                } finally {
                    LOG.debug("Polling alarm table complete.");
                }
            }
        }, pollInterval, pollInterval, TimeUnit.SECONDS);
    }

