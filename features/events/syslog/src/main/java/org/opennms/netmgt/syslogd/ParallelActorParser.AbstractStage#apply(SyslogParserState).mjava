		public final SyslogParserState apply(SyslogParserState state) {
			// Reset the accumulator state if necessary
			if (m_resultConsumer != null) {
				state.accumulatedValue = new StringBuffer();
				state.accumulatedSize = new AtomicInteger(0);
			}

			while(true) {
				state.buffer.mark();

				char c;
				try {
					c = (char)state.buffer.get();
				} catch (BufferUnderflowException e) {
					throw new CancellationException(getClass().getSimpleName() + " reached end of buffer, match failed");
				}

				switch (acceptChar(state, c)) {
					case CONTINUE:
						continue;
					case COMPLETE_AFTER_CONSUMING:
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(state));
						}
						// Reset any local state if necessary
						reset(state);
						return state;
					case COMPLETE_WITHOUT_CONSUMING:
						// Put the char back on the deque
						//m_incoming.putFirst(c);
						state.buffer.reset();
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(state));
						}
						// Reset any local state if necessary
						reset(state);
						return state;
					case CANCEL:
						throw new CancellationException(getClass().getSimpleName() + " match failed");
				}
			}
		}

