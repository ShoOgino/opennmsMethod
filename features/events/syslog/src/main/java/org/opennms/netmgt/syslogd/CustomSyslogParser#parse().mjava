    @Override
    public SyslogMessage parse() throws SyslogParserException {
        LOG.info("Message Parse start");
        final SyslogMessage syslogMessage = new SyslogMessage();
        syslogMessage.setParserClass(getClass());

        String message = getText();

        int lbIdx = message.indexOf('<');
        int rbIdx = message.indexOf('>');

        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {
            LOG.warn("Syslogd received an unparsable message!");
            return null;
        }

        int priCode = 0;
        String priStr = message.substring(lbIdx + 1, rbIdx);

        priCode = parseInt(priStr, "ERROR Bad priority code '{}'");

        LOG.trace("priority code = {}", priCode);

        syslogMessage.setFacility(SyslogFacility.getFacilityForCode(priCode));
        syslogMessage.setSeverity(SyslogSeverity.getSeverityForCode(priCode));

        message = message.substring(rbIdx + 1, message.length());

        final Matcher idMatcher = m_messageIdPattern.matcher(message);
        if (idMatcher.find()) {
            final String messageId = idMatcher.group(2);
            LOG.trace("found message ID '{}'", messageId);
            syslogMessage.setMessageID(messageId);
            message = message.substring(idMatcher.group(1).length() - 1);
        }

        LOG.trace("message = {}", message);

        String timestamp;
        Matcher oldDateMatcher = m_oldDatePattern.matcher(message);
        if (oldDateMatcher.find()) {
            LOG.trace("stdMsg = {}", "true");
            timestamp = oldDateMatcher.group(1);
            message = oldDateMatcher.replaceFirst("");
        } else {
            final Matcher stampMatcher = m_datePattern.matcher(message);
            if (stampMatcher.find()) {
                LOG.trace("stdMsg = {}", "false");
                timestamp = stampMatcher.group(2);
                LOG.trace("found timestamp '{}'", timestamp);
                // message = message.substring(stampMatcher.group(1).length());
            } else {
                try {
                    timestamp = SyslogTimeStamp.getInstance().format(new Date());
                } catch (final IllegalArgumentException ex) {
                    LOG.debug("ERROR INTERNAL DATE ERROR!");
                    timestamp = "";
                }
            }
        }

        LOG.trace("timestamp = {}", timestamp);
        syslogMessage.setDate(parseDate(timestamp));

        // These 2 debugs will aid in analyzing the regexes as syslog seems
        // to differ a lot depending on implementation or message structure.

        LOG.trace("message = {}", message);
        LOG.trace("pattern = {}", m_forwardingPattern);
        LOG.trace("host group = {}", m_matchingGroupHost);
        LOG.trace("message group = {}", m_matchingGroupMessage);

        // We will also here find out if, the host needs to
        // be replaced, the message matched to a UEI, and
        // last if we need to actually hide the message.
        // this being potentially helpful in avoiding showing
        // operator a password or other data that should be
        // confidential.

        final Pattern pattern = m_forwardingPattern;
        final Matcher m = pattern.matcher(message);

        /*
         * We matched on a regexp for host/message pair.
         * This can be a forwarded message as in BSD Style
         * or syslog-ng.
         */

        if (m.matches()) {

            final String matchedMessage = m.group(m_matchingGroupMessage);
            syslogMessage.setMatchedMessage(matchedMessage);

            if (LOG.isTraceEnabled()) {
                LOG.trace("Syslog message '{}' matched regexp '{}'", message, m_forwardingPattern);
                LOG.trace("Found host '{}'", m.group(m_matchingGroupHost));
                LOG.trace("Found message '{}'", matchedMessage);
            }

            syslogMessage.setHostName(m.group(m_matchingGroupHost));

            message = matchedMessage;
        } else {
            LOG.debug("Regexp not matched: {}", message);
            return null;
        }

        lbIdx = message.indexOf('[');
        rbIdx = message.indexOf(']');
        final int colonIdx = message.indexOf(':');
        final int spaceIdx = message.indexOf(' ');

        int processId = 0;
        String processName = "";
        String processIdStr = "";

        // If statement has been reversed in order to make the decision faster
        // rather than always calculating lbIdx < (rbIdx - 1) which might fail

        if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0 && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, colonIdx);
            message = message.substring(colonIdx + 2);
        } else if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1) && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, lbIdx);
            processIdStr = message.substring(lbIdx + 1, rbIdx);
            message = message.substring(colonIdx + 2);
            processId = parseInt(processIdStr, "Bad process id '{}'");
        }

        syslogMessage.setProcessId(processId);
        syslogMessage.setProcessName(processName);
        syslogMessage.setMessage(message.trim());

        LOG.info("Message Parse End");
        return syslogMessage;
    }

