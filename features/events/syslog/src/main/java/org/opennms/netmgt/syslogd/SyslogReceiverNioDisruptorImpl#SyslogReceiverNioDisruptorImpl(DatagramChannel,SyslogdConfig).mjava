    /**
     * Construct a new receiver
     *
     * @param sock
     * @param matchPattern
     * @param hostGroup
     * @param messageGroup
     */
    SyslogReceiverNioDisruptorImpl(DatagramChannel channel, SyslogdConfig config) {
        if (channel == null) {
            throw new IllegalArgumentException("Channel cannot be null");
        } else if (config == null) {
            throw new IllegalArgumentException("Config cannot be null");
        }

        m_stop = false;
        m_channel = channel;
        m_config = config;

        // Turn Cassandra client mode on so that we can use the {@link SharedExecutorPool} classes.
        Config.setClientMode(true);

        m_executor = JMXEnabledSharedExecutorPool.SHARED.newExecutor(Runtime.getRuntime().availableProcessors() * 2, Integer.MAX_VALUE, "syslogConnections", "OpenNMS.Syslogd");

        /*
        m_executor = new ThreadPoolExecutor(
            Runtime.getRuntime().availableProcessors() * 2,
            Runtime.getRuntime().availableProcessors() * 2,
            1000L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(),
            new LogPreservingThreadFactory(getClass().getSimpleName(), Integer.MAX_VALUE)
        );
        */

        // This thread pool is used to process {@link DatagramChannel#receive(ByteBuffer)} calls
        // on the syslog port. By using multiple threads, we can optimize the receipt of
        // packet data from the syslog port and avoid discarding UDP syslog packets.
        m_socketReceivers = JMXEnabledSharedExecutorPool.SHARED.newExecutor(SOCKET_RECEIVER_COUNT, Integer.MAX_VALUE, "socketReceivers", "OpenNMS.Syslogd");

        /*
        m_socketReceivers = new ThreadPoolExecutor(
            Runtime.getRuntime().availableProcessors(),
            Runtime.getRuntime().availableProcessors(),
            1000L,
            TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(),
            new LogPreservingThreadFactory(getClass().getSimpleName() + "-SocketReceiver", Integer.MAX_VALUE)
        );
        */

        /*
        // Use an LMAX Disruptor to process incoming packets
        m_disruptor = new Disruptor<SyslogConnection>(SyslogConnection::new, EVENT_CONVERSION_TASK_QUEUE_SIZE, m_executor);
        // Handle each message by enqueuing it on an executor
        m_disruptor.handleEventsWith(
            (event, sequence, endOfBatch) -> 
            WaterfallExecutor.waterfall(m_executor, event)
        );
        m_disruptor.start();
        */

        /*
        // Use an LMAX Disruptor as a ring buffer for incoming packets
        m_packetRingBuffer = new Disruptor<PacketMessage>(PacketMessage::new, SOCKET_BYTE_BUFFER_QUEUE_SIZE, Executors.newCachedThreadPool());
        // Handle each message by enqueuing it on an executor
        m_disruptor.handleEventsWith(
            (event, sequence, endOfBatch) -> 
            WaterfallExecutor.waterfall(m_executor, new SyslogConnection(event))
        );
        */

        m_byteBuffers = new Disruptor<ByteBufferMessage>(ByteBufferMessage::new, SOCKET_BYTE_BUFFER_QUEUE_SIZE, m_executor);
        m_byteBuffers.start();
        m_ringBuffer = m_byteBuffers.getRingBuffer();

        /*
         * TODO: Do we need to do anything to warm up the ring buffer? Probably not I guess.

        for (int i = 0; i < 8192; i++) {
            long sequence = ringBuffer.next();
            try {
                ringBuffer.get(sequence);
            }
        }
        */
    }

