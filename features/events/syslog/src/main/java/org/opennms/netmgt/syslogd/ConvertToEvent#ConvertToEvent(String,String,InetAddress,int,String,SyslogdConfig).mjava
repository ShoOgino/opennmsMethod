    /**
     * Constructs a new event encapsulation instance based upon the
     * information passed to the method. The passed byte array is decoded into
     * a string using the <tt>US-ASCII</tt> character encoding.
     *
     * @param addr The remote agent's address.
     * @param port The remote agent's port
     * @param data The XML data in US-ASCII encoding.
     * @param len  The length of the XML data in the buffer.
     * @throws java.io.UnsupportedEncodingException
     *          Thrown if the data buffer cannot be decoded using the
     *          US-ASCII encoding.
     * @throws MessageDiscardedException 
     */
    public ConvertToEvent(
        final String systemId,
        final String location,
        final InetAddress addr,
        final int port,
        final String data,
        final SyslogdConfig config
    ) throws UnsupportedEncodingException, MessageDiscardedException {

        if (config == null) {
            throw new IllegalArgumentException("Config cannot be null");
        }

        final UeiList ueiList = config.getUeiList();
        final HideMessage hideMessage = config.getHideMessages();
        final String discardUei = config.getDiscardUei();

        final String syslogString;
        if (data.endsWith("\0")) {
            syslogString = data.substring(0, data.length() - 1);
        } else {
            syslogString = data;
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Converting to event: {}", this);
        }

        SyslogParser parser = SyslogParser.getParserInstance(config, syslogString);
        if (!parser.find()) {
            throw new MessageDiscardedException("message does not match");
        }
        SyslogMessage message;
        try {
            message = parser.parse();
        } catch (final SyslogParserException ex) {
            LOG.debug("Unable to parse '{}'", syslogString, ex);
            throw new MessageDiscardedException(ex);
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("got syslog message {}", message);
        }
        if (message == null) {
            throw new MessageDiscardedException(String.format("Unable to parse '%s'", syslogString));
        }
        // Build a basic event out of the syslog message
        final String priorityTxt = message.getSeverity().toString();
        final String facilityTxt = message.getFacility().toString();

        EventBuilder bldr = new EventBuilder("uei.opennms.org/syslogd/" + facilityTxt + "/" + priorityTxt, "syslogd");

        bldr.setDistPoller(systemId);

        bldr.setCreationTime(message.getDate());

        // Set event host
        bldr.setHost(InetAddressUtils.getLocalHostName());

        final InetAddress hostAddress = message.getHostAddress();
        if (hostAddress != null) {
            // Set nodeId
            int nodeId = SyslogdIPMgrDaoImpl.getInstance().getNodeId(location, hostAddress);
            if (nodeId != -1) {
                bldr.setNodeid(nodeId);
            }

            bldr.setInterface(hostAddress);
        }
        
        bldr.setLogDest("logndisplay");


        // We will also here find out if, the host needs to
        // be replaced, the message matched to a UEI, and
        // last if we need to actually hide the message.
        // this being potentially helpful in avoiding showing
        // operator a password or other data that should be
        // confidential.

        /*
        * We matched on a regexp for host/message pair.
        * This can be a forwarded message as in BSD Style
        * or syslog-ng.
        * We assume that the host is given to us
        * as an IP/Hostname and that the resolver
        * on the ONMS host actually can resolve the
        * node to match against nodeId.
         */

        Pattern msgPat = null;
        Matcher msgMat = null;

        // Time to verify UEI matching.

        final String fullText = message.getFullText();
        final String matchedText = message.getMatchedMessage();

        final List<UeiMatch> ueiMatch = ueiList == null? null : ueiList.getUeiMatchCollection();
        if (ueiMatch == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("No ueiList configured.");
            }
        } else {
            for (final UeiMatch uei : ueiMatch) {
                final boolean otherStuffMatches = containsIgnoreCase(uei.getFacilityCollection(), facilityTxt) &&
                                                  containsIgnoreCase(uei.getSeverityCollection(), priorityTxt) &&
                                                  matchProcess(uei.getProcessMatch(), message.getProcessName()) && 
                                                  matchHostname(uei.getHostnameMatch(), message.getHostName()) &&
                                                  matchHostAddr(uei.getHostaddrMatch(), str(hostAddress));

                // Single boolean check is added instead of performing multiple
                // boolean check for both if and else if which causes a extra time
                if (otherStuffMatches) {
                    if (uei.getMatch().getType().equals("substr")) {
                        if (matchSubstring(discardUei, bldr, matchedText, uei)) {
                            break;
                        }
                    } else if ((uei.getMatch().getType().startsWith("regex"))) {
                        if (matchRegex(message, uei, bldr, discardUei)) {
                            break;
                        }
                    }
                }
            }
        }

        // Time to verify if we need to hide the message
        boolean doHide = false;
        final List<HideMatch> hideMatch = hideMessage == null? null : hideMessage.getHideMatchCollection();
        if (hideMatch == null) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("No hideMessage configured.");
            }
        } else {
            for (final HideMatch hide : hideMatch) {
                if (hide.getMatch().getType().equals("substr")) {
                    if (fullText.contains(hide.getMatch().getExpression())) {
                        // We should hide the message based on this match
                        doHide = true;
                    }
                } else if (hide.getMatch().getType().equals("regex")) {
                    try {
                        msgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);
                        msgMat = msgPat.matcher(fullText);
                    } catch (PatternSyntaxException pse) {
                        LOG.warn("Failed to compile regex pattern '{}'", hide.getMatch().getExpression(), pse);
                        msgMat = null;
                    }
                    if ((msgMat != null) && (msgMat.find())) {
                        // We should hide the message based on this match
                        doHide = true;
                    }
                }
                if (doHide) {
                    LOG.debug("Hiding syslog message from Event - May contain sensitive data");
                    message.setMessage(HIDDEN_MESSAGE);
                    // We want to stop here, no point in checking further hideMatches
                    break;
                }
            }
        }

        // Using parms provides configurability.
        bldr.setLogMessage(message.getMessage());

        bldr.addParam("syslogmessage", message.getMessage());
        bldr.addParam("severity", "" + priorityTxt);
        bldr.addParam("timestamp", message.getSyslogFormattedDate());
        
        if (message.getProcessName() != null) {
            bldr.addParam("process", message.getProcessName());
        }

        bldr.addParam("service", "" + facilityTxt);

        if (message.getProcessId() != null) {
            bldr.addParam("processid", message.getProcessId().toString());
        }

        m_event = bldr.getEvent();
    }

