	/**
	 * This function maps {@link SyslogSemanticType} values of type int to fields in the parser
	 * state.
	 * 
	 * @param semanticString
	 * @return
	 */
	private static BiConsumer<ParserState,Integer> semanticIntegerToField(String semanticString) {
		SyslogSemanticType semanticType = null;
		try {
			semanticType = SyslogSemanticType.valueOf(semanticString);
		} catch (IllegalArgumentException e) {
			// Leave semanticType == null
		}

		if (semanticType == null) {
			return (s,v) -> {
				s.message.setParam(semanticString, v);
			};
		} else {
			switch(semanticType) {
			case day:
				return (s,v) -> {
					s.message.setDayOfMonth(v);
				};
			case facilityPriority:
				return (s,v) -> {
					SyslogFacility facility = SyslogFacility.getFacilityForCode(v);
					SyslogSeverity priority = SyslogSeverity.getSeverityForCode(v);

					s.message.setFacility(facility);
					s.message.setSeverity(priority);
				};
			case hour:
				return (s,v) -> {
					s.message.setHourOfDay(v);
				};
			case minute:
				return (s,v) -> {
					s.message.setMinute(v);
				};
			case month:
				return (s,v) -> {
					s.message.setMonth(v);
				};
			case processId:
				// processId can be an integer or string
				return (s,v) -> {
					s.message.setProcessId(String.valueOf(v));
				};
			case second:
				return (s,v) -> {
					s.message.setSecond(v);
				};
			// TODO: This should be handled as a string... this is only
			// in here as a stopgap until we create a DIGITS pattern type.
			case secondFraction:
				return (s,v) -> {
					if (v >= 1000) {
						s.message.setMillisecond(Math.round(v / 1000));
					} else {
						s.message.setMillisecond(v);
					}
				};
			case version:
				return (s,v) -> {
					s.message.setVersion(v);
				};
			case year:
				return (s,v) -> {
					s.message.setYear(v);
				};
			default:
				throw new IllegalArgumentException(String.format("Semantic type %s does not have an integer value", semanticString));
			}
		}

	}

