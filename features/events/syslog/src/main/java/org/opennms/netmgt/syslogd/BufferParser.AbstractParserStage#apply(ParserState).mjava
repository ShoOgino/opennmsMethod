		public final ParserState apply(ParserState state) {
			// Reset the accumulator state if necessary
			if (m_resultConsumer != null) {
				state.accumulatedValue = new StringBuffer();
				state.accumulatedSize = new AtomicInteger(0);
			}

			while(true) {
				state.buffer.mark();

				char c;
				try {
					c = (char)state.buffer.get();
				} catch (BufferUnderflowException e) {
					if (m_terminal) {
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(state));
						}
						// Reset any local state if necessary
						reset(state);
						return state;
					} else if (m_optional) {
						// TODO: Should we reset the buffer here?
						state.buffer.reset();
						// Reset any local state if necessary
						reset(state);
						return state;
					} else {
						throw new CancellationException(getClass().getSimpleName() + " reached end of buffer, match failed");
					}
				}

				switch (acceptChar(state, c)) {
					case CONTINUE:
						continue;
					case COMPLETE_AFTER_CONSUMING:
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(state));
						}
						// Reset any local state if necessary
						reset(state);
						return state;
					case COMPLETE_WITHOUT_CONSUMING:
						// Put the char back on the deque
						//m_incoming.putFirst(c);
						state.buffer.reset();
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(state));
						}
						// Reset any local state if necessary
						reset(state);
						return state;
					case CANCEL:
						if (m_optional) {
							state.buffer.reset();
							// Reset any local state if necessary
							reset(state);
							return state;
						} else {
							throw new CancellationException(getClass().getSimpleName() + " match failed");
						}
				}
			}
		}

