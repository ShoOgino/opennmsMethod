	/**
	 * TODO: Use a visitor pattern instead?
	 * 
	 * TODO: Coalesce multiple stages into a single thenApply() call when
	 * node.getChildren().size() == 1. Then figure out how to do that recursively.
	 */
	private static void addStageFutures(List<CompletableFuture<ParserState>> finishedFutures, CompletableFuture<ParserState> parent, RadixTreeNode<ParserStage> node) {
		CompletableFuture<ParserState> current = null;

		// If we're at the root of the radix tree (where the content is null), 
		// use the parent future as the current future
		if (node.getContent() == null) {
			current = parent;
		} else {
			// Otherwise, apply the current node's stage to the parent
			current = parent.thenApply(s -> { return node.getContent().apply(s); });
		}

		// If the node has children, then recursively process the children. Do not
		// add the current node to the finished futures list: we're only concerned
		// with seeing if the leaf nodes complete, not the intermediate stages
		if (node.getChildren() != null && node.getChildren().size() > 0) {
			for (RadixTreeNode<ParserStage> child : node.getChildren()) {
				addStageFutures(finishedFutures, current, child);
			}
		} else {
			// If the node is a leaf node, then add it to the list of futures
			// that need to be evaluated as part of the parse tree
			finishedFutures.add(current);
		}
	}

