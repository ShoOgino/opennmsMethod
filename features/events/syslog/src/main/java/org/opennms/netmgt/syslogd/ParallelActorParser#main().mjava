	@Test
	//public void main(final String[] args) {
	public void main() {

		/*
		System.out.println("1: " + CamelUtils.nanoTime());

		Parser parser = new Parser(
			new Stage[] {
				new MatchChar('<'),
				new MatchInteger(event::setPriority),
				new MatchChar('>'),
				new MatchWhitespace(),
				new MatchAny('a'),
				new MatchAny('b')
			}
		);
		*/

		// Try to use ByteBuffer directly instead of LBQ
		//ByteBuffer incoming = new LinkedBlockingDeque<>();

		String abc = "<5>aaabbb    ccc";
		ByteBuffer incoming = ByteBuffer.wrap(abc.getBytes());

		/***
		System.out.println("2: " + CamelUtils.nanoTime());

		EventBuilder builder = new EventBuilder();

		long total = 0; 

		for (int i = 0; i < 100000; i++) {

			AtomicLong end = new AtomicLong();

			SyslogFacility facility = null;

			CompletableFuture future = CompletableFuture
				    .runAsync(new MatchChar(incoming, '<'), m_executor)
				.thenRunAsync(new MatchInteger(incoming, v -> { facility = SyslogFacility.getFacilityForCode(v); }), m_executor)
				.thenRunAsync(new MatchChar(incoming, '>'), m_executor)
				/ *
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				* /
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchAny(incoming), m_executor)
				.thenRunAsync(new MatchWhitespace(incoming), m_executor)
				//.thenRunAsync(new MatchAny(incoming, System.out::println), m_executor)
				.exceptionally(e -> { return null; })
				.thenAccept(v -> {
//					System.out.println("5: " + CamelUtils.nanoTime());
//					System.out.println(event.toString());
					end.set(System.nanoTime());
				});
			;

			long start = System.nanoTime();
			//System.out.println("3: " + );
			/ *
			try {
				while(buffer.hasRemaining()) {
					incoming.put((char)buffer.get());
				}
			} catch (InterruptedException e) {
				// TODO: Do something
			}
			* /
			//System.out.println("4: " + CamelUtils.nanoTime());
			try {
				future.get();
			} catch (InterruptedException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			total += (end.get() - start);
		}

		System.out.println("TOTAL TIME: " + total);
		//try { Thread.sleep(2000); } catch (Exception e) {}
		***/

		//EventBuilder builder = new EventBuilder();
		AtomicReference<SyslogFacility> facility = new AtomicReference<>();

		ParserFactory factory = new ParserFactory();
		factory
			.intBetweenDelimiters('<', '>', v -> { facility.set(SyslogFacility.getFacilityForCode(v)); })
			.stringBetweenDelimiters('a', 'b', v -> { factory.getBuilder().setHost(v); })
			.character('b')
			.character('b')
			.whitespace();

		CompletableFuture<Event> event = null;
		for (int i = 0; i < 100; i++) {
			//incoming.rewind();
			event = factory.parse(incoming.asReadOnlyBuffer(), m_executor);
			event.whenComplete((e, ex) -> {
				if (ex == null) {
					//System.out.println(e.toString());
				} else {
					ex.printStackTrace();
				}
			});
		}
		try {
			event.get();
		} catch (InterruptedException | ExecutionException e) {
			e.printStackTrace();
		}
	}

