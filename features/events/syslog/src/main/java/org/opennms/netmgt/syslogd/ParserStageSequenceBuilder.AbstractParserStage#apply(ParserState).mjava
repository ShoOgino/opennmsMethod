		public final ParserState apply(final ParserState incomingState) {
			if (incomingState == null) {
				return null;
			} else {
				LOG.trace("Starting stage: " + this);
			}

			ParserState state = incomingState.clone();

			// Create a new state for the current ParserStage.
			// Use ByteBuffer.duplicate() to create a buffer with marks
			// and positions that only this stage will use.
//			ParserStageState stageState = new ParserStageState(state.getBuffer().duplicate()); 
			ParserStageState stageState = new ParserStageState(state.getBuffer()); 

			while(true) {
				stageState.buffer.mark();

				char c;
				try {
					c = (char)stageState.buffer.get();
				} catch (BufferUnderflowException e) {
					if (m_terminal) {
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(stageState));
						}

//						// Reset any local state if necessary
//						reset(stageState);

						LOG.trace("End of buffer with terminal match");
						return new ParserState(stageState.buffer, state.message);
					} else if (m_optional) {
//						// TODO: Should we reset the buffer here? It probably
//						// doesn't matter since we're at the end of the buffer.
//						stageState.buffer.reset();

//						// Reset any local state if necessary
//						reset(stageState);

						LOG.trace("End of buffer with optional match");
						return new ParserState(stageState.buffer, state.message);
					} else {
						// Reached end of buffer, match failed
						LOG.trace("Parse failed due to buffer underflow: " + this);
						return null;
					}
				}

				switch (acceptChar(stageState, c)) {
					case CONTINUE:
						continue;
					case COMPLETE_AFTER_CONSUMING:
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(stageState));
						}

//						// Reset any local state if necessary
//						reset(stageState);

						return new ParserState(stageState.buffer, state.message);
					case COMPLETE_WITHOUT_CONSUMING:
						if (m_resultConsumer != null) {
							m_resultConsumer.accept(state, getValue(stageState));
						}

						// Reset any local state if necessary
						reset(stageState);

						// Move the mark back before the current character
						stageState.buffer.reset();

						return new ParserState(stageState.buffer, state.message);
					case CANCEL:
						if (m_optional) {
							stageState.buffer.reset();

							// Reset any local state if necessary
							reset(stageState);

							return new ParserState(stageState.buffer, state.message);
						} else {
							// Match failed
							LOG.trace("Parse failed: " + this);
							return null;
						}
				}
			}
		}

