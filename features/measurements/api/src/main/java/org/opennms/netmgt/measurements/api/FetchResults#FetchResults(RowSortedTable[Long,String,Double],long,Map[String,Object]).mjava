    /**
     * Used when applying filters.
     */
    public FetchResults(final RowSortedTable<Long, String, Double> table, final long step, final Map<String, Object> constants) {
        Preconditions.checkNotNull(table, "table argument");
        Preconditions.checkNotNull(constants, "constants argument");

        m_step = step;
        m_constants = constants;

        if (table.size() < 1) {
            // No rows
            m_timestamps = new long[0];
            m_columns = Maps.newHashMapWithExpectedSize(0);
            return;
        }

        Long firstIndex = null;
        Long lastIndex = null;
        Map<Long, Double> timestampsByIndex = table.column(Filter.TIMESTAMP_COLUMN_NAME);
        for (Long index : timestampsByIndex.keySet()) {
            if (firstIndex == null) {
                firstIndex = index;
            } else {
                Preconditions.checkState(index == (lastIndex + 1), "filter timestamps must be contiguous");
            }
            lastIndex = index;
        }

        int numRows = (int)(lastIndex - firstIndex) + 1;
        m_columns = Maps.newLinkedHashMap(); // preserve ordering
        m_timestamps = new long[numRows];

        for (int k = 0; k < numRows; k++) {
            for (String columnName : table.columnKeySet()) {
                Double value = table.get(Long.valueOf(k), columnName);

                if (Filter.TIMESTAMP_COLUMN_NAME.equals(columnName)) {
                    Preconditions.checkNotNull(value, "filter timestamps must be contiguous");
                    m_timestamps[k] = value.longValue();
                } else {
                    double column[] = m_columns.get(columnName);
                    if (column == null) {
                        column = new double[numRows];
                        m_columns.put(columnName, column);
                    }

                    if (value == null) {
                        column[k] = Double.NaN;
                    } else {
                        column[k] = value;
                    }
                }
            }
        }
    }

