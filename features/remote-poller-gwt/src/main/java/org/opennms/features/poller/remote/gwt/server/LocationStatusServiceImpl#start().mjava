    public void start() {
        LogUtils.debugf(this, "starting location status service");
        initialize();
        final EventExecutorService service = EventExecutorServiceFactory.getInstance().getEventExecutorService(this.getRequest().getSession());

        if (m_timer == null) {
            m_timer = new Timer();
            m_timer.schedule(new TimerTask() {
                CountDownLatch m_latch = new CountDownLatch(APPLICATION_UPDATE_OFFSET);

                @Override
                public void run() {
                    if (!m_initializationComplete.get()) {
                        return;
                    }
                    if (m_lastUpdated == null) {
                        return;
                    }
                    LogUtils.debugf(this, "pushing monitor status updates");
                    final Date endDate = new Date();
                    addEvent(RemotePollerPresenter.LOCATION_EVENT_DOMAIN, new LocationsUpdatedRemoteEvent(m_locationDataService.getUpdatedLocationsBetween(m_lastUpdated, endDate)));
                    LogUtils.debugf(this, "finished pushing monitor status updates");

                    // Every 5 minutes, update the application list too
                    synchronized(m_latch) {
                        m_latch.countDown();
                        if (m_latch.getCount() == 0) {
                            LogUtils.debugf(this, "pushing application updates");
                            final Collection<ApplicationHandler> appHandlers = new ArrayList<ApplicationHandler>();
                            final DefaultApplicationHandler applicationHandler = new DefaultApplicationHandler(m_locationDataService, service, true, m_activeApplications);
                            appHandlers.add(applicationHandler);
                            m_locationDataService.handleAllApplications(appHandlers);
                            synchronized(m_activeApplications) {
                                m_activeApplications.clear();
                                m_activeApplications.addAll(applicationHandler.getApplicationNames());
                            }
                            m_latch = new CountDownLatch(APPLICATION_UPDATE_OFFSET);
                            LogUtils.debugf(this, "finished pushing application updates");
                        }
                    }

                    m_lastUpdated = endDate;
                }
            }, UPDATE_PERIOD, UPDATE_PERIOD);
        }

        final TimerTask initializedTask = new TimerTask() {
            @Override
            public void run() {
                pushInitialData(service);
                service.addEventUserSpecific(new UpdateCompleteRemoteEvent());
                m_lastUpdated = new Date();
                m_initializationComplete.set(true);
            }
        };

        /*
         * final TimerTask uninitializedTask = new TimerTask() {
         * @Override public void run() { pushUninitializedLocations(service);
         * service.addEventUserSpecific(new UpdateCompleteRemoteEvent());
         * m_timer.schedule(initializedTask, PADDING_TIME); } };
         */

        m_timer.schedule(initializedTask, PADDING_TIME);
    }

