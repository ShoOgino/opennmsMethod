    /** {@inheritDoc} */
    @Transactional
    @Override
    public Collection<LocationInfo> getUpdatedLocationsBetween(final Date startDate, final Date endDate) {
        waitForGeocoding("getApplicationDetails");

        final Collection<LocationInfo> locations = new ArrayList<LocationInfo>();
        final Map<String, LocationDef> definitions = new HashMap<String, LocationDef>();

        // check for any monitors that have changed status
        for (LocationDef def : m_monitoringLocationDao.findAll()) {
            for (OnmsLocationMonitor mon : m_locationDao.findByLocationDefinition(def)) {
                final MonitorStatus status = m_monitorStatuses.get(mon.getLocation());
                if (status == null || !status.equals(mon.getStatus())) {
                    definitions.put(def.getLocationName(), def);
                    m_monitorStatuses.put(def.getLocationName(), mon.getStatus());
                }
            }
        }

        // check for any definitions that have status updates
        for (final OnmsLocationSpecificStatus status : m_locationDao.getStatusChangesBetween(startDate, endDate)) {
            final String definitionName = status.getLocationMonitor().getLocation();
            if (!definitions.containsKey(definitionName)) {
                definitions.put(definitionName, m_monitoringLocationDao.get(definitionName));
            }
        }

        for (final LocationDef def : definitions.values()) {
            final LocationInfo location = getLocationInfo(def);
            locations.add(location);
        }

        return locations;
    }

