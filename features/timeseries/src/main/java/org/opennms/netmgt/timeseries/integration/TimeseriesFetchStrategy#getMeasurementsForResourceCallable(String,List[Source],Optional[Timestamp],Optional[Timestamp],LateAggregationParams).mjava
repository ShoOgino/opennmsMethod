    private Callable<Collection<Row<Measurement>>> getMeasurementsForResourceCallable(final String resourceId, final List<Source> listOfSources, final Optional<Timestamp> start, final Optional<Timestamp> end, final LateAggregationParams lag) {
        return new Callable<Collection<Row<Measurement>>>() {
            @Override
            public Collection<Row<Measurement>> call() throws Exception {

                List<List<Sample>> allSamples = new ArrayList<>();

                // get results for all sources
                for (Source source : listOfSources) {
                    // Use the datasource as the metric name if set, otherwise use the name of the attribute
                    final String metricName = source.getDataSource() != null ? source.getDataSource() : source.getAttribute();
                    final Aggregation aggregation = toAggregation(source.getAggregation());
                    final boolean shouldAggregateNatively = storageManager.get().supportsAggregation(aggregation);

                    final ImmutableMetric metric = ImmutableMetric.builder()
                            .intrinsicTag(CommonTagNames.resourceId, resourceId)
                            .intrinsicTag(CommonTagNames.name, metricName)
                            .build();

                    Instant startInstant = Instant.ofEpochMilli(start.or(Timestamp.fromEpochMillis(0)).asMillis());
                    Instant endInstant = Instant.ofEpochMilli(end.or(Timestamp.now()).asMillis());

                    Aggregation aggregationToUse = shouldAggregateNatively ? aggregation : Aggregation.NONE;
                    TimeSeriesFetchRequest request = ImmutableTimeSeriesFetchRequest.builder()
                            .metric(metric)
                            .start(startInstant)
                            .end(endInstant)
                            .step(Duration.ofMillis(lag.getStep()))
                            .aggregation(aggregationToUse)
                            .build();

                    LOG.debug("Querying TimeseriesStorage for resource id {} with request: {}", resourceId, request);
                    List<Sample> samples = storageManager.get().getTimeseries(request);

                    // aggregate if timeseries implementation didn't do it natively)
                    if (!shouldAggregateNatively) {
                        final List<Source> currentSources = Collections.singletonList(source);
                        final ResultDescriptor resultDescriptor = createResultDescriptor(currentSources, lag);
                        samples = NewtsLikeSampleAggregator.builder()
                                .resource(new Resource(resourceId))
                                .start(start.or(Timestamp.fromEpochMillis(0)))
                                .end(end.or(Timestamp.now()))
                                .resolution(org.opennms.newts.api.Duration.millis(lag.getStep()))
                                .resultDescriptor(resultDescriptor)
                                .metric(metric)
                                .build().process(samplesToNewtsRowIterator(samples, currentSources));
                    }
                    allSamples.add(samples);
                }

                // build Rows from the results. One row can contain multiple columns. A Sample represents a cell in the "table"
                List<Row<Measurement>> rows =  new ArrayList<>();
                for(int rowIndex = 0; rowIndex < allSamples.get(0).size(); rowIndex++) {
                    Sample sampleOfFirstList = allSamples.get(0).get(rowIndex);

                    Timestamp timestamp = Timestamp.fromEpochMillis(sampleOfFirstList.getTime().toEpochMilli());
                    Optional<Map<String, String>> resourceAttributes = sampleOfFirstList.getMetric().getMetaTags().isEmpty() ?
                            Optional.absent() : Optional.of(asMap(sampleOfFirstList.getMetric().getMetaTags()));
                    Resource resource = new Resource(sampleOfFirstList.getMetric().getFirstTagByKey("resourceId").getValue(), resourceAttributes);
                    Row<Measurement> row = new Row<>(timestamp, resource);

                    // Let's iterate over all lists and add the samples of row i
                    for(int columnIndex = 0; columnIndex < allSamples.size(); columnIndex++) {
                        List<Sample> list = allSamples.get(columnIndex);
                        Sample sampleOfCurrentList = list.get(rowIndex);
                        final String name = listOfSources.get(columnIndex).getLabel();
                        // final String name = sampleOfCurrentList.getMetric().getFirstTagByKey(CommonTagNames.name).getValue();
                        row.addElement(new Measurement(timestamp, resource, name, sampleOfCurrentList.getValue(), new HashMap<>()));
                    }

                    rows.add(row);
                }

                LOG.debug("Found {} rows.", rows.size());
                 return rows;
            }
        };
    }

