    public List<Sample> computeAggregatedSamples() {

        // make sure we have only the expected metric
        Optional<Sample> missmatchedSample = this.samples.stream().filter(s -> !this.expectedMetric.equals(s.getMetric())).findAny();
        if(missmatchedSample.isPresent()) {
            throw new IllegalArgumentException(String.format("Expected Metric %s but found %s", expectedMetric,missmatchedSample.get().getMetric()));
        }

        if(this.aggregation == Aggregation.NONE) {
            return this.samples; // nothing to do
        }

        // bucket all samples by time
        final Map<Instant, List<Sample>> buckets = new HashMap<>();
        for (Sample sample : this.samples) {
            List<Sample> bucket = getBucket(buckets, sample.getTime());
            bucket.add(sample);
        }

        // fill gaps
        for(long l=this.startTime.toEpochMilli(); l<=this.endTime.toEpochMilli(); l=l+this.bucketSize.toMillis()) {
            Instant currentInstant = Instant.ofEpochMilli(l);
            List<Sample> bucket = getBucket(buckets, currentInstant); // will create bucket automatically
            if(bucket.isEmpty()) {
                bucket.add(ImmutableSample.builder().metric(expectedMetric).time(currentInstant).value(Double.NaN).build());
            }
        }

        // aggregate all samples in bucket and sort by time
        return buckets.entrySet().stream()
                .map(entry -> aggregate(entry.getKey(), entry.getValue()))
                .sorted(Comparator.comparing(i -> i.getTime().toEpochMilli()))
                .collect(Collectors.toList());
    }

