    public Set<Metric> search(ResourcePath path, int depth) throws StorageException {

        // Numeric suffix for the index name, based on the length of parent path
        int idxSuffix = path.elements().length - 1;
        // The length of the resource ids we're interested in finding
        int targetLen = idxSuffix + depth + 2;

        String key = "_idx" + idxSuffix;
        String value = String.format("(%s,%d)", toResourceId(path), targetLen);
        Tag indexTag = new ImmutableTag(key, value);

        Set<Metric> metrics = indexMetricsByTag.getIfCached(indexTag);

        // cache found => we are done
        if (metrics != null) {
            return metrics;
        }

        // in order not to call the TimeseriesStorage implementation for every resource, we query all resources below a certain
        // depth (defined as WILDCARD_INDEX_NO). We have a special index, the "wildcard" index for that.
        if (path.elements().length >= WILDCARD_INDEX_NO) {
            String wildcardPath = toResourceId(ResourcePath.get(Arrays.asList(path.elements()).subList(0, WILDCARD_INDEX_NO)));
            Set<Metric> metricsFromWildcard = getMetricsBelowWildcardPath(wildcardPath);
            for (Metric metric : metricsFromWildcard) {
                metric.getMetaTags().stream()
                        .filter(tag -> tag.getKey() != null)
                        .filter(tag -> tag.getKey().startsWith("_idx"))
                        .filter(tag -> !tag.getKey().equals(WILDCARD_INDEX))
                        .forEach(tag -> getMetricFromCacheOrAddEmptySet(tag).add(metric));
            }
            // Either we have found it by now or it doesn't exist => add empty list
            metrics = getMetricFromCacheOrAddEmptySet(indexTag);

        } else {
            // we are above the wildcard level -> let's just get metrics that are associated with the index tag
            metrics = getMetricFromCacheOrLoad(indexTag);
        }
        return metrics;
    }

