    @Inject
    public TimeseriesWriter(@Named("timeseries.ring_buffer_size") Integer ringBufferSize,
                            @Named("timeseries.writer_threads") Integer numWriterThreads, @Named("timeseriesMetricRegistry") MetricRegistry registry) {
        Preconditions.checkArgument(ringBufferSize > 0, "ringBufferSize must be positive");
        Preconditions.checkArgument(DoubleMath.isMathematicalInteger(Math.log(ringBufferSize) / Math.log(2)), "ringBufferSize must be a power of two");
        Preconditions.checkArgument(numWriterThreads > 0, "numWriterThreads must be positive");
        Preconditions.checkNotNull(registry, "metric registry");

        this.ringBufferSize = ringBufferSize;
        this.numWriterThreads = numWriterThreads;
        numEntriesOnRingBuffer.set(0L);

        registry.register(MetricRegistry.name("ring-buffer", "size"),
                new Gauge<Long>() {
                    @Override
                    public Long getValue() {
                        return numEntriesOnRingBuffer.get();
                    }
                });
        registry.register(MetricRegistry.name("ring-buffer", "max-size"),
                new Gauge<Long>() {
                    @Override
                    public Long getValue() {
                        return Long.valueOf(TimeseriesWriter.this.ringBufferSize);
                    }
                });

        droppedSamples = registry.meter(MetricRegistry.name("ring-buffer", "dropped-samples"));
        sampleWriteTsTimer = registry.timer("samples.write.ts");

        LOG.debug("Using ring_buffer_size: {}", this.ringBufferSize);
        setUpWorkerPool();

    }

