    /**
     * Evaluates the threshold in light of the provided datasource value, for
     * the named instance (or the generic instance if instance is null) and
     * create any events for thresholds.
     *
     * @param values
     *          map of values (by datasource name) to evaluate against the threshold (might be an expression)
     * @param date
     *          Date to use in created events
     * @return List of events
     * @param resource a {@link org.opennms.netmgt.threshd.CollectionResourceWrapper} object.
     */
    public List<Event> evaluateAndCreateEvents(CollectionResourceWrapper resource, Map<String, Double> values, Date date) {
        List<Event> events = new LinkedList<Event>();

        String instance = null;
        if (resource != null) {
            // NMS-9361: Use the instance label as the key for the thresholder's state. This allows us to uniquely
            // identify resources that share the same instance, but whose path
            // on disk may differ due to the use of a StorageStrategy implementation
            // such as the SiblingColumnStorageStrategy
            instance = resource.getInstanceLabel();
        }

        if (getThresholdEvaluatorStates(instance).isEmpty()) {
            throw new IllegalStateException("No thresholds have been added.");
        }

        // This reference contains the function that will be used by each evaluator to retrieve the status
        AtomicReference<EvaluateFunction> evaluateFunctionRef = new AtomicReference<>(null);

        // Depending on the type of threshold, we want to evaluate it differently
        // Threshold Values like value, rearm, trigger and expression are interpolated and cached in state so that
        // subsequent evaluations don't need to do any interpolation.
        getThresholdConfig().accept(new ThresholdDefVisitor() {
            @Override
            public void visit(ThresholdConfigWrapper thresholdConfigWrapper) {

                double computedValue = thresholdConfigWrapper.evaluate(values);
                ThresholdValuesSupplier thresholdValuesSupplier = new ThresholdValuesSupplier() {
                    @Override
                    public ThresholdEvaluatorState.ThresholdValues get() {
                        Scope scope = getScopeForResource(resource);
                        ThresholdEvaluatorState.ThresholdValues thresholdValues = thresholdConfigWrapper.interpolateThresholdValues(scope);
                        thresholdValues.setDsValue(computedValue);
                        return thresholdValues;
                    }

                    @Override
                    public Double getDsValue() {
                        return computedValue;
                    }
                };
                evaluateFunctionRef.set(item -> item.evaluate(thresholdValuesSupplier, resource == null ? null :
                        resource.getSequenceNumber()));
            }

            @Override
            public void visit(ExpressionConfigWrapper expressionConfigWrapper) {
                ExpressionThresholdValueSupplier expressionThresholdValueSupplier = new ExpressionThresholdValueSupplier() {
                    // This covers the case where an expression has not yet been cached, we want to evaluate and
                    // also retrieve the interpolated expression so we can persist it in our state going forward
                    @Override
                    public ExpressionConfigWrapper.ExpressionThresholdValues get() throws ThresholdExpressionException {

                        Scope scope = getScopeForResource(resource);
                        return expressionConfigWrapper
                                .interpolateAndEvaluate(values, scope);
                    }
                    // This covers the case where an expression has already been interpolated and the evaluator is
                    // providing us that expression that it has persisted along with its state so that we do not need to
                    // perform interpolation again
                    @Override
                    public double get(String evaluatedExpression) throws ThresholdExpressionException {
                        return expressionConfigWrapper.evaluate(evaluatedExpression, values);
                    }
                };

                evaluateFunctionRef.set(item -> item.evaluate(expressionThresholdValueSupplier, resource == null ? null :
                        resource.getSequenceNumber()));
            }
        });

        EvaluateFunction evaluateFunction = evaluateFunctionRef.get();
        for (ThresholdEvaluatorState item : getThresholdEvaluatorStates(instance)) {
            ThresholdEvaluatorState.ValueStatus result;
            try {
                result = evaluateFunction.evaluate(item);
            } catch (ThresholdExpressionException e) {
                LOG.warn("Error evaluating: threshold: {} and evaluator: {}", this, item, e);
                continue;
            }
            Status status = result.status;
            Event event = item.getEventForState(status, date, result.value, result.thresholdValues, resource);
            LOG.debug("evaluated: value= {} against threshold: {} and evaluator: {}", result.value, this, item);
            if (event != null) {
                events.add(event);
            }
        }

        return events;
    }

