    /**
     * Evaluates the threshold in light of the provided datasource value, for
     * the named instance (or the generic instance if instance is null) and
     * create any events for thresholds.
     *
     * @param values
     *          map of values (by datasource name) to evaluate against the threshold (might be an expression)
     * @param date
     *          Date to use in created events
     * @return List of events
     * @param resource a {@link org.opennms.netmgt.threshd.CollectionResourceWrapper} object.
     */
    public List<Event> evaluateAndCreateEvents(CollectionResourceWrapper resource, Map<String, Double> values, Date date) {
        List<Event> events = new LinkedList<Event>();

        String instance = null;
        if (resource != null) {
            // NMS-9361: Use the instance label as the key for the thresholder's state. This allows us to uniquely
            // identify resources that share the same instance, but whose path
            // on disk may differ due to the use of a StorageStrategy implementation
            // such as the SiblingColumnStorageStrategy
            instance = resource.getInstanceLabel();
        }

        if (getThresholdEvaluatorStates(instance).isEmpty()) {
            throw new IllegalStateException("No thresholds have been added.");
        }

        // This reference contains the function that will be used by each evaluator to retrieve the status
        AtomicReference<EvaluateFunction> evaluateFunctionRef = new AtomicReference<>(null);

        // Depending on the type of threshold, we want to evaluate it differently
        // Specifically expression based thresholds are treated special because their behavior must change depending on
        // whether or not a given expression has been interpolated already
        getThresholdConfig().accept(new ThresholdDefVisitor() {
            @Override
            public void visit(ThresholdConfigWrapper thresholdConfigWrapper) {
                double computedValue = thresholdConfigWrapper.evaluate(values);
                evaluateFunctionRef.set(item -> new ThresholdEvaluatorState.ValueStatus(computedValue,
                        item.evaluate(computedValue, resource == null ? null : resource.getSequenceNumber())));
            }

            @Override
            public void visit(ExpressionConfigWrapper expressionConfigWrapper) {
                ExpressionThresholdValue expressionThresholdValue = new ExpressionThresholdValue() {
                    // This covers the case where an expression has not yet been interpolated, we want to evaluate and
                    // also retrieve the interpolated expression so we can persist it in our state going forward
                    @Override
                    public double get(Consumer<String> expressionConsumer) throws ThresholdExpressionException {
                        // Default to empty scopes and then attempt to populate each of node, interface, and service
                        // scopes below
                        Scope[] scopes = new Scope[]{EmptyScope.EMPTY, EmptyScope.EMPTY, EmptyScope.EMPTY};

                        if (resource != null) {
                            scopes[0] = m_entityScopeProvider.getScopeForNode(resource.getNodeId());
                            String interfaceIp = resource.getHostAddress();
                            if (interfaceIp != null) {
                                scopes[1] = m_entityScopeProvider.getScopeForInterface(resource.getNodeId(),
                                        interfaceIp);
                                scopes[2] = m_entityScopeProvider.getScopeForService(resource.getNodeId(),
                                        InetAddresses.forString(interfaceIp), resource.getServiceName());
                            }
                        }

                        FallbackScope fallbackScope = new FallbackScope(scopes);

                        ExpressionConfigWrapper.ExpressionValue expressionValue = expressionConfigWrapper
                                .interpolateAndEvaluate(values, fallbackScope);
                        expressionConsumer.accept(expressionValue.expression);

                        return expressionValue.value;
                    }

                    // This covers the case where an expression has already been interpolated and the evaluator is
                    // providing us that expression that it has persisted along with its state so that we do not need to
                    // perform interpolation again
                    @Override
                    public double get(String evaluatedExpression) throws ThresholdExpressionException {
                        return expressionConfigWrapper.evaluate(evaluatedExpression, values);
                    }
                };

                evaluateFunctionRef.set(item -> item.evaluate(expressionThresholdValue, resource == null ? null :
                        resource.getSequenceNumber()));
            }
        });

        EvaluateFunction evaluateFunction = evaluateFunctionRef.get();
        for (ThresholdEvaluatorState item : getThresholdEvaluatorStates(instance)) {
            ThresholdEvaluatorState.ValueStatus result;
            try {
                result = evaluateFunction.evaluate(item);
            } catch (ThresholdExpressionException e) {
                LOG.warn("Error evaluating: threshold: {} and evaluator: {}", this, item, e);
                continue;
            }
            Status status = result.status;
            Event event = item.getEventForState(status, date, result.value, resource);
            LOG.debug("evaluated: value= {} against threshold: {} and evaluator: {}", result.value, this, item);
            if (event != null) {
                events.add(event);
            }
        }

        return events;
    }

