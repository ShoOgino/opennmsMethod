    /**
     * Constructor used to instantiate new objects.
     *
     * @param entityType the base entity class
     * @param aliasTypes the remaining "joined" model classes
     */
    public CriteriaBuilderHelper(Class<?> entityType, Class<?>... aliasTypes) {
        /**
         * adding criteria parsers
         */
        setCriteriaParser(Integer.class, new CriteriaParser<Integer>() {
            @Override
            public Integer parse(String string) {
                int integer = 0;
                try {
                    integer = Integer.parseInt(string);
                } catch (NumberFormatException numberFormatException) {
                    return null;
                }

                return integer;
            }

            @Override
            public Integer getDefault() {
                return 0;
            }
        });

        setCriteriaParser(String.class, new CriteriaParser<String>() {
            @Override
            public String parse(String string) {
                return string;
            }

            @Override
            public String getDefault() {
                return "foo";
            }
        });

        setCriteriaParser(OnmsSeverity.class, new CriteriaParser<OnmsSeverity>() {
            @Override
            public OnmsSeverity parse(String string) {
                for (OnmsSeverity onmsSeverity : OnmsSeverity.values()) {
                    if (onmsSeverity.name().toLowerCase().equals(string.toLowerCase())) {
                        return onmsSeverity;
                    }
                }
                return null;
            }

            @Override
            public OnmsSeverity getDefault() {
                return OnmsSeverity.CLEARED;
            }
        });

        setCriteriaParser(Date.class, new CriteriaParser<Date>() {
            final DateTimeFormatter parserFormatter = new DateTimeFormatterBuilder()
                    .append(DateTimeFormatter.ISO_OFFSET_DATE_TIME)
                    .parseDefaulting(ChronoField.HOUR_OF_DAY, 0)
                    .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 0)
                    .toFormatter();

            final String DELTA_PATTERN = "^[+-]\\d+$";

            private ZonedDateTime parseZonedDateTinme(final String string) {
                if ("0".equals(string)) {
                    return ZonedDateTime.now();
                } else {
                    if (string.matches(DELTA_PATTERN)) {
                        final long delta = Long.parseLong(string.substring(1));
                        if (string.charAt(0) == '+') {
                            return ZonedDateTime.now().plus(delta, ChronoUnit.SECONDS);
                        } else {
                            return ZonedDateTime.now().minus(delta, ChronoUnit.SECONDS);
                        }
                    } else {
                        try {
                            return ZonedDateTime.parse(string, parserFormatter);
                        } catch (DateTimeParseException ex) {
                            return null;
                        }
                    }
                }
            }

            @Override
            public Date parse(String string) {
                final ZonedDateTime zonedDateTime = parseZonedDateTinme(string);

                if (zonedDateTime == null) {
                    return null;
                } else {
                    return Date.from(zonedDateTime.toInstant());
                }
            }

            @Override
            public Date getDefault() {
                return new Date();
            }
        });

        setCriteriaParser(InetAddress.class, new CriteriaParser<InetAddress>() {
            @Override
            public InetAddress parse(String string) {
                InetAddress inetAddress = null;
                try {
                    inetAddress = InetAddress.getByName(string);
                } catch (UnknownHostException e) {
                    return null;
                } catch (SecurityException e) {
                    return null;
                }
                return inetAddress;
            }

            @Override
            public InetAddress getDefault() {
                InetAddress inetAddress = null;
                try {
                    inetAddress = InetAddress.getByName("127.0.0.1");
                } catch (UnknownHostException e) {
                    return null;
                } catch (SecurityException e) {
                    return null;
                }
                return inetAddress;
            }
        });
        /**
         * now populate the entities map
         */
        populateProperties(entityType, false);

        TreeMap<String, Class<?>> sortedMap = new TreeMap<String, Class<?>>();

        for(Class<?> clazz : aliasTypes) {
            sortedMap.put(clazz.getSimpleName(), clazz);
        }
        for (Map.Entry<String, Class<?>> entry : sortedMap.entrySet()) {
            populateProperties(entry.getValue(), true);
        }
    }

