    /**
     * Populates all the properties of the given model class into the data structures of this instance.
     *
     * @param entityClass the entity's class
     * @param alias       true, if the properties should be aliased, false otherwise
     */
    private void populateProperties(Class entityClass, boolean alias) {
        TreeMap<String, Class> sortedMap = new TreeMap<String, Class>(new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return a.toLowerCase().compareTo(b.toLowerCase());
            }
        });

        String aliasName = null;

        if (alias) {
            aliasName = entityClass.getSimpleName().replaceAll("Onms", "").toLowerCase();
        }

        for (java.lang.reflect.Method method : entityClass.getDeclaredMethods()) {
            Annotation[] annotations = method.getAnnotations();

            for (Annotation annotation : annotations) {
                if ("javax.persistence.Column".equals(annotation.annotationType().getName())) {
                    String propertyName = Introspector.decapitalize(method.getName().replace("get", ""));

                    Class clazz = Primitives.wrap(method.getReturnType());

                    if (m_parsers.containsKey(clazz)) {
                        if (aliasName != null) {
                            sortedMap.put(aliasName + "." + propertyName, clazz);
                        } else {
                            sortedMap.put(propertyName, clazz);
                        }
                    } else {
                        LoggerFactory.getLogger(CriteriaBuilderHelper.class).warn("No parser for class " + clazz.getSimpleName() + " found, ignoring property " + propertyName);
                    }
                }
            }
        }
        for (Map.Entry<String, Class> entry : sortedMap.entrySet()) {
            m_entities.put(entry.getKey(), entry.getValue());
        }
    }

