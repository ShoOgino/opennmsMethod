        /**
         * Adjust the size of the thread pool based on the ratio of queue
         * elements to threads. The thread pool is adjusted by the lo and hi
         * water marks which are a ratio of elements to threads.
         */
        private void adjust() {
            int e = size();
            synchronized (m_fibers) {
                int alive = livingFiberCount();
                float ratio = (float) e / (float) (alive <= 0 ? 1 : alive);

                // Never stop the last thread!?
                //
                if (alive > 1 && ratio <= m_loRatio) {
                    // IF
                    // 1) Fibers greater than one, and...
                    // 2) ratio less than low water mark
                    //
                    Fiber f = null;
                    int last = Fiber.START_PENDING;
                    for (int x = 0; x < m_fibers.length; x++) {
                        if (m_fibers[x] != null) {
                            switch (m_fibers[x].getStatus()) {
                            case Fiber.RUNNING:
                                if (last < Fiber.RUNNING) {
                                    f = m_fibers[x];
                                    last = f.getStatus();
                                }
                                break;

                            case Fiber.STOP_PENDING:
                                if (last < Fiber.STOP_PENDING) {
                                    f = null;
                                    last = Fiber.STOP_PENDING;
                                }
                                break;
                            }
                        }
                    }

                    if (f != null && f.getStatus() != Fiber.STOP_PENDING) {
                        Category log = ThreadCategory.getInstance(this.getClass());
                        if (log.isDebugEnabled())
                            log.debug("adjust: calling stop on fiber " + f.getName());
                        f.stop();
                    }

                } else if (((alive == 0 && e > 0) || ratio > m_hiRatio) && alive < m_maxSize) {
                    // If
                    // 1a) Fibers equal to zero and queue not empty, or..
                    // 1a) ratio greater than hiRatio, and...
                    // 2) Fibers less than max size
                    //
                    for (int x = 0; x < m_fibers.length; x++) {
                        if (m_fibers[x] == null || m_fibers[x].getStatus() == Fiber.STOPPED) {
                            Fiber f = new FiberThreadImpl(m_poolName + "-fiber" + x);
                            f.start();
                            m_fibers[x] = f;
                            Category log = ThreadCategory.getInstance(this.getClass());
                            if (log.isDebugEnabled())
                                log.debug("adjust: started fiber " + f.getName() + " ratio = " + ratio + ", alive = " + alive);
                            break;
                        }
                    }
                }
            } // synchronized m_fibers
        }

