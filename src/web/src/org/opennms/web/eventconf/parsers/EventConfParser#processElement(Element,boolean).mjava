    /**
     * This method is called from the parse method and overrides the method in
     * BBParser. It identifies tag names and takes appropriate actions to get
     * data from the xml tags.
     * 
     * @param el
     *            the current tree element
     * @param isRoot
     *            true if the element is the root of the tree
     * @return true if method was successful, false otherwise
     */
    protected boolean processElement(Element el, boolean isRoot) {
        if (el.getTagName().equals("global")) {
            processGlobal(el);
        } else if (el.getTagName().equals("event")) {
            m_curEvent = new Event();
            m_events.add(m_curEvent);
        } else if (el.getTagName().equals("uei")) {
            m_curEvent.setUei(processParmValue((Node) el));
        } else if (el.getTagName().equals("mask")) {
            processMask(el, m_curEvent);
        } else if (el.getTagName().equals("snmp")) {
            m_curEvent.setSnmp(processSnmp(el));
        } else if (el.getTagName().equals("descr")) {
            m_curEvent.setDescription(processParmValue((Node) el));
        } else if (el.getTagName().equals("logmsg")) {
            m_curEvent.setLogMessage(processParmValue((Node) el));
        } else if (el.getTagName().equals("severity")) {
            m_curEvent.setSeverity(processParmValue((Node) el));
        } else if (el.getTagName().equals("correlation")) {
            Correlation correlation = new Correlation();

            correlation.setCorrelationPath(el.getAttribute("path"));
            correlation.setState(el.getAttribute("state"));
            processCorrelation(el, correlation);

            m_curEvent.setCorrelation(correlation);
        } else if (el.getTagName().equals("operinstruct")) {
            m_curEvent.setOperInstruct(processParmValue((Node) el));
        } else if (el.getTagName().equals("autoaction")) {
            m_curEvent.addAutoAction(processAutoAction(el));
        } else if (el.getTagName().equals("operaction")) {
            m_curEvent.addOperatorAction(processOperatorAction(el));
        } else if (el.getTagName().equals("autoacknowledge")) {
            m_curEvent.setAutoAcknowledge(processParmValue((Node) el));
            m_curEvent.setAutoAcknowledgeState(el.getAttribute("state"));
        } else if (el.getTagName().equals("loggroup")) {
            m_curEvent.addLogGroup(processParmValue((Node) el));
        } else if (el.getTagName().equals("notification")) {
            m_curEvent.addNotification(processParmValue((Node) el));
        } else if (el.getTagName().equals("tticket")) {
            m_curEvent.setTticket(processParmValue((Node) el));
            m_curEvent.setTticketState(el.getAttribute("state"));
        } else if (el.getTagName().equals("forward")) {
            Forward forward = new Forward();

            forward.setMechanism(el.getAttribute("mechanism"));
            forward.setState(el.getAttribute("state"));
            forward.setForward(processParmValue((Node) el));

            m_curEvent.addForward(forward);
        } else if (el.getTagName().equals("mouseovertext")) {
            m_curEvent.setMouseOverText(processParmValue((Node) el));
        }

        NodeList nl = el.getChildNodes();
        int size = nl.getLength();
        for (int i = 0; i < size; i++) {
            processNode(nl.item(i));
        }

        return true;
    }

