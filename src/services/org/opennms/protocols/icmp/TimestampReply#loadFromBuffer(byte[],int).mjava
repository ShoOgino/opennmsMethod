	/**
	 * Reads the ICMP Address Mask Reqeust from the specified 
	 * buffer and sets the internal fields equal to the data. 
	 * If the buffer does not have sufficent data to restore the
	 * header then an IndexOutOfBoundsException is thrown
	 * by the method. If the buffer does not contain an
	 * address mask reqeust then an IllegalArgumentException
	 * is thrown.
	 *
	 * @param buf	The buffer to read the data from.
	 * @param offset The offset to start reading data.
	 *
	 * @return The new offset after reading the data.
	 *
	 * @exception java.lang.IndexOutOfBoundsException Thrown if there
	 *	is not sufficent data in the buffer.
	 * @exception java.lang.IllegalArgumentException Thrown if the ICMP type
	 *	is not an Timestamp Reply.
	 */
	public final int loadFromBuffer(byte[] buf, int offset)
	{
		if(buf.length < (offset + 20))
			throw new IndexOutOfBoundsException("Insufficient data to load ICMP header");

		offset = super.loadFromBuffer(buf, offset);

		if(getType() != TYPE_TIMESTAMP_REPLY)
			throw new IllegalArgumentException("The buffer did not contain an Timestamp Reply");

		m_origStamp = byteToInt(buf[offset++]) << 24 |
			      byteToInt(buf[offset++]) << 16 |
			      byteToInt(buf[offset++]) << 8  |
			      byteToInt(buf[offset++]);

		m_recvStamp = byteToInt(buf[offset++]) << 24 |
			      byteToInt(buf[offset++]) << 16 |
			      byteToInt(buf[offset++]) << 8  |
			      byteToInt(buf[offset++]);

		m_xmitStamp = byteToInt(buf[offset++]) << 24 |
			      byteToInt(buf[offset++]) << 16 |
			      byteToInt(buf[offset++]) << 8  |
			      byteToInt(buf[offset++]);

		return offset;
	}

