    /**
     * Writes the ICMP address mask reply out to the specified buffer at the
     * starting offset. If the buffer does not have sufficent data to store the
     * information then an IndexOutOfBoundsException is thrown.
     * 
     * @param buf
     *            The storage buffer.
     * @param offset
     *            The location to start in buf.
     * 
     * @return The new offset after storing to the buffer.
     * 
     * @exception java.lang.IndexOutOfBoundsException
     *                Thrown if the buffer does not have enough storage space.
     * 
     */
    public final int storeToBuffer(byte[] buf, int offset) {
        if (buf.length < (offset + 20))
            throw new IndexOutOfBoundsException("Array index overflow in buffer build");

        computeChecksum();
        offset = super.storeToBuffer(buf, offset);

        //
        // store the current timestamp
        //
        buf[offset++] = (byte) ((m_origStamp >> 24) & 0xff);
        buf[offset++] = (byte) ((m_origStamp >> 16) & 0xff);
        buf[offset++] = (byte) ((m_origStamp >> 8) & 0xff);
        buf[offset++] = (byte) (m_origStamp & 0xff);

        buf[offset++] = (byte) ((m_recvStamp >> 24) & 0xff);
        buf[offset++] = (byte) ((m_recvStamp >> 16) & 0xff);
        buf[offset++] = (byte) ((m_recvStamp >> 8) & 0xff);
        buf[offset++] = (byte) (m_recvStamp & 0xff);

        buf[offset++] = (byte) ((m_xmitStamp >> 24) & 0xff);
        buf[offset++] = (byte) ((m_xmitStamp >> 16) & 0xff);
        buf[offset++] = (byte) ((m_xmitStamp >> 8) & 0xff);
        buf[offset++] = (byte) (m_xmitStamp & 0xff);

        return offset;
    }

