	/**
	 * This method returns a list of all ip addresses that
	 * match the rule that is passed in.
	 * 
	 * @param String rule, an expression rule to be parsed and executed.
	 *
	 * @return List, interface containing all ip addresses selected by the rule.
	 *
	 * @exception FilterParseException, if a rule is syntactically incorrect or
         *            failed in executing the SQL statement
	 */
	public List getIPList(String rule)
		throws FilterParseException
        {
		List resultList = new ArrayList();
		String sqlString = null;
		
		// parse the rule
		parseRule(rule);
		
		// get the database connection
		Connection conn = null;
		try
		{
			DatabaseConnectionFactory.init();
			conn = DatabaseConnectionFactory.getInstance().getConnection();

			//parse the rule and get the sql select statement
			//
			sqlString = getSQLStatement();
			
			//execute query and return the list of ip addresses
			//
			Statement stmt = conn.createStatement();
			ResultSet rset = stmt.executeQuery(sqlString);

			//fill up the array list if the result set has values
			//
			if (rset != null)
			{
				// Iterate through the result and build the array list
				while (rset.next ())
				{
					resultList.add(rset.getString(1));
			    	}
			}

			try
			{
				rset.close();
			} catch(SQLException e) { }

			try
			{
				stmt.close();
			} catch(SQLException e) { }

		}
		catch(ClassNotFoundException e)
		{
			Category log = ThreadCategory.getInstance(getClass());
			log.info("Class Not Found Exception occured getting IP List", e);
			throw new UndeclaredThrowableException(e);
		}
		catch(SQLException e)
		{
			Category log = ThreadCategory.getInstance(getClass());
			log.info("SQL Exception occured getting IP List", e);
			throw new UndeclaredThrowableException(e);
		}
		catch (IOException ie)
		{
			Category log = ThreadCategory.getInstance(getClass());
			log.fatal("IOException getting database connection", ie);
			throw new UndeclaredThrowableException(ie);
		}
		catch (MarshalException me)
		{
			Category log = ThreadCategory.getInstance(getClass());
			log.fatal("Marshall Exception getting database connection", me);
			throw new UndeclaredThrowableException(me);
		}
		catch (ValidationException ve)
		{
			Category log = ThreadCategory.getInstance(getClass());
			log.fatal("Validation Exception getting database connection", ve);
			throw new UndeclaredThrowableException(ve);
		}
		finally
		{
			if (conn != null)
			{
				try
				{
					conn.close();
				}
				catch(SQLException e) { }
			}
		}
		
		return resultList;
	}

