    /**
     * Perform data collection.
     * 
     * @param iface
     *            Network interface to be data collected.
     * @param eproxy
     *            Eventy proxy for sending events.
     * @param parameters
     *            Key/value pairs from the package to which the interface
     *            belongs.
     */
    public int collect(NetworkInterface iface, EventProxy eproxy, Map parameters) {
        try {
            // Retrieve this interface's SNMP peer object
            //
            SnmpPeer peer = getPeer(iface, parameters);
            
            // Establish SNMP session with interface
            //
            SnmpSession session = getSession(peer);
            
            // -----------------------------------------------------------
            // 
            // Collect node and interface MIB data from the remote agent
            //
            // -----------------------------------------------------------
            SnmpNodeCollector nodeCollector = null;
            SnmpIfCollector ifCollector = null;
            
            // Need to be certain that we close the SNMP session when
            // the poll() is completed...wrapping data collection code
            // in a try/finally block
            try {
                // Any interface specific oids to be collected?
                //
                // If there are interface oids to be collected then we need to know
                // how many interfaces are configured on the remote host so that we
                // can efficiently collect data from the interface table (such as
                // ifOctetsIn, ifOctetsOut...). Retrieve the value of the
                // 'interface.ifNumber' MIB object for this purpose.
                //
                // NOTE: The last retrieved value of 'interface.ifNumber' is stored
                // as an interface attribute using the key 'INTERFACE_COUNT_KEY'.
                // If the newly retrieved count differs from the saved value then
                // a forceRescan event will be sent via Eventd to Capsd. Capsd will
                // rescan the node and update the database accordingly. As a result,
                // a reinitializePrimarySnmpInterface or primarySnmpInterfaceChanged
                // may be generated by Capsd.
                int ifCount = -1;
                
                if (hasInterfaceOids(iface)) {
                    int savedIfCount = getSavedIfCount(iface);
                    
                    ifCount = getCurrentIfCount(session, iface);
                    
                    saveIfCount(iface, ifCount);
                    
                    log().debug("collect: interface: " + getHostAddress(iface) + " ifCount: " + ifCount + " savedIfCount: " + savedIfCount);
                    
                    // If saved interface count differs from the newly retreived
                    // interface count the following must occur:
                    // 
                    // 1. generate forceRescan event so Capsd will rescan the
                    // node, update the database, and generate the appropriate
                    // events back to the poller.
                    // 
                    // 2. Skip the data collection by returning COLLECTION_SUCCEEDED
                    // immediately. We return COLLECTION_SUCCEEDED in this instance
                    // since SNMP isn't actually down
                    //
                    if (savedIfCount != -1) {
                        if (ifCount != savedIfCount) {
                            log().info("Number of interfaces on primary SNMP interface " + getHostAddress(iface) + " has changed, generating 'ForceRescan' event. " + "Data collection will not be performed.");
                            
                            generateForceRescanEvent(getHostAddress(iface), eproxy);
                            
                            // FIXME: I don't like this... shouldn't we jus proceed with the collection anyway?
                            return COLLECTION_SUCCEEDED;
                        }
                    }
                }
                
                // 
                // Collect node data
                //
                if (!getNodeInfo(iface).getOidList().isEmpty()) {
                    nodeCollector = collectNodeData(session, iface);
                } // end if (hasNodeOids)
                
                // 
                // Collect interface data
                //
                if (hasInterfaceOids(iface)) {
                    ifCollector = collectIfData(session, iface, ifCount);
                } // end if(hasInterfaceOids)
            } finally {
                //
                // Regardless of what happens with
                // the collection, close the session
                // when we're finished collecting data.
                //
                try {
                    session.close();
                } catch (Exception e) {
                    if (log().isEnabledFor(Priority.WARN))
                        log().warn("collect: An error occured closing the SNMP session for " + getHostAddress(iface), e);
                }
            }
            
            // Update RRD with values retrieved in SNMP collection
            boolean rrdError = updateRRDs(getCollectionName(parameters), iface, nodeCollector, ifCollector);
            
            if (rrdError) {
                log().warn("collect: RRD error during update for " + getHostAddress(iface));
            }
            
            //
            // return the status of the collection
            //
            return COLLECTION_SUCCEEDED;
        } catch (CollectionError e) {
            if (e.getCause() == null)
                log().error(e.getMessage());
            else
                log().error(e.getMessage(), e.getCause());
            return COLLECTION_FAILED;
        } catch (CollectionWarning e) {
            if (e.getCause() == null)
                log().warn(e.getMessage());
            else
                log().warn(e.getMessage(), e.getCause());
            return COLLECTION_FAILED;
        }
    }

