	/**
	 * This method is responsible for building an RRDTool style 'update' command
	 * which is issued via the RRD JNI interface in order to push the latest
	 * SNMP-collected values into the interface's RRD database.
	 * 
	 * @param collectionName
	 *            SNMP data Collection name from 'datacollection-config.xml'
	 * @param iface
	 *            CollectionInterface object of the interface currently being
	 *            polled
	 * @param nodeCollector
	 *            Node level MIB data collected via SNMP for the polled
	 *            interface
	 * @param ifCollector
	 *            Interface level MIB data collected via SNMP for the polled
	 *            interface
	 * @throws CollectionError
	 * @exception RuntimeException
	 *                Thrown if the data source list for the interface is null.
	 */
	private boolean updateRRDs(String collectionName, CollectionInterface iface,
			SnmpNodeCollector nodeCollector, SnmpIfCollector ifCollector,
			Map parms, EventProxy eproxy) throws CollectionError {
		// Log4j category
		InetAddress ipaddr = iface.getInetAddress();

		// Retrieve SNMP storage attribute
		String snmpStorage = iface.getSnmpStorage();

		// Get primary interface index from NodeInfo object
		int nodeId = iface.getNodeId();
		int primaryIfIndex = iface.getIfIndex();

		// Retrieve interface map attribute
		Map ifMap = iface.getIfMap();
		verifyIfMap(iface, ifMap);

		/*
		 * Write relevant collected SNMP statistics to RRD database First the
		 * node level RRD info will be updated. Secondly the interface level RRD
		 * info will be updated.
		 */
		boolean rrdError = false;

		// Node data
		if (nodeCollector != null) {
			log().debug("updateRRDs: processing node-level collection...");

			/*
			 * Build path to node RRD repository. createRRD() will make the
			 * appropriate directories if they do not already exist.
			 */
			String nodeRepository = m_rrdPath + File.separator
					+ String.valueOf(nodeId);

			SNMPCollectorEntry nodeEntry = nodeCollector.getEntry();

			/*
			 * Iterate over the node datasource list and issue RRD update
			 * commands to update each datasource which has a corresponding
			 * value in the collected SNMP data.
			 */
			Iterator iter = iface.getNodeDsList().iterator();
			while (iter.hasNext()) {
				DataSource ds = (DataSource) iter.next();

				try {
					String dsVal = getRRDValue(ds, nodeEntry);
					if (dsVal == null) {
						// Do nothing, no update is necessary
						if (log().isDebugEnabled()) {
							log().debug(
									"updateRRDs: Skipping update, no "
											+ "data retrieved for nodeId: "
											+ nodeId + " datasource: "
											+ ds.getName());
						}
					} else {
						// createRRD(collectionName, ipaddr, nodeRepository,
						// ds);
						if (ds.performUpdate(collectionName, ipaddr
								.getHostAddress(), nodeRepository,
								ds.getName(), dsVal)) {
							log().warn(
									"updateRRDs: ds.performUpdate() "
											+ "failed for node: " + nodeId
											+ " datasource: " + ds.getName());
							rrdError = true;
						}
					}
				} catch (IllegalArgumentException e) {
					log().warn("getRRDValue: " + e.getMessage());

					// Set rrdError flag
					rrdError = true;
					log().warn(
							"updateRRDs: call to getRRDValue() failed "
									+ "for node: " + nodeId + " datasource: "
									+ ds.getName());
				}

			} // end while(more datasources)
		} // end if(nodeCollector != null)

		// Interface-specific data
		boolean forceRescan = false;
		boolean rescanPending = false;
		Map SnmpIfAliasMap = new HashMap();

		if (ifCollector != null) {
			String domain = ParameterMap.getKeyedString(parms, "domain",
					"default");
			String storeByNodeID = ParameterMap.getKeyedString(parms,
					"storeByNodeID", "normal");
			String storeByIfAlias = ParameterMap.getKeyedString(parms,
					"storeByIfAlias", "false");
			String storFlagOverride = ParameterMap.getKeyedString(parms,
					"storFlagOverride", "false");
			String ifAliasComment = ParameterMap.getKeyedString(parms,
					"ifAliasComment", null);

			if (log().isDebugEnabled() && storeByIfAlias.equals("true")) {
				log()
						.debug(
								"domain:storeByNodeID:storeByIfAlias:"
										+ "storFlagOverride:ifAliasComment = "
										+ domain + ":" + storeByNodeID + ":"
										+ storeByIfAlias + ":"
										+ storFlagOverride + ":"
										+ ifAliasComment);
			}

			/*
			 * Retrieve list of SNMP collector entries generated for the remote
			 * node's interfaces.
			 */
			List snmpCollectorEntries = ifCollector.getEntries();
			if (snmpCollectorEntries == null
					|| snmpCollectorEntries.size() == 0) {
				log().warn(
						"updateRRDs: No data retrieved for the interface "
								+ ipaddr.getHostAddress());
			}

			// get the snmpIfAliases
			if (isForceRescanInProgress(nodeId, ipaddr.getHostAddress())) {
				rescanPending = true;
			} else {
				SnmpIfAliasMap = getIfAliasesFromDb(nodeId);
			}

			// Iterate over the SNMP collector entries
			Iterator iter = snmpCollectorEntries.iterator();
			while (iter.hasNext()) {
				SNMPCollectorEntry ifEntry = (SNMPCollectorEntry) iter.next();

				int ifIndex = ifEntry.getIfIndex().intValue();
				String ifIdx = Integer.toString(ifIndex);

				// get the ifAlias if one exists
				String aliasVal = getRRDIfAlias(ifIdx, ifEntry);
				if (aliasVal != null && !aliasVal.equals("")) {
					aliasVal = aliasVal.trim();

					/*
					 * Check DB to see if ifAlias is current and flag a forced
					 * rescan if not.
					 */
					if (!rescanPending) {
						if (SnmpIfAliasMap.get(ifIdx) == null
								|| !SnmpIfAliasMap.get(ifIdx).equals(aliasVal)) {
							rescanPending = true;
							forceRescan = true;
							if (log().isDebugEnabled()) {
								log().debug(
										"Forcing rescan.  IfAlias " + aliasVal
												+ " for index " + ifIdx
												+ " does not match DB value: "
												+ SnmpIfAliasMap.get(ifIdx));
							}
						}
					}
					if (ifAliasComment != null) {
						int si = aliasVal.indexOf(ifAliasComment);
						if (si > -1) {
							aliasVal = aliasVal.substring(0, si).trim();
						}
					}
					if (aliasVal != null && !aliasVal.equals("")) {
						aliasVal = AlphaNumeric.parseAndReplaceExcept(aliasVal,
								nonAnRepl, AnReplEx);
					}
				}

				boolean override = true;
				if (storFlagOverride.equals("false") || (aliasVal == null)
						|| aliasVal.equals("")) {
					override = false;
				}
				String byNode = storeByNodeID;

				/*
				 * Are we storing SNMP data for all interfaces or primary
				 * interface only? If only storing for primary interface only
				 * proceed if current ifIndex is equal to the ifIndex of the
				 * primary SNMP interface.
				 */
				if (snmpStorage.equals(SNMP_STORAGE_PRIMARY)) {
					if (ifIndex != primaryIfIndex) {
						if (override) {
							if (log().isDebugEnabled()) {
								log()
										.debug(
												"updateRRDs: storFlagOverride "
														+ "= true. Storing SNMP data for "
														+ "non-primary interface "
														+ ifIdx);
							}
						} else {
							if (log().isDebugEnabled()) {
								log()
										.debug(
												"updateRRDs: only storing "
														+ "SNMP data for primary interface ("
														+ primaryIfIndex
														+ "), skipping ifIndex: "
														+ ifIdx);
							}
							continue;
						}
						if (byNode.equals("normal")) {
							byNode = "false";
						}
					}
				}

				/*
				 * Use ifIndex to lookup the IfInfo object from the interface
				 * map.
				 */
				IfInfo ifInfo = (IfInfo) ifMap.get(new Integer(ifIndex));
				if (ifInfo == null) {
					// no data needed for this interface
					continue;
				}

				if (snmpStorage.equals(SNMP_STORAGE_SELECT)) {
					if (ifInfo.getCollType().equals(CollectionType.NO_COLLECT)) {
						if (override) {
							if (log().isDebugEnabled()) {
								log()
										.debug(
												"updateRRDs: storFlagOverride "
														+ "= true. Storing SNMP data for "
														+ "interface " + ifIdx
														+ " with CollType = "
														+ ifInfo.getCollType());
							}
						} else {
							if (log().isDebugEnabled()) {
								log()
										.debug(
												"updateRRDs: selectively storing "
														+ "SNMP data for primary interface ("
														+ primaryIfIndex
														+ "), skipping ifIndex: "
														+ ifIdx
														+ " because collType = "
														+ ifInfo.getCollType());
							}
							continue;
						}
						if (byNode.equals("normal")) {
							byNode = "false";
						}
					}
				}
				if (byNode.equals("normal")) {
					byNode = "true";
				}

				if (ifInfo.getDsList() == null) {
					throw new RuntimeException("Data Source list not "
							+ "available for primary IP addr "
							+ ipaddr.getHostAddress() + " and ifIndex "
							+ ifInfo.getIndex());
				}

				/*
				 * Iterate over the interface datasource list and issue RRD
				 * update commands to update each datasource which has a
				 * corresponding value in the collected SNMP data.
				 */
				Iterator i = ifInfo.getDsList().iterator();
				while (i.hasNext()) {
					DataSource ds = (DataSource) i.next();

					/*
					 * Build path to interface RRD repository. createRRD() will
					 * make the appropriate directories if they do not already
					 * exist.
					 */
					String ifRepository = m_rrdPath + File.separator
							+ String.valueOf(nodeId) + File.separator
							+ ifInfo.getLabel();

					try {
						String dsVal = getRRDValue(ds, ifEntry);

						// Build RRD update command
						if (dsVal == null) {
							// Do nothing, no update is necessary
							if (log().isDebugEnabled()) {
								log().debug(
										"updateRRDs: Skipping update, "
												+ "no data retrieved for "
												+ "node/ifindex: " + nodeId
												+ "/" + ifIndex
												+ " datasource: "
												+ ds.getName());
							}
						} else {
							/*
							 * Call createRRD() to create RRD if it doesn't
							 * already exist.
							 */
							// createRRD(collectionName, ipaddr, ifRepository,
							// ds);
							if (byNode.equals("true")) {
								if (ds.performUpdate(collectionName, ipaddr
										.getHostAddress(), ifRepository, ds
										.getName(), dsVal)) {
									log()
											.warn(
													"updateRRDs: "
															+ "ds.performUpdate() failed for "
															+ "node/ifindex: "
															+ nodeId + "/"
															+ ifIndex
															+ " datasource: "
															+ ds.getName());
									rrdError = true;
								}
							}
							if (storeByIfAlias.equals("true")) {
								if ((aliasVal != null) && !aliasVal.equals("")) {
									ifRepository = m_rrdPath + File.separator
											+ domain + File.separator
											+ aliasVal;
									if (ds.performUpdate(collectionName, ipaddr
											.getHostAddress(), ifRepository, ds
											.getName(), dsVal)) {
										log()
												.warn(
														"updateRRDs: "
																+ "ds.performUpdate() failed for "
																+ "node/ifindex/domain/alias: "
																+ nodeId
																+ "/"
																+ ifIndex
																+ "/"
																+ domain
																+ "/"
																+ aliasVal
																+ " datasource: "
																+ ds.getName());
										rrdError = true;
									}
								}
							}

						}
					} catch (IllegalArgumentException e) {
						log().warn("buildRRDUpdateCmd: " + e.getMessage());

						// Set rrdError flag
						rrdError = true;
						log().warn(
								"updateRRDs: call to buildRRDUpdateCmd() "
										+ "failed for node/ifindex: " + nodeId
										+ "/" + ifIndex + " datasource: "
										+ ds.getName());
					}

				} // end while(more datasources)
			} // end while(more SNMP collector entries)
		} // end if(ifCollector != null)

		if (forceRescan) {
			generateForceRescanEvent(ipaddr.getHostAddress(), iface.getNodeId(), eproxy);
		}
		return rrdError;
	}

