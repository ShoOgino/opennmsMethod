    /**
     * Constructs a new instance of a CollectableService object.
     * 
     * @param dbNodeId
     *            The database identifier key for the interfaces' node
     * @param address
     *            InetAddress of the interface to collect from
     * @param svcName
     *            Service name
     * @param pkg
     *            The package containing parms for this collectable service.
     * 
     */
    CollectableService(int dbNodeId, InetAddress address, String svcName, org.opennms.netmgt.config.collectd.Package pkg) {
        super(address);
        Category log = ThreadCategory.getInstance(getClass());
        m_nodeId = dbNodeId;
        m_package = pkg;
        m_status = ServiceCollector.COLLECTION_SUCCEEDED;

	m_storeByIfAlias = pkg.getStoreByIfAlias();
	m_storeByNodeID = pkg.getStoreByNodeID();
	m_ifAliasDomain = pkg.getIfAliasDomain();
	m_storFlagOverride = pkg.getStorFlagOverride();
	m_ifAliasComment = pkg.getIfAliasComment();

        m_scheduler = Collectd.getInstance().getScheduler();
        m_collector = Collectd.getInstance().getServiceCollector(svcName);
        m_updates = new CollectorUpdates();

        m_lastScheduledCollectionTime = 0L;
        m_lastCollectionTime = 0L;

        // find the service matching the name
        // m
        Service svc = null;
        Enumeration esvc = m_package.enumerateService();
        while (esvc.hasMoreElements()) {
            Service s = (Service) esvc.nextElement();
            if (s.getName().equalsIgnoreCase(svcName)) {
                svc = s;
                break;
            }
        }
        if (svc == null)
            throw new RuntimeException("Service name not part of package!");

        // save reference to the service
        m_service = svc;

        // add property list for this service/package combination if
        // it doesn't already exist in the service property map
        //
        m_svcPropKey = m_package.getName() + "." + m_service.getName();
        synchronized (SVC_PROP_MAP) {
            if (!SVC_PROP_MAP.containsKey(m_svcPropKey)) {
                Map m = Collections.synchronizedMap(new TreeMap());
                Enumeration ep = m_service.enumerateParameter();
                while (ep.hasMoreElements()) {
                    Parameter p = (Parameter) ep.nextElement();
                    m.put(p.getKey(), p.getValue());
                }
		if(m_storeByIfAlias != null && isTrue(m_storeByIfAlias)) {
		    m.put("storeByIfAlias", "true");
		    if(m_storeByNodeID != null) {
			if(isTrue(m_storeByNodeID)) {
		            m.put("storeByNodeID", "true");
			} else if(isFalse(m_storeByNodeID)) {
		            m.put("storeByNodeID", "false");
			} else {
		            m.put("storeByNodeID", "normal");
			}
		    }
		    if(m_ifAliasDomain != null) {
			m.put("domain", m_ifAliasDomain);
		    } else {
		        m.put("domain", m_package.getName());
		    }
		    if(m_storFlagOverride != null && isTrue(m_storFlagOverride)) {
		        m.put("storFlagOverride", "true");
		    }
		    m.put("ifAliasComment", m_ifAliasComment);
                    if (log.isDebugEnabled())
		        log.debug("ifAliasDomain = " + m_ifAliasDomain + ", storeByIfAlias = " + m_storeByIfAlias + ", storeByNodeID = " + m_storeByNodeID + ", storFlagOverride = " + m_storFlagOverride + ", ifAliasComment = " + m_ifAliasComment);
		}

                SVC_PROP_MAP.put(m_svcPropKey, m);
            }
        }

        m_proxy = new EventProxy() {
            public void send(Event e) {
                EventIpcManagerFactory.getIpcManager().sendNow(e);
            }

            public void send(Log log) {
                EventIpcManagerFactory.getIpcManager().sendNow(log);
            }
        };

    }

