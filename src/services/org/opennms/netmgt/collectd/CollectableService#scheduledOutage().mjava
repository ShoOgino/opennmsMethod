	/**
     * Checks the package information for the collectable service and determines
     * if any of the calendar outages associated with the package apply to the
     * current time and the service's interface. If an outage applies true is
     * returned...otherwise false is returned.
     * 
     * @return false if no outage found (indicating a collection may be
     *         performed) or true if applicable outage is found (indicating
     *         collection should be skipped).
     */
    private boolean scheduledOutage() {
        boolean outageFound = false;

        PollOutagesConfigFactory outageFactory = PollOutagesConfigFactory.getInstance();

        // Iterate over the outage names defined in the interface's package.
        // For each outage...if the outage contains a calendar entry which
        // applies to the current time and the outage applies to this
        // interface then break and return true. Otherwise process the
        // next outage.
        // 
        Iterator iter = m_spec.getPackage().getOutageCalendarCollection().iterator();
        while (iter.hasNext()) {
            String outageName = (String) iter.next();

            // Does the outage apply to the current time?
            if (outageFactory.isCurTimeInOutage(outageName)) {
                // Does the outage apply to this interface?
                if ((outageFactory.isNodeIdInOutage((long)m_nodeId, outageName)) ||
			(outageFactory.isInterfaceInOutage(m_address.getHostAddress(), outageName)))
		{
                    if (log().isDebugEnabled())
                        log().debug("scheduledOutage: configured outage '" + outageName + "' applies, interface " + m_address.getHostAddress() + " will not be collected for " + m_spec);
                    outageFound = true;
                    break;
                }
            }
        }

        return outageFound;
    }

