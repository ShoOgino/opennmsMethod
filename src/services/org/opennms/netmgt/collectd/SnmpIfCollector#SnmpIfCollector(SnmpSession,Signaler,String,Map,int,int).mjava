	/**
	 * <P>The class constructor is used to initialize the collector
	 * and send out the initial SNMP packet requesting data. The
	 * data is then received and store by the object. When all the
	 * data has been collected the passed signaler object is <EM>
	 * notified</EM> using the notifyAll() method.</P>
	 *
	 * @param session	The SNMP session with the remote agent.
	 * @param signaler	The object signaled when data collection is done.
	 * @param m_primaryIfIndex       The ifIndex value linked to the primary IP.
	 * @param ifMap		Map of org.opennms.netmgt.poller.collectd.IfInfo objects.
	 * @param ifCount	Number of interfaces found in node's MIB-II ifTable
	 * @param maxVarsPerPdu Max number of variables permitted in a single PDU.
	 */
	public SnmpIfCollector(SnmpSession 	session,
				Signaler 	signaler, 
				String 		primaryIfIndex, 
				Map 		ifMap,
				int		ifCount,
				int		maxVarsPerPdu)
	{
		super();
		
		// Log4j category
		//
		Category log = ThreadCategory.getInstance(getClass());
		
		m_error = false;
		m_errorIndex = -1;
		m_timeout = false;
		
		// Process parameters
		//
		m_primaryIf = session.getPeer().getPeer().getHostAddress();
		m_primaryIfIndex = primaryIfIndex;
		m_version = session.getPeer().getParameters().getVersion();
		m_signal = signaler;		
		m_oidListIndex = 0;
		m_collectorEntry = null;
		m_numInterfaces = ifCount;
		m_ifMap = ifMap;
		m_maxVarsPerPdu = maxVarsPerPdu;
		if (log.isDebugEnabled())
			log.debug("SnmpIfCollector: maxVarsPerPdu=" + maxVarsPerPdu);
		
		// Build (String) array of interface indices using ifMap parm
		//
		Collection interfaces = ifMap.values();
		Iterator iter = interfaces.iterator();
		m_indexArray = new String[ifMap.size()];
		if (log.isDebugEnabled())
			log.debug("SnmpIfCollector: ifMap size: " + ifMap.size());

		int i = 0;
		while(iter.hasNext())
		{
			IfInfo ifInfo = (IfInfo)iter.next();
			m_indexArray[i++] = String.valueOf(ifInfo.getIndex());
			if (log.isDebugEnabled())
				log.debug("SnmpIfCollector: arrayIndex: " + i + " ifIndex: " + String.valueOf(ifInfo.getIndex()));
		}	
		
		// Build object lists for SNMPv2 processing
		//
		m_objList = null;
		m_objList_v2 = null;
		if (m_version == SnmpSMI.SNMPV2)
		{
			// Generate object list consisting of all unique oids
			// to be collected from all interfaces
			m_objList = buildV2CombinedOidList(ifMap);
			
			// Create copy of combined oid list which can
			// be modified during collection without affecting
			// the master list
			m_objList_v2 = new ArrayList(m_objList.size());
			for (int c = 0; c < m_objList.size(); c++) 
			{
				m_objList_v2.add(m_objList.get(c));
			}
		}
			
		// Allocate temporary storage to hold response varbinds.
		//
		m_responseVbList = new ArrayList();
		m_responses = 0;

		// Instantiate ArrayList to hold generated SnmpCollectoryEntry objects
		// created during the collection.
		//
		m_entries = new ArrayList(2);
		
		// Create initial PDU request and send it to the remote host.
		//
		SnmpPduPacket pdu = null;
		if (m_version == SnmpSMI.SNMPV2)
		{
			pdu = getNextSnmpV2Pdu(m_primaryIf);
		}
		else if (m_version == SnmpSMI.SNMPV1)
		{
			pdu = getNextSnmpV1Pdu(m_primaryIf);
		}
		if (log.isDebugEnabled())
			log.debug("SnmpIfCollector: sending initial interface SNMP get(Next/Bulk) request PDU for " + m_primaryIf + " with ifIndex: " + m_primaryIfIndex);

		session.send(pdu, this);
	}

