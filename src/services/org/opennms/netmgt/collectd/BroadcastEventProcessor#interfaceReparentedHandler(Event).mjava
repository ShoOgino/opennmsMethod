	/**
	 * This method is responsible for processing 'interfacReparented' events.  
	 * An 'interfaceReparented' event will have old and new nodeId parms
	 * associated with it.  All CollectableService objects in the service 
	 * updates map which match the event's interface address and the SNMP
	 * service have a reparenting update associated with them.  When the 
	 * scheduler next pops one of these services from an interval queue
	 * for collection all of the RRDs associated with the old nodeId are 
	 * moved under the new nodeId and the nodeId of the collectable
	 * service is updated to reflect the interface's new parent nodeId.
	 *
	 * @param event	The event to process.
	 *
	 */
	private void interfaceReparentedHandler(Event event)
	{
		Category log = ThreadCategory.getInstance(getClass());
		if (log.isDebugEnabled())
			log.debug("interfaceReparentedHandler:  processing interfaceReparented event for " + 
				event.getInterface());
		
		// Verify that the event has an interface associated with it
		if (event.getInterface() == null)
			return;
			
		// Extract the old and new nodeId's from the event parms
		String oldNodeIdStr = null;
		String newNodeIdStr = null;
		Parms parms = event.getParms();
		if (parms != null)
		{
			String parmName = null;
			Value parmValue = null;
			String parmContent = null;
		
			Enumeration parmEnum = parms.enumerateParm();
			while(parmEnum.hasMoreElements())
			{
				Parm parm = (Parm)parmEnum.nextElement();
				parmName  = parm.getParmName();
				parmValue = parm.getValue();
				if (parmValue == null)
					continue;
				else 
					parmContent = parmValue.getContent();
	
				// old nodeid 
				if (parmName.equals(EventConstants.PARM_OLD_NODEID))
				{
					oldNodeIdStr = parmContent;
				}
						
				// new nodeid 
				else if (parmName.equals(EventConstants.PARM_NEW_NODEID))
				{
					newNodeIdStr = parmContent;
				}
			}
		}

		// Only proceed provided we have both an old and a new nodeId
		//
		if (oldNodeIdStr == null || newNodeIdStr == null)
		{
			log.warn("interfaceReparentedHandler: old and new nodeId parms are required, unable to process.");
			return;
		}

		// Iterate over the CollectableService objects in the services
		// list looking for entries which share the same interface
		// address as the reparented interface.  Mark any matching objects
		// for reparenting.  
		//
		// The next time the service is scheduled for execution it
		// will move all of the RRDs associated
		// with the old nodeId under the new nodeId and update the service's
		// SnmpMonitor.NodeInfo attribute to reflect the new nodeId.  All
		// subsequent collections will then be updating the appropriate RRDs.
		//
		boolean isPrimarySnmpInterface = false;
		synchronized(m_collectableServices)
		{
			CollectableService cSvc = null;
			Iterator iter = m_collectableServices.iterator();
			while (iter.hasNext())
			{
				cSvc = (CollectableService)iter.next();
						
				InetAddress addr = (InetAddress)cSvc.getAddress();
				if (addr.getHostAddress().equals(event.getInterface()))
				{
					synchronized(cSvc)
					{
						// Got a match! 
						if (log.isDebugEnabled())
							log.debug("interfaceReparentedHandler: got a CollectableService match for " + 
								event.getInterface());
						
						// Retrieve the CollectorUpdates object associated with this CollectableService.
						CollectorUpdates updates = cSvc.getCollectorUpdates();
							
						// Now set the reparenting flag
						updates.markForReparenting(oldNodeIdStr, newNodeIdStr);
						if (log.isDebugEnabled())
							log.debug("interfaceReparentedHandler: marking " + event.getInterface() + 
								" for reparenting for service SNMP.");
					}
				}
			}
		} 
		
		if (log.isDebugEnabled())
			log.debug("interfaceReparentedHandler: processing of interfaceReparented event for interface " + 
				event.getInterface() + " completed.");
	}

