	/**
	 * This method is responsible for building a list of RRDDataSource 
	 * objects from the provided list of MibObject objects.
	 *
	 * @param collectionName	Collection name
	 * @param oidList	List of MibObject objects defining the oid's to
	 * 			be collected via SNMP.
	 * 
	 * @return list of RRDDataSource objects
	 */
	private List buildDataSourceList(String collectionName, List oidList)
	{
		// Log4j category
		//
		Category log = ThreadCategory.getInstance(getClass());
		
		// Retrieve the RRD expansion data source list which contains all
		// the expansion data source's.  Use this list as a basis
		// for building a data source list for the current interface.
		//
		List dsList = new LinkedList();
		
		// Loop through the MIB object list to be collected for this interface
		// and add a corresponding RRD data source object.  In this manner 
		// each interface will have RRD files create which reflect only the data
		// sources pertinent to it.
		//
		Iterator o = oidList.iterator();
		while (o.hasNext())
		{
			MibObject obj = (MibObject)o.next();
			RRDDataSource ds = null;
			
			// Verify that this object has an appropriate "integer" data type
			// which can be stored in an RRD database file (must map to one of 
			// the supported RRD data source types:  COUNTER or GAUGE).
			String ds_type = RRDDataSource.mapType(obj.getType());
			if (ds_type != null)
			{
				// Passed!! Create new data source instance for this MIB object
				// Assign heartbeat using formula (2 * step) and hard code
				// min & max values to "U" ("unknown").
				ds = new RRDDataSource();
				ds.setHeartbeat(2 * DataCollectionConfigFactory.getInstance().getStep(collectionName));
				// For completeness, adding a minval option to the variable.

				String ds_minval = obj.getMinval();
				if (ds_minval == null)
				{
					ds_minval = "U";
				}
				ds.setMax(ds_minval);

				// In order to handle counter wraps, we need to set a max
				// value for the variable. 

				String ds_maxval = obj.getMaxval();
				if (ds_maxval == null)
				{
					ds_maxval = "U";
				}
				ds.setMax(ds_maxval);
				
				// Truncate MIB object name/alias if it exceeds 19 char max for
				// RRD data source names.
				String ds_name = obj.getAlias();
				if (ds_name.length() > MAX_DS_NAME_LENGTH)
				{
					if(log.isEnabledFor(Priority.WARN))
						log.warn("buildDataSourceList: Mib object name/alias '" + obj.getAlias()
							 + "' exceeds 19 char maximum for RRD data source names, truncating.");
					char[] temp = ds_name.toCharArray();
					ds_name = String.copyValueOf(temp, 0, MAX_DS_NAME_LENGTH);
				}
				ds.setName(ds_name);
				
				// Map MIB object data type to RRD data type
				ds.setType(ds_type);
			
				// Assign the data source object identifier and instance
				ds.setOid(obj.getOid());
				ds.setInstance(obj.getInstance());
				if (log.isDebugEnabled())
					log.debug("buildDataSourceList: ds_name: " + ds.getName() + " ds_oid: " + ds.getOid() + "." + ds.getInstance() + " ds_max: " + ds.getMax() + " ds_min: " + ds.getMin());

				// Add the new data source to the list
				dsList.add(ds);
			}
			else if(log.isEnabledFor(Priority.WARN))
			{
				log.warn("buildDataSourceList: Data type '" + obj.getType() + "' not supported.  Only integer-type data may be stored in RRD.");
				log.warn("buildDataSourceList: MIB object '" + obj.getAlias() + "' will not be mapped to RRD data source."); 
			}
		}
		
		return dsList;
	}

