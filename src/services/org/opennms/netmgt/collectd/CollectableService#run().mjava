	/**
	 * This is the main method of the class. An instance is normally
	 * enqueued on the scheduler which checks its <code>isReady</code>
	 * method to determine execution. If the instance is ready for 
	 * execution then it is started with it's own thread context
	 * to execute the query. The last step in the method before
	 * it exits is to reschedule the interface.
	 *
	 */
	public void run()
	{
		Category log = ThreadCategory.getInstance(getClass());

		// Process any oustanding updates.
		//
		if (processUpdates() == ABORT_COLLECTION)
			return;
		
		// Update last scheduled poll time
		m_lastScheduledCollectionTime = System.currentTimeMillis();
		
		// Check scheduled outages to see if any apply indicating
		// that the collection should be skipped
		//
		if (scheduledOutage())
		{
			// Outage applied...reschedule the service and return
			m_scheduler.schedule(this, m_service.getInterval());
			return;
		}
		
		// Perform SNMP data collection
		//
		if (log.isDebugEnabled())
			log.debug("run: starting new collection for " + m_address.getHostAddress());
		
		int status = ServiceCollector.COLLECTION_FAILED;
		Map propertiesMap = (Map)SVC_PROP_MAP.get(m_svcPropKey);
		try
		{
			status = m_collector.collect(this, m_proxy, propertiesMap);
		}
		catch(Throwable t)
		{
			log.error("run: An undeclared throwable was caught during SNMP collection for interface " + m_address.getHostAddress(), t);
		}
		
		// Update last poll time
		m_lastCollectionTime = System.currentTimeMillis();
		
		// Any change in status?
		//
		if(status != m_status)
		{			
			// Generate SNMP collection transition events
			if (log.isDebugEnabled())
				log.debug("run: change in collection status, generating event.");

			// Send the appropriate event
			//
			switch(status)
			{
				case ServiceCollector.COLLECTION_SUCCEEDED:
					sendEvent(EventConstants.DATA_COLLECTION_SUCCEEDED_EVENT_UEI);
					break;
	
				case ServiceCollector.COLLECTION_FAILED: 
					sendEvent(EventConstants.DATA_COLLECTION_FAILED_EVENT_UEI);
					break;
			
				default:
					break;
			}
		}

		// Set the new status
		m_status = status;
		
		// Reschedule the service
		//
		m_scheduler.schedule(this, m_service.getInterval());
		
		return;
	}	

