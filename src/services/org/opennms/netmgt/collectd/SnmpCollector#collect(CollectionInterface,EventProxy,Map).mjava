	/**
	 * Perform data collection.
	 * 
	 * @param iface
	 *            Network interface to be data collected.
	 * @param eproxy
	 *            Eventy proxy for sending events.
	 * @param parameters
	 *            Key/value pairs from the package to which the interface
	 *            belongs.
	 */
	public int collect(CollectionInterface iface, EventProxy eproxy, Map parameters) {
		try {
			// Collect node and interface MIB data from the remote agent

			SnmpNodeCollector nodeCollector = null;
			// construct the nodeCollector
			if (!getNodeInfo(iface).getOidList().isEmpty()) {
				nodeCollector = new SnmpNodeCollector(iface.getInetAddress(),
						getNodeInfo(iface).getOidList());
			}

			IfNumberTracker ifNumber = null;
			SnmpIfCollector ifCollector = null;
			// construct the ifCollector
			if (iface.hasInterfaceOids()) {
				ifCollector = new SnmpIfCollector(iface.getInetAddress(),
						getIfMap(iface));
				ifNumber = new IfNumberTracker();
			}

			collectData(iface, ifNumber, nodeCollector, ifCollector);

			if (iface.hasInterfaceOids()) {
				int savedIfCount = iface.getSavedIfCount();

				int ifCount = ifNumber.getIfNumber();

				iface.saveIfCount(ifCount);

				log().debug(
						"collect: nodeId: " + getNodeInfo(iface).getNodeId()
								+ " interface: " + iface.getHostAddress()
								+ " ifCount: " + ifCount + " savedIfCount: "
								+ savedIfCount);

				/*
				 * If saved interface count differs from the newly retreived
				 * interface count the following must occur: 1. generate
				 * forceRescan event so Capsd will rescan the node, update the
				 * database, and generate the appropriate events back to the
				 * poller.
				 */
				if ((savedIfCount != -1) && (ifCount != savedIfCount)) {
					if (!isForceRescanInProgress(
							getNodeInfo(iface).getNodeId(),
							iface.getHostAddress())) {
						log()
								.info(
										"Number of interfaces on primary SNMP "
												+ "interface "
												+ iface.getHostAddress()
												+ " has changed, generating 'ForceRescan' event.");
						generateForceRescanEvent(iface.getHostAddress(),
								getNodeInfo(iface).getNodeId(), eproxy);
					}
				}
			}

			// Update RRD with values retrieved in SNMP collection
			boolean rrdError = updateRRDs(getCollectionName(parameters), iface,
					nodeCollector, ifCollector, parameters, eproxy);

			if (rrdError) {
				log().warn(
						"collect: RRD error during update for "
								+ iface.getHostAddress());
			}

			// return the status of the collection
			return COLLECTION_SUCCEEDED;
		} catch (CollectionError e) {
			if (e.getCause() == null) {
				log().error(e.getMessage());
			} else {
				log().error(e.getMessage(), e.getCause());
			}
			return COLLECTION_FAILED;
		} catch (CollectionWarning e) {
			if (e.getCause() == null) {
				log().warn(e.getMessage());
			} else {
				log().warn(e.getMessage(), e.getCause());
			}
			return COLLECTION_FAILED;
		} catch (Throwable t) {
			log().error(
					"Unexpected error during node SNMP collection for "
							+ iface.getHostAddress(), t);
			return COLLECTION_FAILED;
		}
	}

