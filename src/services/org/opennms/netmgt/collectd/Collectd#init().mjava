	/** 
	 * Responsible for starting the collection daemon.
	 */
	public synchronized void init()
	{
		// Set the category prefix
		ThreadCategory.setPrefix(LOG4J_CATEGORY);
		
		// get the category logger 
		final Category log = ThreadCategory.getInstance();

		if (log.isDebugEnabled())
			log.debug("init: Initializing collection daemon");

		// Load collectd configuration file
		//
		try
		{
			CollectdConfigFactory.reload();
		}
		catch(MarshalException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load collectd configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		catch(ValidationException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load collectd configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		catch(IOException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load collectd configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		
		// Load up the configuration for the scheduled outages. 
		//
		try
		{
			PollOutagesConfigFactory.reload();
		}
		catch(MarshalException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load poll-outage configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		catch(ValidationException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load poll-outage configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		catch(IOException ex)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to load poll-outage configuration", ex);
			throw new UndeclaredThrowableException(ex);
		}
		
		if (log.isDebugEnabled())
			log.debug("init: Loading collectors");

		// Collectd configuration
		//
		CollectdConfigFactory cCfgFactory = CollectdConfigFactory.getInstance();
		CollectdConfiguration config = cCfgFactory.getConfiguration();
		
		// Load up an instance of each collector from the config
		// so that the event processor will have them for
		// new incomming events to create collectable service objects.
		//
		Enumeration eiter = config.enumerateCollector();
		while(eiter.hasMoreElements())
		{
			Collector collector = (Collector)eiter.nextElement();
			try
			{
				if(log.isDebugEnabled())
				{
					log.debug("init: Loading collector "
						  + collector.getService()
						  + ", classname "
						  + collector.getClassName());
				}
				Class cc = Class.forName(collector.getClassName());
				ServiceCollector sc = (ServiceCollector)cc.newInstance();
				
				// Attempt to initialize the service collector
				//
				Map properties = null; // properties not currently used
				sc.initialize(properties);
				
				m_svcCollectors.put(collector.getService(), sc);
			}
			catch(Throwable t)
			{
				if(log.isEnabledFor(Priority.WARN))
				{
					log.warn("init: Failed to load collector " + collector.getClassName()
						 + " for service " + collector.getService(), t);
				}
			}
		}
		
		// Make sure we can connect to the database and load
		// the services table so we can easily convert from
		// service name to service id
		//
		if (log.isDebugEnabled())
			log.debug("start: Testing database connection");

		java.sql.Connection ctest = null;
		ResultSet rs = null;
		try
		{
			DatabaseConnectionFactory.reload();
			ctest = DatabaseConnectionFactory.getInstance().getConnection();
			
			PreparedStatement loadStmt= ctest.prepareStatement(SQL_RETRIEVE_SERVICE_IDS);
			
			// go ahead and load the service table 
			//
			rs = loadStmt.executeQuery();
			while(rs.next())
			{
				Integer id = new Integer(rs.getInt(1));
				String name = rs.getString(2);

				m_serviceIds.put(name, id);
			}
		}
		catch (IOException iE)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("start: IOException getting database connection", iE);
			throw new UndeclaredThrowableException(iE);
		}
		catch (MarshalException mE)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("start: Marshall Exception getting database connection", mE);
			throw new UndeclaredThrowableException(mE);
		}
		catch (ValidationException vE)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("start: Validation Exception getting database connection", vE);
			throw new UndeclaredThrowableException(vE);
		}
		catch (SQLException sqlE)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("start: Error accessing database.", sqlE);
			throw new UndeclaredThrowableException(sqlE);
		}
		catch (ClassNotFoundException cnfE)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("start: Error accessing database.", cnfE);
			throw new UndeclaredThrowableException(cnfE);
		}
		finally
		{
			if (rs != null)
			{
				try
				{
					rs.close();
				}
				catch(Exception e)
				{
					if(log.isInfoEnabled())
						log.info("start: an error occured closing the result set", e);
				}
			}
			if(ctest != null)
			{
				try
				{
					ctest.close();
				}
				catch(Exception e)
				{
					if(log.isInfoEnabled())
						log.info("start: an error occured closing the SQL connection", e);
				}
			}
		}

		// Create a scheduler
		//
		try
		{
			if(log.isDebugEnabled())
				log.debug("init: Creating collectd scheduler");

			m_scheduler = new Scheduler("Collectd", config.getThreads());
		}
		catch(RuntimeException e)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to create collectd scheduler", e);
			throw e;
		}

		// Schedule existing interfaces for data collection
		
		ReadyRunnable interfaceScheduler = new ReadyRunnable() {
			
			public boolean isReady() { return true; }
			
			public void run() {
				//
				try
				{
					scheduleExistingInterfaces();
				}
				catch(SQLException sqlE)
				{
					if(log.isEnabledFor(Priority.ERROR))
						log.error("start: Failed to schedule existing interfaces", sqlE);
				}
				finally {
				    setSchedulingCompleted(true);
				}
		
			}
		};
		
		m_scheduler.schedule(interfaceScheduler, 0);
		
		// Create an event receiver. The receiver will
		// receive events, process them, creates network
		// interfaces, and schedulers them.
		//
		try
		{
			if(log.isDebugEnabled())
				log.debug("init: Creating event broadcast event processor");

			m_receiver = new BroadcastEventProcessor(m_collectableServices);
		}
		catch(Throwable t)
		{
			if(log.isEnabledFor(Priority.FATAL))
				log.fatal("init: Failed to initialized the broadcast event receiver", t);

			throw new UndeclaredThrowableException(t);
		}
	}

