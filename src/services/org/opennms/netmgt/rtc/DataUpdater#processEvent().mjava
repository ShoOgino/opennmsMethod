	/**
	 * Read the event UEI, nodeid, interface and service - depending
	 * on the UEI, read event parms, if necessary, and call appropriate
	 * methods on the data manager to update data
	 */
	private void processEvent()
		throws SQLException, FilterParseException, RTCException
	{
		Category log = ThreadCategory.getInstance(DataUpdater.class);

		if (m_event == null)
		{
			if(log.isDebugEnabled())
				log.debug("Event is null, nothing to process");
			return;
		}

		// uei
		String eventUEI = m_event.getUei();
		if (eventUEI == null)
		{
			// huh? should only get registered events
			if(log.isDebugEnabled())
				log.debug("Event received with null UEI, ignoring event");
			return;
		}

		// node id
		long nodeid = -1;
		if (m_event.hasNodeid())
		{
			nodeid = m_event.getNodeid();
		}

		// ip
		String ip = m_event.getInterface();

		// service name
		String svcName = m_event.getService();

		// event time
		long eventTime = -1;
		String eventTimeStr = m_event.getTime();
		try
		{
			java.util.Date date = EventConstants.parseToDate(eventTimeStr);
			eventTime = date.getTime();
		}
		catch(ParseException pe)
		{
			log.warn("Failed to convert time " + eventTime + " to java.util.Date, Setting current time instead", pe);

			eventTime = (new java.util.Date()).getTime();
		}

		if(log.isDebugEnabled())
			log.debug("Event UEI: " + eventUEI + "\tnodeid: " + nodeid + "\tip: " + ip + "\tsvcName: " + svcName + "\teventTime: " + eventTimeStr);
		
		//
		//
		// Check for any of the following UEIs:
		//
		//	nodeGainedService 
		//	nodeLostService 
		//	interfaceDown 
		//	nodeDown 
		//	nodeUp 
		//	interfaceUp 
		//	nodeRegainedService 
		//	serviceDeleted
		// 	interfaceReparented
		//	subscribe
		//	unsubscribe
		//
		if (eventUEI.equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI))
		{
			handleNodeGainedService(nodeid, ip, svcName);
		}
		else if(eventUEI.equals(EventConstants.NODE_LOST_SERVICE_EVENT_UEI))
		{
			handleNodeLostService(nodeid, ip, svcName, eventTime);
		}
		else if(eventUEI.equals(EventConstants.INTERFACE_DOWN_EVENT_UEI))
		{
			handleInterfaceDown(nodeid, ip, eventTime);
		}
		else if(eventUEI.equals(EventConstants.NODE_DOWN_EVENT_UEI))
		{
			handleNodeDown(nodeid, eventTime);
		}
		else if(eventUEI.equals(EventConstants.NODE_UP_EVENT_UEI))
		{
			handleNodeUp(nodeid, eventTime);
		}
		else if(eventUEI.equals(EventConstants.INTERFACE_UP_EVENT_UEI))
		{
			handleInterfaceUp(nodeid, ip, eventTime);
		}
		else if(eventUEI.equals(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI))
		{
			handleNodeRegainedService(nodeid, ip, svcName, eventTime);
		}
		else if(eventUEI.equals(EventConstants.SERVICE_DELETED_EVENT_UEI))
		{
			handleServiceDeleted(nodeid, ip, svcName);
		}
		else if (eventUEI.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI))
		{
			handleInterfaceReparented(ip, m_event.getParms());
		}
		else if (eventUEI.equals(EventConstants.RTC_SUBSCRIBE_EVENT_UEI))
		{
			handleRtcSubscribe(m_event.getParms());
		}
		else if (eventUEI.equals(EventConstants.RTC_UNSUBSCRIBE_EVENT_UEI))
		{
			handleRtcUnsubscribe(m_event.getParms());
		}
		else if (eventUEI.equals(EventConstants.ASSET_INFO_CHANGED_EVENT_UEI))
		{
			handleAssetInfoChangedEvent(nodeid);
		}
		else
		{
			if(log.isDebugEnabled())
				log.debug("Event subscribed for not handled?!: " + eventUEI);
		}

		// increment the counter on the rtcvcm
		RTCManager.getInstance().incrementCounter();
	}

