	/**
	 * For each category in the categories list, this reads the 
	 * services and outage tables to get the initial data, creates
	 * 'RTCNode' objects that are added to the map and and to the
	 * appropriate category
	 *
	 * @throws SQLException if the database read fails due to an SQL error
	 * @throws FilterParseException if filtering the data against the category rule fails due to the rule being incorrect
	 * @throws RTCException if the database read or filtering the data against the category rule fails for some reason
	 */
	private void populateNodesFromDB(Connection dbConn)
			throws SQLException, FilterParseException, RTCException
	{
		// create a hashtable of IP->RTCNodes list for startup to save on database access
		Hashtable knownIPs	= new Hashtable();

		// Create the filter
		Filter filter =  new Filter();

		// Prepare the statement to get service entries for each IP
		PreparedStatement servicesGetStmt = dbConn.prepareStatement(RTCConstants.DB_GET_SVC_ENTRIES);
	 	// Prepared statement to get node info for an ip
		PreparedStatement ipInfoGetStmt	=  dbConn.prepareStatement(RTCConstants.DB_GET_INFO_FOR_IP);
	 	// Prepared statement to get outages entries
		PreparedStatement outagesGetStmt = dbConn.prepareStatement(RTCConstants.DB_GET_OUTAGE_ENTRIES);

		Category log = ThreadCategory.getInstance(DataManager.class);

		// loop through the categories

		Iterator catIter = m_categories.values().iterator();
		while(catIter.hasNext())
		{
			RTCCategory cat = (RTCCategory)catIter.next();

			// get the rule for this category, get the list of nodes that satisfy this rule
			String filterRule = cat.getEffectiveRule();

			if(log.isDebugEnabled())
				log.debug("Category: " + cat.getLabel() + "\t" + filterRule);

			String ip = null;
			ResultSet ipRS=null;
			try
			{
				List nodeIPs = filter.getIPList(filterRule);

				if (log.isDebugEnabled())
					log.debug("Number of IPs satisfying rule: " + nodeIPs.size());
				
				// For each of these IP addresses, get the details from the ifServices and services tables
				Iterator ipIter = nodeIPs.iterator();
				while(ipIter.hasNext())
				{
					ip = (String)ipIter.next();

					if(log.isDebugEnabled())
						log.debug("IP: " + ip);

					// check if this ip is something we already know about
					// so we can avoid database lookups
					List ipRTCs = (List)knownIPs.get(ip);
					if (ipRTCs != null)
					{
						addIpToCategory(ipRTCs, cat);
						continue;
					}

					// get node info for this ip
					ipInfoGetStmt.setString(1, ip);

					ipRS = ipInfoGetStmt.executeQuery();
					while(ipRS.next())
					{
						int nodeColIndex = 1;

						long nodeid = ipRS.getLong(nodeColIndex++);

						if(log.isDebugEnabled())
							log.debug("IP->node info lookup result: " + nodeid);

						//
						// get the services for this IP address
						//
						ResultSet  svcRS=null;
						servicesGetStmt.setLong(1, nodeid);
						servicesGetStmt.setString(2, ip);
						svcRS = servicesGetStmt.executeQuery();

						// create node objects for this nodeID/IP/service
						while(svcRS.next())
						{
							int colIndex = 1;
						
							// read data from the resultset
							String svcname = svcRS.getString(colIndex++);

							if(log.isDebugEnabled())
								log.debug("services result: " + nodeid + "\t" + ip + "\t" +  svcname);

							// unless the service found is in the category's services list,
							// do not add that service
							if (!cat.containsService(svcname))
							{
								if(log.isDebugEnabled())
									log.debug("service " + svcname 
										  + " not in category service list of cat " 
										  + cat.getLabel() + " - skipping " 
										  + nodeid + "\t" + ip + "\t" + svcname);
								continue;
							}

							addNodeIpSvcToCategory(nodeid, ip, svcname, cat, knownIPs, outagesGetStmt);
						}

						// finally close the result set
						try
						{
							if (svcRS != null)
								svcRS.close();
						}
						catch(Exception e)
						{
							if(log.isDebugEnabled())
								log.debug("Exception while closing the services result set", e);
						}
					}
				}

			}
			catch(SQLException e)
			{
				if(log.isDebugEnabled())
					log.debug("Unable to get node list for category \'" + cat.getLabel(), e);
				throw e;
			}
			catch(FilterParseException e)
			{
				// if we get here, the error was most likely in
				// getting the nodelist from the filters
				if(log.isDebugEnabled())
					log.debug("Unable to get node list for category \'" + cat.getLabel(), e);

				// throw exception
				throw e;
			}
			catch(Exception e)
			{
				if(log.isDebugEnabled())
					log.debug("Unable to get node list for category \'" + cat.getLabel(), e);

				// throw rtc exception
				throw new RTCException("Unable to get node list for category \'" + cat.getLabel() + "\':\n\t" + e.getMessage());
			}
			finally
			{
				try
				{
					if(ipRS != null)
						ipRS.close();
				}
				catch(Exception e)
				{
					if(log.isDebugEnabled())
						log.debug("Exception while closing the ip get node info result set - ip: " + ip, e);
				}
			}
		}

		//
		// close the prepared statements
		//
		try
		{
			if (servicesGetStmt != null)
				servicesGetStmt.close();

			if (ipInfoGetStmt != null)
				ipInfoGetStmt.close();

			if (outagesGetStmt != null)
				outagesGetStmt.close();
		}
		catch (SQLException csqle)
		{
			if (log.isDebugEnabled())
				log.debug("Exception while closing the prepared statements after populating nodes from DB");

			// do nothing
		}
	}

