    /**
     * Poplulates nodes from the database. For each category in the categories
     * list, this reads the services and outage tables to get the initial data,
     * creates 'RTCNode' objects that are added to the map and and to the
     * appropriate category.
     * 
     * @param dbConn
     *            the database connection.
     * @throws SQLException
     *             if the database read fails due to an SQL error
     * @throws FilterParseException
     *             if filtering the data against the category rule fails due to
     *             the rule being incorrect
     * @throws RTCException
     *             if the database read or filtering the data against the
     *             category rule fails for some reason
     */
    private void populateNodesFromDB(Connection dbConn) throws SQLException, FilterParseException, RTCException {

    	final String getOutagesInWindow = 
    			"select " + 
    			"       ifsvc.nodeid as nodeid, " + 
    			"       ifsvc.ipAddr as ipaddr, " + 
    			"       s.servicename as servicename, " + 
    			"       o.ifLostService as ifLostService, " + 
    			"       o.ifRegainedService as ifRegainedService " + 
    			"  from " + 
    			"       ifservices ifsvc " + 
    			"  join " + 
    			"       service s on (ifsvc.serviceid = s.serviceid) " + 
    			"left outer  join " + 
    			"       outages o on " +
    			"          (" + 
    			"            o.nodeid = ifsvc.nodeid " + 
    			"            and o.ipaddr = ifsvc.ipaddr " + 
    			"            and o.serviceid = ifsvc.serviceid " + 
    			"            and " +
    			"            (" + 
    			"               o.ifLostService > ? " + 
    			"               OR  o.ifRegainedService > ? " + 
    			"               OR  o.ifRegainedService is null " +
    			"            )" +
    			"          ) " +
    			"order by " + 
    			"       ifsvc.nodeid, ifsvc.ipAddr, ifsvc.serviceid, o.ifLostService;";
    	
		long window = (new Date()).getTime() - RTCManager.getRollingWindow();
		Timestamp windowTS = new Timestamp(window);
    	
    	RowCallbackHandler rowHandler = new RowCallbackHandler() {
    		
    		RTCNodeKey m_currentKey = null;
    		Map m_categoryIpLists = new HashMap();

			public void processRow(ResultSet rs) throws SQLException {
				RTCNodeKey key = new RTCNodeKey(rs.getLong("nodeid"), rs.getString("ipaddr"), rs.getString("svcname"));
				if (!matchesCurrent(key)) {
					m_currentKey = key;
					processIfService(key);
				}
				processOutage(key, rs.getTimestamp("ifLostService"), rs.getTimestamp("ifRegainedService"));
			}
    	
    		private boolean matchesCurrent(RTCNodeKey key) {
    			return (m_currentKey != null && m_currentKey.equals(key));
    		}
			
			// This is called exactly once for each unique (nodeid, ipaddr, svcname) tuple
			public void processIfService(RTCNodeKey key) {
				for (Iterator it = m_categories.values().iterator(); it.hasNext();) {
					RTCCategory cat = (RTCCategory) it.next();
					if (catContainsIfService(cat, key)) {
						RTCNode rtcN = getRTCNode(key);
						addNodeToCategory(cat, rtcN);
					}
				}
			
			}
			
			private boolean catContainsIfService(RTCCategory cat, RTCNodeKey key) {
				return cat.containsService(key.getSvcName()) && catContainsIp(cat, key.getIP());
			}

			private boolean catContainsIp(RTCCategory cat, String ip) {
				List ips = catGetIpList(cat);
				return ips.contains(ip);
			}

			private List catGetIpList(RTCCategory cat) {
				List ips = (List)m_categoryIpLists.get(cat.getLabel());
				if (ips == null) {
					ips = catConstructIpList(cat);
					m_categoryIpLists.put(cat.getLabel(), ips);
				}
				return ips;
			}

			private List catConstructIpList(RTCCategory cat) {
				String filterRule = cat.getEffectiveRule();
				try {
					Filter filter = new Filter();

					if (log().isDebugEnabled())
						log().debug("Category: " + cat.getLabel() + "\t" + filterRule);

					List ips = filter.getIPList(filterRule);
					
	                if (log().isDebugEnabled())
	                    log().debug("Number of IPs satisfying rule: " + ips.size());

	                return ips;
	                
				} catch (FilterParseException e) {
					log().error("Unable to parse filter rule "+filterRule+" ignoring category "+cat.getLabel(), e);
					return Collections.EMPTY_LIST;
				}
			}

			// This is processed for each outage, passing two null means there is not outage
			public void processOutage(RTCNodeKey key, Timestamp ifLostService, Timestamp ifRegainedService) {
				RTCNode rtcN = findRTCNode(key);
				// if we can't find the node it doesn't belong to any category
				if (rtcN == null) return;
				
				addOutageToRTCNode(rtcN, ifLostService, ifRegainedService);
				
			}
    		
    	};
    	
    	JdbcTemplate template = new JdbcTemplate(getConnectionFactory());
    	template.query(getOutagesInWindow, new Object[] {windowTS, windowTS}, rowHandler);
    	
    }

