	/**
	 * Remove node from the map and the categories on a 'serviceDeleted' event
	 *
	 * @param  nodeid	the nodeid on which service was deleted
	 * @param  ip		the ip on which service was deleted
	 * @param  service	the service that was deleted
	 */
	public synchronized void serviceDeleted(long nodeid, String ip, String svcName)
	{
		// create lookup key
		RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);

		// lookup the node
		RTCNode rtcN = (RTCNode)m_map.get(key);
		if (rtcN == null)
		{
			Category log = ThreadCategory.getInstance(DataManager.class);
			log.warn("Received a " + EventConstants.SERVICE_DELETED_EVENT_UEI + " event for an unknown node: " + key.toString());

			return;
		}

		//
		// Go through from all the categories this node belongs to
		// and delete the service
		//
		List categories = rtcN.getCategories();
		ListIterator catIter = categories.listIterator();
		while(catIter.hasNext())
		{
			String catlabel = (String)catIter.next();

			RTCCategory cat = (RTCCategory)m_categories.get(catlabel);

			// get nodes in this category
			List  catNodes = cat.getNodes();

			// check if the category contains this node
			Long tmpNodeid = new Long(rtcN.getNodeID());
			int nIndex = catNodes.indexOf(tmpNodeid);
			if (nIndex != -1)
			{
				// remove from the category
				catNodes.remove(nIndex);

				// let the node know that this category is out
				catIter.remove();
			}
		}

		// finally remove from map 
		m_map.remove(key);
		m_map.delete(rtcN.getNodeID(), rtcN);
		m_map.delete(rtcN.getNodeID(), rtcN.getIP(), rtcN);
		
		// allow for gc
		rtcN = null;
	}

