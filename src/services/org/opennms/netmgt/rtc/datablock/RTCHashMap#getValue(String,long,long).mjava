    /**
     * Get the value (uptime) for a category in the last 'rollingWindow'
     * starting at current time
     * 
     * @param catLabel
     *            the category to which the node should belong to
     * @param curTime
     *            the current time
     * @param rollingWindow
     *            the window for which value is to be calculated
     * 
     * @return the value(uptime) for the node
     */
    public double getValue(String catLabel, long curTime, long rollingWindow) {
        // the value (uptime)
        double value = 0.0;

        // total outage time
        long outageTime = 0;

        // number of entries for this node
        int count = 0;

        // downtime for a node
        long downTime = 0;

        // get all nodes in the hashtable
        Set keys = keySet();
        Iterator keyIter = keys.iterator();
        while (keyIter.hasNext()) {
            // get only values of nodeids
            Object key = keyIter.next();
            if (!(key instanceof Long)) {
                continue;
            }

            List valList = (List) get((Long) key);
            if (valList == null || valList.size() == 0)
                continue;

            Iterator valIter = valList.iterator();
            while (valIter.hasNext()) {
                RTCNode node = (RTCNode) valIter.next();
                downTime = node.getDownTime(catLabel, curTime, rollingWindow);
                if (downTime < 0)
                // node does not belong to category
                // or RTCConstants.SERVICE_NOT_FOUND_VALUE
                // or node / interface / service unmanaged
                {
                    continue;
                }

                outageTime += downTime;

                count++;

            }

        }

        double dOut = outageTime * 1.0;
        double dRoll = rollingWindow * 1.0;

        if (count > 0) {
            value = 100 * (1 - (dOut / (dRoll * count)));
        } else {
            value = 100.0;
        }

        return value;
    }

