	/** 
	 * The execution context.
	 */
	public void run()
	{
		// get the thread context right off
		//
		m_context = Thread.currentThread();
		synchronized(m_context)
		{
			m_context.notifyAll();
		}

		// log the thread startup
		//
		Category log = ThreadCategory.getInstance(this.getClass());

		// Check the stop flag, if it is set then go a head and exit
		// before doing any work on the socket
		//
		if(m_stop)
		{
			if(log.isDebugEnabled())
				log.debug("Stop flag set before thread startup, thread exiting");

			return;
		}
		else if(log.isDebugEnabled())
		{
			InetAddress sender = m_connection.getInetAddress();
			log.debug("Thread started, remote is " + sender.getHostAddress());
		}

		// get the input stream
		//
		InputStream socketIn = null;
		try
		{
			m_connection.setSoTimeout(500); // needed incase connection closed!
			socketIn = new BufferedInputStream(m_connection.getInputStream());
		}
		catch(IOException e)
		{
			if(!m_stop)
				log.warn("An I/O Exception occured", e);
			m_xchange.add(e);

			if(log.isDebugEnabled())
				log.debug("Thread exiting due to socket exception, stop flag = " + m_stop);

			return;
		}

		int level = 8;
		int ch    = 0;
		boolean moreInput = true;
		while(moreInput)
		{
			// check to see if the thread is interrupted
			//
			if(Thread.interrupted())
			{
				if(log.isDebugEnabled())
					log.debug("Thread Interrupted");
				break;
			}

			try
			{
				ch = socketIn.read();
				if(ch == -1)
				{
					moreInput = false;
					continue;
				}

			}
			catch(InterruptedIOException e)
			{
				// this was expected
				continue;
			}
			catch(EOFException e)
			{
				m_xchange.add(e);
				moreInput = false;
				continue;
			}
			catch(IOException e)
			{
				m_xchange.add(e);
				if(!m_stop)
					log.warn("An I/O error occured reading from the remote host",e);
				moreInput = false;
				continue;
			}

			try
			{
				level = m_tokenizer[level].next((char)ch);
			}
			catch(IOException e)
			{
				if(!m_stop)
				{
					log.warn("An I/O error occured writing to the processor stream",e);
					log.warn("Discarding the remainder of the event contents");
					try
					{
						// this will discard current stream
						// and cause all forwards to be discarded.
						closeStream();
					}
					catch(IOException e2) { }
				}
				else
				{
					m_xchange.add(e);
					moreInput = false;
				}
			}

		} // end while

		// ensure that the receive knows that no new element
		// is coming!
		try
		{
			if(m_out != null)
				m_out.close();
		}
		catch(IOException e)
		{
			if(!m_stop)
				log.warn("An I/O Error occured closing the processor stream", e);
		}

		m_xchange.add(new EOFException("No More Input"));

		if(log.isDebugEnabled())
			log.debug("Thread Terminated");

	} // end run method

