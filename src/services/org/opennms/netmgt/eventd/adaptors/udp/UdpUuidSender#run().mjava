	public void run()
	{
		// get the context
		//
		m_context = Thread.currentThread();

		// get a logger
		//
		ThreadCategory.setPrefix(m_logPrefix);
		Category log = ThreadCategory.getInstance(getClass());
		boolean isTracing = log.isDebugEnabled();

		if(m_stop)
		{
			if(isTracing)
				log.debug( "Stop flag set before thread started, exiting");
			return;
		}
		else if(isTracing)
			log.debug( "Thread context started");

		// This loop is labeled so that it can be
		// exited quickly when the thread is interrupted
		//
		ArrayList eventHold = new ArrayList(30);
		Map receipts = new HashMap();

		RunLoop:
		while(!m_stop)
		{
			if(isTracing)
				log.debug( "Waiting on event receipts to be generated");

			synchronized(m_eventUuidsOut)
			{
				// wait for an event to show up.
				// wait in 1 second intervals
				//
				while(m_eventUuidsOut.isEmpty())
				{
					try
					{
						// use wait instead of sleep to 
						// release the lock!
						//
						m_eventUuidsOut.wait(1000);
					}
					catch(InterruptedException ie)
					{
						if(isTracing)
							log.debug( "Thread context interrupted");
						break RunLoop;
					}
				}
				
				eventHold.addAll(m_eventUuidsOut);
				m_eventUuidsOut.clear();
			}

			if(isTracing)
			{
				log.debug( "Received " + eventHold.size() + " event receipts to process");
				log.debug( "Processing receipts");
			}

			// build an event-receipt
			//
			Iterator iter = eventHold.iterator();
			while(iter.hasNext())
			{
				UdpReceivedEvent re = (UdpReceivedEvent)iter.next();
				Iterator xiter = re.getAckedEvents().iterator();
				while(xiter.hasNext())
				{
					Event e = (Event)xiter.next();
					if(e.getUuid() != null)
					{
						EventReceipt receipt = (EventReceipt) receipts.get(re);
						if(receipt == null)
						{
							receipt = new EventReceipt();
							receipts.put(re, receipt);
						}
						receipt.addUuid(e.getUuid());
					}
				}
			}
			eventHold.clear();

			if(isTracing)
				log.debug( "Event receipts sorted, transmitting receipts");

			// turn them into XML and send it out the socket
			// 
			iter = receipts.entrySet().iterator();
			while(iter.hasNext())
			{
				Map.Entry entry = (Map.Entry)iter.next();
				UdpReceivedEvent re = (UdpReceivedEvent)entry.getKey();
				EventReceipt receipt = (EventReceipt)entry.getValue();

				StringWriter writer = new StringWriter();
				try
				{
					Marshaller.marshal(receipt, writer);
				}
				catch(ValidationException e)
				{
					log.warn("Failed to build event receipt for agent " 
						 + re.getSender().getHostAddress() + ":" + re.getPort(), e);
				}
				catch(MarshalException e)
				{
					log.warn("Failed to build event receipt for agent " 
						 + re.getSender().getHostAddress() + ":" + re.getPort(), e);
				}

				String xml = writer.getBuffer().toString();
				try
				{
					byte[] xml_bytes = xml.getBytes("US-ASCII");
					DatagramPacket pkt = new DatagramPacket(xml_bytes, xml_bytes.length, re.getSender(), re.getPort());

					if(isTracing)
					{
						log.debug( "Transmitting receipt to destination "
							+ re.getSender().getHostAddress()
							+ ":"
							+ re.getPort());
					}

					m_dgSock.send(pkt);
					synchronized(m_handlers)
					{
						Iterator i = m_handlers.iterator();
						while(i.hasNext())
						{
							try
							{
								((EventHandler)i.next()).receiptSent(receipt);
							}
							catch(Throwable t)
							{
								log.warn("Error processing event receipt", t);
							}
						}
					}

					if(isTracing)
					{
						log.debug( "Receipt transmitted OK {");
						log.debug( xml);
						log.debug( "}");
					}
				}
				catch(UnsupportedEncodingException e)
				{
					log.warn("Failed to convert XML to byte array", e);
				}
				catch(IOException e)
				{
					log.warn("Failed to send packet to host" + re.getSender().getHostAddress() + ":" + re.getPort(), e);
				}
			}
			receipts.clear();

		} // end RunLoop
		
		if(isTracing)
			log.debug( "Context finished, returning");
		
	} // end run()

