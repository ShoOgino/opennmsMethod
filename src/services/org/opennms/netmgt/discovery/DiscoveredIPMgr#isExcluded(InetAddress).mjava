	/**
	 * Returns true if the passed address is included in the
	 * range of addresses to be skipped and is not contained 
	 * within the specifcs address list (which takes precedence
	 * over the exclude ranges.
	 *
	 * @param addr	The address to check for exclusion
	 *
	 * @return True if the address is excluded.
	 *
	 */
	static synchronized boolean isExcluded(InetAddress addr)
	{
		boolean rc = false;
		if(m_excluded != null)
		{
			long laddr = 0;
			byte[] octets = addr.getAddress();
			for(int x = 0; x < octets.length; x++)
				laddr = (laddr << 8)
				      | (octets[x] < 0 ? 256L + octets[x] : octets[x] + 0L);

			for(int x = 0; !rc && x < m_excluded.length; x++)
			{
				try
				{
					InetAddress abegin = InetAddress.getByName(m_excluded[x].getBegin());
					InetAddress aend   = InetAddress.getByName(m_excluded[x].getEnd());
					long begin = IPSorter.convertToLong(abegin.getAddress());
					long end   = IPSorter.convertToLong(aend.getAddress());
					if(begin <= laddr && laddr <= end)
					{
						// Ok, the address is excluded by this range...now
						// check to see if the address is contained within
						// the list of specifics.  If not then return true.
						boolean inSpecifics = false;
						Iterator iter = m_specifics.iterator();
						while (iter.hasNext())
						{
							IPPollAddress tmp = (IPPollAddress)iter.next();
							InetAddress specific = tmp.getAddress();
							if (specific.equals(addr))
							{
								inSpecifics = true;
								break;
							}
						}		
						
						if (!inSpecifics)
						{
							rc = true;
							break;
						}
					}
				}
				catch(UnknownHostException ex)
				{
					Category log = ThreadCategory.getInstance(DiscoveredIPMgr.class);
					log.error("DiscoveredIPMgr.isExcluded: failed to convert exclusion address to InetAddress", ex);
				}
			}
		}
		
		return rc;
	}

