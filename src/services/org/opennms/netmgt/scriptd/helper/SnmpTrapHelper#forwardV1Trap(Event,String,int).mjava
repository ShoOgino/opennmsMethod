  /**
   * Create an SNMP V1 trap, based on the content of the specified event, and forward
   * the trap to the specified address and port. It is assumed that the specified event
   * represents an SNMP V1 or V2 trap that was received by OpenNMS (TrapD).
   *
   * @param  event  The event upon which the trap content should be based
   * @param  destAddr  The address to which the trap should be forwarded
   * @param  destPort  The port to which the trap should be forwarded
   *
	 * @exception  Throws SnmpTrapHelperException if the variable binding cannot be
	 * added to the trap for any reason.
	 */
	public void forwardV1Trap(Event event, String destAddr, int destPort) throws SnmpTrapHelperException
	{
    // the event must correspond to an SNMP trap
    
		Snmp snmpInfo = event.getSnmp();

		if (snmpInfo == null)
		{
			throw new SnmpTrapHelperException("Cannot forward an event with no SNMP info: " + event.getUei());
		}

    // check the version of the original trap
    
		String version = snmpInfo.getVersion();

		SnmpPduTrap trap = new SnmpPduTrap();

		if ("v1".equals(version))
		{

			trap.setEnterprise(snmpInfo.getId());

			IPv4Address addr = new IPv4Address(event.getSnmphost());
			trap.setAgentAddress(new SnmpIPAddress(addr.getAddressBytes()));

			trap.setGeneric(snmpInfo.getGeneric());

			trap.setSpecific(snmpInfo.getSpecific());

			trap.setTimeStamp(snmpInfo.getTimeStamp());

			// varbinds

			Parm[] parms = event.getParms().getParm();

			for (int i = 0; i < parms.length; i++)
			{
				Parm parm = parms[i];
				Value value = parm.getValue();

				try
				{
					addVarBinding(trap, parm.getParmName(), value.getType(), value.getEncoding(), value.getContent());
				}

				catch (SnmpTrapHelperException e)
				{
					throw new SnmpTrapHelperException(e.getMessage() + " in event parm[" + i + "]");
				}
			}
		}
		else if ("v2".equals(version))
		{

			// converting V2 trap to V1 (see RFC2576)

			trap.setEnterprise(snmpInfo.getId());

			Parm[] parms = event.getParms().getParm();

			IPv4Address addr = null;

			for (int i = 0; i < parms.length; i++)
			{
				Parm parm = parms[i];

				if (SNMP_TRAP_ADDRESS_OID.equals(parm.getParmName()))
				{
					addr = new IPv4Address(parm.getValue().getContent());
					break;
				}
			}

			if (addr == null)
			{
				addr = new IPv4Address("0.0.0.0");
			}

			trap.setAgentAddress(new SnmpIPAddress(addr.getAddressBytes()));

			trap.setGeneric(snmpInfo.getGeneric());

			trap.setSpecific(snmpInfo.getSpecific());

			trap.setTimeStamp(snmpInfo.getTimeStamp());

			// varbinds

			for (int i = 0; i < parms.length; i++)
			{
				Parm parm = parms[i];
				Value value = parm.getValue();

				// omit any parms with type=Counter64

				if (!(EventConstants.TYPE_SNMP_COUNTER64.equals(value.getType())))
				{

					try
					{
						addVarBinding(trap, parm.getParmName(), value.getType(), value.getEncoding(), value.getContent());
					}

					catch (SnmpTrapHelperException e)
					{
						throw new SnmpTrapHelperException(e.getMessage() + " in event parm[" + i + "]");
					}
				}
			}

		}
		else
		{
			throw new SnmpTrapHelperException("Invalid SNMP version: " + version);
		}

		// send the trap

		sendTrap(snmpInfo.getCommunity(), trap, destAddr, destPort);
	}

