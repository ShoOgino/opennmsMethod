	/**
	 * Sends a standard message about "event" (not a notification) to all who have received the notification
	 * identified by notificationId
	 * 
	 * Used on auto-acked events to send "up" messages to those who received the "down" message, when clear=true
	 * @param notificationId
	 * @param event
	 */
	private void sendMessageToReceiversOfNotice(int origNotifId, Event secondEvent) {

		long now = System.currentTimeMillis();
		try {
			//Find the users who got the original notification and interate over them
			List usersNotified = NotificationFactory.getInstance().getUsersNotified(origNotifId);
			Iterator iter = usersNotified.iterator();
			while (iter.hasNext()) {
				Map userInfo = (Map) iter.next();
				String userId = (String) userInfo.get("userId");
				//We need to know which command was originally used to contact the user in question
				String[] commands = new String[] {(String) userInfo.get("command")};
				//This is a little counter-intuitive.  We need to find all notifications for the *second* event
				// (the one which, when recieved, caused the original notification to be auto-ack).  Typically
				// this will be only one, but we need all of them in order to send all appropriate "up" notification
				// messages.  Much of this next section is duplicated code from elsewhere in this class, but slightly 
				// different - it can probably be rather nicely refactored.
				Notification[] notifications =
					NotificationFactory.getInstance().getNotifForEvent(secondEvent);
				if (notifications != null) {
					for (int i = 0; i < notifications.length; i++) {
						Notification notification = notifications[i];
						String queueID =
							(notification.getNoticeQueue() != null
								? notification.getNoticeQueue()
								: "default");

						NoticeQueue noticeQueue = (NoticeQueue) m_noticeQueues.get(queueID);

						List targetSiblings = new ArrayList();
						NotificationTask newTask = null;
						Map params = buildParameterMap(notification, secondEvent, origNotifId);
						if (GroupFactory.getInstance().hasGroup((userId))) {
							Group group = GroupFactory.getInstance().getGroup(userId);
							String[] users = group.getUser();

							if (users != null && users.length > 0) {
								for (int j = 0; j < users.length; j++) {
									newTask =
										makeUserTask(
											now,
											params,
											origNotifId,
											users[j],
											commands,
											targetSiblings);
									//Always send this, even if the notification has been acked (which it will have been in this case)	
									newTask.setAlwaysSend(true);
									//Nuke this list - no-body cares (it's only used to *not* send messages), we just want the messages sent.
									targetSiblings.clear();
									if (newTask != null) {
										noticeQueue.put(new Long(now), newTask);
									}
								}
							} else {
								ThreadCategory.getInstance(getClass()).debug(
									"Not sending notice, no users specified for group "
										+ group.getName());
							}
						} else if (UserFactory.getInstance().hasUser(userId)) {
							newTask =
								makeUserTask(
									now,
									params,
									origNotifId,
									userId,
									commands,
									targetSiblings);
							//Always send this, even if the notification has been acked (which it will have been in this case)	
							newTask.setAlwaysSend(true);
							//Nuke this list - no-body cares (it's only used to *not* send messages), we just want the messages sent.
							targetSiblings.clear();
							if (newTask != null) {
								noticeQueue.put(new Long(now), newTask);
							}

						} else if (userId.indexOf("@") > -1) {
							newTask =
								makeEmailTask(
									now,
									params,
									origNotifId,
									userId,
									commands,
									targetSiblings);
							//Always send this, even if the notification has been acked (which it will have been in this case)	
							newTask.setAlwaysSend(true);
							//Nuke this list - no-body cares (it's only used to *not* send messages), we just want the messages sent.
							targetSiblings.clear();
							if (newTask != null) {
								noticeQueue.put(new Long(now), newTask);
							}

						}
					}

				}
			}
		} catch (ValidationException e) {
			ThreadCategory.getInstance(getClass()).error(
				"error trying to send auto-ack messages:" + e.getMessage());
			return;
		} catch (MarshalException e) {
			ThreadCategory.getInstance(getClass()).error(
				"error trying to send auto-ack messages:" + e.getMessage());
			return;
		} catch (IOException e) {
			ThreadCategory.getInstance(getClass()).error(
				"error trying to send auto-ack messages:" + e.getMessage());
			return;
		}
	}

