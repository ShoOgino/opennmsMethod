    /**
     * This is where all the work of the class is done.
     */
    public void run() {
        Category log = ThreadCategory.getInstance(getClass());

        //
        // perform rescan of the node
        //
        DbNodeEntry dbNodeEntry = null;

        // Get DbNodeEntry object which represents this node and
        // load it from the database
        try {
            dbNodeEntry = DbNodeEntry.get(m_scheduledNode.getNodeId());
            if (log.isDebugEnabled())
                log.debug("start rescanning node: " + m_scheduledNode.getNodeId());
        } catch (SQLException sqlE) {
            log.error("RescanProcessor: unable to load node info for nodeId " + m_scheduledNode.getNodeId() + " from the database.", sqlE);
            log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
            return;
        }

        // If this is a forced rescan then retrieve all the interfaces
        // associated with this node and perform collections against them.
        // Otherwise, this is a regularly scheduled rescan, only the
        // node's managed interfaces are to be retrieved and collected.
        // 
        DbIpInterfaceEntry[] dbInterfaces = null;

        // Retrieve list of interfaces associated with this nodeID
        // from the database
        if (log.isDebugEnabled())
            log.debug("retrieving all interfaces for node: " + m_scheduledNode.getNodeId());
        try {
            dbInterfaces = dbNodeEntry.getInterfaces();
        } catch (NullPointerException npE) {
            log.error("RescanProcessor: Null pointer when retrieving interfaces for node " + m_scheduledNode.getNodeId(), npE);
            log.error("Forced rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
            return;
        } catch (SQLException sqlE) {
            log.error("RescanProcessor: unable to load interface info for nodeId " + m_scheduledNode.getNodeId() + " from the database.", sqlE);
            log.error("Forced rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
            return;
        }

        boolean doesSnmp = true;
        IfSnmpCollector snmpc = null;
        IfSnmpCollector prevSnmpc = null;
        IpAddrTable ipAddTable = null;
        List prevAddrList = null;
        boolean snmpcAgree = false;
        boolean gotSnmpCollection = false;
        boolean gotSnmpc = false;
        Map collectorMap = new HashMap();
        Map nonSnmpCollectorMap = new HashMap();

        DbIpInterfaceEntry primarySnmpInterface = null;
        DbIpInterfaceEntry oldPrimarySnmpInterface = null;

        // Get primary snmp interface from database
        try {
             oldPrimarySnmpInterface = dbNodeEntry.getPrimarySnmpInterface(dbInterfaces);
        }
        catch (NullPointerException npE) {
            log.error("RescanProcessor: Null pointer when retrieving primary snmp interface from DB for node " + m_scheduledNode.getNodeId(), npE);
        }

        if(oldPrimarySnmpInterface != null) {
            // Run collector for DB primary snmp interface and add result
            // to a collector map.
            InetAddress ifaddr = oldPrimarySnmpInterface.getIfAddress();
            if (log.isDebugEnabled())
                log.debug("running collection for DB primary snmp interface " + ifaddr.getHostAddress());
            IfCollector collector = new IfCollector(ifaddr, true);
            collector.run();
            snmpc = collector.getSnmpCollector();
            if (snmpc == null) {
                if (log.isDebugEnabled())
                    log.debug("SNMP Collector from DB primary snmp interface is null");
            } else {
                gotSnmpCollection = true;
                collectorMap.put(ifaddr.getHostAddress(), collector);
                if (log.isDebugEnabled())
                    log.debug("SNMP data collected from DB primary snmp interface" + ifaddr.getHostAddress());
                if (!snmpc.hasIfTable()) {
                    if (log.isDebugEnabled())
                        log.debug("SNMP Collector has no IfTable");
                }
                if (!snmpc.hasIpAddrTable() || snmpc.getIfIndex(snmpc.getTarget()) == -1) {
                    if (log.isDebugEnabled())
                        log.debug("SNMP Collector has no IpAddrTable. Assume its a lame SNMP host.");
                }
            }
        }

        if(!gotSnmpCollection) {

            if (!m_forceRescan) {
                // just rescan managed interfaces interfaces associated with this nodeID
                if (log.isDebugEnabled())
                    log.debug("retrieving managed interfaces for node: " + m_scheduledNode.getNodeId());
                try {
                    dbInterfaces = dbNodeEntry.getManagedInterfaces();
                } catch (NullPointerException npE) {
                    log.error("RescanProcessor: Null pointer when retrieving managed interfaces for node " + m_scheduledNode.getNodeId(), npE);
                    log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
                    return;
                } catch (SQLException sqlE) {
                    log.error("RescanProcessor: unable to load interface info for nodeId " + m_scheduledNode.getNodeId() + " from the database.", sqlE);
                    log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
                    return;
                }
            }

            // Run collector for each retrieved interface and add result
            // to a collector map.
            for (int i = 0; i < dbInterfaces.length; i++) {
                InetAddress ifaddr = dbInterfaces[i].getIfAddress();

                // collect the information from the interface.
                // NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
                if (ifaddr.getHostAddress().startsWith("127") || ifaddr.getHostAddress().equals("0.0.0.0")) {
                    continue;
                }

                if (log.isDebugEnabled())
                    log.debug("running collection for " + ifaddr.getHostAddress());

                IfCollector collector = new IfCollector(ifaddr, true);
                collector.run();

                snmpc = collector.getSnmpCollector();
                if (snmpc != null)
                    gotSnmpc = true;
                if (snmpc != null && snmpc.hasIpAddrTable() && snmpc.getIfIndex(snmpc.getTarget()) != -1) {

                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        gotSnmpCollection = true;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress());
                            log.debug("Adding " + ifaddr.getHostAddress() + " to collectorMap for node: " + m_scheduledNode.getNodeId());
                        }
                        snmpcAgree = false;
                        break;
                    }
                    else if (ipAddTable == null) {
                        snmpcAgree = true;
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        ipAddTable = snmpc.getIpAddrTable();
                        prevAddrList = IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        prevSnmpc = snmpc;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress() + " does not agree with database. Tentatively adding to" + " the collectorMap and continuing");
                            Iterator h = prevAddrList.iterator();
                            while(h.hasNext()) {
                                log.debug("IP address in list = " +h.next());
                            }
                        }
                    }
                    else if (ipAddTable != null && snmpcAgree == true) {
                        ipAddTable = snmpc.getIpAddrTable();
                        List addrList = IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        boolean listMatch = true;
                        String jstring = null;
                        String kstring = null;
                        Iterator j = prevAddrList.iterator();
                        Iterator k = addrList.iterator();
                        while(j.hasNext()) {
                            jstring = j.next().toString();
                            if(k.hasNext()) {
                                kstring = k.next().toString();
                                if(jstring.equals(kstring)) {
                                    if (log.isDebugEnabled())
                                        log.debug(jstring + " = " + kstring);
                                }
                                else {
                                    if (log.isDebugEnabled())
                                        log.debug(jstring + " != " + kstring);
                                    listMatch = false;
                                }
                            }
                            else {
                                listMatch = false;
                            }
                        }
                        if(k.hasNext()) {
                            listMatch = false;
                        }
                        if (listMatch) {
                            if (log.isDebugEnabled())
                                log.debug("Current and previous address lists match");
                        }
                        else {
                            if (log.isDebugEnabled())
                                log.debug("Current and previous address lists DO NOT match");
                            snmpcAgree = false;
                        }
                    }
                    if (snmpcAgree == false) {
                        if (log.isDebugEnabled())
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress() + " does not agree with database or with other interface(s) on this node.");
                    }
                }
                // Build a non-SNMP collectorMap, skipping 127.*.*.* and 0.0.0.0
                nonSnmpCollectorMap.put(ifaddr.getHostAddress(), collector);
                if (log.isDebugEnabled()) {
                    log.debug("Adding " + ifaddr.getHostAddress() + " to nonSnmpCollectorMap for node: " + m_scheduledNode.getNodeId());
                }
            }
        }

        if (!gotSnmpCollection && snmpcAgree == false) {
            // We didn't get a collection from a primary snmp interface,
            // and we didn't get a collection that agrees with the db, and
            // multiple interface collections don't agree with each other.
            // First check for lame SNMP host, otherwise use the
            // nonSnmpCollectorMap and set doesSnmp = false
            //
            collectorMap = nonSnmpCollectorMap;
            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {
                doesSnmp = true;
                if (log.isDebugEnabled()) {
                    log.debug("node " + m_scheduledNode.getNodeId() + " appears to be a lame SNMP host... Proceeding");
                }
            } else {
                doesSnmp = false;
                if (log.isDebugEnabled()) {
                    if (gotSnmpc == false) {
                        log.debug("Could not collect SNMP data for node: " + m_scheduledNode.getNodeId());
                    } else {
                        log.debug("Not using SNMP data for node: " + m_scheduledNode.getNodeId() + ". Collection does not agree with database.");
                    }
                }
            }
        }
        else if (snmpcAgree == true) {
            // We didn't get a collection from a primary snmp interface,
            // and we didn't get a collection that agrees with the db, but
            // all collections we DID get agree with each other.
            // May want to create an event here
            snmpc = prevSnmpc;
            if (log.isDebugEnabled()) {
                log.debug("SNMP collection for node: " + m_scheduledNode.getNodeId() + " does not agree with database, but there is no conflict among the interfaces on this node which respond to SNMP. Proceeding...");
            }
            createSnmpConflictsWithDbEvent(dbNodeEntry);
        }

        // Update the database
        //
        Date now = null;
        Connection dbc = null;
        boolean updateCompleted = false;
        try {
            // Synchronize on the Capsd sync lock so we can check if
            // the interface is already in the database and perform
            // the necessary inserts in one atomic operation
            //	
            // The SuspectEventProcessor class is also synchronizing on this
            // lock prior to performing database inserts or updates.
            synchronized (Capsd.getDbSyncLock()) {
                // Get database connection
                //
                dbc = DatabaseConnectionFactory.getInstance().getConnection();

                // There is a slight possibility that the node being rescanned
                // has been deleted (due to reparenting) by another thread
                // between the time this rescan was started and the database
                // sync lock was grabbed. Verify that the current nodeid is
                // still valid (ie, not deleted) before continuing.
                //
                if (!isNodeDeleted(dbc, m_scheduledNode.getNodeId())) {

                    // Update interface information
                    //
                    now = new Date();
                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap, doesSnmp);
                    if (doesSnmp) {
                        // Get old primary SNMP interface(s) (if one or more exists)
                        //
                        List oldPriIfs = SuspectEventProcessor.getPrimarySnmpInterfaceFromDb(dbc, dbNodeEntry);

                        // Now that all interfaces have been added to the
                        // database we can update the 'primarySnmpInterface'
                        // field of the ipInterface table. Necessary because
                        // the IP address must already be in the database
                        // to evaluate against a filter rule.
                        //
                        // First create a list of eligible loopback interfaces
                        // and a list of all eligible interfaces. Test in the
                        // following order: 1) strict = true (interface must
                        // be part of a Collectd package) and loopback. 2)
                        // strict = true and all eligible interfaces.
                        // strict = false and loopback. 4) strict = false and
                        // all eligible interfaces.
                        //
                        boolean strict = true;
                        List snmpLBAddresses = buildLBSnmpAddressList(collectorMap, snmpc);
                        List snmpAddresses = buildSnmpAddressList(collectorMap, snmpc);
                        InetAddress newSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);
                        String psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " loopback addresses";

                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);
                            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " addresses";
                        }

                        strict = false;
                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);
                            psiType = "DB loopback addresses";
                        }

                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);
                            psiType = "DB addresses";
                        }

                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = snmpc.getTarget();
                            psiType = "snmp collector target address";
                        }

                        if (newSnmpPrimaryIf != null) {
                            if(log.isDebugEnabled()) {
                                log.debug("primary SNMP interface is: " + newSnmpPrimaryIf + ", selected from " + psiType);
                            }
                            // iterate over list of old primaries. There should only be one,
                            // but in case there are more, this should clear out the extras.
                            Iterator opiter = oldPriIfs.iterator();
                            if(opiter.hasNext()) {
                                while (opiter.hasNext()) {
                                    SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, (InetAddress) opiter.next());
                                }
                            } else {
                                SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, null);
                            }
                        }
                        else {
                            if(log.isDebugEnabled())
                                log.debug("SuspectEventProcessor: Unable to determine a primary snmp interface");
                        }   

                        // Now that we've identified the new primary SNMP
                        // interface we can determine if it is necessary to
                        // generate certain SNMP data collection related
                        // events
                        //
                        generateSnmpDataCollectionEvents(dbNodeEntry, oldPriIfs, newSnmpPrimaryIf);

                        // Update the node table entry
                        //
                        DbNodeEntry updatedNodeEntry = updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf, dbInterfaces, collectorMap);
                    }
                    updateCompleted = true;
                }
            }

        } // end try
        catch (Throwable t) {
            log.error("Error updating records", t);
        } finally {
            // Finished with the database connection, close it.
            try {
                if (dbc != null)
                    dbc.close();
            } catch (SQLException e) {
                log.error("Error closing connection", e);
            }
        }

        // Send events associcatd with the rescan
        //
        if (updateCompleted) {
            // Send all events created during rescan process to eventd
            //
            Iterator iter = m_eventList.iterator();
            while (iter.hasNext()) {
                try {
                    EventIpcManagerFactory.getInstance().getManager().sendNow((Event) iter.next());

                } catch (Throwable t) {
                    log.warn("run: unexpected throwable exception caught during send to middleware", t);
                }
            }
        }

        // Update the schedule information for the rescanned node
        // 
        m_scheduledNode.setLastScanned(now);
        m_scheduledNode.setScheduled(false);

        if (log.isDebugEnabled())
            log.debug("Rescan for node w/ nodeid " + m_scheduledNode.getNodeId() + " completed.");
    } // end run

