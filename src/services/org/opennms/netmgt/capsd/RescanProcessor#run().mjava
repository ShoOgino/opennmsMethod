    /**
     * This is where all the work of the class is done.
     */
    public void run() {
        Category log = ThreadCategory.getInstance(RescanProcessor.class);
        //
        // perform rescan of the node
        //
        DbNodeEntry dbNodeEntry = getNode();
        
        if (dbNodeEntry == null) return;
        
        if (log.isDebugEnabled())
            log.debug("start rescanning node: " + m_scheduledNode.getNodeId());

        DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);
        
        if (dbInterfaces == null) return;

        // this indicates whether or not we found an iface the responds to snmp
        boolean doesSnmp = true;
        
        IfSnmpCollector prevSnmpc = null;
        IpAddrTable ipAddTable = null;
        List prevAddrList = null;
        boolean snmpcAgree = false;
        boolean gotSnmpc = false;
        Map collectorMap = new HashMap();
        Map nonSnmpCollectorMap = new HashMap();

        boolean gotSnmpCollection = scanPrimarySnmpInterface(log, dbInterfaces, collectorMap);

        if(!gotSnmpCollection) {

            // Run collector for each retrieved interface and add result
            // to a collector map.
            for (int i = 0; i < dbInterfaces.length; i++) {
                InetAddress ifaddr = dbInterfaces[i].getIfAddress();

                // collect the information from the interface.
                // NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
                if (ifaddr.getHostAddress().startsWith("127") || ifaddr.getHostAddress().equals("0.0.0.0")) {
                    continue;
                }

                if (log.isDebugEnabled())
                    log.debug("running collection for " + ifaddr.getHostAddress());

                IfCollector collector = new IfCollector(ifaddr, true);
                collector.run();

                IfSnmpCollector snmpc = collector.getSnmpCollector();
                if (snmpc != null)
                    gotSnmpc = true;
                if (snmpc != null && snmpc.hasIpAddrTable() && snmpc.getIfIndex(snmpc.getTarget()) != -1) {

                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        gotSnmpCollection = true;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress());
                            log.debug("Adding " + ifaddr.getHostAddress() + " to collectorMap for node: " + m_scheduledNode.getNodeId());
                        }
                        snmpcAgree = false;
                        break;
                    }
                    else if (ipAddTable == null) {
                        snmpcAgree = true;
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        ipAddTable = snmpc.getIpAddrTable();
                        prevAddrList = IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        prevSnmpc = snmpc;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress() + " does not agree with database. Tentatively adding to" + " the collectorMap and continuing");
                            Iterator h = prevAddrList.iterator();
                            while(h.hasNext()) {
                                log.debug("IP address in list = " +h.next());
                            }
                        }
                    }
                    else if (ipAddTable != null && snmpcAgree == true) {
                        ipAddTable = snmpc.getIpAddrTable();
                        List addrList = IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        boolean listMatch = true;
                        String jstring = null;
                        String kstring = null;
                        Iterator j = prevAddrList.iterator();
                        Iterator k = addrList.iterator();
                        while(j.hasNext()) {
                            jstring = j.next().toString();
                            if(k.hasNext()) {
                                kstring = k.next().toString();
                                if(jstring.equals(kstring)) {
                                    if (log.isDebugEnabled())
                                        log.debug(jstring + " = " + kstring);
                                }
                                else {
                                    if (log.isDebugEnabled())
                                        log.debug(jstring + " != " + kstring);
                                    listMatch = false;
                                }
                            }
                            else {
                                listMatch = false;
                            }
                        }
                        if(k.hasNext()) {
                            listMatch = false;
                        }
                        if (listMatch) {
                            if (log.isDebugEnabled())
                                log.debug("Current and previous address lists match");
                        }
                        else {
                            if (log.isDebugEnabled())
                                log.debug("Current and previous address lists DO NOT match");
                            snmpcAgree = false;
                        }
                    }
                    if (snmpcAgree == false) {
                        if (log.isDebugEnabled())
                            log.debug("SNMP data collected via " + ifaddr.getHostAddress() + " does not agree with database or with other interface(s) on this node.");
                    }
                }
                // Build a non-SNMP collectorMap, skipping 127.*.*.* and 0.0.0.0
                nonSnmpCollectorMap.put(ifaddr.getHostAddress(), collector);
                if (log.isDebugEnabled()) {
                    log.debug("Adding " + ifaddr.getHostAddress() + " to nonSnmpCollectorMap for node: " + m_scheduledNode.getNodeId());
                }
            }
        }

        if (!gotSnmpCollection && snmpcAgree == false) {
            // We didn't get a collection from a primary snmp interface,
            // and we didn't get a collection that agrees with the db, and
            // multiple interface collections don't agree with each other.
            // First check for lame SNMP host, otherwise use the
            // nonSnmpCollectorMap and set doesSnmp = false
            //
            collectorMap = nonSnmpCollectorMap;
            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {
                doesSnmp = true;
                if (log.isDebugEnabled()) {
                    log.debug("node " + m_scheduledNode.getNodeId() + " appears to be a lame SNMP host... Proceeding");
                }
            } else {
                doesSnmp = false;
                if (log.isDebugEnabled()) {
                    if (gotSnmpc == false) {
                        log.debug("Could not collect SNMP data for node: " + m_scheduledNode.getNodeId());
                    } else {
                        log.debug("Not using SNMP data for node: " + m_scheduledNode.getNodeId() + ". Collection does not agree with database.");
                    }
                }
            }
        }
        else if (snmpcAgree == true) {
            // We didn't get a collection from a primary snmp interface,
            // and we didn't get a collection that agrees with the db, but
            // all collections we DID get agree with each other.
            // May want to create an event here
            if (log.isDebugEnabled()) {
                log.debug("SNMP collection for node: " + m_scheduledNode.getNodeId() + " does not agree with database, but there is no conflict among the interfaces on this node which respond to SNMP. Proceeding...");
            }
            createSnmpConflictsWithDbEvent(dbNodeEntry);
        }

        // Update the database
        //
        Date now = null;
        Connection dbc = null;
        boolean updateCompleted = false;
        try {
            // Synchronize on the Capsd sync lock so we can check if
            // the interface is already in the database and perform
            // the necessary inserts in one atomic operation
            //	
            // The SuspectEventProcessor class is also synchronizing on this
            // lock prior to performing database inserts or updates.
            log.debug("Waiting for capsd dbLock to process "+m_scheduledNode.getNodeId());
            synchronized (Capsd.getDbSyncLock()) {
                log.debug("Got capsd dbLock. processing "+m_scheduledNode.getNodeId());
                // Get database connection
                //
                dbc = DatabaseConnectionFactory.getInstance().getConnection();

                // There is a slight possibility that the node being rescanned
                // has been deleted (due to reparenting) by another thread
                // between the time this rescan was started and the database
                // sync lock was grabbed. Verify that the current nodeid is
                // still valid (ie, not deleted) before continuing.
                //
                if (!isNodeDeleted(dbc, m_scheduledNode.getNodeId())) {

                    // Update interface information
                    //
                    now = new Date();
                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap, doesSnmp);
                    
                    if (doesSnmp) {
                        InetAddress newSnmpPrimaryIf = updatePrimarySnmpInterface(dbc, dbNodeEntry, collectorMap);

                        DbNodeEntry updatedNodeEntry = updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf, dbInterfaces, collectorMap);
                    }
                    updateCompleted = true;
                }
            }

        } // end try
        catch (Throwable t) {
            log.error("Error updating records", t);
        } finally {
            // Finished with the database connection, close it.
            try {
                if (dbc != null)
                    dbc.close();
            } catch (SQLException e) {
                log.error("Error closing connection", e);
            }
        }

        // Send events associcatd with the rescan
        //
        if (updateCompleted) {
            // Send all events created during rescan process to eventd
            //
            Iterator iter = m_eventList.iterator();
            while (iter.hasNext()) {
                try {
                    EventIpcManagerFactory.getInstance().getManager().sendNow((Event) iter.next());

                } catch (Throwable t) {
                    log.warn("run: unexpected throwable exception caught during send to middleware", t);
                }
            }
        }

        // Update the schedule information for the rescanned node
        // 
        m_scheduledNode.setLastScanned(now);
        m_scheduledNode.setScheduled(false);

        if (log.isDebugEnabled())
            log.debug("Rescan for node w/ nodeid " + m_scheduledNode.getNodeId() + " completed.");
    } // end run

