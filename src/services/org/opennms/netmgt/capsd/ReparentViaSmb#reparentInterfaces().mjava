    /**
     * This method is responsible for reparenting interfaces belonging to
     * duplicate nodes under the appropriate reparent node id. During this
     * processing the reparented interface map is generated. This map contains a
     * list of reparented interfaces associated with each reparent node. This
     * list will make it possible to generate 'interfaceReparented' events for
     * each reparented interface.
     * 
     * During reparenting the 'ipInterface', 'snmpInterface', and 'ifServices'
     * tables are all updated to reflect the new parent node id for the
     * reparented interface.
     * 
     * @throws SQLException
     *             if error occurs updating the database
     */
    private void reparentInterfaces() throws SQLException {
        Category log = ThreadCategory.getInstance(getClass());
        List reparentedIfList = null;
        m_reparentedIfMap = null;

        PreparedStatement ipInterfaceStmt = m_connection.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);
        PreparedStatement snmpInterfaceStmt = m_connection.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);
        PreparedStatement ifServicesStmt = m_connection.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);

        Set keys = m_reparentNodeMap.keySet();
        Iterator iter = keys.iterator();

        while (iter.hasNext()) {
            LightWeightNodeEntry reparentNode = (LightWeightNodeEntry) iter.next();
            int reparentNodeID = reparentNode.getNodeId();

            // Now construct a "heavier weight" DbNodeEntry object for this
            // node...sysName, sysDescription and other fields from the node
            // table will be necessary later when the reparentInterface
            // event is generated.
            reparentNode.setHeavyWeightNodeEntry(DbNodeEntry.get(reparentNodeID));

            // Retrieve duplicate node list for this reparent node key
            List dupList = (List) m_reparentNodeMap.get(reparentNode);
            log.debug("ReparentViaSmb.retrieveNodeData: duplicate node list retrieved, list size=" + dupList.size());

            Iterator dupIter = dupList.iterator();
            while (dupIter.hasNext()) {
                LightWeightNodeEntry dupNode = (LightWeightNodeEntry) dupIter.next();
                int dupNodeID = dupNode.getNodeId();

                try {
                    if (log.isDebugEnabled())
                        log.debug("reparentInterfaces: reparenting all interfaces/services for nodeID " + dupNodeID + " under reparent nodeID " + reparentNodeID);

                    //
                    // Prior to reparenting the interfaces associated with the
                    // duplicate node retrieve a list of the node's interface
                    // IP addresses and add them to the m_reparentedIfMap. This
                    // list will allow us to generate 'interfaceReparented'
                    // events for each one
                    //
                    PreparedStatement stmt = m_connection.prepareStatement(SQL_DB_RETRIEVE_INTERFACES);
                    stmt.setInt(1, dupNodeID);

                    try {
                        // Issue database query
                        if (log.isDebugEnabled())
                            log.debug("reparentInterfaces: issuing db query...");
                        ResultSet rs = stmt.executeQuery();

                        // Process result set
                        // Build list of LightWeightIfEntry objects representing
                        // each of the
                        // interfaces pulled from the 'ipInterface' table
                        while (rs.next()) {
                            String ifAddress = rs.getString(1);
                            String hostName = rs.getString(2);

                            LightWeightIfEntry lwIfEntry = new LightWeightIfEntry(ifAddress, hostName, reparentNodeID, dupNodeID);

                            if (reparentedIfList == null)
                                reparentedIfList = new ArrayList();
                            reparentedIfList.add(lwIfEntry);

                            if (log.isDebugEnabled())
                                log.debug("reparentInterfaces: will reparent " + lwIfEntry.getAddress() + " : oldNodeId: " + lwIfEntry.getOldParentNodeId() + " newNodeId: " + lwIfEntry.getParentNodeId());
                        }

                        rs.close();

                    } catch (SQLException sqlE) {
                        throw sqlE;
                    } finally {
                        stmt.close();
                    }

                    // Update the 'ipInterface' table so that all interfaces
                    // associated with the duplicate node are reparented.
                    ipInterfaceStmt.setInt(1, reparentNodeID);
                    ipInterfaceStmt.setInt(2, dupNodeID);

                    // execute and log
                    ipInterfaceStmt.executeUpdate();

                    // Update the 'snmpinterface' table so that all interfaces
                    // associated with the duplicate node are reparented
                    snmpInterfaceStmt.setInt(1, reparentNodeID);
                    snmpInterfaceStmt.setInt(2, dupNodeID);

                    // execute and log
                    snmpInterfaceStmt.executeUpdate();

                    // Update the 'ifservices' table so that all services
                    // associated
                    // with the duplicate node are reparented
                    ifServicesStmt.setInt(1, reparentNodeID);
                    ifServicesStmt.setInt(2, dupNodeID);

                    // execute and log
                    ifServicesStmt.executeUpdate();
                } catch (SQLException sqlE) {
                    log.error("SQLException while reparenting duplicate node w/ nodeID " + dupNodeID);
                    throw sqlE;
                } finally {
                    ipInterfaceStmt.close();
                    snmpInterfaceStmt.close();
                    ifServicesStmt.close();
                }

                // 
                // Now that all the interfaces have been reparented...lets
                // delete this duplicate node from the 'node' table
                //
                if (log.isDebugEnabled())
                    log.debug("reparentInterfaces: deleting duplicate node id: " + dupNodeID);
                PreparedStatement deleteNodeStmt = null;
                try {
                    deleteNodeStmt = m_connection.prepareStatement(SQL_DB_DELETE_NODE);
                    deleteNodeStmt.setInt(1, dupNodeID);

                    // execute update
                    deleteNodeStmt.executeUpdate();
                } catch (SQLException sqlE) {
                    throw sqlE;
                } finally {
                    deleteNodeStmt.close();
                }

            } // end while(dupIter.hasNext())

            // Should have a reparented interface list now...add it to
            // the reparented interface map with the reparent node as the key
            if (reparentedIfList != null && !reparentedIfList.isEmpty()) {
                if (m_reparentedIfMap == null)
                    m_reparentedIfMap = new HashMap();

                m_reparentedIfMap.put(reparentNode, reparentedIfList);
            }
        } // end while(iter.hasNext())
    }

