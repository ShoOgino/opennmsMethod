	/**
	 * <P>This method is used to process received SNMP PDU packets from
	 * the remote agent. The method is part of the SnmpHandler interface
	 * and will be invoked when a PDU is successfully decoded. The method
	 * is passed the receiving session, the PDU command, and the actual
	 * PDU packet.</P>
	 *
	 * <P>When all the data has been received from the session the signaler
	 * object, initialized in the constructor, is signaled. In addition,
	 * the receiving instance will call notifyAll() on itself at the same
	 * time.</P>
	 *
	 * @param session	The SNMP Session that received the PDU
	 * @param command	The command contained in the received pdu
	 * @param pdu		The actual received PDU.
	 *
	 */
	public void snmpReceivedPdu(SnmpSession session, int command, SnmpPduPacket pdu)
	{	
		boolean doNotify = true;
		boolean more_obj = true;

		Category log = ThreadCategory.getInstance(getClass());

		if(log.isDebugEnabled())
			log.debug("snmpReceivedPdu: got SNMP response, current version: " + ((m_version==SnmpSMI.SNMPV1)?"SNMPv1":"SNMPv2"));

		if(command != SnmpPduPacket.RESPONSE)
		{
			m_error = true;
		}
		else
		{
			//
			// Check for error stored in request pdu
			//
			int errStatus = ((SnmpPduRequest)pdu).getErrorStatus();
			if (errStatus != SnmpPduPacket.ErrNoError)
			{
				m_error = true;
			}
			else
			{
				// The last variable in the list of elements
				// is always the first to run off the table, so 
				// we only need to check that one.
				//
			    
				// GETBULK response handling
				if (m_version == SnmpSMI.SNMPV2) 
				{
					int numVarBinds = pdu.getLength();
					
					for (int x = 0; x < numVarBinds; x++)
					{
						SnmpVarBind vb = pdu.getVarBindAt(x);
						
						if (vb.getValue() instanceof org.opennms.protocols.snmp.SnmpV2Error)
						{
							m_error = true;
							if (log.isDebugEnabled())
								log.debug("snmpReceivedPDU: varbind: " + vb.getName() + "  error: '" + vb.getValue() + "'");								
							break;
						}
						m_snmpVarBindList.add(vb);
					 }
				
					if (!m_error)
					{
						//in case we did not receive all the data from the 
						//first packet, must generate a new GETBULK packet
						//starting at the OID the previous one left off.
						//
						if (m_stopAt.compare(pdu.getVarBindAt(numVarBinds-1).getName()) > 0) 
						{
							SnmpObjectId id = new SnmpObjectId(pdu.getVarBindAt(numVarBinds-1).getName());
							SnmpVarBind[] newvblist = { new SnmpVarBind(id) };

							SnmpPduPacket nxt = new SnmpPduBulk(0, 10, newvblist);
							nxt.setRequestId(nxt.nextSequence());
							session.send(nxt, this);
							doNotify = false;
						}				
						else 
						{
							// Convert SNMP variable binding list to an array for processing
							//
							SnmpVarBind[] tempStorage = new SnmpVarBind[m_snmpVarBindList.size()];
							tempStorage = (SnmpVarBind[])m_snmpVarBindList.toArray(tempStorage);
						
							//since the MIB does not store the number of interfaces that have
							//IP addresses, the method must resort to an alternative.  By 
							//counting the number of values found for the ipAddrIfIndex variable,
							//we'll have the number of interfaces with IP's.  Each IP-bound 
							//interface will have a value for each MIB variable listed
							//
							int numInterfaces = 0;
							SnmpObjectId ipAddrIfIndex = new SnmpObjectId(IP_ADDR_IF_INDEX);
					    
							while (ipAddrIfIndex.compare(tempStorage[numInterfaces].getName()) > 0) 
								numInterfaces++;
					
							//store the IP Address Table data for each interface into a map.
							//
							int numEntries = IpAddrTableEntry.getElementListSize();
							for (int if_index = 0; if_index < numInterfaces; if_index++) 
							{
								SnmpVarBind[] vblist = new SnmpVarBind[numEntries];
								for (int vb_index = 0;  vb_index < numEntries; vb_index++)
								{
									vblist[vb_index] = tempStorage[if_index + (vb_index*numInterfaces)];
								}
								IpAddrTableEntry ent = new IpAddrTableEntry(vblist);
								m_entries.add(ent);
							}
						}
					} 
				} 
				else if (m_version == SnmpSMI.SNMPV1)// GETNEXT response handling 
				{	
					// Create a new map of the interface entry
					//
					// The last varbind will be the first one to walk off the end 
					// of the ipAddrTable. So verify that the last entry in the 
					// received pdu is still within the scope of the IpAddrTable...
					// if it is then create a new entry.
					//
					if (IpAddrTableEntry.ROOT.isRootOf(pdu.getVarBindAt(pdu.getLength()-1).getName()))
					{
						if(log.isDebugEnabled())
						log.debug("snmpReceivedPdu: got SNMPv1 response and still within IpAddrTable, creating new entry.");
						SnmpVarBind [] vblist = pdu.toVarBindArray();
						IpAddrTableEntry ent = new IpAddrTableEntry(vblist);
						m_entries.add(ent);
				    
						// next pdu
						//
						SnmpPduRequest nxt = new SnmpPduRequest(SnmpPduPacket.GETNEXT);
						for(int x = 0; x < pdu.getLength(); x++)
						{
							nxt.addVarBind(new SnmpVarBind(pdu.getVarBindAt(x).getName()));
						}
					
						nxt.setRequestId(nxt.nextSequence());
						session.send(nxt, this);
						doNotify = false;
					}
				}
			}
		}
		
		if(doNotify)
		{
			synchronized(this)
			{
				notifyAll();
			}
			if(m_signal != null)
			{
				synchronized(m_signal)
				{
					m_signal.signalAll();
				}
			}
		}
	}

