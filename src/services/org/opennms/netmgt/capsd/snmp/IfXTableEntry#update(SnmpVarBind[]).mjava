    /**
     * <P>
     * This method is used to update the map with the current information from
     * the agent. The array of variables should be all the elements in the
     * interfaces row.
     * </P>
     * 
     * </P>
     * This does not clear out any column in the actual ifXEntry row that does
     * not have a definition.
     * </P>
     * 
     * @param vars
     *            The variables in the interface row.
     * 
     */
    public void update(SnmpVarBind[] vars) {
        Category log = ThreadCategory.getInstance(getClass());

        //
        // iterate through the variable bindings
        // and set the members appropiately.
        //
        // Note: the creation of the snmp object id
        // is in the outer loop to limit the times a
        // new object is created.
        //
        for (int x = 0; x < ms_elemList.length; x++) {
            SnmpObjectId id = new SnmpObjectId(ms_elemList[x].getOid());
            for (int y = 0; y < vars.length; y++) {
                if (id.isRootOf(vars[y].getName())) {
                    try {
                        //
                        // Retrieve the class object of the expected SNMP data
                        // type for this element
                        //
                        Class classObj = ms_elemList[x].getTypeClass();

                        // SPECIAL CASE
                        // 
                        // Since we don't have the ifIndex as part of the
                        // interface extensions table we will retrieve the
                        // ifIndex from the object id of the
                        // first retrieved element (ifName) and store it
                        // in the map with the key of "IF_INDEX".
                        if (x == 0) {
                            // Extract the instance id from the returned object
                            // id associated with ifName variable. This instance
                            // id becomes our ifIndex value. // Extract the
                            // "instance" id from the current SnmpVarBind's
                            // object id
                            String from_oid = vars[y].getName().toString();
                            SnmpObjectId objId = new SnmpObjectId(from_oid);
                            int[] ids = objId.getIdentifiers();
                            SnmpInt32 instanceId = new SnmpInt32(ids[ids.length - 1]);

                            // Store it
                            put("ifIndex", instanceId);
                        }
                        //
                        // If the SnmpSyntax object matches the expected class
                        // then store it in the map. Else, store a null pointer
                        // in the map.
                        //
                        if (classObj.isInstance(vars[y].getValue())) {
                            put(ms_elemList[x].getAlias(), vars[y].getValue());
                            put(ms_elemList[x].getOid(), vars[y].getValue());
                        } else {
                            put(ms_elemList[x].getAlias(), null);
                            put(ms_elemList[x].getOid(), null);
                        }
                    } catch (ClassNotFoundException e) {
                        log.error("update: Failed retrieving SNMP type class for element: " + ms_elemList[x].getAlias(), e);
                    } catch (NullPointerException e) {
                        log.error("update: NullPointerException retrieveing SNMP information", e);
                    }
                }
            }
        }
    }

