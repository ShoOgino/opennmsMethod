	/**
	 * <P>This method is used to process received SNMP PDU packets from
	 * the remote agent. The method is part of the SnmpHandler interface
	 * and will be invoked when a PDU is successfully decoded. The method
	 * is passed the receiving session, the PDU command, and the actual
	 * PDU packet.</P>
	 *
	 * <P>When all the data has been received from the session the signaler
	 * object, initialized in the constructor, is signaled. In addition,
	 * the receiving instance will call notifyAll() on itself at the same
	 * time.</P>
	 *
	 * <P>For SNMP version 2 devices, all the received data enters a 
	 * temporary array.  After the collecting process, the method
	 * sorts the data so that each interface has its own map.</P>
	 *
	 * @param session	The SNMP Session that received the PDU
	 * @param command	The command contained in the received pdu
	 * @param pdu		The actual received PDU.
	 *
	 */
	public void snmpReceivedPdu(SnmpSession session, int command, SnmpPduPacket pdu)
	{
		boolean doNotify = true;
	
		// lookup the category
		//
		Category log = ThreadCategory.getInstance(getClass());
		
		if (command != SnmpPduPacket.RESPONSE)
		{
			m_error = true;
		}
		else
		{
			//
			// Check for error stored in request pdu
			//
			int errStatus = ((SnmpPduRequest)pdu).getErrorStatus();
			if (errStatus != SnmpPduPacket.ErrNoError)
			{		
				m_error = true;
			} 
			else
			{
			    	// Is this the response to our request to retrieve ifNumber?
			    	// If so, begin gathering all the MIB data for the device
			    	if (pdu.getRequestId() ==  m_ifNumberRequestId) 
			    	{
					// Check for v2 error in varbind
					SnmpVarBind vb = pdu.getVarBindAt(0);
					if (vb.getValue() instanceof org.opennms.protocols.snmp.SnmpV2Error)
					{
						m_error = true;
						if (log.isDebugEnabled())
							log.debug("snmpReceivedPDU: varbind: " + vb.getName() + "  error: '" + vb.getValue() + "'");
					}
						
					if (!m_error)
					{
						SnmpInt32 temp = (SnmpInt32)vb.getValue();
						m_ifNumber = temp.getValue();
						if (log.isDebugEnabled())
							log.debug("snmpReceivedPdu: Number of interfaces = " + m_ifNumber);
					
						// 
						// Now that we know the number of interfaces we can can allocate
						// the temp storage to hold all the response variable bindings
						// 
						tempStorage = new SnmpVarBind[m_ifNumber * IfXTableEntry.getElementListSize()];
						SnmpPduPacket nxt = null;
						if (m_version == SnmpSMI.SNMPV2)
						{
							nxt = IfXTableEntry.getBulkPdu(m_ifNumber);
						}
						else
						{
							nxt = IfXTableEntry.getNextPdu();
						}
						
						session.send(nxt, this);
						doNotify = false;
					}
			    	}
			    	// Handle SNMPv2 GetBulk responses...
			    	else if (m_version == SnmpSMI.SNMPV2) 
			    	{
					if (log.isDebugEnabled())
					{
						log.debug("snmpReceivedPdu: Handling GETBULK packet");
					}
					int length = pdu.getLength();
					
					for (int y = 0; y < pdu.getLength(); y++) 
					{
						// Check for v2 error in each returned varbind
						SnmpVarBind vb = pdu.getVarBindAt(y);
						
						if (vb.getValue() instanceof org.opennms.protocols.snmp.SnmpV2Error)
						{
							m_error = true;
							if (log.isDebugEnabled())
								log.debug("snmpReceivedPDU: varbind: " + vb.getName() + "  error: '" + vb.getValue() + "'");
							break;
						}
						
				    		tempStorage[m_responses] = vb;
						m_responses++;
					}
					 
					if (!m_error)
					{
						//
						//in case we did not receive all the data from the 
						//first packet, must generate a new GETBULK packet
						//starting at the OID the previous one left off.
						//
					
						// Calculate maxRepetitions for next GETBULK packet
						int maxReps = (m_ifNumber*IfXTableEntry.getElementListSize()) - m_responses;
						if (log.isDebugEnabled())
							log.debug("snmpReceivedPdu: calculated number of maxRepetitions = " + maxReps);
					
						if (maxReps > 0 && m_stopAt.compare(pdu.getVarBindAt(length-1).getName()) > 0) 
						{
							SnmpObjectId id = new SnmpObjectId(pdu.getVarBindAt(length-1).getName());
				    			SnmpVarBind[] newvblist = {new SnmpVarBind(id)};
				    			SnmpPduPacket nxt = new SnmpPduBulk(0, maxReps, newvblist);
							nxt.setRequestId(SnmpPduPacket.nextSequence());
							if (log.isDebugEnabled())
								log.debug("smnpReceivedPDU: Starting new GETBULK packet at OID = " + id.toString() + ", with request ID: " + nxt.getRequestId());
				    			session.send(nxt, this);
				    			doNotify = false;
						}
						else 
						{
							if (log.isDebugEnabled())
								log.debug("smnpReceivedPDU: All SNMPv2 data received, processing.");
								
							//all the data has been retrieved from the MIB, so now
				    			//we must enter it into our maps.  Each map will hold all
				    			//the MIB variable values per interface.
							
							/* DEBUG ONLY
							if (log.isDebugEnabled())
							{
								// Dump content of tempStorage
								for (int x=0; x<m_responses; x++)
								{	
									log.debug("snmpReceivedPdu: tempStorage[" + x + "] oid: " + tempStorage[x].getName().toString());
								}
								log.debug("snmpReceivedPdu: done dumping temp storage!!!");
	
							}
							*/
	
							// 
							// Create an IfXTableEntry for each interface using the variable
							// names and values stored in the temporary storage array.
							//
							// Unlike the ifTable, the ifXTable doesn't have the benefit of the 
							// ifIndex object...so use the variable name of the first ifXTableEntry
							// (ifName) to derive the ifIndex as each interface is processed.
							// The last decimal value (the instance id) in the variable name will be 
							// extracted and used as the ifIndex for the interface.  For example, given
							// a variable name of '.1.3.6.1.2.1.31.1.1.1.5', the last decimal value '5' 
							// is parsed out and used as the ifIndex.
							if (log.isDebugEnabled())
								log.debug("snmpReceivedPdu: processing temp storage array...");
							
				    			for (int x = 0; x < m_ifNumber; x++) 
				    			{
								SnmpVarBind[] templist = new SnmpVarBind[IfXTableEntry.NUM_OIDS];
								
								// Extract the ifIndex from the current SnmpVarBind's object id
								String from_oid = tempStorage[x].getName().toString();
								SnmpObjectId id = new SnmpObjectId(from_oid);
								int[] ids = id.getIdentifiers();
								int ifIndex = ids[ids.length-1];
								
								//parse each oid to get index
								int tempcount = 0;
								
								for (int j = 0; j < m_responses && tempcount<IfXTableEntry.NUM_OIDS; j++) 
								{
					    				// Extract the "instance" id from the current SnmpVarBind's object id
									from_oid = tempStorage[j].getName().toString();
									id = new SnmpObjectId(from_oid);
									ids = id.getIdentifiers();
									int instance_id = ids[ids.length-1];
									
									//if the indexes match, store it within templist
									if (instance_id == ifIndex) 
									{
						    				templist[tempcount++] = tempStorage[j];
									}
								}
					
								//create VarBind list from templist.  
								SnmpVarBind[] vblist = new SnmpVarBind[tempcount];
								for (int a = 0; a < tempcount; a++) 
								{
									/* DEBUG
									if (log.isDebugEnabled())
					    					log.debug("snmpReceivedPdu: oid = " + templist[a].getName().toString() + " value = " + templist[a].getValue().toString());
									*/
					    				vblist[a] = templist[a];    
								}
					
								//create new IfXTableEntry with all variables for a 
								//particular index.
								IfXTableEntry ent = new IfXTableEntry(vblist);
								m_entries.add(ent);
				    			} // end for()
						}
					} // end if (!m_error)
			    	} // end if (m_version == SnmpSMI.SNMPV2)
			    
			    	// Handle SNMPv1 GetNext responses
			    	else if (m_version == SnmpSMI.SNMPV1) 
			    	{
					if (log.isDebugEnabled())
						log.debug("snmpReceivedPdu: Handling GETNEXT packet, response count: " + m_responses);
					
					//if the response count is less than the number of interfaces, continue to
					//store info and generate packets for gathering data.
					if (m_responses < m_ifNumber) 
					{
				    		SnmpVarBind[] vblist = pdu.toVarBindArray();
				    		IfXTableEntry ent = new IfXTableEntry(vblist);
				    		m_entries.add(ent);
				    
				    		SnmpPduRequest nxt = new SnmpPduRequest(SnmpPduPacket.GETNEXT);
					    	for(int x = 0; x < pdu.getLength(); x++)
						{
						    	nxt.addVarBind(new SnmpVarBind(pdu.getVarBindAt(x).getName()));
						}
					    	nxt.setRequestId(SnmpPduPacket.nextSequence());
					    	session.send(nxt, this);
					    	doNotify = false;
					    	m_responses++;
					}
			    	} // end if (m_version == SnmpSMI.SNMPV1
			} // end if (errStatus != SnmpPduPacket.ErrNoError)
		} // end if (command != SnmpPduPacket.RESPONSE) 
		
		//
		// call the notifyAll() method on self, and 
		// the signalAll() method on the signaler
		//
		if(doNotify)
		{
			synchronized(this)
			{
				notifyAll();
			}
			if(m_signal != null)
			{
				synchronized(m_signal)
				{
					m_signal.signalAll();
				}
			}
		}
	}

