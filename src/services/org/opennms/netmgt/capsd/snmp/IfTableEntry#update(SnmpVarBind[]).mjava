	/**
	 * <P>This method is used to update the map
	 * with the current information from the agent.
	 * The array of variables should be all the
	 * elements in the interfaces row.</P>
	 *
	 * </P>This does not clear out any column in the
	 * actual ifEntry row that does not have a definition.</P>
	 *
	 * @param vars	The variables in the interface row.
	 *
	 */
	public void update(SnmpVarBind[] vars)
	{
		//
		// iterate through the variable bindings
		// and set the members appropiately.
		//
		// Note: the creation of the snmp object id
		// is in the outer loop to limit the times a
		// new object is created.
		//
		for(int x = 0; x < ms_elemList.length; x++)
		{
			SnmpObjectId id = new SnmpObjectId(ms_elemList[x].getOid());
			for(int y = 0; y < vars.length; y++)
			{
			    	if(id.isRootOf(vars[y].getName()))
				{
					try 
					{
						//
						// Retrieve the class object of the expected SNMP data type for this element
						//
						Class classObj = ms_elemList[x].getTypeClass();
						
						//
						// If the SnmpSyntax object matches the expected class 
						// then store it in the map. Else, store a null pointer
						// in the map.
						//
						if (classObj.isInstance(vars[y].getValue()))
						{
							put(ms_elemList[x].getAlias(), vars[y].getValue());
							put(ms_elemList[x].getOid(), vars[y].getValue());
						}
						else
						{
							put(ms_elemList[x].getAlias(), null);
							put(ms_elemList[x].getOid(), null);
						}
					}
					catch (ClassNotFoundException e)
					{
						Category log = ThreadCategory.getInstance(getClass());
						log.error("Failed retrieving SNMP type class for element: " + ms_elemList[x].getAlias(), e);
					}
					catch (NullPointerException e)
					{
						Category log = ThreadCategory.getInstance(getClass());
						log.error("Invalid reference", e);
					}
				}
			}
		}
	}

