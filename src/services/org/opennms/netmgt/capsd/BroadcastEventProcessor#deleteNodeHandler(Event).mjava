        /** 
	 * This method handles the deletion of a node.
         * <pre>1. removing the node specified in the deleteNode event from the database.
         * 2. delete all IP addresses associated with this node from the database.
         * 3. delete all services being polled from this node from the database
         * 4. issue an nodeDeleted event so that this node will be removed from the 
         *    Poller's pollable node map, and all the servies polling from this node 
         *    shall be stopped.
         * 5. delete all info associated with this node from the database, such as
         *    notifications, events, outages etc.</pre>
         */
	private void deleteNodeHandler(Event event)
	{
		Category log = ThreadCategory.getInstance(getClass());
                String sourceUei = event.getUei();
                
		// Extract node label and transaction No. from the event parms
		String nodeLabel = null;
                long txNo = -1L;
                
		String transaction = null;
		Parms parms = event.getParms();
		int nodeid = (int)event.getNodeid();

		if (nodeid < 1)
			nodeid = -1;

		if (parms != null)
		{
			String parmName = null;
			Value parmValue = null;
			String parmContent = null;
		
			Enumeration parmEnum = parms.enumerateParm();
			while(parmEnum.hasMoreElements())
			{
				Parm parm = (Parm)parmEnum.nextElement();
				parmName  = parm.getParmName();
				parmValue = parm.getValue();
				if (parmValue == null)
					continue;
				else 
					parmContent = parmValue.getContent();
	
				//  get node label
				if (parmName.equals(EventConstants.PARM_NODE_LABEL))
				{
					nodeLabel = parmContent;
				}
				else if (parmName.equals(EventConstants.PARM_TRANSACTION_NO))
                                {
                                        transaction = parmContent;
		                        if (log.isDebugEnabled())
			                        log.debug("deleteNodeHandler:  parmName: " + parmName
                                                        + " /parmContent: " + parmContent);
					if (!transaction.equals("webUI"))
					{
                                        	try
                                        	{
                                                	txNo = Long.valueOf(transaction).longValue();
                                        	}
                                        	catch (NumberFormatException nfe)
                                        	{
                                                	log.warn("deleteNodeHandler: Parameter " + EventConstants.PARM_TRANSACTION_NO 
                                                      	 	 + " cannot be non-numeric", nfe);
                                                	txNo = -1L;
                                        	}
                                	}
                                }
						
			}
		}
                
                boolean invalidParameters = (nodeLabel == null);
                if (m_xmlrpc)
                        invalidParameters = invalidParameters || (txNo == -1L);
                        
		if ((invalidParameters) && (!transaction.equals("webUI")))
                {
		        if (log.isDebugEnabled())
		                log.debug("deleteNodeHandler:  Invalid parameters." );
                                
                        if (m_xmlrpc)
                        {
                                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                        "Invalid parameters", status, "OpenNMS.Capsd");
                        }
                        
			return;
		}
                
		if (log.isDebugEnabled())
			log.debug("deleteNodeHandler: deleting node: " + nodeLabel);
		
                java.sql.Connection dbConn = null;
		PreparedStatement stmt = null;
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();
		        
                        // First, verify if the node exists in database, and retrieve
                        // nodeid if exists.

			if (nodeid == -1)
			{
				stmt = dbConn.prepareStatement(SQL_QUERY_NODE_EXIST);
	
				stmt.setString(1, nodeLabel);
                        
				ResultSet rs = stmt.executeQuery();
				while(rs.next())
				{
                                	nodeid = rs.getInt(1);
                        	}
		        
                        	if (nodeid == -1)  // Sanity check
		        	{
			        	log.error("DeleteNode: There is no node with node label: " + nodeLabel + " exists in the database.");
                                	int status = EventConstants.XMLRPC_NOTIFY_SUCCESS;
                                	XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                        	"Node does not exist in the database", status, "OpenNMS.Capsd");
			        	return;
		        	}
			}
		
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: Starting delete of nodeid: " + nodeid);

			// We need to send a serviceDeletedEvent before we blow away the database so that
			// RTC can update the categories.

			stmt = dbConn.prepareStatement(SQL_FIND_SERVICES_ON_NODE);
			stmt.setInt(1, nodeid);
			ResultSet rs = stmt.executeQuery();
			while (rs.next())
			{
				String iface = rs.getString(1);
				String svcname = rs.getString(2);
				sendServiceDeletedEvent(nodeid, iface, svcname);
			}
                
	                // Deleting all the userNotified info associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_USERSNOTIFIED_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all usersNotified info on  nodeid: " + nodeid);

	                // Deleting all the notifications associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_NOTIFICATIONS_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all notifications on  nodeid: " + nodeid);

	                // Deleting all the outages associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_OUTAGES_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all outages on  nodeid: " + nodeid);

	                // Deleting all the events associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_EVENTS_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all events on  nodeid: " + nodeid);

	                // Deleting all the ifservices associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_IFSERVICES_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all ifservices on  nodeid: " + nodeid);

	                // Deleting all the ipaddresses associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_ALL_INTERFACES_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
                        {
				log.debug("deleteNodeHandler: deleted all ipaddresses on  nodeid: " + nodeid);
                        
			}
	                
	                // Deleting all the snmpInterfaces associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_SNMPINTERFACE_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all snmpinterfaces on  nodeid: " + nodeid);
                        
	                // Deleting all the assets associated with the nodeid
			stmt = dbConn.prepareStatement(SQL_DELETE_ASSETS_ON_NODE);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted all assets on  nodeid: " + nodeid);
                        
                        // Deleting the node from the database 
			stmt = dbConn.prepareStatement(SQL_DELETE_NODEID);
			stmt.setInt(1, nodeid);
			stmt.executeUpdate();
			if (log.isDebugEnabled())
				log.debug("deleteNodeHandler: deleted the node with node label: " + nodeLabel);
                        
                        // Create a nodeDeleted event and send it to eventd, this new event will remove all
                        // the services and interfaces associated with the specified node from the pollable
                        // node list, so the poller will stop to poll any service on this node.
                        createAndSendNodeDeletedEvent(nodeid, event.getHost(), nodeLabel, txNo, sourceUei);
                        if (m_xmlrpc)
                        {
                                int status = EventConstants.XMLRPC_NOTIFY_SUCCESS;
                                String message = new String("Successfully deleted node with node label: ")  + nodeLabel;
                                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, message, 
                                        status, "OpenNMS.Capsd"); 
                        }

                }
		catch(SQLException sqlE)
		{
			log.error("SQLException during add node and ipaddress to tables", sqlE);
                        if (m_xmlrpc)
                        {
                                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                        sqlE.getMessage(), status, "OpenNMS.Capsd"); 
                        }
		}
		finally
		{
			// close the statement
			if (stmt != null)
				try { stmt.close(); } catch(SQLException sqlE) { };

			// close the connection
			if (dbConn != null)
				try { dbConn.close(); } catch(SQLException sqlE) { };					
		}
                
	}

