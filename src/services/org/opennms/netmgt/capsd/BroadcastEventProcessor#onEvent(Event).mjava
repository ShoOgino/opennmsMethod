	/**
	 * This method is invoked by the EventIpcManager
	 * when a new event is available for processing. Currently
	 * only text based messages are processed by this callback.
	 * Each message is examined for its Universal Event Identifier
	 * and the appropriate action is taking based on each UEI.
	 *
	 * @param event	The event.
	 */
	public void onEvent(Event event)
	{
		Category log = ThreadCategory.getInstance(getClass());

		String eventUei = event.getUei();
		if (eventUei == null)
		{
			return;
		}
		
		if (log.isDebugEnabled())
		{
			log.debug("Received event: " + eventUei);
		}

		if(eventUei.equals(EventConstants.NEW_SUSPECT_INTERFACE_EVENT_UEI))
		{
			// new poll event
			try
			{
				if (log.isDebugEnabled())
				{
					log.debug("onMessage: Adding interface to suspectInterface Q: " + event.getInterface());
				}
				m_suspectQ.add(new SuspectEventProcessor(event.getInterface()));
			}
			catch(Exception ex)
			{
				log.error("onMessage: Failed to add interface to suspect queue", ex);
			}
		}
		else if(eventUei.equals(EventConstants.FORCE_RESCAN_EVENT_UEI))
		{
			// If the event has a node identifier use it otherwise
			// will need to use the interface to lookup the node id
			// from the database
			int nodeid = -1;
			
			if (event.hasNodeid())
				nodeid = (int)event.getNodeid();
			else
			{
				// Extract interface from the event and use it to
				// lookup the node identifier associated with the 
				// interface from the database.
				//
			
				// Get database connection and retrieve nodeid
				Connection dbc = null;
				PreparedStatement stmt = null;
				ResultSet rs = null;
				try
				{
					dbc = DatabaseConnectionFactory.getInstance().getConnection();
				
					// Retrieve node id
					stmt = dbc.prepareStatement(SQL_RETRIEVE_NODEID);
					stmt.setString(1, event.getInterface());
					rs = stmt.executeQuery();
					if (rs.next())
					{
						nodeid = rs.getInt(1);
					}
				}
				catch (SQLException sqlE)
				{
					log.error("onMessage: Database error during nodeid retrieval for interface " + event.getInterface(), sqlE);
				}
				finally	
				{
					// Close the prepared statement
					if (stmt != null)
					{
						try
						{
							stmt.close();
						}
						catch (SQLException sqlE)
						{
							// Ignore
						}
					}
				
					// Close the connection
					if (dbc != null)
					{
						try
						{
							dbc.close();
						}
						catch (SQLException sqlE)
						{
							// Ignore
						}
					}
				}
			
				if (nodeid == -1)
				{
					log.error("onMessage: Nodeid retrieval for interface " + event.getInterface() + " failed.  Unable to perform rescan.");
					return;
				}
			}
			
			// Rescan the node.  
			m_scheduler.forceRescan(nodeid);
		}
		else if(eventUei.equals(EventConstants.NODE_ADDED_EVENT_UEI))
		{
			// Schedule the new node.
			try
			{
				m_scheduler.scheduleNode((int)event.getNodeid());
			}
			catch(SQLException sqlE)
			{
				log.error("onMessage: SQL exception while attempting to schedule node " + event.getNodeid(), sqlE);
			}
		}
		else if(eventUei.equals(EventConstants.NODE_DELETED_EVENT_UEI))
		{
			// Remove the deleted node from the scheduler
			m_scheduler.unscheduleNode((int)event.getNodeid());
		}
		else if(eventUei.equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI))
		{
			// Remove the deleted node from the scheduler
			m_scheduler.unscheduleNode((int)event.getNodeid());
		}
	} // end onEvent()

