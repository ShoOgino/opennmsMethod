	/**
	 * <P>Test to see if the passed host-port pair is the 
	 * endpoint for a TCP server. If there is a TCP server
	 * at that destination then a value of true is returned
	 * from the method. Otherwise a false value is returned 
	 * to the caller.  In order to return true the remote host
	 * must generate a banner line which contains the text from
	 * the bannerMatch argument.</P>
	 *
	 * @param host	The remote host to connect to.
	 * @param port 	The remote port on the host.
	 * @param bannerMatch	Banner line generated by the remote host must contain this text.
	 *
	 * @return True if a connection is established with the host and the banner line
	 *		contains the bannerMatch text.
	 */
	private boolean isServer(InetAddress host, int port, int retries, int timeout, RE regex, StringBuffer bannerResult)
	{
		Category log = ThreadCategory.getInstance(getClass());

		boolean isAServer = false;
		for (int attempts=0; attempts <= retries && !isAServer; attempts++)
		{
                        SocketChannel sChannel = null;
			try
			{
				// create a connected socket
				//
                                sChannel = SocketChannelUtil.getConnectedSocketChannel(host, port, timeout);
                                if (sChannel == null)
                                {
                                        log.debug("TcpPlugin: did not connect to host within timeout: " + timeout +" attempt: " + attempts);
                                        continue;
                                }
                                log.debug("TcpPlugin: connected to host: " + host + " on port: " + port);

			
				// If banner matching string is null or wildcard ("*") then we 
				// only need to test connectivity and we've got that!
				//
				if (regex == null)
				{
					isAServer = true;
				}
				else
				{
					// get a line reader
					//
	                                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(sChannel.socket().getInputStream()));

				
					// Read the server's banner line ouptput and validate it against
					// the bannerMatch parameter to determine if this interface supports the service.
					//
					String response = lineRdr.readLine();
					if(regex.match(response))
					{
						if (log.isDebugEnabled())
							log.debug("isServer: matching response=" + response);
						isAServer = true;
						if(bannerResult != null)
							bannerResult.append(response);
					}
					else
					{
						// Got a response but it didn't match...no need to
						// attempt retries
						isAServer=false;
						if (log.isDebugEnabled())
							log.debug("isServer: NON-matching response=" + response);
						break;
					}
				}
			}
			catch(ConnectException e)
			{
				// Connection refused!!  No need to perform retries.
				//
				log.debug("TcpPlugin: Connection refused to " + host.getHostAddress() + ":" + port);
				isAServer = false;
				break;
			}
			catch(NoRouteToHostException e)
			{
				// No Route to host!!!
				//
				e.fillInStackTrace();
				log.info("TcpPlugin: Could not connect to host " + host.getHostAddress() + ", no route to host", e);
				isAServer = false;
				throw new UndeclaredThrowableException(e);
			}
			catch(InterruptedIOException e)
			{
				// This is an expected exception
				//
				isAServer = false;
			}
			catch(IOException e)
			{
				log.info("TcpPlugin: An expected I/O exception occured connecting to host " + host.getHostAddress() + " on port " + port, e);
				isAServer = false;
			}
			catch(Throwable t)
			{
				isAServer = false;
				log.warn("TcpPlugin: An undeclared throwable exception was caught connecting to host " + host.getHostAddress()
					 + " on port " + port, t);
			}
			finally
			{
				try
				{
                                        if(sChannel != null)
                                                sChannel.close();
				}
				catch(IOException e) { }
			}
		}

		//
		// return the success/failure of this
		// attempt to contact an ftp server.
		//
		return isAServer;
	}

