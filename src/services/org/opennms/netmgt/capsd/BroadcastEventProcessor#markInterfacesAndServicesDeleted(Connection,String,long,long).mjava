    /**
     * Marks all the interfaces and services for a given node deleted and constructs events for
     * each. The order of events is significant representing the hierarchy, service events
     * preceed the event for the interface the service is on
     * 
     * @param dbConn
     *            the database connection
     * @param source
     *            the source for use in the constructed events
     * @param nodeId
     *            the node whose interfaces and services are to be deleted
     * @param txNo
     *            a transaction number to associate with this deletion
     * @return a List of events indicating which nodes and services have been deleted
     * 
     * @throws SQLException
     */
    private List markInterfacesAndServicesDeleted(Connection dbConn, String source, long nodeId, long txNo) throws SQLException {
        Category log = ThreadCategory.getInstance(getClass());
        List eventsToSend = new LinkedList();

        // The following query takes a nodeid and produces a table of (ipaddr, interface
        // status, serviceid, service status) tuples
        // 
        //  - Interfaces that are not marked deleted and with services that are not marked
        // deleted have fully filled out
        //    columns
        //  - Interfaces that have no services or whose services are already marked deleted are
        // in the table with NULL in the
        //    serviceid and service status columns.
        //  - Interfaces that have been marked deleted but have undeleted services will be fully
        // filled out in the table
        //    but will have a 'D' in the interface status column
        //  - Interfaces that have been marked deleted and have no services or have only
        // services that have been marked deleted
        //    do not show up in the table.
        //
        // This table is ordered by ipAddr, serviceid

        final String DB_FIND_IFS_AND_SVCS_FOR_NODE = "SELECT ipinterface.ipaddr, ipinterface.ismanaged, service.servicename, ifservices.serviceid, ifservices.status "
                + "FROM ipinterface LEFT OUTER JOIN ifservices "
                + "ON (ipinterface.nodeid = ifservices.nodeid AND ipinterface.ipaddr = ifservices.ipaddr AND ifservices.status != 'D') "
                + "LEFT OUTER JOIN service ON (ifservices.serviceid = service.serviceid) "
                + "WHERE ipinterface.nodeId = ? AND (ifservices.serviceid is not null or ipinterface.ismanaged != 'D') "
                + "ORDER BY ipinterface.ipaddr, ifservices.serviceid";

        PreparedStatement stmt = dbConn
                .prepareStatement(DB_FIND_IFS_AND_SVCS_FOR_NODE, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
        stmt.setLong(1, nodeId);
        ResultSet rs = stmt.executeQuery();

        String prevIpAddr = null;
        while (rs.next()) {
            String ipAddr = rs.getString(1);
            String ifStatus = rs.getString(2);

            // mark the service deleted and create a serviceDeleted event
            String serviceName = rs.getString(3);
            long serviceId = rs.getLong(4);
            if (!rs.wasNull()) { // a service for this interface exists
                rs.updateString(5, "D");
                if (serviceName != null)
                    eventsToSend.add(EventUtils.createServiceDeletedEvent(source, nodeId, ipAddr, serviceName, txNo));
                else
                    log.error("found a service id " + serviceId + " with no correspondonding serviceName");
            }

            // only process interfaces that are not already deleted.
            if (!"D".equals(ifStatus)) {
                // update the status in the table
                // DAVE: look here
                rs.updateString(2, "D");

                // if the ipAddr is different from the previous row then we have a new
                // ipAddr so send the event from the lastRow
                if (!ipAddr.equals(prevIpAddr)) {
                    if (prevIpAddr != null) {
                        eventsToSend.add(EventUtils.createInterfaceDeletedEvent(source, nodeId, prevIpAddr, txNo));
                    }
                    prevIpAddr = ipAddr;
                }
            }

            rs.updateRow();
        }

        if (prevIpAddr != null) {
            eventsToSend.add(EventUtils.createInterfaceDeletedEvent(source, nodeId, prevIpAddr, txNo));
        }

        if (log.isDebugEnabled()) log.debug("markServicesDeleted: marked service deleted: " + nodeId);

        rs.close();
        stmt.close();

        return eventsToSend;
    }

