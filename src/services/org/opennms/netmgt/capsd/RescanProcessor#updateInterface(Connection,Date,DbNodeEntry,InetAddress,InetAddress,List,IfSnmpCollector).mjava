	/**
	 * This method is responsible for updating the ipInterface table entry
	 * for a specific interface.
	 *
	 * @param dbc		Database Connection
	 * @param now		Date/time to be associated with the update.
	 * @param node		Node entry for the node being rescanned
	 * @param target 	Target interface (from IfCollector.getTarget())
	 * @param ifaddr	Interface being updated.
	 * @param protocols	Protocols supported by the interface.
	 * @param snmpc		SNMP collector or null if SNMP not supported.
	 * 
	 * @throws SQLException if there is a problem updating the ipInterface table.
	 */
	private void updateInterface(Connection  dbc,
				     Date        now,
				     DbNodeEntry node,
				     InetAddress target,
				     InetAddress ifaddr,
				     List	 protocols,
				     IfSnmpCollector snmpc)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		CapsdConfigFactory cFactory = CapsdConfigFactory.getInstance();
		PollerConfigFactory pollerCfgFactory = PollerConfigFactory.getInstance();

		if (log.isDebugEnabled())
		{
			log.debug("updateInterface: updating interface " + ifaddr.getHostAddress() + "(targetIf=" + target.getHostAddress() + ")");
		}
				
		boolean isAlias = false;
		boolean reparentFlag = false;
		
		DbNodeEntry duplicateNodeEntry = null;
		boolean deleteDuplicateNodeFlag = false;
		
		// Attempt to load IP Interface entry from the database
		//
		DbIpInterfaceEntry dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);
		if (dbIpIfEntry == null)
		{
			//
			// Reparenting
			//
			// This sub-interface was not previously associated with this node.  If 
			// the sub-interface is already associated with another node we must do 
			// one of the following:
			//
			// 1. If the target interface (the one being rescanned) appears to be an 
			//    interface alias all of the interfaces under the sub-interface's node 
			//    will be reparented under the nodeid of the target interface.
			//
			// 2. If however the interface is not an alias, only the sub-interface will
			//    be reparented under the nodeid of the interface being rescanned.
			//
			// In the reparenting process, the database ipinterface, snmpinterface
			// and ifservices table entries associated with the reparented interface
			// will be "updated" to reflect the new nodeid.  If the old node has 
			// no remaining interfaces following the reparenting it will be marked 
			// as deleted.
			//
			
			// Special case:  Need to skip interface reparenting for '0.0.0.0' 
			// interfaces as well as loopback interfaces ('127.*.*.*').
			int oldNodeId = -1;
			if (!ifaddr.getHostAddress().equals("0.0.0.0") && 
				!ifaddr.getHostAddress().startsWith("127.")) 
			{
				oldNodeId = cFactory.getInterfaceDbNodeId(dbc, ifaddr);
			}
			else
			{
				if (log.isDebugEnabled())
					log.debug("updateInterface: interface " + ifaddr.getHostAddress() + " is NOT eligible for reparenting.");
			}
				
			if (oldNodeId != -1)
			{
				if (log.isDebugEnabled())
					log.debug("updateInterface: interface " + ifaddr.getHostAddress() + " is however under nodeid " + oldNodeId);

				// Determine if target interface is an alias or not?
				isAlias = isInterfaceAlias(target, snmpc); 
				if (isAlias)
				{

                                        // the target interface is not exist in the ipAddrTable of this node.
                                        // Do nothing
					if (log.isDebugEnabled())
						log.debug("updateInterface: target interface " + ifaddr.getHostAddress() + " is an alias, reparenting all interfaces from node " + oldNodeId + " to node " + node.getNodeId());
						
					// Its an alias, move all the interfaces associated with the 
					// sub-interface's nodeid under the target's nodeid
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
					if (duplicateNodeEntry != null)
					{
						// Retrieve list of interfaces associated with the old node
						DbIpInterfaceEntry[] tmpIfArray = duplicateNodeEntry.getInterfaces(dbc);
						
						// Reparent each interface under the targets' nodeid 
						for (int i=0; i<tmpIfArray.length; i++)
						{
							InetAddress addr = tmpIfArray[i].getIfAddress();
							int ifIndex = tmpIfArray[i].getIfIndex();
							
							// Skip non-IP or loopback interfaces
							if (!addr.getHostAddress().equals("0.0.0.0") && 
								!addr.getHostAddress().startsWith("127.")) 
							{
								continue;
							}
							
							if (log.isDebugEnabled())
								log.debug("updateInterface: reparenting interface " + tmpIfArray[i].getIfAddress().getHostAddress() + " under node " + node.getNodeId());
								
							reparentInterface(dbc, addr, ifIndex, node.getNodeId(), oldNodeId);
							
							// Create interfaceReparented event
							createInterfaceReparentedEvent(node, oldNodeId, addr);
						}
					}
					
					// Set reparent flag
					reparentFlag = true;
				}
				else
				{
                                        // 
                                        // target interface is not an alias. Check if the updating interface
                                        // exists in the ipAddrTable of the oldNode. If it is not in the old 
                                        // node, reparent the interface to the new node. Otherwise, it is a
                                        // duplicate interface, and add it to the new node and create an 
                                        // interfaceAdded event and duplicateInterface event.
                                        //
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
					if (duplicateNodeEntry != null)
        				{
                                                if (isInIpAddrTable(ifaddr, duplicateNodeEntry))
                                                {
                                                        addDuplicateInterface(node, ifaddr, protocols, snmpc);
                                                }
                                                else
                                                {
        					        // 
        					        // It is not in the ipAddrTable of the oldNodeId, issue SQL update to 
                                                        // move the sub-interface and its services under its new parent node
        					        //
        					        if (log.isDebugEnabled())
                						log.debug("updateInterface: target interface " 
                                                                        + ifaddr.getHostAddress() 
                                                                        + " is not exist on nodeID: " + oldNodeId 
                                                                        +". Reparenting " + ifaddr.getHostAddress() 
                                                                        + " under nodeid " + node.getNodeId());
                						
                					// Get ifindex for this address
                					int ifIndex = -1;
                					if (snmpc != null && !snmpc.failed() && snmpc.hasIpAddrTable())
                					{
                						ifIndex = IpAddrTable.getIfIndex(snmpc.getIpAddrTable().getEntries(), 
                                                                                                 ifaddr.getHostAddress());
                					}
                					if (log.isDebugEnabled())
                						log.debug("updateInterface: interface " + ifaddr.getHostAddress() 
                                                                        + " has ifIndex " + ifIndex);
                					
                					reparentInterface(dbc, ifaddr, ifIndex, node.getNodeId(), oldNodeId);
                					
                					// Create interfaceReparented event
                					createInterfaceReparentedEvent(node, oldNodeId, ifaddr);
                					
                					// Set reparent flag
                					reparentFlag = true;
                                                }
                                        }
				}
				
				// Delete the old node id if it has no additional IP interfaces
				// under it...non-IP interfaces do not count as they are only 
				// discoverable via SNMP.
				//
				if (duplicateNodeEntry == null)
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
				
				if (duplicateNodeEntry != null)
				{
					DbIpInterfaceEntry[] duplicateNodeInterfaces = duplicateNodeEntry.getInterfaces(dbc);
					
					if (log.isDebugEnabled())
						log.debug("updateInterface: checking if there are any remaining IP interfaces for this dup node.");
					
					// Determine IP interface count remaining under this node
					int ipCount = 0;
					int nonIpCount = 0;
					for (int ii=0; ii<duplicateNodeInterfaces.length; ii++)
					{
						InetAddress addr = duplicateNodeInterfaces[ii].getIfAddress();
						if (log.isDebugEnabled())
							log.debug("updateInterface: remaining interface address: " + addr.getHostAddress());
						
						// Increment count if address is not "0.0.0.0" and
						// is not a loopback address
						if (!addr.getHostAddress().equals("0.0.0.0") && 
							!addr.getHostAddress().startsWith("127.")) 
						{
							ipCount ++;
						}
						else
						{
							nonIpCount ++;
						}
					}
					if (log.isDebugEnabled())
						log.debug("updateInterface: ipCount=" + ipCount + " nonIpCount=" + nonIpCount);
					
					// If no IP interfaces left we can delete the old
					// node entry
					if (ipCount == 0)
					{
						if (log.isDebugEnabled())
							log.debug("updateInterface: old nodeid " + oldNodeId + " has no IP interfaces associated with it, deleting...");
						
						// If any non IP interface entries remain we must
						// first mark them as deleted.
						if (nonIpCount > 0)
						{
							if (log.isDebugEnabled())
								log.debug("updateInterface: dup nodeid " + oldNodeId + " has at least one non-IP interface associated with it, deleting all non-IP interfaces...");
							
							for (int ii=0; ii<duplicateNodeInterfaces.length; ii++)
							{
								if (log.isDebugEnabled())
									log.debug("updateInterface: deleting non-IP interface with ifIndex " + duplicateNodeInterfaces[ii].getIfIndex() + " from dup node " + oldNodeId);
								duplicateNodeInterfaces[ii].setManagedState(DbIpInterfaceEntry.STATE_DELETED);
								duplicateNodeInterfaces[ii].store(dbc);
							}
						}
						
						// Delete any remaining snmpInterface table entries
						if (log.isDebugEnabled())
							log.debug("updateInterface: deleting any remaining snmpInterface table entries for old node " + oldNodeId);
						PreparedStatement delete = dbc.prepareStatement("DELETE FROM snmpinterface WHERE nodeid=?");
						try
						{
							delete.setInt(1, oldNodeId);
							delete.executeUpdate();
						}
						finally
						{
							try 
							{
								delete.close();
							}
							catch (SQLException e)
							{
								// Do nothing
							}
						}
						
						// Now mark the node as deleted
						duplicateNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_DELETED);
						duplicateNodeEntry.store(dbc);
						deleteDuplicateNodeFlag = true;
					}
				}
			}
		}

		//
		// IMPORTANT:  Notice that from here on event if the target interface was
		// an alias resulting in the reparenting of multiple interfaces under the
		// target interface's node, we only actually update the current sub-interface.
		// This is ok because this method, updateInterface() should be called 
		// for each sub-interface retrieved via SNMP...and these interfaces no
		// longer need to be reparented so they will be updated as normal.
		boolean newIpIfEntry = false;
		if (reparentFlag)
		{
			// Interface was reparented, now we can load its interface entry
			dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);
		}
		else if (dbIpIfEntry == null)
		{
			// Interface not found with this nodeId so create new interface entry
			if (log.isDebugEnabled())
				log.debug("updateInterface: interface " + ifaddr + " not in database under nodeid " + node.getNodeId() + ", creating new interface object.");
			dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
			newIpIfEntry = true;
		}
		
		// Clone the existing database entry so we have access to the values
		// of the database fields associated with the interface in the event
		// that something has changed.
		DbIpInterfaceEntry originalIpIfEntry = DbIpInterfaceEntry.clone(dbIpIfEntry);
		
		// Create IP interface entry representing latest information
		// retrieved for the interface via the collector
		//
		DbIpInterfaceEntry currIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
			
		// Hostname
		currIpIfEntry.setHostname(ifaddr.getHostName());
			
		// Managed state
		// NOTE: (reference internal bug# 201)
		// If the ip is 'managed', it might still be 'not polled' based
		// on the poller configuration.
		//
		// Try to avoid re-evaluating the ip against filters for
		// each service, try to get the first package here and use
		// that for service evaluation
		//
		// At this point the ip is already/ in the database, so package filter
		// evaluation should go through OK
		//
		org.opennms.netmgt.config.poller.Package ipPkg = null;

		if(cFactory.isAddressUnmanaged(ifaddr))
			currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
		else
		{
			boolean ipToBePolled = false;
			ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
			if (ipPkg != null)
				ipToBePolled = true;

			if (ipToBePolled)
				currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);
			else
				currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
		}
		
		// If SNMP data collection is available set SNMP Primary state 
		// as well as ifIndex and ifStatus.  Also retrieve ifType (loopback
		// interfaces will be skipped).
		//
		int ifType = -1;
		if (snmpc != null && !snmpc.failed())
		{	
			int ifIndex = snmpc.getIfIndex(ifaddr);
			if(ifIndex != -1)
			{
				currIpIfEntry.setIfIndex(ifIndex);
				int status = snmpc.getAdminStatus(ifIndex);
				currIpIfEntry.setStatus(status);
				ifType = snmpc.getIfType(ifIndex);
				
				// For new interfaces simply set 'isSnmpPrimary' field to secondary for now.  
				// Following the interface updates the primary SNMP interface will be determined
				// and the value of the 'isSnmpPrimary' field set to 'P' (primary) for that
				// interface.
				if (newIpIfEntry)
					currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
				else
					currIpIfEntry.setPrimaryState(originalIpIfEntry.getPrimaryState());
			}
			else
			{
				// No ifIndex found so set primary state to NOT_ELIGIBLE
				currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
			}
		}
		
		// Update any fields which have changed
		dbIpIfEntry.setLastPoll(now);
		dbIpIfEntry.updateHostname(currIpIfEntry.getHostname());
		dbIpIfEntry.updateManagedState(currIpIfEntry.getManagedState());
		dbIpIfEntry.updateStatus(currIpIfEntry.getStatus());
		dbIpIfEntry.updatePrimaryState(currIpIfEntry.getPrimaryState());
		dbIpIfEntry.updateIfIndex(currIpIfEntry.getIfIndex());
			
		// Set event flags
		// NOTE:  Must set these flags prior to call to DbIpInterfaceEntry.store()
		// method which will cause the change map to be cleared.
		boolean ifIndexChangedFlag = false;
		boolean ipHostnameChangedFlag = false;
		
		if (dbIpIfEntry.hasIfIndexChanged())
			ifIndexChangedFlag = true;
		
		if (dbIpIfEntry.hasHostnameChanged())
			ipHostnameChangedFlag = true;
		
		// Update the database
		dbIpIfEntry.store(dbc);

		// If the interface was not already in the database under 
		// the node being rescanned or some other node send a
		// nodeGainedInterface event.
		if (newIpIfEntry && !reparentFlag)
		{
			createNodeGainedInterfaceEvent(dbIpIfEntry);
		}
		// If an interface has been reparented send associated events
		else if (reparentFlag)
		{
			// Duplicate node deleted?
			if (deleteDuplicateNodeFlag)
			{
				createDuplicateNodeDeletedEvent(duplicateNodeEntry);
			}
			
			// InterfaceIndexChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: ifIndex changed: " + ifIndexChangedFlag);
			if (ifIndexChangedFlag)
			{
				createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);
				m_ifIndexOnNodeChangedFlag = true;
			}
		
			// IPHostNameChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: hostname changed: " + ipHostnameChangedFlag);
			if (ipHostnameChangedFlag)
			{
				createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);
			}
		}
		// If the interface is not new check to see if the interface's
		// ifIndex or ipHostname have changed.
		else
		{
			// InterfaceIndexChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: ifIndex changed: " + ifIndexChangedFlag);
			if (ifIndexChangedFlag)
			{
				createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);
				m_ifIndexOnNodeChangedFlag = true;
			}
		
			// IPHostNameChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: hostname changed: " + ipHostnameChangedFlag);
			if (ipHostnameChangedFlag)
			{
				createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);
			}
		}
		
		// Retrieve from the database the interface's service list
		DbIfServiceEntry[] dbSupportedServices = dbIpIfEntry.getServices(dbc);
			
		// add newly supported protocols
		//		
		// NOTE!!!!!: (reference internal bug# 201)
		// If the ip is 'managed', the service can still be 'not polled'
		// based on the poller configuration - at this point the ip is already
		// in the database, so package filter evaluation should go through OK
		//
		Iterator iproto = protocols.iterator();
		while(iproto.hasNext())
		{
			IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
			Number sid = (Number)cFactory.getServiceIdentifier(p.getProtocolName());

			// Only adding newly supported services so check against the service 
			// list retrieved from the database
			boolean found = false;
			for (int i=0; i<dbSupportedServices.length && !found; i++)
			{
				if (dbSupportedServices[i].getServiceId() == sid.intValue())
					found = true;
			}
			if (!found)
			{
				DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());

				// now fill in the entry
				//
				if(cFactory.isAddressUnmanaged(ifaddr))
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
				else 
				{
					boolean svcToBePolled = false;
					if (ipPkg != null)
					{
						svcToBePolled = pollerCfgFactory.isPolled(p.getProtocolName(), ipPkg);
						if (!svcToBePolled)
							svcToBePolled = pollerCfgFactory.isPolled(ifaddr.getHostAddress(), p.getProtocolName());
					}

					if (svcToBePolled)
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
					else
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
				}
				
				// Set qualifier if available.  Currently the qualifier field
				// is used to store the port at which the protocol was found.
				//
				if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
				{
					try
					{
						Integer port = (Integer)p.getQualifiers().get("port");
						if (log.isDebugEnabled())
							log.debug("addInterfaces: got a port qualifier: " + port);
						ifSvcEntry.setQualifier(port.toString());
					}
					catch (ClassCastException ccE)
					{
						// Do nothing
					}
				}
					
				ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
				ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);
				
				int ifIndex = dbIpIfEntry.getIfIndex();
				if (ifIndex > 0)
					ifSvcEntry.setIfIndex(ifIndex);
		
				ifSvcEntry.store();
				
				// Generate nodeGainedService event
				createNodeGainedServiceEvent(node, dbIpIfEntry, p.getProtocolName());
				
				// If this interface already existed in the database and SNMP
				// service has been gained then create interfaceSupportsSNMP event
				if (!newIpIfEntry && p.getProtocolName().equalsIgnoreCase("SNMP"))
				{
					createInterfaceSupportsSNMPEvent(dbIpIfEntry);
				}
			}
		} // end while(more protocols)
		
		//
		// If SNMP info is available update the snmpInterface table entry with
		// anything that has changed.
		//		
		if (snmpc != null && !snmpc.failed() && dbIpIfEntry.getIfIndex() != -1)
		{
			if (log.isDebugEnabled())
				log.debug("updateInterface: updating snmp interface for nodeId/ifIndex=" +
					+ node.getNodeId() + "/" + dbIpIfEntry.getIfIndex());
			
			// Create and load SNMP Interface entry from the database
			//
			boolean newSnmpIfTableEntry = false;
			DbSnmpInterfaceEntry dbSnmpIfEntry = DbSnmpInterfaceEntry.get(dbc, node.getNodeId(), dbIpIfEntry.getIfIndex());
			if (dbSnmpIfEntry == null)
			{
				// SNMP Interface not found with this nodeId, create new interface
				if (log.isDebugEnabled())
					log.debug("updateInterface: SNMP interface index " + dbIpIfEntry.getIfIndex() + " not in database, creating new interface object.");
				dbSnmpIfEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), dbIpIfEntry.getIfIndex());
				newSnmpIfTableEntry = true;
			}
		
			// Create SNMP interface entry representing latest information
			// retrieved for the interface via the collector
			//
			DbSnmpInterfaceEntry currSnmpIfEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), dbIpIfEntry.getIfIndex());
			
			// Find the ifTable entry for this interface
			IfTable ift = snmpc.getIfTable();
			Iterator ifiter = ift.getEntries().iterator();
			IfTableEntry ifte = null;
			while(ifiter.hasNext())
			{
				ifte = (IfTableEntry)ifiter.next();
				
				// index
				//
				SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_INDEX);
				if(sint != null)
				{
					if (dbIpIfEntry.getIfIndex() == sint.getValue())
						break;
				}
			}
			
			// Make sure we have a valid IfTableEntry object
			if (ifte != null)
			{
				// IP address and netmask
				//
				// WARNING:  IfSnmpCollector.getIfAddressAndMask() ONLY returns
				// the FIRST IP address and mask for a given interface as specified
				// in the ipAddrTable.
				//
				InetAddress[] aaddrs = snmpc.getIfAddressAndMask(dbIpIfEntry.getIfIndex());

				// Address array should NEVER be null but just in case..
				//
				if(aaddrs == null)
				{
					log.warn("updateInterface: unable to retrieve address and netmask for nodeId/ifIndex: " +
						node.getNodeId() + "/" + dbIpIfEntry.getIfIndex());

					aaddrs = new InetAddress[2];

					// Set interface address to current interface
					aaddrs[0] = ifaddr;

					// Set netmask to NULL
					aaddrs[1] = null;
				}

				// IP address
				//
				currSnmpIfEntry.setIfAddress(aaddrs[0]);
				
				// netmask
				//
				if (aaddrs[1] != null)
				{
					if (log.isDebugEnabled()) 
						log.debug("updateInterface: interface " + aaddrs[0].getHostAddress() 
                                                        + " has netmask: " + aaddrs[1].getHostAddress());
					currSnmpIfEntry.setNetmask(aaddrs[1]);
				}
				
				// type
				//
				SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_TYPE);
				currSnmpIfEntry.setType(sint.getValue());
					
				// description
				String str = SystemGroup.getPrintableString((SnmpOctetString)ifte.get(IfTableEntry.IF_DESCR));
				if (log.isDebugEnabled())
					log.debug("updateInterface: " + ifaddr + " has ifDescription: " + str);
				if(str != null && str.length() > 0)
					currSnmpIfEntry.setDescription(str);
					
				// physical address
				StringBuffer sbuf = new StringBuffer();
				SnmpOctetString ostr = (SnmpOctetString)ifte.get(IfTableEntry.IF_PHYS_ADDR);
                                if ( ostr != null && ostr.getLength() > 0)
                                {
					byte[] bytes = ostr.getString();
					for(int i = 0; i < bytes.length; i++)
					{
						sbuf.append(Integer.toHexString(((int)bytes[i] >> 4) & 0xf));
						sbuf.append(Integer.toHexString((int)bytes[i] & 0xf));
					}
				}
				
				String physAddr = sbuf.toString().trim();
			
				if (log.isDebugEnabled())
					log.debug("updateInterface: " + ifaddr + " has phys address: -" + physAddr + "-");
				
				if (physAddr.length() == 12)
				{
					currSnmpIfEntry.setPhysicalAddress(physAddr);
				}
			
				// speed
				SnmpUInt32 uint = (SnmpUInt32)ifte.get(IfTableEntry.IF_SPEED);
				currSnmpIfEntry.setSpeed((int)uint.getValue());

				// admin status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_ADMIN_STATUS);
				currSnmpIfEntry.setAdminStatus(sint.getValue());
						
				// oper status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_OPER_STATUS);
				currSnmpIfEntry.setOperationalStatus(sint.getValue());
				
				// name (from interface extensions table)
				SnmpOctetString snmpIfName = snmpc.getIfName(dbIpIfEntry.getIfIndex());
				if (snmpIfName != null)
				{
					String ifName = SystemGroup.getPrintableString(snmpIfName);
					if (ifName!= null  && ifName.length() > 0)
						currSnmpIfEntry.setName(ifName);
				}
					
			} // end if valid ifTable entry
			
			// Update any fields which have changed
			//dbSnmpIfEntry.updateIfIndex(currSnmpIfEntry.getIfIndex());
			dbSnmpIfEntry.updateIfAddress(currSnmpIfEntry.getIfAddress());
			dbSnmpIfEntry.updateNetmask(currSnmpIfEntry.getNetmask());
			dbSnmpIfEntry.updatePhysicalAddress(currSnmpIfEntry.getPhysicalAddress());
			dbSnmpIfEntry.updateDescription(currSnmpIfEntry.getDescription());
			dbSnmpIfEntry.updateName(currSnmpIfEntry.getName());
			dbSnmpIfEntry.updateType(currSnmpIfEntry.getType());
			dbSnmpIfEntry.updateSpeed(currSnmpIfEntry.getSpeed());
			dbSnmpIfEntry.updateAdminStatus(currSnmpIfEntry.getAdminStatus());
			dbSnmpIfEntry.updateOperationalStatus(currSnmpIfEntry.getOperationalStatus());
			
			// If this is a new interface or if any of the following 
			// key fields have changed set the m_snmpIfTableChangedFlag 
			// variable to TRUE.  This will potentially trigger an event 
			// which will cause the poller to reinitialize the primary 
			// SNMP interface for the node.
			if (!m_snmpIfTableChangedFlag &&
				newSnmpIfTableEntry || 
				//dbSnmpIfEntry.hasIfIndexChanged() ||
				dbSnmpIfEntry.hasIfAddressChanged() ||
				dbSnmpIfEntry.hasTypeChanged() ||
				dbSnmpIfEntry.hasNameChanged() ||
				dbSnmpIfEntry.hasDescriptionChanged() ||
				dbSnmpIfEntry.hasPhysicalAddressChanged())
			{
				m_snmpIfTableChangedFlag = true;
			}
			
			// Update the database
			dbSnmpIfEntry.store(dbc);
		} // end if snmp info available
	}

