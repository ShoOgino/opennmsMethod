    /**
     * This method is responsble for inserting new entries into the ipInterface
     * table for each interface found to be associated with the suspect
     * interface during the capabilities scan.
     * 
     * @param dbc
     *            Database connection.
     * @param node
     *            DbNodeEntry object representing the suspect interface's parent
     *            node table entry
     * @param useExistingNode
     *            False if a new node was created for the suspect interface.
     *            True if an existing node entry was found under which the the
     *            suspect interface is to be added.
     * @param ifaddr
     *            Suspect interface
     * @param collector
     *            Interface collector containing SMB and SNMP info collected
     *            from the remote device.
     * 
     * @throws SQLException
     *             if an error occurs adding interfaces to the ipInterface
     *             table.
     */
    private void addInterfaces(Connection dbc, DbNodeEntry node, boolean useExistingNode, InetAddress ifaddr, IfCollector collector) throws SQLException {
        
        Category log = ThreadCategory.getInstance(getClass());

        CapsdConfig cFactory = CapsdConfigFactory.getInstance();
        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();

        Date now = new Date();

        DbIpInterfaceEntry ipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
        ipIfEntry.setLastPoll(now);
        ipIfEntry.setHostname(ifaddr.getHostName());

        // NOTE: (reference internal bug# 201)
        // If the ip is 'managed', it might still be 'not polled' based
        // on the poller configuration
        //
        // The package filter evaluation requires that the ip be in the
        // database - at this point the ip is NOT in db, so insert as active
        // and update afterward
        //
        // Try to avoid re-evaluating the ip against filters for
        // each service, try to get the first package here and use
        // that for service evaluation
        //

        boolean addrUnmanaged = cFactory.isAddressUnmanaged(ifaddr);
        if (addrUnmanaged)
            ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
        else
            ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

        ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

        ipIfEntry.store(dbc);

        // now update if necessary
        org.opennms.netmgt.config.poller.Package ipPkg = null;
        if (!addrUnmanaged) {
            // The newly discoveried IP addr is not in the Package IPList
            // Mapping yet, so rebuild the list.
            //
            PollerConfigFactory.getInstance().rebuildPackageIpListMap();

            boolean ipToBePolled = false;
            ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
            if (ipPkg != null)
                ipToBePolled = true;

            if (!ipToBePolled) {
                // update ismanaged to 'N' in ipinterface
                ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
                ipIfEntry.store(dbc);
            }
        }

        int ifIndex = -1;
        IfSnmpCollector snmpc = null;
        if (collector.hasSnmpCollection()) {
            snmpc = collector.getSnmpCollector();
            if (snmpc.hasIpAddrTable() && (ifIndex = snmpc.getIfIndex(ifaddr)) != -1) {
                // Just set primary state to secondary for now. The primary SNMP
                // interface won't be selected until after all interfaces have
                // been inserted into the database. This is because the interface
                // must already be in the database for filter rule evaluation to
                // succeed.

                if (snmpc.hasIfTable()) {
                    int status = snmpc.getAdminStatus(ifIndex);
                    if (status != -1)
                        ipIfEntry.setStatus(status);
                }
            } else {
                // Address does not have a valid ifIndex associated with it
                // Assume there is no ipAddrTable and set ifIndex equal to
                // CapsdConfigFactory.LAME_SNMP_HOST_IFINDEX
                ifIndex = CapsdConfigFactory.LAME_SNMP_HOST_IFINDEX;
                if (log.isDebugEnabled())
                    log.debug("SuspectEventProcessor: no valid ifIndex for " + ifaddr + " Assume this is a lame SNMP host");
            }
            ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
            if (ifIndex != -1)
                if (log.isDebugEnabled())
                    log.debug("SuspectEventProcessor: setting ifindex for " + ifaddr + " to " + ifIndex);
                ipIfEntry.setIfIndex(ifIndex);
            ipIfEntry.store(dbc);
        }

        // Add supported protocols
        addSupportedProtocols(node, ifaddr, collector.getSupportedProtocols(), addrUnmanaged, ifIndex, ipPkg);

        // If the useExistingNode flag is true, then we're done. The
        // interface is most likely an alias and the subinterfaces
        // collected via SNMP should already be in the database.
        //
        if (useExistingNode == true)
            return;

        if (snmpc != null) {

            boolean forceSnmpInterfaceEntry = true;

            // Made it this far...lets add the sub interfaces
            // 
            if (snmpc.hasIpAddrTable()) {
                Map extraTargets = collector.getAdditionalTargets();
                Iterator iter = extraTargets.keySet().iterator();
                while (iter.hasNext()) {
                    InetAddress xifaddr = (InetAddress) iter.next();

                    if (log.isDebugEnabled())
                        log.debug("addInterfaces: adding interface " + xifaddr.getHostAddress());

                    DbIpInterfaceEntry xipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), xifaddr);
                    xipIfEntry.setLastPoll(now);
                    xipIfEntry.setHostname(xifaddr.getHostName());

                    // NOTE: (reference internal bug# 201)
                    // If the ip is 'managed', it might still be 'not polled' based
                    // on the poller configuration
                    //
                    // The package filter evaluation requires that the ip be in the
                    // database - at this point the ip is NOT in db, so insert as
                    // active
                    // and update afterward
                    //
                    // Try to avoid re-evaluating the ip against filters for
                    // each service, try to get the first package here and use
                    // that for service evaluation
                    //
                    boolean xaddrUnmanaged = cFactory.isAddressUnmanaged(xifaddr);
                    if (xaddrUnmanaged)
                        xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
                    else
                        xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

                    int xifIndex = -1;
                    if ((xifIndex = snmpc.getIfIndex(xifaddr)) != -1) {
                        xipIfEntry.setIfIndex(xifIndex);
                        int status = snmpc.getAdminStatus(xifIndex);
                        if (status != -1)
                            xipIfEntry.setStatus(status);

                        if (supportsSnmp((List) extraTargets.get(xifaddr))) {
                            // Just set primary state to secondary for now. The
                            // primary SNMP interface
                            // won't be selected until after all interfaces have
                            // been inserted
                            // into the database. This is because the interface must
                            // already be in
                            // the database for filter rule evaluation to succeed.
                            xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
                        } else {
                            xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
                        }
                    } else {
                        // No ifIndex found so set primary state to NOT_ELIGIBLE
                        xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
                    }

                    xipIfEntry.store(dbc);

                    // now update if necessary
                    org.opennms.netmgt.config.poller.Package xipPkg = null;
                    if (!xaddrUnmanaged) {
                        // The newly discoveried IP addr is not in the Package
                        // IPList
                        // Mapping yet, so rebuild the list.
                        //
                        PollerConfigFactory.getInstance().rebuildPackageIpListMap();

                        boolean xipToBePolled = false;
                        xipPkg = pollerCfgFactory.getFirstPackageMatch(xifaddr.getHostAddress());
                        if (xipPkg != null)
                            xipToBePolled = true;

                        if (!xipToBePolled) {
                            // update ismanaged to 'N' in ipinterface
                            xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
                            xipIfEntry.store(dbc);
                        }
                    }

                    // add the supported protocols
                    addSupportedProtocols(node, xifaddr, (List) extraTargets.get(xifaddr), xaddrUnmanaged, xifIndex, xipPkg);
                } // end while()
                // Now add any non-IP interfaces
                //
                if (collector.hasNonIpInterfaces()) {
                    iter = ((List) collector.getNonIpInterfaces()).iterator();
                    while (iter.hasNext()) {
                        Integer ifindex = (Integer) iter.next();

                        DbIpInterfaceEntry xipIfEntry = null;
                        try {
                            xipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), InetAddress.getByName("0.0.0.0"));
                        } catch (UnknownHostException e) {
                            continue;
                        }
                        xipIfEntry.setLastPoll(now);
                        xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);

                        xipIfEntry.setIfIndex(ifindex.intValue());
                        
                        int status = snmpc.getAdminStatus(ifindex.intValue());
                        if (status != -1)
                            xipIfEntry.setStatus(status);

                        xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

                        xipIfEntry.store(dbc);
                    }
                }
            }

            // last thing to do is add all the snmp interface information
            //
            if (snmpc.hasIfTable()) {
                IfTable ift = snmpc.getIfTable();
                Iterator ifiter = ift.getEntries().iterator();
                while (ifiter.hasNext()) {
                    IfTableEntry ifte = (IfTableEntry) ifiter.next();

                    // index
                    //
                    int xifIndex = -1;
                    Integer sint = ifte.getIfIndex();
                    if (sint != null)
                        xifIndex = sint.intValue();
                    else
                        continue;

                    // address
                    //
                    // WARNING: IfSnmpCollector.getIfAddressAndMask() ONLY returns
                    // the FIRST IP address and mask for a given interface as
                    // specified
                    // in the ipAddrTable.
                    //
                    InetAddress[] aaddrs = null;
                    if (snmpc.hasIpAddrTable())
                        aaddrs = snmpc.getIfAddressAndMask(sint.intValue());
                    if (aaddrs == null) {
                        // Must be non-IP interface, set ifAddress to '0.0.0.0' and
                        // Mask to null
                        aaddrs = new InetAddress[2];
                        try {
                            aaddrs[0] = InetAddress.getByName("0.0.0.0");
                        } catch (UnknownHostException e) {
                            continue;
                        }
                        aaddrs[1] = null;
                    }

                    // Retrieve ifType so we can check for loopback
                    //
                    sint = ifte.getIfType();
                    // FIXME: What if sint is null
                    int ifType = sint.intValue();

                    // Skip loopback interfaces
                    //
                    if (aaddrs[0].getHostAddress().startsWith("127."))
                        continue;

                    DbSnmpInterfaceEntry snmpEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), xifIndex);

                    // IP address
                    snmpEntry.setIfAddress(aaddrs[0]);
                    if(aaddrs[0].equals(ifaddr))
                        forceSnmpInterfaceEntry = false;

                    // netmask
                    if (aaddrs[1] != null)
                        snmpEntry.setNetmask(aaddrs[1]);

                    // description
                    String str = ifte.getIfDescr();
                    if (log.isDebugEnabled())
                        log.debug("SuspectEventProcessor: " + aaddrs[0].getHostAddress() + " has ifDescription: " + str);
                    if (str != null && str.length() > 0)
                        snmpEntry.setDescription(str);

                    // physical address
                    String physAddr = ifte.getPhysAddr();
                        
                    if (log.isDebugEnabled())
                        log.debug("SuspectEventProcessor: " + aaddrs[0].getHostAddress() + " has physical address: -" + physAddr + "-");
                    
                    if (physAddr != null && physAddr.length() == 12) {
                        snmpEntry.setPhysicalAddress(physAddr);
                    }
                    

                    // type
                    snmpEntry.setType(ifType);

                    // speed
                    Long uint = ifte.getIfSpeed();
                    if (uint == null) {
                        snmpEntry.setSpeed(0);
                    } else {
                        snmpEntry.setSpeed(uint.longValue());
                    }

                    // admin status
                    sint = ifte.getIfAdminStatus();
                    if (sint == null) {
                        snmpEntry.setAdminStatus(0);
                    } else {
                        snmpEntry.setAdminStatus(sint.intValue());
                    }

                    // oper status
                    sint = ifte.getIfOperStatus();
                    if (sint == null) {
                        snmpEntry.setOperationalStatus(0);
                    } else {
                        snmpEntry.setOperationalStatus(sint.intValue());
                    }

                    // name (from interface extensions table)
                    String ifName = snmpc.getIfName(xifIndex);
                    if (ifName != null && ifName.length() > 0)
                        snmpEntry.setName(ifName);

                    // alias (from interface extensions table)
                    String ifAlias = snmpc.getIfAlias(xifIndex);
                    if (ifAlias != null && ifAlias.length() > 0)
                        snmpEntry.setAlias(ifAlias);

                    snmpEntry.store(dbc);
                }
            }
            if(ifIndex == CapsdConfigFactory.LAME_SNMP_HOST_IFINDEX || forceSnmpInterfaceEntry) {
                DbSnmpInterfaceEntry snmpEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), ifIndex);
                // IP address
                snmpEntry.setIfAddress(ifaddr);
                snmpEntry.store(dbc);
            }
        }
    }

