	/**
	 * This method is responsble for inserting new entries into the ipInterface
	 * table for each interface found to be associated with the suspect interface
	 * during the capabilities scan.
	 * 
	 * @param dbc		Database connection.
	 * @param node		DbNodeEntry object representing the suspect interface's
	 *                      parent node table entry
	 * @param useExistingNode False if a new node was created for the suspect interface.
	 *                        True if an existing node entry was found under which the
	 *                        the suspect interface is to be added.                    
	 * @param ifaddr	Suspect interface
	 * @param collector	Interface collector containing SMB and SNMP info 
	 * 			collected from the remote device.
	 **
	 * @throws SQLException if an error occurs adding interfaces to the ipInterface 
	 *                      table.
	 */
	private void addInterfaces(Connection dbc, 
				   DbNodeEntry node,
				   boolean     useExistingNode,
				   InetAddress ifaddr,
				   IfCollector collector)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());

		CapsdConfigFactory cFactory = CapsdConfigFactory.getInstance();
		PollerConfigFactory pollerCfgFactory = PollerConfigFactory.getInstance();

		Date now = new Date();

		// if there is no snmp information then it's a
		// simple addtion to the database
		//
		if(!collector.hasSnmpCollection() || collector.getSnmpCollector().failed())
		{
			DbIpInterfaceEntry ipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
			ipIfEntry.setLastPoll(now);
			ipIfEntry.setHostname(ifaddr.getHostName());

			// NOTE: (reference internal bug# 201)
			// If the ip is 'managed', it might still be 'not polled' based
			// on the poller configuration
			//
			// The package filter evaluation requires that the ip be in the
			// database - at this point the ip is NOT in db, so insert as active
			// and update afterward
			//
			// Try to avoid re-evaluating the ip against filters for
			// each service, try to get the first package here and use
			// that for service evaluation
			//
			//
			boolean addrUnmanaged = cFactory.isAddressUnmanaged(ifaddr);
			if(addrUnmanaged)
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
			else
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

			ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

			ipIfEntry.store(dbc);

			// now update if necessary
			org.opennms.netmgt.config.poller.Package ipPkg = null;
			if (!addrUnmanaged)
			{
				boolean ipToBePolled = false;
				ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
				if (ipPkg != null)
					ipToBePolled = true;

				if (!ipToBePolled)
				{
					// update ismanaged to 'N' in ipinterface
					ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
					ipIfEntry.store(dbc);
				}
			}

			// add the supported protocols
			//
			// NOTE!!!!!: (reference internal bug# 201)
			// If the ip is 'managed', the service can still be 'not polled'
			// based on the poller configuration - at this point the ip is already
			// in the database, so package filter evaluation should go through OK
			//
			Iterator iproto = collector.getSupportedProtocols().iterator();
			while(iproto.hasNext())
			{
				IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
				Number sid = (Number)cFactory.getServiceIdentifier(p.getProtocolName());

				DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());

				// now fill in the entry
				//
				if(addrUnmanaged)
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
				else 
				{
					boolean svcToBePolled = false;
					if (ipPkg != null)
					{
						svcToBePolled = pollerCfgFactory.isPolled(p.getProtocolName(), ipPkg);
						if (!svcToBePolled)
							svcToBePolled = pollerCfgFactory.isPolled(ifaddr.getHostAddress(), p.getProtocolName());
					}

					if (svcToBePolled)
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
					else
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
				}

				// Set qualifier if available.  Currently the qualifier field
				// is used to store the port at which the protocol was found.
				//
				if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
				{
					try
					{
						Integer port = (Integer)p.getQualifiers().get("port");
						log.debug("addInterfaces: got a port qualifier: " + port);
						ifSvcEntry.setQualifier(port.toString());
					}
					catch (ClassCastException ccE)
					{
						// Do nothing
					}
				}
					
				ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
				ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);

				ifSvcEntry.store();
			}
		}
		else
		{
			IfSnmpCollector snmpc = collector.getSnmpCollector();

			// more complicate work needs to be done here. Information must
			// be looked up in various entrys now!
			//
			DbIpInterfaceEntry ipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
			ipIfEntry.setLastPoll(now);
			ipIfEntry.setHostname(ifaddr.getHostName());

			// NOTE: (reference internal bug# 201)
			// If the ip is 'managed', it might still be 'not polled' based
			// on the poller configuration
			//
			// The package filter evaluation requires that the ip be in the
			// database - at this point the ip is NOT in db, so insert as active
			// and update afterward
			//
			// Try to avoid re-evaluating the ip against filters for
			// each service, try to get the first package here and use
			// that for service evaluation
			//
			boolean addrUnmanaged = cFactory.isAddressUnmanaged(ifaddr);
			if(addrUnmanaged)
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
			else
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

			ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

			ipIfEntry.store(dbc);

			// now update if necessary
			org.opennms.netmgt.config.poller.Package ipPkg = null;
			if (!addrUnmanaged)
			{
				boolean ipToBePolled = false;
				ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
				if (ipPkg != null)
					ipToBePolled = true;

				if (!ipToBePolled)
				{
					// update ismanaged to 'N' in ipinterface
					ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
					ipIfEntry.store(dbc);
				}
			}

			int ifIndex = -1;
			if((ifIndex = snmpc.getIfIndex(ifaddr)) != -1)
			{
			// Just set primary state to secondary for now.  The primary SNMP interface
			// won't be selected until after all interfaces have been inserted
			// into the database. This is because the interface must already be in
			// the database for filter rule evaluation to succeed.
				ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
			
				ipIfEntry.setIfIndex(ifIndex);
				int status = snmpc.getAdminStatus(ifIndex);
				if(status != -1)
					ipIfEntry.setStatus(status);
			}
			else
			{
				// Address does not have a valid ifIndex associated with it
				// so set primary state to NOT_ELIGIBLE.
				ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
			}

			ipIfEntry.store(dbc);

			// add the supported protocols
			//
			// NOTE!!!!!: (reference internal bug# 201)
			// If the ip is 'managed', the service can still be 'not polled'
			// based on the poller configuration - at this point the ip is already
			// in the database, so package filter evaluation should go through OK
			//
			Iterator iproto = collector.getSupportedProtocols().iterator();
			while(iproto.hasNext())
			{
				IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
				Number sid = (Number)cFactory.getServiceIdentifier(p.getProtocolName());

				DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());

				// now fill in the entry
				//
				if(addrUnmanaged)
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
				else 
				{
					boolean svcToBePolled = false;
					if (ipPkg != null)
					{
						svcToBePolled = pollerCfgFactory.isPolled(p.getProtocolName(), ipPkg);
						if (!svcToBePolled)
							svcToBePolled = pollerCfgFactory.isPolled(ifaddr.getHostAddress(), p.getProtocolName());
					}

					if (svcToBePolled)
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
					else
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
				}


				// Set qualifier if available.  Currently the qualifier field
				// is used to store the port at which the protocol was found.
				//
				if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
				{
					try
					{
						Integer port = (Integer)p.getQualifiers().get("port");
						log.debug("addInterfaces: got a port qualifier: " + port);
						ifSvcEntry.setQualifier(port.toString());
					}
					catch (ClassCastException ccE)
					{
						// Do nothing
					}
					
				}
				
				ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
				ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);
				if(ifIndex != -1)
					ifSvcEntry.setIfIndex(ifIndex);

				ifSvcEntry.store();
			}

			// If the useExistingNode flag is true, then we're done.  The interface
			// is most likely an alias and the subinterfaces collected via SNMP should
			// already be in the database.
			//
			if (useExistingNode == true)
				return;
			
			// Made it this far...lets add the sub interfaces
			// 
			Map extraTargets = collector.getAdditionalTargets();
			Iterator iter = extraTargets.keySet().iterator();
			while(iter.hasNext())
			{
				InetAddress xifaddr = (InetAddress)iter.next();
	
				if (log.isDebugEnabled())
					log.debug("addInterfaces: adding interface " + xifaddr.getHostAddress());
						
				DbIpInterfaceEntry xipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), xifaddr);
				xipIfEntry.setLastPoll(now);
				xipIfEntry.setHostname(xifaddr.getHostName());

				// NOTE: (reference internal bug# 201)
				// If the ip is 'managed', it might still be 'not polled' based
				// on the poller configuration
				//
				// The package filter evaluation requires that the ip be in the
				// database - at this point the ip is NOT in db, so insert as active
				// and update afterward
				//
				// Try to avoid re-evaluating the ip against filters for
				// each service, try to get the first package here and use
				// that for service evaluation
				//
				boolean xaddrUnmanaged = cFactory.isAddressUnmanaged(xifaddr);
				if(xaddrUnmanaged)
					xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
				else
					xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

				int xifIndex = -1;
				if((xifIndex = snmpc.getIfIndex(xifaddr)) != -1)
				{
					xipIfEntry.setIfIndex(xifIndex);
					int status = snmpc.getAdminStatus(xifIndex);
					if(status != -1)
						xipIfEntry.setStatus(status);

				if (supportsSnmp((List)extraTargets.get(xifaddr)))					
				{
					// Just set primary state to secondary for now.  The primary SNMP interface
					// won't be selected until after all interfaces have been inserted
					// into the database. This is because the interface must already be in
					// the database for filter rule evaluation to succeed.
						xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
				}
				else
				{
						xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
					}
				}
				else
				{
					// No ifIndex found so set primary state to NOT_ELIGIBLE
					xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
				}
	
				xipIfEntry.store(dbc);
	
				// now update if necessary
				org.opennms.netmgt.config.poller.Package xipPkg = null;
				if (!xaddrUnmanaged)
				{
					boolean xipToBePolled = false;
					xipPkg = pollerCfgFactory.getFirstPackageMatch(xifaddr.getHostAddress());
					if (xipPkg != null)
						xipToBePolled = true;

					if (!xipToBePolled)
					{
						// update ismanaged to 'N' in ipinterface
						xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
						xipIfEntry.store(dbc);
					}
				}

				// add the supported protocols
				//
				// NOTE!!!!!: (reference internal bug# 201)
				// If the ip is 'managed', the service can still be 'not polled'
				// based on the poller configuration - at this point the ip is already
				// in the database, so package filter evaluation should go through OK
				//
				iproto = ((List)extraTargets.get(xifaddr)).iterator();
				while(iproto.hasNext())
				{
					IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
					Number sid = (Number)cFactory.getServiceIdentifier(p.getProtocolName());
	
					DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), xifaddr, sid.intValue());
	
					// now fill in the entry
					//
					if(xaddrUnmanaged)
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
					else 
					{
						boolean svcToBePolled = false;
						if (xipPkg != null)
						{
							svcToBePolled = pollerCfgFactory.isPolled(p.getProtocolName(), ipPkg);
							if (!svcToBePolled)
								svcToBePolled = pollerCfgFactory.isPolled(xifaddr.getHostAddress(), p.getProtocolName());
						}

						if (svcToBePolled)
							ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
						else
							ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
					}


					// Set qualifier if available.  Currently the qualifier field
					// is used to store the port at which the protocol was found.
					//
					if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
					{
						try
						{
							Integer port = (Integer)p.getQualifiers().get("port");
							log.debug("addInterfaces: got a port qualifier: " + port);
							ifSvcEntry.setQualifier(port.toString());
						}
						catch (ClassCastException ccE)
						{
							// Do nothing
						}
					}
							
					ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
					ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);	
					
					if(xifIndex != -1)
						ifSvcEntry.setIfIndex(xifIndex);
	
					ifSvcEntry.store();
				} // end while (iproto.hasNext())
			} // end while()

			// Now add any non-IP interfaces
			//
			if (collector.hasNonIpInterfaces())
			{
				iter = ((List)collector.getNonIpInterfaces()).iterator();
				while(iter.hasNext())
				{
					SnmpInt32 ifindex = (SnmpInt32)iter.next();
						
					DbIpInterfaceEntry xipIfEntry = null;
					try
					{
						xipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), InetAddress.getByName("0.0.0.0"));
					}
					catch(UnknownHostException e)
					{
						continue;
					}
					xipIfEntry.setLastPoll(now);
					xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
						
					xipIfEntry.setIfIndex(ifindex.getValue());
					int status = snmpc.getAdminStatus(ifIndex);
					if(status != -1)
						xipIfEntry.setStatus(status);
					
					xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
					
					xipIfEntry.store(dbc);
				}
			}
			
			// last thing to do is add all the snmp interface information
			//
			IfTable ift = snmpc.getIfTable();
			Iterator ifiter = ift.getEntries().iterator();
			while(ifiter.hasNext())
			{
				IfTableEntry ifte = (IfTableEntry)ifiter.next();
					
				// index
				//
				int xifIndex = -1;
				SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_INDEX);
				if(sint != null)
					xifIndex = sint.getValue();
				else
					continue;

				// address
				//
				// WARNING:  IfSnmpCollector.getIfAddressAndMask() ONLY returns
				// the FIRST IP address and mask for a given interface as specified
				// in the ipAddrTable.
				//
				InetAddress[] aaddrs = snmpc.getIfAddressAndMask(sint.getValue());
				if(aaddrs == null)
				{
					// Must be non-IP interface, set ifAddress to '0.0.0.0' and
					// Mask to null
					aaddrs = new InetAddress[2];
					try
					{
						aaddrs[0] = InetAddress.getByName("0.0.0.0");
					}	
					catch (UnknownHostException e)
					{
						continue;
					}
					aaddrs[1] = null;
				}

				// Retrieve ifType so we can check for loopback
				//
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_TYPE);
				int ifType = sint.getValue();
								
				// Skip loopback interfaces
				//
				if (aaddrs[0].getHostAddress().startsWith("127.") || ifType == 24)
					continue;
					
				DbSnmpInterfaceEntry snmpEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), xifIndex);

				// IP address
				snmpEntry.setIfAddress(aaddrs[0]);
					
				// netmask
				if (aaddrs[1] != null)
					snmpEntry.setNetmask(aaddrs[1]);

				// description
				String str = SystemGroup.getPrintableString((SnmpOctetString)ifte.get(IfTableEntry.IF_DESCR));
				if (log.isDebugEnabled())
					log.debug("SuspectEventProcessor: " + aaddrs[0].getHostAddress() + " has ifDescription: " + str);
				if(str != null && str.length() > 0)
					snmpEntry.setDescription(str);

				// physical address
				StringBuffer sbuf = new StringBuffer();
				SnmpOctetString ostr = (SnmpOctetString)ifte.get(IfTableEntry.IF_PHYS_ADDR);
				
				byte[] bytes = ostr.getString();
				for(int i = 0; i < bytes.length; i++)
				{
					sbuf.append(Integer.toHexString(((int)bytes[i] >> 4) & 0xf));
					sbuf.append(Integer.toHexString((int)bytes[i] & 0xf));
				}
				
				String physAddr = sbuf.toString().trim();
			
				if (log.isDebugEnabled())
					log.debug("SuspectEventProcessor: " + aaddrs[0].getHostAddress() + " has physical address: -" + physAddr + "-");
				
				if (physAddr.length() == 12)
				{
					snmpEntry.setPhysicalAddress(physAddr);
				}
	
				// type
				snmpEntry.setType(ifType);
				
				// speed
				SnmpUInt32 uint = (SnmpUInt32)ifte.get(IfTableEntry.IF_SPEED);
				snmpEntry.setSpeed((int)uint.getValue());

				// admin status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_ADMIN_STATUS);
				snmpEntry.setAdminStatus(sint.getValue());
				
				// oper status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_OPER_STATUS);
				snmpEntry.setOperationalStatus(sint.getValue());

				// name (from interface extensions table)
				SnmpOctetString snmpIfName = snmpc.getIfName(xifIndex);
				if (snmpIfName != null)
				{
					String ifName = SystemGroup.getPrintableString(snmpIfName);
					if (ifName != null && ifName.length() > 0)
						snmpEntry.setName(ifName);
				}
				
				snmpEntry.store(dbc);
			}
		}
	}

