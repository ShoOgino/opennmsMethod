	/**
	 * Returns true if the protocol defined by this
	 * plugin is supported. If the protocol is not 
	 * supported then a false value is returned to the 
	 * caller. The qualifier map passed to the method is
	 * used by the plugin to return additional information
	 * by key-name. These key-value pairs can be added to 
	 * service events if needed.
	 *
	 * @param address	The address to check for support.
	 * @param qualiier	The map where qualification are set
	 *			by the plugin.
	 *
	 * @return True if the protocol is supported by the address.
	 */
	public boolean isProtocolSupported(InetAddress address, Map qualifiers)
	{
		boolean isSupported = false;
		SnmpSession session = null;
		SnmpPeer peer = SnmpPeerFactory.getInstance().getPeer(address);
		try
		{
			if(peer == null)
				peer = new SnmpPeer(address);

			String expectedValue = null;
			if (qualifiers != null)
			{
				// "port" parm
				//
				if(qualifiers.get("port") != null)
			 	{
					int port = getKeyedInteger(qualifiers, "port", peer.getPort());
					peer.setPort(port);
				}
				
				// "timeout" parm
				//
				if(qualifiers.get("timeout") != null)
			 	{
					int timeout = getKeyedInteger(qualifiers, "timeout", peer.getTimeout());
					peer.setTimeout(timeout);
				}
			    
				// "retry" parm
				//
				if(qualifiers.get("retry") != null)
			 	{
					int retry = getKeyedInteger(qualifiers, "retry", peer.getRetries());
					peer.setRetries(retry);
				}
				
				// "force version" parm
				//
				if(qualifiers.get("force version") != null)
				{
					String version = (String)qualifiers.get("force version");
					if(version.equalsIgnoreCase("snmpv1"))
						peer.getParameters().setVersion(SnmpSMI.SNMPV1);
					else if(version.equalsIgnoreCase("snmpv2"))
						peer.getParameters().setVersion(SnmpSMI.SNMPV2);
				}
	    
				// "vbvalue" parm
				//
				if(qualifiers.get("vbvalue") != null)
				{
					expectedValue = (String)qualifiers.get("vbvalue");
				}
			}
			
			session = new SnmpSession(peer);

			String oid = getKeyedString(qualifiers, "vbname", DEFAULT_OID);

			SnmpResponseHandler handler = new SnmpResponseHandler();
			
			SnmpPduPacket out = null;
			if (peer.getParameters().getVersion() == SnmpSMI.SNMPV1)
				out = new SnmpPduRequest(SnmpPduPacket.GETNEXT,
							       	new SnmpVarBind[] { new SnmpVarBind(oid) });
			else if (peer.getParameters().getVersion() == SnmpSMI.SNMPV2)
				out = new SnmpPduBulk(1,     	// nonRepeaters
				 		0, 		// maxRepetitions	
						new SnmpVarBind[] { new SnmpVarBind(oid) });  
			
			synchronized(handler)
			{
				session.send(out, handler);
				try
				{
					handler.wait((long)((peer.getRetries()+1) * peer.getTimeout()));
				}
				catch(InterruptedException e)
				{
					Thread.currentThread().interrupt();
				}
			}

			if(handler.getResult() != null)
			{
				String retrievedValue = handler.getResult().getValue().toString();
				
				// If no expected value to check against isSupported is true
				if (expectedValue == null)
				{
					isSupported = true;
				}
				// If there is an expected value, verify it matches the retrieved value
				else
				{
					if (retrievedValue.equals(expectedValue))
						isSupported = true;
				}
					
				if(qualifiers != null)
				{
					qualifiers.put("vbname", handler.getResult().getName().toString());
					qualifiers.put("vbvalue", retrievedValue);
					if(peer.getParameters().getVersion() == SnmpSMI.SNMPV1)
						qualifiers.put("version", "SNMPv1");
					else if(peer.getParameters().getVersion() == SnmpSMI.SNMPV2)
						qualifiers.put("version", "SNMPv2");
				}
			}
		}
		catch(Throwable t)
		{
			throw new UndeclaredThrowableException(t);
		}
		finally
		{
			if(session != null)
				session.close();
		}

		return isSupported;
	}

