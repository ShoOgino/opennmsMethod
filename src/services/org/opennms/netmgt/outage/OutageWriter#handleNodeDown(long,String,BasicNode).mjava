    /**
     * Handles node down events. Record the 'nodeDown' event in the outages
     * table - create a new outage entry for each active service of the nodeid
     * if service is not already down.
     * @param node TODO
     */
    private void handleNodeDown(long eventID, String eventTime, BasicNode node) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        
        if (eventID == -1 || !node.isValid()) {
            log.warn(EventConstants.NODE_DOWN_EVENT_UEI + " ignored - info incomplete - eventid/nodeid: " + eventID + "/" + node);
            return;
        }

        Connection dbConn = null;
        try {
            dbConn = getConnection();

            // Set the database commit mode
            dbConn.setAutoCommit(false);

            // Prepare SQL statement used to get active services for the nodeid
            PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_NODE);

            // Prepare SQL statement used to see if there is already an
            // 'open' record for the node/ip/svc combination
            PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD);
            // Prepare statement to insert a new outage table entry
            PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);

            // Prepare statement to insert a new outage table entry
            newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);

            if (log.isDebugEnabled())
                log.debug("handleNodeDown: creating new outage entries...");

            // Get all active services for the nodeid
            activeSvcsStmt.setLong(1, node.getNodeId());
            ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
            while (activeSvcsRS.next()) {
                BasicService svc = new BasicService(node.getNodeId(), activeSvcsRS.getString(1), activeSvcsRS.getLong(2));
                if (svc.openOutageExists(dbConn)) {
                    if (log.isDebugEnabled())
                        log.debug("handleNodeDown: " + svc + " already down");
                } else {
                    // set parms
                    newOutageWriter.setLong(1, getNextOutageId(dbConn));
                    newOutageWriter.setLong(2, eventID);
                    newOutageWriter.setLong(3, svc.getNodeId());
                    newOutageWriter.setString(4, svc.getIpAddr());
                    newOutageWriter.setLong(5, svc.getServiceId());
                    newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));

                    // execute update
                    newOutageWriter.executeUpdate();

                    if (log.isDebugEnabled())
                        log.debug("handleNodeDown: Recording outage for " + svc);
                }

            }
            // close result set
            activeSvcsRS.close();

            // commit work
            DbUtil.commit(log, dbConn, "Outage recorded for all active services for " + node, "nodeDown could not be recorded  for nodeId: " + node);

            // close statements
            activeSvcsStmt.close();
            openStmt.close();
            newOutageWriter.close();
        } catch (SQLException sqle) {
            DbUtil.rollback(log, dbConn, "SQL exception while handling \'nodeDown\'", sqle);
        } finally {
            DbUtil.close(log, dbConn);
        }
    }

