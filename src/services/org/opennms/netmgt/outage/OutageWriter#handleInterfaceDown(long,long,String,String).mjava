	/**
	 * <p>Record the 'interfaceDown' event in the outages table - create
	 * a new outage entry for each active service of the nodeid/ip if
	 * service not already down</p>
	 */
	private void handleInterfaceDown(long eventID, long nodeID, String ipAddr, String eventTime)
	{
		Category log = ThreadCategory.getInstance(OutageWriter.class);

		if(eventID == -1 || nodeID == -1 || ipAddr == null)
		{
			log.warn(EventConstants.INTERFACE_DOWN_EVENT_UEI + " ignored - info incomplete - eventid/nodeid/ip: " + eventID + "/" + nodeID + "/" + ipAddr);
			return;
		}


		Connection dbConn = null;
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();

			// Set the database commit mode
			try
			{
				dbConn.setAutoCommit(false);
			}
			catch (SQLException sqle)
			{
				log.error("Unable to change database AutoCommit to FALSE", sqle);
				return;
			}

	 		// Prepare SQL statement used to get active services for the nodeid/ip
			PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_INTERFACE);

	 		// Prepare SQL statement used to see if there is already an
			// 'open' record for the node/ip/svc combination
			PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD);
			// Prepare statement to insert a new outage table entry
			PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);

	 		// Prepare SQL statement to get the next outage id from the db sequence
			PreparedStatement getNextOutageIdStmt  = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());

			// Get all active services for the nodeid/ip
			activeSvcsStmt.setLong  (1, nodeID);
			activeSvcsStmt.setString(2, ipAddr);
			ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
			while(activeSvcsRS.next())
			{
				long serviceID = activeSvcsRS.getLong(1);

				int numOpenRecs = -1;

				// Check if this service is already down
				openStmt.setLong  (1, nodeID);
				openStmt.setString(2, ipAddr);
				openStmt.setLong  (3, serviceID);
				
				ResultSet openOutageRS = openStmt.executeQuery();
				if(openOutageRS.next())
				{
					numOpenRecs = openOutageRS.getInt(1);
				}
				// close result set
				openOutageRS.close();

				if (numOpenRecs > 0)
				{
					if (log.isDebugEnabled())
						log.debug(nodeID + "/" + ipAddr + "/" + serviceID + " already down");
				}
				else
				{

					long outageID = -1;

					// Execute the statement to get the next outage id from the sequence
					//
					ResultSet seqRS = getNextOutageIdStmt.executeQuery();
					if (seqRS.next())
					{
						outageID = seqRS.getLong(1);
					}
					seqRS.close();

					// get timestamp
					java.sql.Timestamp eventTimeTS = null;
					try
					{
						java.util.Date date = EventConstants.parseToDate(eventTime);
						eventTimeTS = new java.sql.Timestamp(date.getTime());
					}
					catch(ParseException pe)
					{
						log.warn("Failed to convert time " + eventTime + " to java.sql.Timestamp, Setting current time instead", pe);

						eventTimeTS = new java.sql.Timestamp((new java.util.Date()).getTime());
					}

					newOutageWriter.setLong  (1, outageID);
					newOutageWriter.setLong  (2, eventID);
					newOutageWriter.setLong  (3, nodeID);
					newOutageWriter.setString(4, ipAddr);
					newOutageWriter.setLong  (5, serviceID);
					newOutageWriter.setTimestamp(6, eventTimeTS);

					// execute update
					newOutageWriter.executeUpdate();

					if (log.isDebugEnabled())
						log.debug("Recording outage for " + nodeID + "/" + ipAddr + "/" + serviceID);
				}

			}
			// close result set
			activeSvcsRS.close();

			// commit work
			try
			{
				dbConn.commit();

				if (log.isDebugEnabled())
					log.debug("Outage recorded for all active services for " + nodeID + "/" + ipAddr);
			}
			catch(SQLException se)
			{
				log.warn("Rolling back transaction, interfaceDown could not be recorded  for nodeid/ipAddr: " + nodeID + "/" + ipAddr, se);


				try 
				{
					dbConn.rollback();
				}
				catch (SQLException sqle)
				{
					log.warn("SQL exception during rollback, reason", sqle);
				}

			}

			// close statements
			activeSvcsStmt.close();
			openStmt.close();
			newOutageWriter.close();
		}
		catch (SQLException sqle)
		{
			log.warn("SQL exception while handling \'interfaceDown\'", sqle);
		}
		finally
		{
			try
			{
				if(dbConn != null)
					dbConn.close();
			}
			catch(SQLException e)
			{
				log.warn("Exception closing JDBC connection", e);
			}
		}
	}

