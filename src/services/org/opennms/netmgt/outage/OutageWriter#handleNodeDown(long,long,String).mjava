	/**
	 * <p>Record the 'nodeDown' event in the outages table - create a new
	 * outage entry for each active service of the nodeid if service is
	 * not already down</p>
	 */
	private void handleNodeDown(long eventID, long nodeID, String eventTime)
	{
		Category log = ThreadCategory.getInstance(OutageWriter.class);

		if(eventID == -1 || nodeID == -1)
		{
			log.warn(EventConstants.NODE_DOWN_EVENT_UEI + " ignored - info incomplete - eventid/nodeid: " + eventID + "/" + nodeID);
			return;
		}


		Connection dbConn = null;
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();

			// Set the database commit mode
			try
			{
				dbConn.setAutoCommit(false);
			}
			catch (SQLException sqle)
			{
				log.error("Unable to change database AutoCommit to FALSE", sqle);
				return;
			}

	 		// Prepare SQL statement used to get active services for the nodeid
			PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_NODE);

	 		// Prepare SQL statement used to see if there is already an
			// 'open' record for the node/ip/svc combination
			PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD);
			// Prepare statement to insert a new outage table entry
			PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);

	 		// Prepare SQL statement to get the next outage id from the db sequence
			PreparedStatement getNextOutageIdStmt  = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());

//                        // Check the OutageCache to see if an event exists.
//
//                        OutageEventEntry regainedEvent = OutageEventCache.getInstance().findCacheMatch(eventID,
//                                                                                        nodeID,
//                                                                                        null,
//                                                                                        -1,
//                                                                                        eventTime,
//                                                                                        OutageEventEntry.EVENT_TYPE_NODE_DOWN);
//
//                        if (regainedEvent == null || openOutageExists(dbConn, nodeID))
//                        {
                                // No matching regained service event in the cache

                                // Prepare statement to insert a new outage table entry
                                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);

                                if (log.isDebugEnabled())
                                        log.debug("handleNodeDown: creating new outage entries...");

                                // Get all active services for the nodeid
                                activeSvcsStmt.setLong  (1, nodeID);
                                ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
                                while(activeSvcsRS.next())
                                {
                                        String ipAddr = activeSvcsRS.getString(1);
                                        long serviceID = activeSvcsRS.getLong(2);

                                        if (openOutageExists(dbConn, nodeID, ipAddr, serviceID))
                                        {
                                                if (log.isDebugEnabled())
                                                        log.debug("handleNodeDown: " + nodeID + "/" + ipAddr + "/" + serviceID + " already down");
                                        }
                                        else
                                        {
                                                long outageID = -1;

                                                ResultSet seqRS = getNextOutageIdStmt.executeQuery();
                                                if (seqRS.next())
                                                {
                                                        outageID = seqRS.getLong(1);
                                                }
                                                seqRS.close();

                                                // set parms
                                                newOutageWriter.setLong  (1, outageID);
                                                newOutageWriter.setLong  (2, eventID);
                                                newOutageWriter.setLong  (3, nodeID);
                                                newOutageWriter.setString(4, ipAddr);
                                                newOutageWriter.setLong  (5, serviceID);
                                                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));

                                                // execute update
                                                newOutageWriter.executeUpdate();

                                                if (log.isDebugEnabled())
                                                        log.debug("handleNodeDown: Recording outage for " + nodeID + "/" + ipAddr + "/" + serviceID);
                                        }

                                }
                                // close result set
                                activeSvcsRS.close();
//                        } else if (regainedEvent != null)
//                        {
//                                // Matching regained service event in the cache.
//
//                                // Prepare statement to insert a closed outage table entry
//                                if (log.isDebugEnabled())
//                                        log.debug("handleNodeDown: creating closed outage entries...");
//
//                                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_CACHE_HIT);
//
//                                // Get all active services for the nodeid
//                                activeSvcsStmt.setLong  (1, nodeID);
//                                ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
//                                while(activeSvcsRS.next())
//                                {
//                                        String ipAddr = activeSvcsRS.getString(1);
//                                        long serviceID = activeSvcsRS.getLong(2);
//
//                                        // Execute the statement to get the next outage id from the sequence
//                                        //
//                                        long outageID = -1;
//                                        ResultSet seqRS = getNextOutageIdStmt.executeQuery();
//                                        if (seqRS.next())
//                                        {
//                                                outageID = seqRS.getLong(1);
//                                        }
//                                        seqRS.close();
//
//                                        newOutageWriter.setLong  (1, outageID);
//                                        newOutageWriter.setLong  (2, eventID);
//                                        newOutageWriter.setLong  (3, nodeID);
//                                        newOutageWriter.setString(4, ipAddr);
//                                        newOutageWriter.setLong  (5, serviceID);
//                                        newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));
//                                        newOutageWriter.setLong  (7, regainedEvent.getEventId());
//                                        newOutageWriter.setTimestamp(8, convertEventTimeIntoTimestamp(regainedEvent.getEventTime()));
//
//                                        // execute insert
//                                        newOutageWriter.executeUpdate();
//
//                                        if (log.isDebugEnabled())
//                                                log.debug("handleNodeDown: Recording closed outage for " + nodeID + "/" + ipAddr + "/" + serviceID);
//                                }
//                        }

			// commit work
			try
			{
				dbConn.commit();

				if (log.isDebugEnabled())
					log.debug("Outage recorded for all active services for " + nodeID);
			}
			catch(SQLException se)
			{
				log.warn("Rolling back transaction, nodeDown could not be recorded  for nodeId: " + nodeID, se);

				try 
				{
					dbConn.rollback();
				}
				catch (SQLException sqle)
				{
					log.warn("SQL exception during rollback, reason", sqle);
				}

			}

			// close statements
			activeSvcsStmt.close();
			openStmt.close();
			newOutageWriter.close();
		}
		catch (SQLException sqle)
		{
			log.warn("SQL exception while handling \'nodeDown\'", sqle);
		}
		finally
		{
			try
			{
				if(dbConn != null)
					dbConn.close();
			}
			catch(SQLException e)
			{
				log.warn("Exception closing JDBC connection", e);
			}
		}
                
                // Notify the xmlrpc server the nodeDown event when 
                // needed
                if (m_xmlrpc && m_xmlrpcServerUrl != null)
                {
                        if (log.isDebugEnabled())
                                log.debug("handleNodeDown: Notify external xmlrpc server...");
                        
                        try
                        {
                                XmlRpcNotifier notifier = new XmlRpcNotifier(m_xmlrpcServerUrl, m_event);
                                String reply = notifier.sendNodeDownEvent();
                                if (log.isDebugEnabled())
                                        log.debug("handleNodeDown: The reply from the xmlrpc server is: "
                                                + "\n\t\t" + reply);
                                
                        } catch (XmlRpcException xe)
                        {
                                log.warn("handleNodeDown: Failed to notify xmlrpc server.", xe);
                        } catch (IOException ioe)
                        {
                                log.warn("handleNodeDown: Failed to notify xmlrpc server.", ioe);
                        }
                }
	}

