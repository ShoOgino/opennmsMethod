	/**
	 * <p>Delete the service - mark the corresponding 'ifServices' table entry
	 * as deleted. If this is the last active service on its interface, mark
	 * interface as deleted, cascade to the node level - mark node as deleted
	 * if interface just deleted was the last managed interface on the node.</p>
	 *
	 * <p>If service deleted is 'SNMP', clear out snmp info in the 'ipinterface'
	 * and 'node' tables, clear entries in the 'snmpInterface' table, 
	 * and generate a 'forceRescan' on the node</p>
	 *
	 * <p>Generate serviceDeleted, interfaceDeleted, nodeDeleted, forceRescan events
	 * as appropriate</p>
	 */
	private void handleDeleteService(long eventID, long nodeID, String ipAddr, String serviceName, long serviceID)
	{
		Category log = ThreadCategory.getInstance(OutageWriter.class);

		if(eventID == -1 || nodeID == -1 || ipAddr == null || serviceName == null)
		{
			log.warn(EventConstants.DELETE_SERVICE_EVENT_UEI 
                                + " ignored - info incomplete - eventID/nodeid/ip/svc: " 
                                + eventID + "/" + nodeID + "/" + ipAddr + "/" + serviceName);
			return;
		}
		
		boolean generateServiceDeletedEvent = false;
		boolean generateDeleteInterfaceEvent = false;
		boolean generateDeleteNodeEvent = false;
		boolean generateForceNodeRescanEvent= false;

		boolean bRollback = false;
		
		Connection dbConn = null;
                PreparedStatement stmt = null;
                ResultSet rs = null;
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();

			// Set the database commit mode
			try
			{
				dbConn.setAutoCommit(false);
			}
			catch (SQLException sqle)
			{
				log.error("Unable to change database AutoCommit to FALSE", sqle);
				return;
			}
	
                        if (OutageManagerConfigFactory.getInstance().deletePropagation())
                        {
                                // First, verify if there are other services exist on the node/interface pair.
                                stmt = dbConn.prepareStatement(OutageConstants.DB_COUNT_REMAIN_SERVICES_ON_INTERFACE);
                                stmt.setLong(1, nodeID);
                                stmt.setString(2, ipAddr);
                                stmt.setLong(3, serviceID);
                        
                                rs = stmt.executeQuery();

                                int otherServices = 0;
                                if (rs.next())
                                        otherServices = rs.getInt(1);
                        
                                rs.close();
                                stmt.close();
                        
                                if (otherServices < 1)
                                {
                                        // The service to delete is the only service on the node/interface pair.
                                        // verify if the interface is the only one on the node
                                        stmt = dbConn.prepareStatement(OutageConstants.DB_COUNT_REMAIN_INTERFACES_ON_NODE);
                                        stmt.setLong(1, nodeID);
                                        stmt.setString(2, ipAddr);

                                        rs = stmt.executeQuery();
                                        int otherInterfaces = 0;

                                        if (rs.next())
                                                otherInterfaces = rs.getInt(1);
                                
                                        rs.close();
                                        stmt.close();
                                
                                        if (otherInterfaces < 1)
                                        {
                                                // the interface is the only one on the node. Delete the node.
		                                generateDeleteNodeEvent = true;
			                        if (log.isDebugEnabled())
				                        log.debug("handleDeleteService: Will generate delete node event: " + nodeID);
                                        }
                                        else
                                        {
                                                // there are other interfaces on the node. Just delete the 
                                                //interface.
		                                generateDeleteInterfaceEvent = true;
			                        if (log.isDebugEnabled())
				                        log.debug("handleDeleteService: Will generate delete interface "
                                                                + "event for node/interface: " + nodeID + "/" + ipAddr);
                                        }
                                }
                        }
                        
                        if (!generateDeleteNodeEvent && !generateDeleteInterfaceEvent)
                        {
			        if (log.isDebugEnabled())
			                log.debug("handleDeleteService: start deleting nodeid/interface/service: " 
                                        + nodeID + "/" + ipAddr + "/" + serviceName);
                                deleteService(dbConn, nodeID, ipAddr, serviceName, serviceID);
			
                                // If service is SNMP, make sure appropriate adjustments or
			        // deletions occur for SNMP
			        if (serviceName.equals(SNMP_SVC))
			        {
			                if (isSnmpPrimaryInterface(dbConn, nodeID, ipAddr))
		                        {	
				                // Since a deleteService was received for SNMP, and the interface
                                                // host this SNMP serviceis the primary SNMP interface of a node,
                                                // a forceRescan should be performed for the node
				                generateForceNodeRescanEvent = true;
                                        }
				        // Delete all entries in the 'snmpInterface' table for this node
				        stmt = dbConn.prepareStatement(OutageConstants.DB_DELETE_SNMP_INTERFACE);
				        stmt.setLong(1, nodeID);
				        stmt.executeUpdate();
			
			                stmt.close();
				        if (log.isDebugEnabled())
				                log.debug("handleDeleteService: deleted interface entries from 'snmpinterface' table");		
                                }
		                generateServiceDeletedEvent = true;
                        }
			//
			// commit the work
			//
			dbConn.commit();

			if (log.isDebugEnabled())
				log.debug("Commited changes for deleteService (node/ip/service): " 
                                        + nodeID + "/" + ipAddr + "/" + serviceID);

		} 
                catch(SQLException sqlE)
		{
			log.warn("Database service deletion failed for " 
                                + nodeID + "/" + ipAddr + "/" + serviceID, sqlE);
			bRollback = true;
		}
		catch(Throwable t)
		{
			log.warn("Run into unexpected exception.");
			bRollback = true;
		}

		//
		// rollback if necessary
		//
		if(bRollback)
		{
			if (log.isDebugEnabled())
				log.debug("rolling back transaction");

			try
			{
				dbConn.rollback();
			}
			catch (SQLException sqlE)
			{
				log.warn("SQL exception during rollback, reason", sqlE);
			}

			if (log.isDebugEnabled())
				log.debug("rolled back changes for (node/ip/service): " 
                                        + nodeID + "/" + ipAddr + "/" + serviceID);

			return;
		}

		// close database connection
		try
		{
			if(dbConn != null)
				dbConn.close();
		}
		catch(SQLException e)
		{
			log.warn("Exception closing JDBC connection", e);
		}
		
		// Form now events generated will have this date - will need to be
		// the date set if the ifservices table ever gets a service deletion time field
		java.util.Date deleteDate = new java.util.Date();
		
                // 
		// generate events to notify of modifications made to the database
		//
                try 
                {
                        EventIpcManagerFactory eFactory = EventIpcManagerFactory.getInstance();
		        
                        if (generateServiceDeletedEvent)
		        {
				// Generate event notifying of service deletion
				eFactory.getManager().sendNow(createEvent(EventConstants.SERVICE_DELETED_EVENT_UEI, 
						deleteDate,
						nodeID,
						ipAddr, 
						serviceName));
                                                
			        if (log.isDebugEnabled())
				        log.debug("Sent service deleted event to eventd for:"
                                                + nodeID + "/" + ipAddr + "/" + serviceName);
			}
                        
                        if (generateDeleteNodeEvent)
		        {
				// Generate event notifying of service deletion
				eFactory.getManager().sendNow(createEvent(EventConstants.DELETE_NODE_EVENT_UEI, 
						deleteDate,
						nodeID,
						null, 
						null));
			
                                if (log.isDebugEnabled())
				        log.debug("Sent delete node event to eventd for: " + nodeID);
			}
                        if (generateDeleteInterfaceEvent)
		        {
				// Generate event notifying of service deletion
				eFactory.getManager().sendNow(createEvent(EventConstants.DELETE_INTERFACE_EVENT_UEI, 
						deleteDate,
						nodeID,
						ipAddr, 
						null));
			
                                if (log.isDebugEnabled())
				        log.debug("Sent delete interface event to eventd for: "
                                                + nodeID + "/" + ipAddr);
			}
                        
                        if (generateForceNodeRescanEvent)
		        {
				// Generate event notifying of service deletion
				eFactory.getManager().sendNow(createEvent(EventConstants.FORCE_RESCAN_EVENT_UEI, 
						deleteDate,
						nodeID,
						ipAddr, 
						serviceName));
			
                                if (log.isDebugEnabled())
				        log.debug("Sent force rescan event to eventd on node:" + nodeID);
			}
		}
		catch(Throwable t)
		{
			log.error("Failed to send new event(s) to eventd", t);
		}
	}

