	/**
	 * <P>Poll the specified address for ICMP service availability.</P>
	 *
	 * <P>The ICMP service monitor relies on Discovery for the actual
	 * generation of IMCP 'ping' requests.  A JSDT session with two
	 * channels (send/recv) is utilized for passing poll requests and
	 * receiving poll replies from discovery.  All exchanges are
	 * SOAP/XML compliant.</P>
	 *
	 * @param iface		The network interface to test the service on.
	 * @param parameters	The package parameters (timeout, retry, etc...) to be 
	 *  used for this poll.
	 *
	 * @return The availibility of the interface and if a transition event
	 * 	should be supressed.
	 *
	 */
	public int poll(NetworkInterface iface, Map parameters, org.opennms.netmgt.config.poller.Package pkg) 
	{
		// Get interface address from NetworkInterface
		//
		if (iface.getType() != iface.TYPE_IPV4)
			throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

		Category log = ThreadCategory.getInstance(this.getClass());

		// get parameters
		//
		int retry = ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
		int timeout = ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);
		String rrdPath = ParameterMap.getKeyedString(parameters, "rrd-repository", null);
                String dsName = ParameterMap.getKeyedString(parameters, "ds-name", null);

		if (rrdPath == null)
		{
			log.info("poll: RRD repository not specified in parameters, latency data will not be stored.");
		}
                if (dsName == null)
                {
                        dsName = DS_NAME;
                }
		
		// Find an appropritate thread id
		//
		Long tidKey = null;
		long tid = (long)Thread.currentThread().hashCode();
		synchronized(m_waiting)
		{
			while(m_waiting.containsKey(tidKey = new Long(tid)))
				++tid;
		}


		InetAddress ipv4Addr = (InetAddress)iface.getAddress();
		DatagramPacket pkt   = getDatagram(ipv4Addr, tid);
		Ping reply           = new Ping(ipv4Addr);
		m_waiting.put(tidKey, reply);

		int serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
		for(int attempts = 0; attempts <= retry && !reply.isSignaled(); ++attempts)
		{
			// Send the datagram and wait
			//
			synchronized(reply)
			{
				try
				{
					m_icmpSock.send(pkt);
				}
				catch(IOException ioE)
				{
					log.info("Failed to send to address " + ipv4Addr, ioE);
					break;
				}
				catch(Throwable t)
				{
					log.info("Undeclared throwable exception caught sending to " + ipv4Addr, t);
					break;
				}
			
				try
				{
					reply.wait(timeout);
				}
				catch(InterruptedException ex)
				{
					// interrupted so return, reset interrupt.
					//
					Thread.currentThread().interrupt();
					break;
				}
			}
		}

		m_waiting.remove(tidKey);

		if(reply.isSignaled())
		{
			serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;
			
			// Determine round-trip-time for the ping packet
			Packet replyPkt = reply.getPacket();
			if (replyPkt != null)
			{
                                long rtt = replyPkt.getPingRTT();
                                log.debug("Ping round trip time for " + ipv4Addr + ": " + rtt + "us");

                                // Store round-trip-time in RRD database
                                if (rtt >= 0 && rrdPath != null)
				{
					try
					{
	                                        this.updateRRD(m_rrdInterface, rrdPath, ipv4Addr, dsName, rtt, pkg);
					}
					catch(RuntimeException rex)
					{
						log.debug("There was a problem writing the RRD:" + rex);
					}
				}
			}
		}
		
		return serviceStatus;
	}

