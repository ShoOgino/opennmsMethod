    /**
     * Verifies that the result of the SNMP query meets the criteria specified by the
     * operator and the operand from the configuartion file.
     * 
     * @param result
     * @param operator
     * @param operand
     * @return
     */
    public boolean meetsCriteria(SnmpSyntax result, String operator, String operand) {
        if (result == null)
            return false;
        
        if (operator == null || operand == null)
            return true;

        String value = result.toString();
        if (EQUALS.equals(operator))
            return operand.equals(value);
        else if (NOT_EQUAL.equals(operator))
            return !operand.equals(value);
        else if (MATCHES.equals(operator))
            return Pattern.compile(operand).matcher(value).find();
        
        
        BigInteger val = null;
        switch (result.typeId()) {
        case SnmpSMI.SMI_INTEGER:
            val = BigInteger.valueOf(((SnmpInt32)result).getValue());
            break;
        case SnmpSMI.SMI_COUNTER64:
            val = ((SnmpCounter64)result).getValue();
            break;
        case SnmpSMI.SMI_GAUGE32:
        case SnmpSMI.SMI_TIMETICKS:
        case SnmpSMI.SMI_COUNTER32:
            val = BigInteger.valueOf(((SnmpUInt32)result).getValue());
            break;
        default:
            val = new BigInteger(result.toString());
            break;
        }
        
        BigInteger intOperand = new BigInteger(operand);
        if (LESS_THAN.equals(operator)) {
            return val.compareTo(intOperand) < 0;
        } else if (LESS_THAN_EQUALS.equals(operator)) {
            return val.compareTo(intOperand) <= 0;
        } else if (GREATER_THAN.equals(operator)) {
            return val.compareTo(intOperand) > 0;
        } else if (GREATER_THAN_EQUALS.equals(operator)) {
            return val.compareTo(intOperand) >= 0;
        } else {
            throw new IllegalArgumentException("operator "+operator+" is unknown");
        }
    }

