    /**
     * <P>
     * Invokes a poll of the service.
     * </P>
     * 
     * If the service changes status then node outage processing will be invoked
     * and the status of the entire interface will be evaluated.
     */
    public synchronized int poll(PollableService pSvc) {
        Category log = ThreadCategory.getInstance(getClass());

        m_statusChangedFlag = false;

        int svcStatus = Pollable.STATUS_UNKNOWN;

        // Get configured critical service
        String criticalSvcName = getPollerConfig().getCriticalService();
        if (log.isDebugEnabled())
            log.debug("poll: polling interface " + m_address.getHostAddress() + " status=" + Pollable.statusType[getStatus()] + " (criticalSvc= " + criticalSvcName + ")");

        // If no critical service defined then retrieve the
        // value of the 'pollAllIfNoCriticalServiceDefined' flag
        boolean pollAllServices = true;
        if (criticalSvcName == null) {
            pollAllServices = getPollerConfig().pollAllIfNoCriticalServiceDefined();
            if (log.isDebugEnabled())
                log.debug("poll: pollAllServices (since no critical svc defined) flag: " + pollAllServices);
        }

        // Polling logic if interface is currently DOWN
        //
        // Remember if critical service is defined and the interface is DOWN
        // we only poll the critical service (provided that the interface
        // actually supports the critical service).
        //
        if (getStatus() == Pollable.STATUS_DOWN) {
            // Critical service defined and supported by interface
            if (criticalSvcName != null && this.supportsService(criticalSvcName)) {
                PollableService criticalSvc = null;

                // Service to be polled is critical service?
                if (pSvc.getServiceName().equals(criticalSvcName)) {
                    // Issue poll
                    svcStatus = pSvc.getSchedule().poll();
                    criticalSvc = pSvc;
                } else {
                    // This may be the first time this status has been
                    // polled since the interface was found to be DOWN
                    // (since it only takes the critical service being DOWN
                    // for the entire interface to be seen as DOWN) so go
                    // ahead and set the status on this service to DOWN.
                    pSvc.updateStatus(Pollable.STATUS_DOWN);

                    /*
                     * -------------------------------------------- Commenting
                     * this logic out for now, need to implement code to create
                     * PollableServiceProxy objects and this doesn't fit in well
                     * with that...will revisit this afterwards.
                     * -------------------------------------------- 
                     * // Determine if we need to repoll the critical 
                     * // service using the statement: 
                     * // NOW - T:critical >= I:svc 
                     * // where 
                     * // NOW = current time 
                     * // T:critical= time critical svc last polled 
                     * // I:svc = current poll interval for scheduled svc 
                     * // 
                     * // If the statement resolves to true we should go 
                     * // ahead and repoll the critical svc otherwise 
                     * // simply return.criticalSvc.getLastPollTime() 
                     * criticalSvc = this.getService(criticalSvcName); if (criticalSvc !=
                     * null) { long timeSinceLastCriticalPoll =
                     * System.currentTimeMillis() -
                     * criticalSvc.getLastPollTime(); if (log.isDebugEnabled())
                     * log.debug("poll: timeSinceLastCriticalPoll=" +
                     * timeSinceLastCriticalPoll + " interval for " +
                     * pSvc.getInterface().getAddress().getHostAddress() + "/" +
                     * pSvc.getServiceName() + " is " +
                     * pSvc.getLastScheduleInterval()); if (
                     * timeSinceLastCriticalPoll >=
                     * pSvc.getLastScheduleInterval()) { // Re-poll critical svc
                     * if (log.isDebugEnabled()) log.debug("poll: re-polling
                     * critical service..."); svcStatus = criticalSvc.poll(); } }
                     * ------------------------------------------------
                     */
                }

                if (svcStatus == Pollable.STATUS_UP && criticalSvc.statusChanged()) {
                    // Mark interface as up and poll all remaining
                    // services on this interface
                    //
                    setStatus(Pollable.STATUS_UP);
                    m_statusChangedFlag = true;

                    Iterator iter = m_services.values().iterator();
                    while (iter.hasNext()) {
                        PollableService svc = (PollableService) iter.next();

                        // Skip critical service since already polled
                        if (svc == criticalSvc)
                            continue;

                        // Poll the service
                        int tmpStatus = svc.getSchedule().poll();

                        // If status of non-critical service changes to UP
                        // then create PollableServiceProxy object and
                        // reschedule the proxy service at the
                        // appropriate interval
                        //
                        // PollableServiceProxy is a lightweight object which
                        // encapsulates the PollableService object and allows us
                        // to reschedule the service to be polled at the
                        // appropriate
                        // interval until the scheduler schedules the
                        // PollableService
                        // object and it is updated with an interval based on
                        // its new status.
                        if (tmpStatus == Pollable.STATUS_UP) {
                            svc.adjustSchedule();
                        }
                    }

                    // Iterate over pollable services list, poll
                    // any remaining services which match this node/interface
                    // combination, and then reschedule them via the
                    // PollableServiceProxy.
                    synchronized (m_pollableServices) {
                        iter = m_pollableServices.iterator();
                        while (iter.hasNext()) {
                            PollableService tmp = (PollableService) iter.next();
                            InetAddress addr = (InetAddress) tmp.getAddress();
                            if (addr.equals(m_address)) {
                                if (!m_services.containsValue(tmp)) {
                                    int tmpStatus = tmp.getSchedule().poll();
                                    if (tmpStatus == Pollable.STATUS_UP) {
                                        tmp.adjustSchedule();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Critical svc not defined or not supported by interface.
            else {
                // Issue poll
                svcStatus = pSvc.getSchedule().poll();
                if (svcStatus == Pollable.STATUS_UP && pSvc.statusChanged()) {
                    // Mark interface as up
                    setStatus(Pollable.STATUS_UP);
                    m_statusChangedFlag = true;

                    // Check flag which controls whether all services
                    // are polled if no critical service is defined
                    if (pollAllServices) {
                        // Poll all remaining services on the interface
                        Iterator iter = m_services.values().iterator();

                        while (iter.hasNext()) {
                            PollableService svc = (PollableService) iter.next();
                            // Skip service that was just polled
                            if (svc == pSvc)
                                continue;
                            svc.getSchedule().poll();
                        }
                    }
                }
            }
        }
        // Polling logic if interface is currently UP
        //
        else if (getStatus() == Pollable.STATUS_UP) {
            // Issue poll
            svcStatus = pSvc.getSchedule().poll();
            if (svcStatus == Pollable.STATUS_DOWN && pSvc.statusChanged()) {
                // If this is the only service supported by
                // the interface mark it as down
                if (m_services.size() == 1) {
                    setStatus(Pollable.STATUS_DOWN);
                    m_statusChangedFlag = true;
                }
                // else if Critical service defined and supported by interface
                // (regardless of pkg)
                else if (criticalSvcName != null && this.supportsService(criticalSvcName)) {
                    // Retrieve critical service PollableService object
                    // and poll it.
                    if (log.isDebugEnabled())
                        log.debug("poll: status changed to DOWN, now polling critical svc...");
                    PollableService criticalSvc = this.findService(criticalSvcName);

                    // If the service we just polled WAS in fact the critical
                    // service
                    // then no need to poll it again...the interface is DOWN!
                    int criticalSvcStatus = Pollable.STATUS_UNKNOWN;
                    if (pSvc == criticalSvc) {
                        criticalSvcStatus = svcStatus;
                    } else {
                        criticalSvcStatus = criticalSvc.getSchedule().poll();
                    }

                    if (criticalSvcStatus == Pollable.STATUS_DOWN) {
                        if (log.isDebugEnabled())
                            log.debug("poll: critical svc DOWN, interface is down!");
                        setStatus(Pollable.STATUS_DOWN);
                        m_statusChangedFlag = true;
                    } else {
                        if (log.isDebugEnabled())
                            log.debug("poll: critical svc UP, interface still up!");
                    }
                }
                // else if no critical service or critical service not supported
                else {
                    // Check flag which controls whether all services
                    // are polled if no critical service is defined
                    if (pollAllServices) {
                        // Poll all remaining services on the interface
                        // If all services are DOWN then mark the interface DOWN
                        boolean allSvcDown = true;
                        Iterator iter = m_services.values().iterator();

                        while (iter.hasNext()) {
                            PollableService tmpSvc = (PollableService) iter.next();
                            // Skip service that was already polled
                            if (tmpSvc == pSvc)
                                continue;
                            int tmpStatus = tmpSvc.getSchedule().poll();
                            if (tmpStatus == Pollable.STATUS_UP) {
                                allSvcDown = false;
                            }
                        }

                        if (allSvcDown) {
                            setStatus(Pollable.STATUS_DOWN);
                            m_statusChangedFlag = true;
                        }
                    }
                }
            }
        }

        if (log.isDebugEnabled())
            log.debug("poll: poll of interface " + m_address.getHostAddress() + " completed, status= " + Pollable.statusType[getStatus()]);
        return getStatus();
    }

