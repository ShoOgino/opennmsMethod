    /**
     * @return
     */
    long recalculateInterval() {
        Category log = ThreadCategory.getInstance(getClass());
    
        // If poll immediate flag is set the service hasn't
        // been polled yet. Return 0 to cause an immediate
        // poll of the interface.
        if (isPollImmediate()) {
            return 0;
        }
    
        long when = getServiceConfig().getService().getInterval();
        long downSince = 0;
        if (m_svc.getStatus() == PollStatus.STATUS_DOWN)
            downSince = System.currentTimeMillis() - m_svc.getStatusChangeTime();
    
        if (log.isDebugEnabled())
            log.debug("recalculateInterval for " + m_svc + " : " + " status= " + m_svc.getStatus() + " downSince= " + downSince);
    
        if (m_svc.getStatus() == PollStatus.STATUS_DOWN) {
            boolean matched = false;
            Enumeration edowntime = m_svcConfig.getPackage().enumerateDowntime();
            while (edowntime.hasMoreElements()) {
                Downtime dt = (Downtime) edowntime.nextElement();
                if (dt.getBegin() <= downSince) {
                    if (dt.getDelete() != null && (dt.getDelete().equals("yes") || dt.getDelete().equals("true"))) {
                        when = -1;
                        matched = true;
                    }
                    // FIXME: the below is a subtle bug... should be downSince
                    // not m_statusChangeTime it is masked by the fact we go thru to 
                    // loop more than once and reset the values
                    else if (dt.hasEnd() && dt.getEnd() > m_svc.getStatusChangeTime()) {
                        // in this interval
                        //
                        when = dt.getInterval();
                        matched = true;
                    } else // no end
                    {
                        when = dt.getInterval();
                        matched = true;
                    }
                }
            }
            if (!matched) {
                log.warn("recalculateInterval: Could not locate downtime model, throwing runtime exception");
                throw new RuntimeException("Downtime model is invalid, cannot schedule service " + m_svc);
            }
        }
        else if (m_svc.getStatus() != PollStatus.STATUS_UP) {
            log.warn("recalculateInterval: invalid status found, downtime model lookup failed. throwing runtime exception");
            throw new RuntimeException("Invalid Polling Status for service " + m_svc + ", status = " + m_svc.getStatus());
        }
    
        if (log.isDebugEnabled())
            log.debug("recalculateInterval: new scheduling interval for " + m_svc + " = " + when);
        return when;
    }

