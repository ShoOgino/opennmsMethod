	/**
	 * This method is used to return the next interval for this
	 * interface. If the interval is zero then this service 
	 * has never run and should be scheduled immediantly. If the
	 * time is -1 then the node should be deleted. Otherwise the
	 * appropriate scheduled time is returned.
	 *
	 * @throws java.lang.RuntimeException Throws if the ready
	 * 	time cannot be computed due to invalid downtime model.
	 */
	long recalculateInterval()
	{
		Category log = ThreadCategory.getInstance(getClass());

		// If poll immediate flag is set the service hasn't
		// been polled yet.  Return 0 to cause an immediate 
		// poll of the interface.
		if (m_pollImmediate)
		{
			return 0;
		}
		
		long when = m_service.getInterval();
		long downSince = 0;
		if (m_status == ServiceMonitor.SERVICE_UNAVAILABLE)
			downSince = System.currentTimeMillis() - m_statusChangeTime;
		 
		if (log.isDebugEnabled())
			log.debug("recalculateInterval for " + 
				m_pInterface.getAddress().getHostAddress() + "/" + m_service.getName() + " : " +
				" status= " + Pollable.statusType[m_status] +  
				" downSince= " + downSince);

		switch(m_status)
		{
			case ServiceMonitor.SERVICE_AVAILABLE:
				break;
	
			case ServiceMonitor.SERVICE_UNAVAILABLE:
				boolean matched = false;
				Enumeration edowntime = m_package.enumerateDowntime();
				while(edowntime.hasMoreElements())
				{
					Downtime dt = (Downtime)edowntime.nextElement();
					if(dt.getBegin() <= downSince)
					{
						if(dt.getDelete() != null && (dt.getDelete().equals("yes") || dt.getDelete().equals("true")))
						{
							when    = -1;
							matched = true;
						}
                        // FIXME: the below is a subtle bug... should be downSince not m_statusChangeTime
                        // it is masked by the fact we go thru to loop more than once and reset the values
						else if(dt.hasEnd() && dt.getEnd() > m_statusChangeTime)
						{
							// in this interval
							//
							when = dt.getInterval();
							matched = true;
						}
						else // no end
						{
							when = dt.getInterval();
							matched = true;
						}
					}
				}
				if(!matched)
				{
					log.warn("recalculateInterval: Could not locate downtime model, throwing runtime exception");
					throw new RuntimeException("Downtime model is invalid, cannot schedule interface "
								   + m_pInterface.getAddress().getHostAddress() + ", service = "
								   + m_service.getName());
				}
	
				break;
	
			default:
				log.warn("recalculateInterval: invalid status found, downtime model lookup failed. throwing runtime exception");
				throw new RuntimeException("Invalid Polling Status for interface " + m_pInterface.getAddress().getHostAddress() 
							   + ", service = " + m_service.getName() + ", status = " + m_status);

		} // end switch()
		
		if (log.isDebugEnabled())
			log.debug("recalculateInterval: new scheduling interval for " + 
					m_pInterface.getAddress().getHostAddress() + "/" +
					m_service.getName() + " = " + when);
		return when;
	}

