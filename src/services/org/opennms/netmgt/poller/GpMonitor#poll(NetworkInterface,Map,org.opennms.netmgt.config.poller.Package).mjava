	/**
	 * Poll the specified address for service availability.
	 *
	 * During the poll an attempt is made to call the specified
	 * external script or program.  If the connection request is
	 * successful, the banner line returned as standard output by
	 * the script or program is parsed for a partial match with
	 * the banner string specified in the poller configuration.
	 * Provided that the script's response is valid we set the
	 * service status to SERVICE_AVAILABLE and return.
	 *
	 * The timeout is handled by ExecRunner and is also passed
	 * as a parameter to the script or program being called.
	 *
	 * @param iface		The network interface to test the service on.
	 * @param parameters	The package parameters (timeout, retry, etc...)
	 * to be used for this poll.
	 *
	 * @return The availibility of the interface and if a transition event
	 * 	should be supressed.
	 *
	 * @throws java.lang.RuntimeException Thrown if the interface
	 * experiences error during the poll.
	 */
	public int poll(NetworkInterface iface, Map parameters, org.opennms.netmgt.config.poller.Package pkg) 
	{
		//
		// Process parameters
		//
		Category log = ThreadCategory.getInstance(getClass());

		//
		// Get interface address from NetworkInterface
		//
		if (iface.getType() != NetworkInterface.TYPE_IPV4)
			throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

		int retry = ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
		int timeout = ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);
		//
		// convert timeout to seconds for ExecRunner
		//
		if (0 < timeout && timeout < 1000)
			timeout = 1;
		else
			timeout = timeout/1000;
                String rrdPath = ParameterMap.getKeyedString(parameters, "rrd-repository", null);
                String dsName = ParameterMap.getKeyedString(parameters, "ds-name", null);

                if (rrdPath == null || dsName == null)
                {
                        log.info("poll: RRD repository and/or ds-name not specified in parameters, latency data will not be stored.");
                }

                String args = ParameterMap.getKeyedString(parameters, "args", null);

		// Script
		//
		String script = ParameterMap.getKeyedString(parameters, "script", null);
		if(script == null)
		{
			throw new RuntimeException("GpMonitor: required parameter 'script' is not present in supplied properties.");
		}
		
		// BannerMatch
		//
		String strBannerMatch = (String)parameters.get("banner");

		// Get the address instance.
		//
		InetAddress ipv4Addr = (InetAddress)iface.getAddress();

		if(log.isDebugEnabled())
			log.debug("poll: address = " + ipv4Addr.getHostAddress()
				  + ", script = " + script + ", arguments = " + args
				  + ", timeout(seconds) = " + timeout + ", retry = " + retry);

		// Give it a whirl
		//
		int serviceStatus = SERVICE_UNAVAILABLE;
                long responseTime = -1;

		for (int attempts=0; attempts <= retry && serviceStatus != SERVICE_AVAILABLE; attempts++)
		{
			try
			{
				long sentTime = System.currentTimeMillis();
				
				int exitStatus = 100;
				ExecRunner er = new ExecRunner();
				er.setMaxRunTimeSecs(timeout);
				if (args == null)
					exitStatus = er.exec(script + " --hostname " + ipv4Addr.getHostAddress() + " --timeout " +timeout);
				else
					exitStatus = er.exec(script + " --hostname " + ipv4Addr.getHostAddress() + " --timeout " +timeout + " " + args);
				if (exitStatus != 0)
				{
					log.debug(script + " failed with exit code " + exitStatus);
					serviceStatus = SERVICE_UNAVAILABLE;
				}
				if (er.isMaxRunTimeExceeded())
					{
						log.debug(script + " failed. Timeout exceeded");
						serviceStatus = SERVICE_UNAVAILABLE;
					}
				else
				{
					if (exitStatus == 0)
					{
						String scriptoutput = "";
						scriptoutput = er.getOutString();
						String scripterror = "";
						scripterror = er.getErrString();
                                        	if (!scriptoutput.equals(""))
							log.debug(script + " output  = " + scriptoutput);
						else
							log.debug(script + " returned no output");
                                        	if (!scripterror.equals(""))
							log.debug(script + " error = " + scripterror);
						if (strBannerMatch == null || strBannerMatch.equals("*"))
							serviceStatus = SERVICE_AVAILABLE;
						else
						{
							if (scriptoutput.indexOf(strBannerMatch) > -1)
							{
								serviceStatus = SERVICE_AVAILABLE;
							}
							else serviceStatus = SERVICE_UNRESPONSIVE;
						}
						if (serviceStatus == SERVICE_AVAILABLE)
						{
							responseTime = System.currentTimeMillis() - sentTime;
							if(log.isDebugEnabled())
							{
								log.debug("poll: responseTime = " + responseTime + "ms");
							}
							if (responseTime >= 0 && rrdPath != null && dsName != null)
							{
								this.updateRRD(m_rrdInterface, rrdPath, ipv4Addr, dsName, responseTime, pkg);
							}
						}
					}
				}

			}
			catch(ArrayIndexOutOfBoundsException e)
			{
				e.fillInStackTrace();
				log.debug(script + " ArrayIndexOutOfBoundsException");
			}
			catch(IOException e)
			{
				e.fillInStackTrace();
				log.debug("IOException occurred. Check for proper operation of " + script);
			}
			catch(Exception e)
			{
				e.fillInStackTrace();
				log.debug(script + "Exception occurred");
			}
		}
	
		//
		// return the status of the service
		//
		log.debug("poll: GP - serviceStatus= " +serviceStatus + "  " + ipv4Addr.getHostAddress());
		return serviceStatus;
	}

