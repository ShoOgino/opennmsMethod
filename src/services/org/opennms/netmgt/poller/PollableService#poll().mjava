    /**
     * <P>
     * Invokes a poll of the service via the ServiceMonitor.
     * </P>
     */
    public int poll() {
        Category log = ThreadCategory.getInstance(getClass());

        m_lastPoll = System.currentTimeMillis();
        m_statusChangedFlag = false;
        if (log.isDebugEnabled())
            log.debug("poll: starting new poll for " + this + ":" + getPackageName());

        // Poll the interface/service pair via the service monitor
        //
        int status = ServiceMonitor.SERVICE_UNAVAILABLE;
        Map propertiesMap = getSvcConfig().getPropertyMap();
        try {
            status = m_monitor.poll(m_netInterface, propertiesMap, getSvcConfig().getPackage());
            if (log.isDebugEnabled())
                log.debug("poll: polled for " + this + ":" + getPackageName()+" with result: " + Pollable.statusType[status]);
        } catch (NetworkInterfaceNotSupportedException ex) {
            log.error("poll: Interface " + getAddress().getHostAddress() + " Not Supported!", ex);
            return status;
        } catch (Throwable t) {
            log.error("poll: An undeclared throwable was caught polling interface " + getAddress().getHostAddress(), t);
        }

        // serviceUnresponsive behavior disabled?
        //
        if (!getPollerConfig().serviceUnresponsiveEnabled()) {
            // serviceUnresponsive behavior is disabled, a status
            // of SERVICE_UNRESPONSIVE is treated as SERVICE_UNAVAILABLE
            if (status == ServiceMonitor.SERVICE_UNRESPONSIVE)
                status = ServiceMonitor.SERVICE_UNAVAILABLE;
        } else {
            // Update unresponsive flag based on latest status
            // returned by the monitor and generate serviceUnresponsive
            // or serviceResponsive event if necessary.
            //
            switch (status) {
            case ServiceMonitor.SERVICE_UNRESPONSIVE:
                // Check unresponsive flag to determine if we need
                // to generate a 'serviceUnresponsive' event.
                //
                if (m_unresponsiveFlag == false) {
                    m_unresponsiveFlag = true;
                    sendEvent(EventConstants.SERVICE_UNRESPONSIVE_EVENT_UEI, propertiesMap);

                    // Set status back to available, don't want unresponsive
                    // service to generate outage
                    status = ServiceMonitor.SERVICE_AVAILABLE;
                }
                break;

            case ServiceMonitor.SERVICE_AVAILABLE:
                // Check unresponsive flag to determine if we
                // need to generate a 'serviceResponsive' event
                if (m_unresponsiveFlag == true) {
                    m_unresponsiveFlag = false;
                    sendEvent(EventConstants.SERVICE_RESPONSIVE_EVENT_UEI, propertiesMap);
                }
                break;

            case ServiceMonitor.SERVICE_UNAVAILABLE:
                // Clear unresponsive flag
                m_unresponsiveFlag = false;
                break;

            default:
                break;
            }
        }

        // Any change in status?
        //
        if (status != getStatus()) {
            // get the time of the status change
            //
            m_statusChangedFlag = true;
            setStatusChangeTime(System.currentTimeMillis());

            // Is node outage processing disabled?
            if (!getPollerConfig().nodeOutageProcessingEnabled()) {
                // node outage processing disabled, go ahead and generate
                // transition events.
                if (log.isDebugEnabled())
                    log.debug("poll: node outage disabled, status change will trigger event.");

                // Send the appropriate event
                //
                switch (status) {
                case ServiceMonitor.SERVICE_AVAILABLE: // service up!
                    sendEvent(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI, propertiesMap);
                    break;

                case ServiceMonitor.SERVICE_UNAVAILABLE: // service down!
                    sendEvent(EventConstants.NODE_LOST_SERVICE_EVENT_UEI, propertiesMap);
                    break;

                default:
                    break;
                }
            }
        }

        // Set status
        setStatus(status);

        m_schedule.setPollImmediate(false);

        // Reschedule the interface
        // 
        // NOTE: rescheduling now handled by PollableService.run()
        // reschedule(false);

        return getStatus();
    }

