	/**
	 * <P>Invokes a poll of the service via the ServiceMonitor.</P>
	 */
	public int poll()
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		m_lastPoll = System.currentTimeMillis();
		m_statusChangedFlag = false;
		InetAddress addr = (InetAddress)m_pInterface.getAddress();
		
		if (log.isDebugEnabled())
			log.debug("poll: starting new poll for " + addr.getHostAddress() + 
					"/" + m_service.getName() + "/" + m_package.getName());
		
		// Poll the interface/service pair via the service monitor
		//
		int status = ServiceMonitor.SERVICE_UNAVAILABLE;
		Map propertiesMap = (Map)SVC_PROP_MAP.get(m_svcPropKey);
		try
		{
			status = m_monitor.poll(this, propertiesMap);
		}
		catch(NetworkInterfaceNotSupportedException ex)
		{
			log.error("poll: Interface " + addr.getHostAddress() + " Not Supported!", ex);
			return status;
		}
		catch(Throwable t)
		{
			log.error("poll: An undeclared throwable was caught polling interface " + addr.getHostAddress(), t);
		}
		
		// serviceUnresponsive behavior disabled?
                //
                if (!PollerConfigFactory.getInstance().serviceUnresponsiveEnabled())
                {
                        // serviceUnresponsive behavior is disabled, a status
                        // of SERVICE_UNRESPONSIVE is treated as SERVICE_UNAVAILABLE
                        if (status == ServiceMonitor.SERVICE_UNRESPONSIVE)
                                status = ServiceMonitor.SERVICE_UNAVAILABLE;
                }
                else
                {
			// Update unresponsive flag based on latest status
			// returned by the monitor and generate serviceUnresponsive
			// or serviceResponsive event if necessary.
			//
			switch (status)
			{
				case ServiceMonitor.SERVICE_UNRESPONSIVE: 
					// Check unresponsive flag to determine if we need
					// to generate a 'serviceUnresponsive' event.
					//
					if (m_unresponsiveFlag == false )
					{
						m_unresponsiveFlag = true;
						sendEvent(EventConstants.SERVICE_UNRESPONSIVE_EVENT_UEI, propertiesMap);
						
						// Set status back to available, don't want unresponsive 
						// service to generate outage
						status = ServiceMonitor.SERVICE_AVAILABLE;
					}
					break;
			
				case ServiceMonitor.SERVICE_AVAILABLE: 
					// Check unresponsive flag to determine if we
					// need to generate a 'serviceResponsive' event
					if (m_unresponsiveFlag == true)
					{
						m_unresponsiveFlag = false;
						sendEvent(EventConstants.SERVICE_RESPONSIVE_EVENT_UEI, propertiesMap);
					}
					break;
		
				case ServiceMonitor.SERVICE_UNAVAILABLE: 
					// Clear unresponsive flag
					m_unresponsiveFlag = false;
					break;
	
				default:
					break;
			}
		}
			
		// Any change in status?
		//
		if(status != m_status)
		{
			// get the time of the status change
			//
			m_statusChangedFlag = true;
			m_statusChangeTime = System.currentTimeMillis();
				
			// Is node outage processing disabled? 
			if (!PollerConfigFactory.getInstance().nodeOutageProcessingEnabled())
			{
				// node outage processing disabled, go ahead and generate
				// transition events.
				if (log.isDebugEnabled())
					log.debug("poll: node outage disabled, status change will trigger event.");
	
				// get the "qualifier" property from the properties map if it exists.
				// This is mainly used by HTTP at the moment.
				//
				String qualifier = (String)propertiesMap.get("qualifier");
	
				// Send the appropriate event
				//
				switch(status)
				{
				case ServiceMonitor.SERVICE_AVAILABLE: // service up!
					sendEvent(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI, propertiesMap);
					break;
	
				case ServiceMonitor.SERVICE_UNAVAILABLE: // service down!
					sendEvent(EventConstants.NODE_LOST_SERVICE_EVENT_UEI, propertiesMap);
					break;

				default:
					break;
				}
			}
		}

		// Set the new status
		m_status = status;
		
		// Reset poll immediate flag
		m_pollImmediate = false;
		
		// Reschedule the interface
		// 
		// NOTE: rescheduling now handled by PollableService.run()
		//reschedule(false);
			
		return m_status;
	}

