	private void scheduleExistingInterfaces()
		throws SQLException
	{
		// get the category logger 
		//
		Category log = ThreadCategory.getInstance();
		
		PollerConfigFactory pollerCfgFactory = PollerConfigFactory.getInstance();

		// Database connection
		java.sql.Connection dbConn = null;

		PreparedStatement stmt = null;
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();

			stmt = dbConn.prepareStatement(SQL_RETRIEVE_INTERFACES);
		
			// Loop through loaded monitors and schedule for each one present
			//
			Set svcNames = m_svcMonitors.keySet();
			Iterator i = svcNames.iterator();
			while (i.hasNext())
			{
				String svcName = (String)i.next();
				ServiceMonitor monitor = (ServiceMonitor)m_svcMonitors.get(svcName);
				
				if(log.isDebugEnabled())
					log.debug("scheduleExistingInterfaces: Scheduling existing interfaces for monitor: " + svcName);

				// Retrieve list of interfaces from the database which 
				// support the service polled by this monitor
				//
				try
				{
					if(log.isDebugEnabled())
						log.debug("scheduleExistingInterfaces: dbConn = " + dbConn + ", svcName = " + svcName);

					stmt.setString(1, svcName);    	// Service name
					ResultSet rs = stmt.executeQuery();

					// Iterate over result set and schedule each interface/service
					// pair which passes the criteria
					//
					while (rs.next())
					{
						int nodeId = rs.getInt(1);
						String ipAddress = rs.getString(2);

						PollerConfiguration pConfig = pollerCfgFactory.getConfiguration();
						Enumeration epkgs = pConfig.enumeratePackage();
						
						// Compare interface/service pair against each poller package
						// For each match, create new PollableService object and 
						// schedule it for polling.
						//
						while(epkgs.hasMoreElements())
						{
							org.opennms.netmgt.config.poller.Package pkg = (org.opennms.netmgt.config.poller.Package)epkgs.nextElement();

							// Make certain the the current service is in the package
							// and enabled!
							//
							if (!pollerCfgFactory.serviceInPackageAndEnabled(svcName, pkg))
							{
								if (log.isDebugEnabled())
									log.debug("scheduleExistingInterfaces: address/service: " + 
											ipAddress + "/" + svcName + 
											" not scheduled, service is not enabled or does not exist in package: " + 
											pkg.getName());
								continue;
							}

							// Is the interface in the package?
							//
							if (!pollerCfgFactory.interfaceInPackage(ipAddress, pkg))
							{
								if (log.isDebugEnabled())
									log.debug("scheduleExistingInterfaces: address/service: " + 
											ipAddress + "/" + svcName + 
											" not scheduled, interface does not belong to package: " + 
											pkg.getName());
								continue;
							}
							
							//
							// getServiceLostDate() method will return the date a service 
							// was lost if the service was last known to be unavailable or
							// will return null if the service was last known to be 
							// available...based on outage information on the 'outages' table.
							Date svcLostDate = getServiceLostDate(dbConn, nodeId, ipAddress, svcName);
							int lastKnownStatus = -1;
							if (svcLostDate != null)
							{
								lastKnownStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
								if (log.isDebugEnabled())
									log.debug("scheduleExistingInterfaces: address= " + ipAddress + 
											" svc= " + svcName + 
											" lastKnownStatus= unavailable" + 
											" svcLostDate= " + svcLostDate);
							}
							else
							{
								lastKnownStatus = ServiceMonitor.SERVICE_AVAILABLE;
								if (log.isDebugEnabled())
									log.debug("scheduleExistingInterfaces: address= " + ipAddress + 
											" svc= " + svcName + " lastKnownStatus= available");
							}
							
							// Criteria checks have all been padded...update Node Outage 
							// Hierarchy and create new service for polling
							//
							PollableNode pNode = null;
							PollableInterface pInterface = null;
							PollableService pSvc = null;
							boolean ownLock = false;
							boolean nodeCreated = false;
							boolean interfaceCreated = false;
							
							try
							{
								// Does the node already exist in the poller's pollable node map?
								//
								pNode = this.getNode(nodeId);
								if (pNode == null)
								{
									// Nope...so we need to create it
									pNode = new PollableNode(nodeId);
									nodeCreated = true;
								}
								else
								{
									// Obtain node lock
									//
									ownLock = pNode.getNodeLock(WAIT_FOREVER);
								}
								
								// Does the interface exist in the pollable node?
								//
								pInterface = pNode.getInterface(ipAddress);
								if (pInterface == null)
								{
									// Create the PollableInterface
									pInterface = new PollableInterface(pNode, InetAddress.getByName(ipAddress));
									interfaceCreated = true;
								}

								// Create a new PollableService representing this node, interface,
								// service and package pairing
								//
								pSvc = new PollableService(pInterface,
												svcName,
												pkg,
												lastKnownStatus,
												svcLostDate);

								// Initialize the service monitor with the pollable service 
								//
								monitor.initialize(pSvc);
				
								// Add new service to the pollable services list.
								//
								m_pollableServices.add(pSvc);
								
								// Add the service to the PollableInterface object
								//
								// WARNING:  The PollableInterface stores services in a map
								//           keyed by service name, therefore, only the LAST
								//           PollableService aded to the interface for a 
								//           particular service will be represented in the
								//           map.  THIS IS BY DESIGN.
								//
								// NOTE:     addService() calls recalculateStatus() on the interface
								log.debug("scheduleExistingInterfaces: adding pollable service to service list of interface: " + ipAddress);
								pInterface.addService(pSvc);
									
								if (interfaceCreated)
								{
									// Add the interface to the node
									//
									// NOTE:  addInterface() calls recalculateStatus() on the node
									if (log.isDebugEnabled())
										log.debug("scheduleExistingInterfaces: adding new pollable interface "
												 + ipAddress + " to pollable node " + nodeId);
									pNode.addInterface(pInterface);
								}
								else
								{
									// Recalculate node status
									//
									pNode.recalculateStatus();
								}
								
								if (nodeCreated)
								{
									// Add the node to the node map
									//
									if (log.isDebugEnabled())
										log.debug("scheduleExistingInterfaces: adding new pollable node: " + 
												nodeId);
									this.addNode(pNode);
								}
								
								// Schedule the service
								//
								m_scheduler.schedule(pSvc, pSvc.recalculateInterval());
							} 
							catch(UnknownHostException ex)
							{
								log.error("scheduleExistingInterfaces: Failed to schedule interface " + ipAddress + 
												" for service monitor " + svcName + ", illegal address", ex);
							}
							catch(InterruptedException ie)
							{
								log.error("scheduleExistingInterfaces: Failed to schedule interface " + ipAddress + 
												" for service monitor " + svcName + ", thread interrupted", ie);
							}
							catch(RuntimeException rE)
							{
								log.warn("scheduleExistingInterfaces: Unable to schedule " + 
										ipAddress + " for service monitor " + svcName + 
										", reason: " + rE.getMessage());
							}
							catch(Throwable t)
							{
								log.error("scheduleExistingInterfaces: Uncaught exception, failed to schedule interface "
										+ ipAddress + " for service monitor " + svcName, t);
							}
							finally
							{
								if (ownLock)
								{
									try
									{
										pNode.releaseNodeLock();
									}
									catch (InterruptedException iE)
									{
										log.error("scheduleExistingInterfaces: Failed to release node lock on nodeid " + 
												pNode.getNodeId() + ", thread interrupted.");
									}
								}
								
							}
						} // end while more packages exist
					} // end while more interfaces in result set

					rs.close();
				}
				catch (SQLException sqle)
				{
					log.warn("scheduleExistingInterfaces: SQL exception while querying ipInterface table", sqle);
					throw sqle;
				}
			} // end while more service monitors exist

			// Debug dump pollable node map content
			//
			if (log.isDebugEnabled())
			{
				log.debug("scheduleExistingInterfaces: dumping content of pollable node map: " );
				Iterator j = m_pollableNodes.values().iterator();
				while (j.hasNext())
				{
					PollableNode pNode = (PollableNode)j.next();
					log.debug("	nodeid=" + pNode.getNodeId() + " status=" + Pollable.statusType[pNode.getStatus()] );
					Iterator k = pNode.getInterfaces().iterator();
					while(k.hasNext())
					{
						PollableInterface pIf = (PollableInterface)k.next();
						log.debug("		interface=" + pIf.getAddress().getHostAddress() + " status=" + Pollable.statusType[pIf.getStatus()]);

						Iterator s = pIf.getServices().iterator();
						while(s.hasNext())
						{
							PollableService pSvc = (PollableService)s.next();
							log.debug("			service=" + pSvc.getServiceName() + " status=" + Pollable.statusType[pSvc.getStatus()]);
						}
					}
				}
			}
		}
		finally
		{
			if (stmt != null)
			{
				try
				{
					stmt.close();
				}
				catch (Exception e)
				{
					if(log.isDebugEnabled())
						log.debug("scheduleExistingInterfaces: an exception occured closing the SQL statement", e);
				}
			}

			if(dbConn != null)
			{
				try
				{
					dbConn.close();
				}
				catch(Throwable t)
				{
					if(log.isDebugEnabled())
						log.debug("scheduleExistingInterfaces: an exception occured closing the SQL connection", t);
				}
			}
		}
	}

