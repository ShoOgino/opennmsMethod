    /**
     * This used to be the implementation for the run() method. When we created
     * run(boolean), however, we needed to move the implementation down a level
     * lower so that we could overload the run() method.
     * 
     * @param allowedToRescheduleMyself
     *            set this to true if you want the pollable service to
     *            reschedule itself when done processing.
     * 
     * @throws LockUnavailableException
     *             If it was unable to obtain a node lock
     * @throws ThreadInterruped
     *             If the thread was interrtuped while waiting for a node lock.
     * 
     */
    void doRun(boolean allowedToRescheduleMyself) throws LockUnavailableException, InterruptedException {
        // Update last scheduled poll time if allowedToRescheduleMyself
        // flag is true
        if (allowedToRescheduleMyself)
            m_schedule.setLastScheduledPoll(System.currentTimeMillis());

        Category log = ThreadCategory.getInstance(getClass());

        // Is the service marked for deletion? If so simply return.
        //
        if (this.isDeleted()) {
            if (log.isDebugEnabled()) {
                log.debug("PollableService doRun: Skipping service marked as deleted on " + m_pInterface.getAddress().getHostAddress() + ", service = " + getServiceName() + ", status = " + getStatus());
            }
            return;
        }

        // NodeId
        int nodeId = m_pInterface.getNode().getNodeId();


        // Check scheduled outages to see if any apply indicating
        // that the poll should be skipped
        //
        if (getSvcConfig().scheduledOutage(this)) {
            // Outage applied...reschedule the service and return
            if (allowedToRescheduleMyself) {
                m_schedule.reschedule(true);
            }

            return;
        }

        // Is node outage processing enabled?
        if (getPollerConfig().nodeOutageProcessingEnabled()) {
            // Lookup PollableNode object using nodeId as index
            //
            // TODO: We alrady have the pollable node via the pollable interface
            PollableNode pNode = getPoller().findNode(nodeId);

            /*
             * Acquire lock to 'PollableNode'
             */
            boolean ownLock = false;
            try {
                // Attempt to obtain node lock...wait no longer than 500ms
                // We don't want to tie up the thread for long periods of time
                // waiting for the lock on the PollableNode to be released.
                if (log.isDebugEnabled())
                    log.debug("run: ------------- requesting node lock for nodeid: " + nodeId + " -----------");

                if (!(ownLock = pNode.getNodeLock(500)))
                    throw new LockUnavailableException("failed to obtain lock on nodeId " + nodeId);
            } catch (InterruptedException iE) {
                // failed to acquire lock
                throw new InterruptedException("failed to obtain lock on nodeId " + nodeId + ": " + iE.getMessage());
            }
            // Now we have a lock

            if (ownLock) // This is probably redundant, but better to be
                            // sure.
            {
                try {
                    // Make sure the node hasn't been deleted.
                    if (!pNode.isDeleted()) {
                        if (log.isDebugEnabled())
                            log.debug("run: calling poll() for " + nodeId + "/" + m_pInterface.getAddress().getHostAddress() + "/" + getServiceName());

                        pNode.poll(this);

                        if (log.isDebugEnabled())
                            log.debug("run: call to poll() finished for " + nodeId + "/" + m_pInterface.getAddress().getHostAddress() + "/" + getServiceName());
                    }
                } finally {
                    if (log.isDebugEnabled())
                        log.debug("run: ----------- releasing node lock for nodeid: " + nodeId + " ----------");
                    try {
                        pNode.releaseNodeLock();
                    } catch (InterruptedException iE) {
                        log.error("run: thread interrupted...failed to release lock on nodeId " + nodeId);
                    }
                }
            }
        } else {
            // Node outage processing disabled so simply poll the service
            if (log.isDebugEnabled())
                log.debug("run: node outage processing disabled, polling: " + m_pInterface.getAddress().getHostAddress() + "/" + getServiceName());
            this.poll();
        }

        // reschedule the service for polling
        if (allowedToRescheduleMyself) {
            m_schedule.reschedule(false);
        }

        return;
    }

