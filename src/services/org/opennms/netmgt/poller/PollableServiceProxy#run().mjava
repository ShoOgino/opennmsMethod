    /**
     * <P>
     * This is the main method of the class.
     * </P>
     * 
     * <P>
     * It passes a run() call through to the PollableService that it proxies,
     * and then makes a rescheduling decision on its behalf. If it encounters an
     * inability to finish processing on run() (such as a node lock unavailable
     * or an interrupted thread) it will reschedule itself to retry at 10
     * seconds.
     * </P>
     * 
     */
    public void run() {
        Category log = ThreadCategory.getInstance(getClass());

        // Check to see if the proxied service has caught up with the proxy
        if (System.currentTimeMillis() > this._service.getScheduledRuntime()) {
            log.debug("run: Proxied service got ahead of proxy.  politely going away.");
            return; // Return and politely go away
        }

        try {
            // Run the service, specifying that it should not reschedule itself
            log.debug("run: Proxy calling run() on the proxied service");
            this._service.run(false);

            // Calculate the interval and the next scheduled runtime
            long interval = this._service.recalculateInterval();
            this._scheduledRuntime = System.currentTimeMillis() + interval;

            /*
             * If the next scheduled runtime is sooner than the one scheduled
             * for the proxied pollable, then go ahead and register it with the
             * scheduler.
             */
            if (this._scheduledRuntime < this._service.getScheduledRuntime()) {
                log.debug("run: Proxy rescheduling itself at " + interval + " ms");
                getScheduler().schedule(this, interval);
            } else {
                log.debug("run: Proxied service will run before the next scheduled" + " time for the proxy.  Therefore, the proxy is politely" + " going away");
            }
        } catch (LockUnavailableException e) {
            log.debug("Lock unavailable; rescheduling at 10 seconds", e);
            getScheduler().schedule(this, 10000);
        } catch (InterruptedException e) {
            log.debug("Thread Interrupted; rescheduling at 10 seconds", e);
            getScheduler().schedule(this, 10000);
        }

        return;
    }

