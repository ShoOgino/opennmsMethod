	/** 
	 * This method is responsible for removing the node specified
	 * in the nodeDeleted event from the Poller's pollable node map.
	 */
	private void nodeDeletedHandler(Event event)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		int nodeId = (int)event.getNodeid();
		
		PollableNode pNode = Poller.getInstance().getNode(nodeId);
		if (pNode == null)  // Sanity check
		{
			log.error("Nodeid " + nodeId + " does not exist in pollable node map, unable to delete node.");
			return;
		}
		
		// acquire lock to 'PollableNode'
		//
		boolean ownLock = false;
		try
		{
			// Attempt to obtain node lock...wait as long as it takes.
			// 
			if (log.isDebugEnabled())
				log.debug("nodeDeletedHandler: deleting nodeId: " + nodeId);
	
			ownLock = pNode.getNodeLock(WAIT_FOREVER);
			if (ownLock)
			{
				if (log.isDebugEnabled())
					log.debug("nodeDeletedHandler: obtained node lock for nodeid: " + nodeId);
			
				// Remove the node from the Poller's node map
				Poller.getInstance().removeNode(nodeId);
				
				// Iterate over the node's interfaces and delete
				// all services on each interface.
				Iterator iter = pNode.getInterfaces().iterator();
				while (iter.hasNext())
				{
					PollableInterface pIf = (PollableInterface)iter.next();
					
					// Iterate over the interface's services and mark
					// them for deletion.
					Iterator svc_iter = pIf.getServices().iterator();
					while (svc_iter.hasNext())
					{
						PollableService pSvc = (PollableService)svc_iter.next();
						pSvc.markAsDeleted();
						
						// Now remove the service from the pollable services list
						m_pollableServices.remove(pSvc);
					}
					
					// Delete all entries from the interface's internal service map
					pIf.deleteAllServices();
				}
			
				// Delete all entries from the node's internal interface map
				pNode.deleteAllInterfaces();
				
				// Mark the node as deleted to prevent any further node 
				// outage processing on this node
				pNode.markAsDeleted();
				
				if (log.isDebugEnabled())
					log.debug("nodeDeletedHandler: deletion of nodeid " + pNode.getNodeId() + " completed.");
			}
			else
			{
				// failed to acquire lock
				log.error("nodeDeletedHandler: failed to obtain lock on nodeId " + nodeId);
			}
		}
		catch (InterruptedException iE)
		{
			// failed to acquire lock
			log.error("nodeDeletedHandler: thread interrupted...failed to obtain lock on nodeId " + nodeId);
		}
		catch (Throwable t)
		{
			log.error("exception caught processing nodeDeleted event for " + nodeId, t);
		}
		finally
		{
			if (ownLock)
			{
				if (log.isDebugEnabled())
					log.debug("nodeDeletedHandler: releasing node lock for nodeid: " + nodeId);
				try
				{
					pNode.releaseNodeLock();
				}
				catch (InterruptedException iE)
				{
					log.error("nodeDeletedHandler: thread interrupted...failed to release lock on nodeId " + nodeId);
				}
			}
		}
	}

