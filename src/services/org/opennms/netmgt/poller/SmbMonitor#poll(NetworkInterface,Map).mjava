	/**
	 * <P>Poll the specified address for response to NetBIOS name queries.</P>
	 *
	 * <P>During the poll ...</P>
	 *
	 * @param iface		The network interface to test the service on.
	 * @param parameters	The package parameters (timeout, retry, etc...) to be 
	 *  used for this poll.
	 *
	 * @return The availibility of the interface and if a transition event
	 * 	should be supressed.
	 *
	 */
	public int poll(NetworkInterface iface, Map parameters) 
	{
		// Get interface address from NetworkInterface
		//
		if (iface.getType() != iface.TYPE_IPV4)
			throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

		// get the logger
		//
		Category log = ThreadCategory.getInstance(getClass());

		// get parameters
		//
		int retry   = getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
		int timeout = getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);

		// Extract the address
		//
		InetAddress ipv4Addr = (InetAddress)iface.getAddress();

		// Default is a failed status
		//
		int serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;

		// Attempt to retrieve NetBIOS name of this interface in order
		// to determine if SMB is supported.
		//
		NbtAddress nbtAddr = null;
		try
		{
			// Debugging only
			/*
			if (m_logger.isDebugEnabled()) m_logger.debug("SmbMonitor.poll: configuring netbios logging ");
			jcifs.netbios.Log.setPrintWriter( new FileWriter( "/var/log/opennms/jcifs_netbios.log" ));
			if (m_logger.isDebugEnabled()) m_logger.debug("SmbMonitor.poll: configuring netbios logging mask");
			jcifs.netbios.Log.setMask(jcifs.util.Log.ALL);
			
			if (m_logger.isDebugEnabled()) m_logger.debug("SmbMonitor.poll: configuring smb logging ");
			jcifs.smb.Log.setPrintWriter( new FileWriter( "/var/log/opennms/jcifs_smb.log" ));
			jcifs.smb.Log.setMask(jcifs.util.Log.ALL);
			*/
			// end debugging
			
			//
			// Don't fully understand why yet but it isn't enough to 
			// just call getByName().  getByName() will return a valid
			// NbtAddress object for an IP address for which it does not
			// successfully resolve a netbios name for...the netbios 
			// name in this case retrieved by calling getHostName()
			// is set to the node's IP address.  A subsequent call
			// to getNodeType() will however throw UnknownHostException
			// if the Netbios name is not resolved.
			//
			nbtAddr = NbtAddress.getByName(ipv4Addr.getHostAddress());
			int nodeType = nbtAddr.getNodeType();
			
			/*
			if(log.isDebugEnabled())
			{
				log.debug("Successfully created NbtAddress for " + ipv4Addr.toString() + ".  Netbios name= " + nbtAddr.toString());
				log.debug("      Host address: " + nbtAddr.getHostAddress());
				log.debug("      Netbios name: " + nbtAddr.getHostName());
				log.debug("      Node type: " + nodeType);
			}
			 */
						
			serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;
		}
		catch(UnknownHostException uhE)
		{
			if(log.isDebugEnabled())
				log.debug("poll: Unknown host exception generated for " + ipv4Addr.toString() + ", reason: " + uhE.getLocalizedMessage());
		}
		catch (IOException ioE)
		{
			if(log.isEnabledFor(Priority.ERROR))
				log.error("poll: IOException during SMB communication", ioE);
		}
		catch (RuntimeException rE)
		{
			if(log.isEnabledFor(Priority.ERROR))
				log.error("poll: Unexpected runtime exception", rE);
		}
		catch (Exception e)
		{
			if(log.isEnabledFor(Priority.ERROR))
				log.error("poll: Unexpected exception", e);
		}
	
		//
		// return the status of the service
		//
		return serviceStatus;
	}

