	/**
	 * Process the event, construct new PollableService object representing
 	 * the node/interface/service/pkg combination, and schedule all services
	 * on the specified interface for polling. 
	 * 
	 * If any errors occur scheduling the interface no error is returned, but 
         * any SQL Exception will cause the process to stop, and an error will be
         * logged.
	 *
	 * @param event	The event to process.
	 *
	 */
	private void restartPollingInterfaceHandler(Event event)
	{
                String ipaddr = event.getInterface();
                String sourceUei = event.getUei();

		Category log = ThreadCategory.getInstance(getClass());
		if (log.isDebugEnabled())
			log.debug("restartPollingInterfaceHandler: start process event for interface: " + ipaddr);

                // Extract node label and transaction No. from the event parms
                long txNo = -1L;
                Parms parms = event.getParms();
                if (parms != null)
                {
                        String parmName = null;
                        Value parmValue = null;
                        String parmContent = null;
                                                                                                                                                                     Enumeration parmEnum = parms.enumerateParm();
                        while(parmEnum.hasMoreElements())
                        {
                                Parm parm = (Parm)parmEnum.nextElement();
                                parmName  = parm.getParmName();
                                parmValue = parm.getValue();
                                if (parmValue == null)
                                        continue;
                                else
                                        parmContent = parmValue.getContent();

                                //  get the external transaction number
                                if (parmName.equals(EventConstants.PARM_TRANSACTION_NO))
                                {
                                        String temp = parmContent;
                                        if (log.isDebugEnabled())
                                                log.debug("restartPollingInterfaceHandler:  parmName: " + parmName
                                                        + " /parmContent: " + parmContent);
                                        try
                                        {
                                                txNo = Long.valueOf(temp).longValue();
                                        }
                                        catch (NumberFormatException nfe)
                                        {
                                                log.warn("restartPollingInterfaceHandler: Parameter " 
                                                        + EventConstants.PARM_TRANSACTION_NO
                                                        + " cannot be non-numberic", nfe);
                                                txNo = -1;
                                        }
                                }
                        }
                }

                boolean invalidParameters = (ipaddr == null);
                if (m_xmlrpc)
                        invalidParameters = invalidParameters || (txNo == -1L);

                if (invalidParameters)
                {
                        if (log.isDebugEnabled())
                                log.debug("restartPollingInterfaceHandler: Invalid parameters.");

                        if (m_xmlrpc)
                        {
                                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                createAndSendXmlrpcNotificationEvent(txNo, sourceUei, "Invalid parameters", status);
                        }
                }
		
                java.sql.Connection dbConn = null;
		PreparedStatement stmt = null;
		
		try
		{
			dbConn = DatabaseConnectionFactory.getInstance().getConnection();
		
                        // retrieve the nodeid
			stmt = dbConn.prepareStatement(SQL_RETRIEVE_NODE_ID);
	                int nodeid = -1;
                        
			stmt.setString(1, ipaddr);
			ResultSet rs = stmt.executeQuery();
			while(rs.next())
			{
				nodeid  = rs.getInt(1);
		                if (log.isDebugEnabled())
			                log.debug("restartPollingInterfaceHandler: retrieved the nodeid: " + nodeid 
                                                + " for interface: " + ipaddr);
			}

                        if (nodeid < 0)
                        {
                                log.error("restartPollingInterfaceHandler: node does not exist.");
                                if (m_xmlrpc)
                                {
                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                        createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                                                        "Node does not exist.", status);
                                }
                                return;
                        }        
		        stmt.close();
               
                        // Count active services to poll
			stmt = dbConn.prepareStatement(SQL_COUNT_IFSERVICES_TO_POLL);
	                int count = -1;
                        
			stmt.setString(1, ipaddr);
	
			rs = stmt.executeQuery();
			while(rs.next())
			{
			        count  = rs.getInt(1);
		                if (log.isDebugEnabled())
			                log.debug("restartPollingInterfaceHandler: count active ifservices to poll for interface: " + ipaddr);
			}

			if (count <= 0)
			{
				if (log.isDebugEnabled())
				{
					log.debug("restartPollingInterfaceHandler: counted services in status to poll: " + count); 
					log.debug("restartPollingInterfaceHandler: " + nodeid + "/" + ipaddr +
                                                " has no active services to poll");
				}
				return;
			}

			if (log.isDebugEnabled())
				log.debug("restartPollingInterfaceHandler: " + nodeid + "/" + ipaddr + 
                                " has " + count +  " active services to poll");
                        stmt.close();

                        // Fetch each active service to poll
			stmt = dbConn.prepareStatement(SQL_FETCH_IFSERVICES_TO_POLL);
			stmt.setString(1, ipaddr);
			rs = stmt.executeQuery();
		        if (log.isDebugEnabled())
			        log.debug("restartPollingInterfaceHandler: retrieve active service to poll on interface: " + ipaddr);

			while(rs.next())
			{
			        int serviceid  = rs.getInt(1);
                                String serviceName = rs.getString(2);
		                
                                if (log.isDebugEnabled())
			                log.debug("restartPollingInterfaceHandler: retrieved active service: " + serviceName);

		                PollerConfigFactory pCfgFactory = PollerConfigFactory.getInstance();
		                PollerConfiguration config =  pCfgFactory.getConfiguration();
		                Enumeration epkgs = config.enumeratePackage();
		                while(epkgs.hasMoreElements())
		                {
			                org.opennms.netmgt.config.poller.Package pkg = 
                                                (org.opennms.netmgt.config.poller.Package)epkgs.nextElement();
			
			                // Make certain the service is in the package and enabled!
			                //
			                if (!pCfgFactory.serviceInPackageAndEnabled(serviceName, pkg))
			                {
				                if(log.isDebugEnabled())
					                log.debug("restartPollingInterfaceHandler: interface " + ipaddr + 
							        " has active service " + serviceName + 
							        ", but the service is not enabled or does not exist in package: " 
							        + pkg.getName());
				                continue;
			                }
					
			                // Is the interface in the package?
			                //
			                if(!pCfgFactory.interfaceInPackage(ipaddr, pkg))
			                {
				                if(log.isDebugEnabled())
					                log.debug("restartPollingInterfaceHandler: interface " + ipaddr + 
							" has active service " + serviceName + 
							", but the interface was not in package: " 
							+ pkg.getName());
				                continue;
			                }
			
			                // Update Node Outage Hierarchy and schedule new service for polling
			                //
			                PollableNode pNode = null;
			                PollableInterface pInterface = null;
			                PollableService pSvc = null;
			                boolean ownLock = false;
			                boolean nodeCreated = false;
			                boolean interfaceCreated = false;
			
				        // Does the node already exist in the poller's pollable node map?
				        //
                                        try 
                                        {
        				        pNode = Poller.getInstance().getNode(nodeid);
        				        log.debug("restartPollingInterfaceHandler: attempting to retrieve pollable "
                                                        + "node object for nodeid " + nodeid);
        				        if (pNode == null)
        				        {
        					        // Nope...so we need to create it
        					        pNode = new PollableNode(nodeid);
        					        nodeCreated = true;
        				        } 
        				        else
        				        {
        					        // Obtain node lock
        					        //
        					        ownLock = pNode.getNodeLock(WAIT_FOREVER);
        				        }
        				
        				        // Does the interface exist in the pollable node?
        				        //
        				        pInterface = pNode.getInterface(ipaddr);
        				        if (pInterface == null)
        				        {
        					        // Create the PollableInterface and add it to the node
        					        if (log.isDebugEnabled())
        						        log.debug("restartPollingInterfaceHandler: creating new pollable interface: " 
                                                                + ipaddr + 
        							" to pollable node " + pNode.getNodeId());
        					        pInterface = new PollableInterface(pNode, 
                                                                        InetAddress.getByName(ipaddr));
        					        interfaceCreated = true;
        				        }
        				
        				        // Create a new PollableService representing this node, interface,
        				        // service and package pairing
        				        log.debug("restartPollingInterfaceHandler: creating new pollable service object for: " 
                                                + nodeid + "/" + ipaddr + "/" + serviceName);
        				
                                                pSvc = new PollableService(pInterface,
        								serviceName,
        								pkg,
        								ServiceMonitor.SERVICE_AVAILABLE,
        								new Date());
        
        		        		// Initialize the service monitor with the pollable service and schedule 
        			        	// the service for polling. 
        				        //							
        				        ServiceMonitor monitor = Poller.getInstance().getServiceMonitor(serviceName);
        				        monitor.initialize(pSvc);
        				
        				        // Add new service to the pollable services list.  
        				        //
        				        m_pollableServices.add(pSvc);
        				
        				        // Add the service to the PollableInterface object
        				        //
        				        // WARNING:  The PollableInterface stores services in a map
        				        //           keyed by service name, therefore, only the LAST
        				        //           PollableService aded to the interface for a 
        				        //           particular service will be represented in the
        				        //           map.  THIS IS BY DESIGN
        			        	log.debug("restartPollingInterfaceHandler: adding pollable service to service list " 
                                                        + "of interface: " + ipaddr);
        				        pInterface.addService(pSvc);
        				
        				        if (interfaceCreated)
        				        {
        					        // Add the interface to the node
        					        //
        					        // NOTE:  addInterface() calls recalculateStatus() automatically
        					        if (log.isDebugEnabled())
        						        log.debug("restartPollingInterfaceHandler: adding new pollable interface " + 
        								ipaddr + " to pollable node " + pNode.getNodeId());
        					        pNode.addInterface(pInterface);
        				        }
        				        else
        				        {
        					        // Recalculate node status
        					        //
        					        pNode.recalculateStatus();
        				        }
        				
        				        if (nodeCreated)
        				        {
        					        // Add the node to the node map
        					        //
        					        if (log.isDebugEnabled())
        						        log.debug("restartPollingInterfaceHandler: adding new pollable node: " 
                                                                        + pNode.getNodeId());
        					        Poller.getInstance().addNode(pNode);
        				        }
        								
        				        // Schedule the service for polling
        				        m_scheduler.schedule(pSvc, pSvc.recalculateInterval());
        				        if (log.isDebugEnabled())
        					        log.debug("restartPollingInterfaceHandler: " + pNode.getNodeId() + "/" + ipaddr + 
        							"/" + serviceName + " scheduled ");
                                        }
                        		catch(UnknownHostException ex)
                        		{
                        			log.error("Failed to schedule interface " + ipaddr + 
                        					" for service monitor " + serviceName + ", illegal address", ex);
                                                if (m_xmlrpc)
                                                {
                                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                                        createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                                                        ex.getMessage(), status);
                                                }
                        		}
                        		catch(InterruptedException ie)
                        		{
                        			log.error("Failed to schedule interface " + ipaddr + 
                        					" for service monitor " + serviceName + ", thread interrupted", ie);
                                                if (m_xmlrpc)
                                                {
                                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                                        createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                                                        ie.getMessage(), status);
                                                }
                        		}
                        		catch(RuntimeException rE)
                        		{
                        			log.warn("Unable to schedule " + ipaddr + " for service monitor " + serviceName + 
                        					", reason: " + rE.getMessage());
                                                if (m_xmlrpc)
                                                {
                                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                                        createAndSendXmlrpcNotificationEvent(txNo, sourceUei, 
                                                                        rE.getMessage(), status);
                                                }
                        		}
                        		catch(Throwable t)
                        		{
                        			log.error("Uncaught exception, failed to schedule interface " + ipaddr + 
                        					" for service monitor " + serviceName, t);
                                                if (m_xmlrpc)
                                                {
                                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                                        createAndSendXmlrpcNotificationEvent(
                                                                txNo, 
                                                                sourceUei, 
                                                                "Failed to schedule interface " + 
                                                                "because of uncaught exception.", 
                                                                status);
                                                }
                        		}
                        		finally
                        		{
                        			if (ownLock)
                        			{
                        				try
                        				{
                        					pNode.releaseNodeLock();
                        				}
                        				catch (InterruptedException iE)
                        				{
                        					log.error("Failed to release node lock on nodeid " + 
                        							pNode.getNodeId() + ", thread interrupted.");
                                                                if (m_xmlrpc)
                                                                {
                                                                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                                                        createAndSendXmlrpcNotificationEvent(
                                                                                txNo, 
                                                                                sourceUei, 
                                                                                iE.getMessage(), 
                                                                                status);
                                                                }
                        				}
                        			}
                                        } // end inner try
			
			        } //end package while loop
                        } //end services while loop
                }//end try
		catch(SQLException sqlE)
		{
			log.error("SQLException during check to see if nodeid/ip/service is active", sqlE);
                        if (m_xmlrpc)
                        {
                                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                                createAndSendXmlrpcNotificationEvent(txNo, sourceUei, sqlE.getMessage(), status);
                        }
		}
		finally
		{
                        // close the statement
			if (stmt != null)
				try { stmt.close(); } catch(SQLException sqlE) { };

			// close the connection
			if (dbConn != null)
				try { dbConn.close(); } catch(SQLException sqlE) { };					
		}
	}

