    public int poll() {
        Category log = ThreadCategory.getInstance(m_svc.getClass());
    
        setLastPoll(System.currentTimeMillis());
        m_svc.resetStatusChanged();
        if (log.isDebugEnabled())
            log.debug("poll: starting new poll for " + m_svc + ":" + getPackageName());
    
        // Poll the interface/service pair via the service monitor
        //
        int status = ServiceMonitor.SERVICE_UNAVAILABLE;
        Map propertiesMap = getPropertyMap();
        try {
            status = getServiceMonitor().poll(m_svc.getNetInterface(), propertiesMap, getPackage());
            if (log.isDebugEnabled())
                log.debug("poll: polled for " + m_svc + ":" + getPackageName()+" with result: " + Pollable.statusType[status]);
        } catch (NetworkInterfaceNotSupportedException ex) {
            log.error("poll: Interface " + m_svc.getIpAddr() + " Not Supported!", ex);
        } catch (Throwable t) {
            log.error("poll: An undeclared throwable was caught polling interface " + m_svc.getIpAddr(), t);
        }
    
        // serviceUnresponsive behavior disabled?
        //
        if (!getPollerConfig().serviceUnresponsiveEnabled()) {
            // serviceUnresponsive behavior is disabled, a status
            // of SERVICE_UNRESPONSIVE is treated as SERVICE_UNAVAILABLE
            if (status == ServiceMonitor.SERVICE_UNRESPONSIVE)
                status = ServiceMonitor.SERVICE_UNAVAILABLE;
        } else {
            // Update unresponsive flag based on latest status
            // returned by the monitor and generate serviceUnresponsive
            // or serviceResponsive event if necessary.
            //
            switch (status) {
            case ServiceMonitor.SERVICE_UNRESPONSIVE:
                // Check unresponsive flag to determine if we need
                // to generate a 'serviceUnresponsive' event.
                //
                if (!m_svc.isUnresponsive()) {
                    m_svc.setUnresponsive(true);
                    m_svc.sendEvent(EventConstants.SERVICE_UNRESPONSIVE_EVENT_UEI, propertiesMap);
    
                    // Set status back to available, don't want unresponsive
                    // service to generate outage
                    status = ServiceMonitor.SERVICE_AVAILABLE;
                }
                break;
    
            case ServiceMonitor.SERVICE_AVAILABLE:
                // Check unresponsive flag to determine if we
                // need to generate a 'serviceResponsive' event
                if (m_svc.isUnresponsive()) {
                    m_svc.setUnresponsive(false);
                    m_svc.sendEvent(EventConstants.SERVICE_RESPONSIVE_EVENT_UEI, propertiesMap);
                }
                break;
    
            case ServiceMonitor.SERVICE_UNAVAILABLE:
                // Clear unresponsive flag
                m_svc.setUnresponsive(false);
                break;
    
            default:
                break;
            }
        }
    
        // Any change in status?
        //
        if (status != m_svc.getStatus()) {
            // get the time of the status change
            //
            m_svc.setStatusChanged();
            m_svc.setStatusChangeTime(System.currentTimeMillis());
    
            // Is node outage processing disabled?
            if (!getPollerConfig().nodeOutageProcessingEnabled()) {
                // node outage processing disabled, go ahead and generate
                // transition events.
                if (log.isDebugEnabled())
                    log.debug("poll: node outage disabled, status change will trigger event.");
    
                // Send the appropriate event
                //
                switch (status) {
                case ServiceMonitor.SERVICE_AVAILABLE: // service up!
                    m_svc.sendEvent(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI, propertiesMap);
                    break;
    
                case ServiceMonitor.SERVICE_UNAVAILABLE: // service down!
                    m_svc.sendEvent(EventConstants.NODE_LOST_SERVICE_EVENT_UEI, propertiesMap);
                    break;
    
                default:
                    break;
                }
            }
        }
    
        // Set status
        m_svc.setStatus(status);
    
        // Reschedule the interface
        // 
        // NOTE: rescheduling now handled by PollableService.run()
        // reschedule(false);
    
        return m_svc.getStatus();
    }

