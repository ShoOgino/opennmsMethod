	/**
	 * Checks the package information for the pollable service and determines
	 * if any of the calendar outages associated with the package apply to 
	 * the current time and the service's interface.  If an outage applies
	 * true is returned...otherwise false is returned.
	 *
	 * @return false if no outage found (indicating a poll may be performed)
	 * or true if applicable outage is found (indicating poll should be skipped).
	 */
	private boolean scheduledOutage()
	{
		boolean outageFound = false;
		
		PollOutagesConfig outageFactory = getPollOutagesConfig();
		
		// Iterate over the outage names defined in the interface's package.
		// For each outage...if the outage contains a calendar entry which 
		// applies to the current time and the outage applies to this 
		// interface then break and return true.  Otherwise process the 
		// next outage.
		// 
		Iterator iter = m_package.getOutageCalendarCollection().iterator();
		while (iter.hasNext())
		{
			String outageName = (String)iter.next();
			
			// Does the outage apply to the current time?
			if (outageFactory.isCurTimeInOutage(outageName))
			{
				// Does the outage apply to this interface?
				
				if ((outageFactory.isInterfaceInOutage(m_address.getHostAddress(), outageName)) ||
				   (outageFactory.isInterfaceInOutage("match-any", outageName)))
				{
					if (ThreadCategory.getInstance(getClass()).isDebugEnabled())
						ThreadCategory.getInstance(getClass()).debug("scheduledOutage: configured outage '" + 
											outageName + 
											"' applies, interface " + 
											m_address.getHostAddress() + 
											" will not be polled for " + 
											m_service.getName());
					outageFound  = true;
					break;
				}
			}
		}
		
		return outageFound;
	}

