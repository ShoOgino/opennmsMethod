    public void reparentTo(final PollableNode newNode) {
        final PollableNode oldNode = getNode();
        
        if (oldNode.equals(newNode)) return;
        
        // always lock the nodes in nodeId order so deadlock is not possible
        Object firstLock = (oldNode.getNodeId() <= newNode.getNodeId() ? oldNode.getTreeLock() : newNode.getTreeLock());
        Object secondLock = (oldNode.getNodeId() <= newNode.getNodeId() ? newNode.getTreeLock() : oldNode.getTreeLock());
        
        synchronized(firstLock) {
            synchronized(secondLock) {
                
                getContext().reparentOutages(getIpAddr(), getNodeId(), newNode.getNodeId());
                oldNode.removeMember(this);
                newNode.addMember(this);
                setNode(newNode);
                
                if (getCause() == null || getCause().equals(oldNode.getCause())) {
                    // the current interface outage is a node outage or no outage at all
                    if (newNode.getCause() != null) {
                        // if the new Node has a node outage then we recursively set the 
                        // causes so when process events we properly handle the causes
                        PollableVisitor visitor = new PollableVisitorAdaptor() {
                            public void visitElement(PollableElement element) {
                                boolean matches = (element.getCause() == null ? oldNode.getCause() == null : element.getCause().equals(oldNode.getCause()));
                                if (matches) {
                                    element.setCause(newNode.getCause());
                                }
                            }
                        };
                        visit(visitor);
                    } 
                }
                
                oldNode.recalculateStatus();
                newNode.recalculateStatus();
            }
        }
    }

