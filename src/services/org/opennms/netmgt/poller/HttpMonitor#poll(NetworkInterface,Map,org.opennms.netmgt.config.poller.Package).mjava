	/**
	 * <P>Poll the specified address for HTTP service availability</P>
	 *
	 * <P>During the poll an attempt is made to connect on the specified
	 * port(s) (by default TCP ports 80, 8080, 8888).  If the connection
	 * request is successful, an HTTP 'GET' command is sent to the interface.
	 * The response is parsed and a return code extracted and verified.  
	 * Provided that the interface's response is valid we set the service 
	 * status to SERVICE_AVAILABLE and return.</P>
	 *
	 * @param iface		The network interface to test the service on.
	 * @param parameters	The package parameters (timeout, retry, etc...) to be 
	 *  used for this poll.
	 *
	 * @return The availibility of the interface and if a transition event
	 * 	should be supressed.
	 *
	 */
	public int poll(NetworkInterface iface, Map parameters, org.opennms.netmgt.config.poller.Package pkg) 
	{
		//
        	// Get interface address from NetworkInterface
		//
		if (iface.getType() != iface.TYPE_IPV4)
			throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

		Category log = ThreadCategory.getInstance(getClass());

		int retry   = ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
		int timeout = ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);
		int[] ports = ParameterMap.getKeyedIntegerArray(parameters, "ports", DEFAULT_PORTS);
		String url  = ParameterMap.getKeyedString(parameters, "url", DEFAULT_URL);
		String rrdPath = ParameterMap.getKeyedString(parameters, "rrd-repository", null);
		String dsName = ParameterMap.getKeyedString(parameters, "ds-name", null);
		if (rrdPath == null)
		{
			log.info("poll: RRD repository not specified in parameters, latency data will not be stored.");
		}
                if (dsName == null)
                {
                        dsName = DS_NAME;
                }
		int response = ParameterMap.getKeyedInteger(parameters, "response", -1);
		String responseText = ParameterMap.getKeyedString(parameters, "response text", null);

		// Set to true if "response" property has a valid return code specified.
		//  By default response will be deemed valid if the return code 
		//  falls in the range:   99 < rc < 500
		//  This is based on the following information from RFC 1945 (HTTP 1.0)
		// 		HTTP 1.0 GET return codes:
		//		 	1xx: Informational - Not used, future use
		//			2xx: Success
		//			3xx: Redirection
		//			4xx: Client error
		//			5xx: Server error
		boolean bStrictResponse = (response > 99 && response < 600);


		// Extract the ip address
		//
		InetAddress ipv4Addr = (InetAddress)iface.getAddress();
	
		// Following a successful poll 'currentPort' will contain the port on 
		// the remote host that was successfully queried
		//
		final String cmd = "GET " + url + " HTTP/1.0\r\n\r\n";

		// Cycle through the port list
		//
		int serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
		int currentPort = -1;
		long responseTime = -1;
		for (int portIndex=0; portIndex < ports.length && serviceStatus != ServiceMonitor.SERVICE_AVAILABLE; portIndex++)
		{
			currentPort = ports[portIndex];
			
			if (log.isDebugEnabled()) 
			{
				log.debug("Port = "+ currentPort + ", Address = " + ipv4Addr 
					  + ", Timeout = " + timeout + ", Retry = " + retry);
			}

			for (int attempts=0; attempts <= retry && serviceStatus != ServiceMonitor.SERVICE_AVAILABLE; attempts++)
			{
                        	SocketChannel sChannel = null;
				try
				{
					//
					// create a connected socket
					//
                                	sChannel = SocketChannelUtil.getConnectedSocketChannel(ipv4Addr, currentPort, timeout);
                                	if (sChannel == null)
                                	{
                                        	log.debug("HttpMonitor: did not connect to host within timeout: " + timeout +" attempt: " + attempts);
                                        	continue;
                                	}
                                	log.debug("HttpMonitor: connected to host: " + ipv4Addr + " on port: " + currentPort);

					// We're connected, so upgrade status to unresponsive
					serviceStatus = SERVICE_UNRESPONSIVE;
					
					//
					// Issue HTTP 'GET' command and check the return code in the response
					//
					long sentTime = System.currentTimeMillis();
                                        sChannel.socket().getOutputStream().write(cmd.getBytes());


					//
					// Get a buffered input stream that will read a line
					// at a time
					//
	                                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(sChannel.socket().getInputStream()));
					String line = lineRdr.readLine();
					responseTime = System.currentTimeMillis() - sentTime;
					if (line == null)
						continue;

					if(log.isDebugEnabled())
					{
						log.debug("poll: response= " + line);
						log.debug("poll: responseTime= " + responseTime + "ms");
					}

					if(line.startsWith("HTTP/"))
					{
						StringTokenizer t = new StringTokenizer(line);
						t.nextToken();

						int rVal = -1;
						try
						{
							rVal = Integer.parseInt(t.nextToken());
						}
						catch(NumberFormatException nfE)
						{
							log.info("Error converting response code from host = " + ipv4Addr + ", response = " + line);
						}

						if (bStrictResponse && rVal == response)
						{
							serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;	
						}
						else if(!bStrictResponse && rVal > 99 && rVal < 500 && (url.equals(DEFAULT_URL)))
						{
							serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;
						}
						else if(!bStrictResponse && rVal > 99 && rVal < 400)
						{
							serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;
						}
						else
						{
							serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
						}
					}
	
					if (serviceStatus == ServiceMonitor.SERVICE_AVAILABLE &&
					    responseText != null && responseText.length() > 0)
					{
						// This loop will rip through the rest of the Response Header
						//
						do 
						{
							line = lineRdr.readLine();

						} while (line != null && line.length() != 0);
						if (line == null)
							continue;
						
						// Now lets rip through the Entity-Body (i.e., content) looking
						// for the required text.
						//
						boolean bResponseTextFound = false;
						do 
						{
							line = lineRdr.readLine();
							
							if(line != null)
							{
								int responseIndex = line.indexOf(responseText);
								if (responseIndex != -1)
									bResponseTextFound = true;
							}	

						} while (line != null && !bResponseTextFound);

						// Set the status back to failed
						//
						if (!bResponseTextFound)
							serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
					}
				}
				catch(NoRouteToHostException e)
				{
					e.fillInStackTrace();
					log.warn("No route to host exception for address " + ipv4Addr, e);
					portIndex = ports.length; // Will cause outer for(;;) to terminate
					break; 			  // Break out of inner for(;;)
				}
                        	catch(InterruptedException e)
                        	{
                                	// Ignore
                                	e.fillInStackTrace();
                                	if(log.isDebugEnabled())
                                	        log.debug("HttpMonitor: Interrupted exception for address: " + ipv4Addr, e);
                        	}
				catch(ConnectException e)
				{
					// Connection Refused. Continue to retry.
					//
					e.fillInStackTrace();
					log.debug("Connection exception for " + ipv4Addr + ":" + ports[portIndex]);

				}
				catch(IOException e)
				{
					// Ignore
					//
					e.fillInStackTrace();
					log.debug("IOException while polling address " + ipv4Addr, e);
				}
				finally
				{
					try
					{
						// Close the socket
                                                if(sChannel != null)
                                                {
                                                        if (sChannel.socket() != null)
                                                                sChannel.socket().close();
                                                        sChannel.close();
                                                        sChannel = null;
                                                }
					}
					catch(IOException e) 
					{ 
						e.fillInStackTrace();
						log.debug("Error closing socket connection", e);
					}
				}

			} // end for (attempts)
		} // end for (ports)
		
		// Add the 'qualifier' parm to the parameter map.  This parm will
		// contain the port on which the service was found if AVAILABLE or
		// will contain a comma delimited list of the port(s) which were 
		// tried if the service is UNAVAILABLE
		//
		if (serviceStatus == ServiceMonitor.SERVICE_UNAVAILABLE)
		{
			//
			// Build port string
			//
			StringBuffer testedPorts = new StringBuffer();
			for(int i = 0; i < ports.length; i++)
			{
				if(i == 0)
					testedPorts.append(ports[0]);
				else
					testedPorts.append(',').append(ports[i]);
			}
			
			// Add to parameter map
			parameters.put("qualifier", testedPorts.toString());
		}
		else if (serviceStatus == ServiceMonitor.SERVICE_AVAILABLE)
		{
			parameters.put("qualifier", Integer.toString(currentPort));
			
			// Store response time in RRD
			if (responseTime >= 0 && rrdPath != null)
			{
                        	try
                        	{
					this.updateRRD(m_rrdInterface, rrdPath, ipv4Addr, dsName, responseTime, pkg);
                        	}
                        	catch(RuntimeException rex)
                        	{
                                	log.debug("There was a problem writing the RRD:" + rex);
                        	}
			}
		}	
		
		//
		// return the status of the service
		//
		return serviceStatus;
	}

