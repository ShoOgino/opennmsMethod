    /**
     * Poll the specified address for HTTP service availability.
     * 
     * During the poll an attempt is made to connect on the specified port(s) (by default TCP
     * ports 80, 8080, 8888). If the connection request is successful, an HTTP 'GET' command is
     * sent to the interface. The response is parsed and a return code extracted and verified.
     * Provided that the interface's response is valid we set the service status to
     * SERVICE_AVAILABLE and return.
     * 
     * @param iface
     *            The network interface to test the service on.
     * @param parameters
     *            The package parameters (timeout, retry, and others) to be used for this poll.
     * 
     * @return The availibility of the interface and if a transition event should be supressed.
     *  
     */
    public int checkStatus(NetworkInterface iface, Map parameters, org.opennms.netmgt.config.poller.Package pkg) {
        
        //
        // Get interface address from NetworkInterface
        //
        if (iface.getType() != NetworkInterface.TYPE_IPV4)
                throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

        String dsName = getDsName(parameters);
        if (getRrdPath(parameters) == null) {
            log().info("poll: RRD repository not specified in parameters, latency data will not be stored.");
        }

        String cmd = buildCommand(iface, parameters);

        // Cycle through the port list
        //
        int serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
        int currentPort = -1;
        long responseTime = -1;
        for (int portIndex = 0; portIndex < getPorts(parameters).length && serviceStatus != ServiceMonitor.SERVICE_AVAILABLE; portIndex++) {
            currentPort = getPorts(parameters)[portIndex];

            if (log().isDebugEnabled()) {
                log().debug("Port = " + currentPort + ", Address = " + getIpv4Addr(iface) + ", Timeout = " + getTimeout(parameters) + ", Retry = " + getRetries(parameters));
            }

            for (int attempts = 0; attempts <= getRetries(parameters) && serviceStatus != ServiceMonitor.SERVICE_AVAILABLE; attempts++) {
                Socket socket = null;
                try {
                    //
                    // create a connected socket
                    //
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(getIpv4Addr(iface), currentPort), getTimeout(parameters));
                    socket.setSoTimeout(getTimeout(parameters));

                    log().debug("HttpMonitor: connected to host: " + getIpv4Addr(iface) + " on port: " + currentPort);

                    // We're connected, so upgrade status to unresponsive
                    serviceStatus = SERVICE_UNRESPONSIVE;

                    //
                    // Issue HTTP 'GET' command and check the return code in the response
                    //
                    long sentTime = System.currentTimeMillis();
                    socket.getOutputStream().write(cmd.getBytes());

                    //
                    // Get a buffered input stream that will read a line
                    // at a time
                    //
                    BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    String line = lineRdr.readLine();
                    responseTime = System.currentTimeMillis() - sentTime;
                    if (line == null) continue;

                    if (log().isDebugEnabled()) {
                        log().debug("poll: response= " + line);
                        log().debug("poll: responseTime= " + responseTime + "ms");
                    }

                    if (line.startsWith("HTTP/")) {
                        StringTokenizer t = new StringTokenizer(line);
                        t.nextToken();

                        int serverResponseValue = -1;
                        try {
                            serverResponseValue = Integer.parseInt(t.nextToken());
                        } catch (NumberFormatException nfE) {
                            log().info("Error converting response code from host = " + getIpv4Addr(iface) + ", response = " + line);
                        }
                        
                        if (SnmpPeerFactory.matchNumericListOrRange(String.valueOf(serverResponseValue), getResponse(parameters))) {
                            serviceStatus = ServiceMonitor.SERVICE_AVAILABLE;
                        } else {
                            serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
                            StringBuffer sb = new StringBuffer();
                            sb.append("HTTP response value: ");
                            sb.append(serverResponseValue);
                            sb.append(". Expecting: ");
                            sb.append(getResponse(parameters));
                            sb.append(".");
                            m_reason = sb.toString();
                        }
                    }

                    if (serviceStatus == ServiceMonitor.SERVICE_AVAILABLE && getResponseText(parameters) != null && getResponseText(parameters).length() > 0) {
                        // This loop will rip through the rest of the Response Header
                        //
                        do {
                            line = lineRdr.readLine();
                            
                            if (isVerbose(parameters))
                                log().debug("\theader: "+line);

                        } while (line != null && line.length() != 0);
                        if (line == null) continue;

                        // Now lets rip through the Entity-Body (i.e., content) looking
                        // for the required text.
                        //
                        boolean bResponseTextFound = false;
                        int nullCount = 0;
                        do {
                            line = lineRdr.readLine();
                            
                            if (isVerbose(parameters))
                                log().debug("\tbody: "+line);
                            
                            if (line != null) {
                                if (getResponseText(parameters).charAt(0) == '~') {
                                    if (line.matches(getResponseText(parameters).substring(1))) bResponseTextFound = true;
                                } else {
                                    int responseIndex = line.indexOf(getResponseText(parameters));
                                    if (responseIndex != -1) bResponseTextFound = true;
                                }
                            } else {
                                nullCount++;
                            }
                            
                        } while (nullCount < 2 && !bResponseTextFound);

                        // Set the status back to failed
                        //
                        if (!bResponseTextFound) {
                            serviceStatus = ServiceMonitor.SERVICE_UNAVAILABLE;
                            m_reason = "Matching text: ["+getResponseText(parameters)+"] not found in body of HTTP response";
                        }
                    }
                } catch (NoRouteToHostException e) {
                    e.fillInStackTrace();
                    log().info("checkStatus: No route to host exception for address " + getIpv4Addr(iface), e);
                    portIndex = getPorts(parameters).length; // Will cause outer for(;;) to terminate
                    m_reason = "No route to host exception";
                    break; // Break out of inner for(;;)
                } catch (InterruptedIOException e) {
                    // Ignore
                    log().info("checkStatus: did not connect to host within timeout: " + getTimeout(parameters) + " attempt: " + attempts);
                    m_reason = "HTTP connection timeout";
                } catch (ConnectException e) {
                    // Connection Refused. Continue to retry.
                    //
                    e.fillInStackTrace();
                    log().warn("Connection exception for " + getIpv4Addr(iface) + ":" + getPorts(parameters)[portIndex]);
                    m_reason = "HTTP connection exception on port: "+getPorts(parameters)[portIndex];
                } catch (IOException e) {
                    // Ignore
                    //
                    e.fillInStackTrace();
                    log().warn("IOException while polling address " + getIpv4Addr(iface), e);
                    m_reason = "IOException while polling address: "+getIpv4Addr(iface);
                } finally {
                    try {
                        // Close the socket
                        if (socket != null) socket.close();
                    } catch (IOException e) {
                        e.fillInStackTrace();
                        log().warn("Error closing socket connection", e);
                    }
                }

            } // end for (attempts)
        } // end for (ports)

        // Add the 'qualifier' parm to the parameter map. This parm will
        // contain the port on which the service was found if AVAILABLE or
        // will contain a comma delimited list of the port(s) which were
        // tried if the service is UNAVAILABLE
        //
        if (serviceStatus == ServiceMonitor.SERVICE_UNAVAILABLE) {
            //
            // Build port string
            //
            StringBuffer testedPorts = new StringBuffer();
            for (int i = 0; i < getPorts(parameters).length; i++) {
                if (i == 0)
                    testedPorts.append(getPorts(parameters)[0]);
                else
                    testedPorts.append(',').append(getPorts(parameters)[i]);
            }

            // Add to parameter map
            parameters.put("qualifier", testedPorts.toString());
            m_reason += "/Ports: "+testedPorts.toString();
            log().debug("checkStatus: Reason: \""+m_reason+"\"");
        } else if (serviceStatus == ServiceMonitor.SERVICE_AVAILABLE) {
            parameters.put("qualifier", Integer.toString(currentPort));

            // Store response time in RRD
            if (responseTime >= 0 && getRrdPath(parameters) != null) {
                try {
                    this.updateRRD(getRrdPath(parameters), getIpv4Addr(iface), dsName, responseTime, pkg);
                } catch (RuntimeException rex) {
                    log().debug("There was a problem writing the RRD:" + rex);
                }
            }
        }

        //
        // return the status of the service
        //
        return serviceStatus;
    }

