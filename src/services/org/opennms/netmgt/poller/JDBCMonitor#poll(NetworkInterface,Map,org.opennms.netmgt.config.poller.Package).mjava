  	/**
   	* Network interface to poll for a given service.
   	* Make sure you're using the latest (at least 5.5) <a href="http://www.sybase.com/detail_list/1,6902,2912,00.html">JConnect version</a>
   	* or the plugin will not be able to tell exactly if the service is up or not.
   	* @param iface The interface to poll
   	* @param parameters Parameters to pass when polling the interface
   	* Currently recognized Map keys:
   	* <ul>
   	* <li> user - Database user
   	* <li> password - User password
   	* <li> port - server port
   	* <li> timeout - Number of miliseconds to wait before sending a timeout
   	* <li> driver - The JDBC driver to use
   	* <li> url - The vendor specific jdbc  URL
   	* </ul>
   	* @return int An status code that shows the status of the service
   	* @throws java.lang.RuntimeException Thrown if an unrecoverable error
   	*	 occurs that prevents the interface from being monitored.
   	* @see org.opennms.netmgt.poller.ServiceMonitor#SURPRESS_EVENT_MASK
   	* @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_AVAILABLE
   	* @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNAVAILABLE
   	* @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNRESPONSIVE
   	* @see <a href="http://manuals.sybase.com/onlinebooks/group-jc/jcg0550e/prjdbc/@Generic__BookTextView/9332;pt=1016#X">Error codes for JConnect</a>
   	*/	
  	public int poll(NetworkInterface iface, Map parameters, org.opennms.netmgt.config.poller.Package pkg) 
	{
    		Category log = ThreadCategory.getInstance(getClass());

    		// Asume that the service is down
    		int status = SERVICE_UNAVAILABLE;
    		Connection con = null;
    		Statement statement = null;
    		ResultSet resultset = null;

    		if(iface.getType() != NetworkInterface.TYPE_IPV4) 
		{
      			log.error(getClass().getName() + ": Unsupported interface type, only TYPE_IPV4 currently supported");
      			throw new NetworkInterfaceNotSupportedException(getClass().getName() + ": Unsupported interface type, only TYPE_IPV4 currently supported");
    		}
    
    		if (parameters == null) 
		{
	    	throw new NullPointerException();
    		}
    		try 
		{
	    	Class.forName(ParameterMap.getKeyedString(parameters, "driver", DBTools.DEFAULT_JDBC_DRIVER)).newInstance();
    		} 
		catch (Exception exp) {
	    		exp.printStackTrace();
	    		throw new RuntimeException(exp.toString());
    		}
    		log.info(getClass().getName() + ": Loaded JDBC driver");

    		// Get the JDBC url host part
    		InetAddress ipv4Addr = (InetAddress)iface.getAddress();
    		String url = null;
    		url = DBTools.constructUrl(ParameterMap.getKeyedString(parameters, "url", DBTools.DEFAULT_URL), ipv4Addr.getCanonicalHostName());
	  	if (log.isDebugEnabled()) {
            		log.debug(getClass().getName() + ": JDBC url: " + url);
		}

		int retries = ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
		int timeout = ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);
		String db_user = ParameterMap.getKeyedString(parameters, "user", DBTools.DEFAULT_DATABASE_USER);
		String db_pass = ParameterMap.getKeyedString(parameters, "password", DBTools.DEFAULT_DATABASE_PASSWORD);
	        String rrdPath = ParameterMap.getKeyedString(parameters, "rrd-repository", null);
    		String dsName = ParameterMap.getKeyedString(parameters, "ds-name", null);
	
       		if (rrdPath == null) {
            		log.info("poll: RRD repository not specified in parameters, latency data will not be stored.");
        	}
        	if (dsName == null) {
            		dsName = DS_NAME;
        	}

    		for (int attempts = 0; attempts <= retries; attempts++) 
		{ 
      		try 
		{
			long responseTime = -1;
        		DriverManager.setLoginTimeout(timeout);
			long sentTime = System.currentTimeMillis();
        		con = DriverManager.getConnection(url, db_user, db_pass);

        		// We are connected, upgrade the status to unresponsive
        		status = SERVICE_UNRESPONSIVE;

        		if ( con != null) 
			{
				DatabaseMetaData metadata = con.getMetaData();
				resultset = metadata.getCatalogs();
				while (resultset.next()) 
				{
					resultset.getString(1);
				}

          			// The query worked, assume than the server is ok
          			if (resultset != null) 
				{
					responseTime = System.currentTimeMillis() - sentTime;
            				status = SERVICE_AVAILABLE;
	  				if (log.isDebugEnabled()) {
            					log.debug(getClass().getName() + ": JDBC service is AVAILABLE on: " + ipv4Addr.getCanonicalHostName());
				                log.debug("poll: responseTime= " + responseTime + "ms");

					}
					// Update response time
				        if (responseTime >= 0 && rrdPath != null) {
                        			try {
                            				this.updateRRD(m_rrdInterface, rrdPath, ipv4Addr, dsName, responseTime, pkg);
                        			} catch (RuntimeException rex) {
                            				log.debug("There was a problem writing the RRD:" + rex);
                        			}
                    			}
            				break;
          			}
        		} // end if con
      		} 
		catch (SQLException sqlEx) 
		{
	  		if (log.isDebugEnabled()) 
			{
	      			log.debug(getClass().getName() + ": JDBC service is not responding on: " + ipv4Addr.getCanonicalHostName() + ", " + sqlEx.getSQLState() + ", " + sqlEx.toString());
	      		sqlEx.printStackTrace();
			}
      		} 
		finally 
		{
			if (resultset != null) 
			{
          		try  
			{ 
				resultset.close(); 
			} 
			catch (SQLException ignore) {}
          		resultset = null;
        		}
		if (statement != null) 
			{
          		try  
			{ 
			statement.close(); 
			} 
			catch (SQLException ignore) {}
          		statement = null;
        		}
        	if (con != null) 
			{
          		try  
			{ 
			con.close(); 
			} 
			catch (SQLException ignore) {}
          		con = null;
        		}	
      		}
    	}
    	return status;
  }

