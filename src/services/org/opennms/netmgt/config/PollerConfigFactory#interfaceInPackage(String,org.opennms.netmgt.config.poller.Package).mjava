	/**
	 * <p>This method is used to determine if the named interface is
	 * included in the passed package definition. If the interface
	 * belongs to the package then a value of true is returned. If
	 * the interface does not belong to the package a false value
	 * is returned.</p>
	 *
	 * <p><strong>Note:</strong>Evaluation of the interface against a
	 * package filter will only work if the IP is already in the database</p>
	 *
	 * @param iface		The interface to test against the package.
	 * @param pkg		The package to check for the inclusion of
	 *	the interface.
	 *
	 * @return	True if the interface is included in the package,
	 *	false otherwise.
	 */
	public synchronized boolean interfaceInPackage(String iface, org.opennms.netmgt.config.poller.Package pkg)
	{
		Category log = ThreadCategory.getInstance(this.getClass());

		//
		// check if interface passes the package filter
		//
		Filter filter = new Filter();
		boolean filterPassed = false;
		try
		{
			filterPassed = filter.isValid(iface, pkg.getFilter().getContent());
		}
		catch (Throwable t)
		{
			if(log.isEnabledFor(Priority.ERROR))
			{
				log.error("interfaceInPackage: Unable to validate interface: "
					  + iface + " against filter for package: "
					  + pkg.getName() + " - interface WILL NOT BE SCHEDULED", t);
			}
			filterPassed = false;
		}

		if (log.isDebugEnabled())
			log.debug("interfaceInPackage: Interface " + iface + " passed filter "
				  + pkg.getFilter().getContent() + " for package "
				  + pkg.getName() + "?: " + filterPassed);

		if (!filterPassed)
			return false;

		//
		// Ensure that the interface is in the specific list or
		// that it is in the include range and is not excluded
		//
		boolean has_specific = false;
		boolean has_range_include = false;
		boolean has_range_exclude = false;

		long addr = IPSorter.convertToLong(iface);
		Enumeration eincs = pkg.enumerateIncludeRange();
		while(!has_range_include && eincs.hasMoreElements())
		{
			IncludeRange rng = (IncludeRange)eincs.nextElement();
			long start = IPSorter.convertToLong(rng.getBegin());
			if(addr > start)
			{
				long end = IPSorter.convertToLong(rng.getEnd());
				if(addr <= end)
				{
					has_range_include = true;
				}
			}
			else if(addr == start)
			{
				has_range_include = true;
			}
		}

		Enumeration espec = pkg.enumerateSpecific();
		while(!has_specific && espec.hasMoreElements())
		{
			long speca = IPSorter.convertToLong(espec.nextElement().toString());
			if(speca == addr)
				has_specific = true;
		}

		Enumeration eurl = pkg.enumerateIncludeUrl();
		while(!has_specific && eurl.hasMoreElements())
		{
			has_specific = interfaceInUrl(iface, (String)eurl.nextElement());
		}

		Enumeration eex = pkg.enumerateExcludeRange();
		while(!has_range_exclude && !has_specific && eex.hasMoreElements())
		{
			ExcludeRange rng = (ExcludeRange)eex.nextElement();
			long start = IPSorter.convertToLong(rng.getBegin());
			if(addr > start)
			{
				long end = IPSorter.convertToLong(rng.getEnd());
				if(addr <= end)
				{
					has_range_exclude = true;
				}
			}
			else if(addr == start)
			{
				has_range_exclude = true;
			}
		}

		return has_specific || (has_range_include && !has_range_exclude);
	}

