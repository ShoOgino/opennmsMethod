		/**
		 * Closes the SQL connection for the owner of the
		 * conneciton. The close request may be forwarded
		 * to the encapsulate connection if an error has
		 * occured or the connection is read-only. Otherwise
		 * the connection is returned to the connection
		 * pool for reuse.
		 *
		 * @throws java.sql.SQLException May be thrown by the encapsulated connection
		 */
		public synchronized void close()
			throws SQLException
		{
			Category log = ThreadCategory.getInstance(getClass());
			boolean isTracing = log.isDebugEnabled();

			if(!m_inUse)
				log.warn("The in use flag was not set but the connection is being closed!", new Throwable());

			try
			{
				// re-enable auto commit on close
				//
				if(m_delegate.getAutoCommit() == false)
					m_delegate.setAutoCommit(true);

				// don't reuse read-only connections
				//
				if(m_delegate.isReadOnly())
				{
					if(isTracing)
						log.debug("connection is read-only, setting bad flag");

					m_hadError = true;
				}

				// don't reuse closed connections
				//
				if(m_delegate.isClosed())
				{
					if(isTracing)
						log.debug("connection is closed, setting bad flag");

					m_hadError = true;
				}
			}
			catch(SQLException ex)
			{
				if(isTracing)
					log.debug("setting bad flag true", ex);

				m_hadError = true;
			}

			// If the connection had errors then close
			// the connection. If the connection is cool
			// then push the conneciton onto the pool
			// stack.
			//
			m_inUse = false;
			if(m_hadError)
			{
				m_delegate.close();
			}
			else // m_hadError == false
			{
				synchronized(m_owner.m_dbcCache)
				{
					if(isTracing)
						log.debug("adding connection back into pool [id=" + this + "]");

					m_owner.m_dbcCache.addFirst(this);
				}
				m_lastUse = System.currentTimeMillis();
			}
		}

