	/**
	 * <p>Process a V2 trap and convert it to an event for transmission</p>
	 * 
	 * <p>From RFC2089 ('Mapping SNMPv2 onto SNMPv1'), section 3.3 
	 * ('Processing an outgoing SNMPv2 TRAP')</p>
	 *
	 * <p><strong>2b</strong>
	 * <p>If the snmpTrapOID.0 value is one of the standard traps the
	 * specific-trap field is set to zero and the generic trap
	 * field is set according to this mapping:<p>
	 *
	 * <pre>
	 *      value of snmpTrapOID.0                generic-trap
	 *      ===============================       ============
	 *      1.3.6.1.6.3.1.1.5.1 (coldStart)                  0
	 *      1.3.6.1.6.3.1.1.5.2 (warmStart)                  1
	 *      1.3.6.1.6.3.1.1.5.3 (linkDown)                   2
	 *      1.3.6.1.6.3.1.1.5.4 (linkUp)                     3
	 *      1.3.6.1.6.3.1.1.5.5 (authenticationFailure)      4
	 *      1.3.6.1.6.3.1.1.5.6 (egpNeighborLoss)            5
	 * </pre>
	 *
	 * <p>The enterprise field is set to the value of
	 *  snmpTrapEnterprise.0 if this varBind is present, otherwise
	 *  it is set to the value snmpTraps as defined in RFC1907 [4].</p>
	 *
	 * <p><strong>2c.</strong></p>
	 * <p>If the snmpTrapOID.0 value is not one of the standard
	 * traps, then the generic-trap field is set to 6 and the
	 * specific-trap field is set to the last subid of the
	 * snmpTrapOID.0 value.</p>
	 *
	 * <p>If the next to last subid of snmpTrapOID.0 is zero,
	 * then the enterprise field is set to snmpTrapOID.0 value
	 * and the last 2 subids are truncated from that value.
	 * If the next to last subid of snmpTrapOID.0 is not zero,
	 * then the enterprise field is set to snmpTrapOID.0 value
	 * and the last 1 subid is truncated from that value.</p>
	 *
	 * <p>In any event, the snmpTrapEnterprise.0 varBind (if present)
	 * is ignored in this case.</p>
	 *
	 * @param info		V2 trap
	 */
	private void process(Trapd.V2TrapInformation info)
	{
		Category log = ThreadCategory.getInstance(getClass());

		SnmpPduPacket pdu = info.getPdu();
		InetAddress agent = info.getAgent();
		
		//
		// verify the type
		//
		if(pdu.typeId() != (byte)(SnmpPduPacket.V2TRAP))
		{
			// if not V2 trap, do nothing
			log.warn("Recieved not SNMPv2 Trap from host " + agent.getHostAddress());
			log.warn("PDU Type = " + pdu.getCommand());
			return;
		}
		
		//
		// get the address converted
		//
		IPv4Address addr = new IPv4Address(agent);
		String trapInterface = addr.toString();

		Event event = new Event();
		event.setSource("trapd");
		event.setHost(trapInterface);
		event.setSnmphost(trapInterface);
		event.setInterface(trapInterface);
		event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));

		if(log.isDebugEnabled())
			log.debug("V2 trap - trapInterface: " + trapInterface);
		
		//
		// set the information
		//
		int numVars = pdu.getLength();
		if(log.isDebugEnabled())
			log.debug("V2 trap numVars or pdu length: " + numVars);
		if(numVars >= 2) // check number of varbinds
		{
			//
			// The first varbind has the sysUpTime
			// The second varbind has the snmpTrapOID
			// Confirm that these two are present
			//
			String varBindName0 = pdu.getVarBindAt(0).getName().toString();
			String varBindName1 = pdu.getVarBindAt(1).getName().toString();
			if ( (!(varBindName0.equals(SNMP_SYSUPTIME_OID))) ||
			     (!(varBindName1.equals(SNMP_TRAP_OID)))      )
			{
				log.warn("V2 trap from " + trapInterface + " IGNORED due to not having the required varbinds.\n\tThe first varbind must be sysUpTime.0 and the second snmpTrapOID.0\n\tVarbinds received are : " + varBindName0 + " and " + varBindName1);
				return;
			}

			Snmp snmpInfo = new Snmp();

			if(log.isDebugEnabled())
				log.debug("V2 trap first varbind value: " 
					  + pdu.getVarBindAt(0).getValue().toString());
			
			// Get the value for the snmpTrapOID
			SnmpObjectId snmpTrapOid = (SnmpObjectId)pdu.getVarBindAt(SNMP_TRAP_OID_INDEX).getValue();
			String snmpTrapOidValue = snmpTrapOid.toString();

			// Force leading "." (dot) if not present
			if (!snmpTrapOidValue.startsWith("."))
			{
				snmpTrapOidValue = "." + snmpTrapOidValue;
			}
			
			if(log.isDebugEnabled())
				log.debug("snmpTrapOID: " + snmpTrapOidValue);

			// get the last subid
			int length = snmpTrapOidValue.length();
			int lastIndex = snmpTrapOidValue.lastIndexOf(DOT_CHAR);

			String lastSubIdStr = snmpTrapOidValue.substring(lastIndex+1);
			int lastSubId = -1;
			try
			{
				lastSubId = Integer.parseInt(lastSubIdStr);
			}
			catch(NumberFormatException nfe)
			{
				lastSubId = -1;
			}

			// Check if standard trap
			if (GENERIC_TRAPS.contains(snmpTrapOid))
			{
				// set generic
				snmpInfo.setGeneric(lastSubId - 1);

				// set specific to zero
				snmpInfo.setSpecific(0);

				// if present, the 'snmpTrapEnterprise' OID occurs as
				// the last OID
				// Check the last varbind to see if it is the enterprise ID
				String varBindName = pdu.getVarBindAt(numVars-1).getName().toString();
				if (varBindName.equals(SNMP_TRAP_ENTERPRISE_ID))
				{
					// if present, set the value of the varbind as the enterprise id
					snmpInfo.setId(pdu.getVarBindAt(numVars-1).getValue().toString());
				}
				else
				{
					// if not present, set the value of the varbind as the
					// snmpTraps value defined as in RFC 1907
					snmpInfo.setId(SNMP_TRAPS + "." + snmpTrapOidValue.charAt(snmpTrapOidValue.length()-1));
				}
				
			}
			else // not standard trap
			{
				// set generic to 6
				snmpInfo.setGeneric(6);

				// set specific to lastsubid
				snmpInfo.setSpecific(lastSubId);
				
				// get the next to last subid
				int nextToLastIndex = snmpTrapOidValue.lastIndexOf(DOT_CHAR, lastIndex-1);

				// check if value is zero
				String nextToLastSubIdStr = snmpTrapOidValue.substring(nextToLastIndex+1, lastIndex);
				if (nextToLastSubIdStr.equals("0"))
				{
					// set enterprise value to trap oid minus the
					// the last two subids
					snmpInfo.setId(snmpTrapOidValue.substring(0, nextToLastIndex));
				}
				else
				{
					snmpInfo.setId(snmpTrapOidValue.substring(0, lastIndex));
				}
			}

			if(log.isDebugEnabled())
				log.debug("snmp specific/generic/eid: " 
					  + snmpInfo.getSpecific() + "\t" 
					  + snmpInfo.getGeneric() + "\t" 
					  + snmpInfo.getId());

			// version
			snmpInfo.setVersion("v2");

			// community
			snmpInfo.setCommunity(new String(info.getCommunity().getString()));

			event.setSnmp(snmpInfo);
			
			Parms parms = new Parms();
			
			for(int i = 0; i < pdu.getLength(); i++)
			{
				Value val = new Value();
				
				String name    = pdu.getVarBindAt(i).getName().toString();
				SnmpSyntax obj = pdu.getVarBindAt(i).getValue();

				if(obj instanceof SnmpInt32)
				{
					val.setType(EventConstants.TYPE_SNMP_INT32 );
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpNull)
				{
					val.setType(EventConstants.TYPE_SNMP_NULL);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpObjectId)
				{
					val.setType(EventConstants.TYPE_SNMP_OBJECT_IDENTIFIER);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpIPAddress)
				{
					val.setType(EventConstants.TYPE_SNMP_IPADDRESS);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpTimeTicks)
				{
					val.setType(EventConstants.TYPE_SNMP_TIMETICKS);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpCounter32)
				{
					val.setType(EventConstants.TYPE_SNMP_COUNTER32);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpGauge32)
				{
					val.setType(EventConstants.TYPE_SNMP_GAUGE32);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else if(obj instanceof SnmpOpaque)
				{
					val.setType(EventConstants.TYPE_SNMP_OPAQUE);
					val.setEncoding(EventConstants.XML_ENCODING_BASE64);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_BASE64, obj));
				}
				else if(obj instanceof SnmpOctetString)
				{
					//
					// check for non-printable characters. If they
					// exist then print the string out as hexidecimal
					//
					boolean asHex = false;
					byte[]  data  = ((SnmpOctetString)obj).getString();
					for(int x = 0; x < data.length; x++)
					{
						byte b = data[x];
						if((b < 32 && b != 10 && b != 13) ||  b == 127)
						{
							asHex = true;
							break;
						}
					}
					data = null;
					
					String encoding = asHex ? EventConstants.XML_ENCODING_BASE64 
									: EventConstants.XML_ENCODING_TEXT; 
					val.setType(EventConstants.TYPE_SNMP_OCTET_STRING);
					val.setEncoding(encoding);
					val.setContent(EventConstants.toString(encoding, obj));

					// DEBUG
					if (!asHex && log.isDebugEnabled())
					{
						log.debug("snmpReceivedTrap: string varbind: " 
							  + ( ((SnmpOctetString)obj).toString() ));
					}
				}
				else if(obj instanceof SnmpCounter64)
				{
					val.setType(EventConstants.TYPE_SNMP_COUNTER64);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(EventConstants.toString(EventConstants.XML_ENCODING_TEXT, obj));
				}
				else
				{
					val.setType(EventConstants.TYPE_STRING);
					val.setEncoding(EventConstants.XML_ENCODING_TEXT);
					val.setContent(obj.toString());
				}
				
				Parm parm = new Parm();
				parm.setParmName( name );
				parm.setValue( val );
				parms.addParm( parm );
			} // end for loop
			
			event.setParms(parms);
		}
		
		// send the event to eventd
		EventIpcManagerFactory.getInstance().getManager().sendNow(event);

		if(log.isDebugEnabled())
			log.debug("V2 Trap successfully converted and sent to eventd");
		
		if (!m_knownIps.contains(trapInterface))
		{
			m_knownIps.add(trapInterface);
			sendNewSuspectEvent(trapInterface);

			if(log.isDebugEnabled())
				log.debug("Sent newSuspectEvent for interface: " + trapInterface);
		}
	}

