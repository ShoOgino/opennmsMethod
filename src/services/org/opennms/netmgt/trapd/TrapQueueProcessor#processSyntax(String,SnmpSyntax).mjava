	public Parm processSyntax(String name, SnmpSyntax obj) {
		Category log = ThreadCategory.getInstance(getClass());
		Value val = new Value();

		if (obj instanceof SnmpOctetString) {
			//
			// check for non-printable characters. If they
			// exist then print the string out as hexidecimal
			//
			boolean asHex = false;
			byte[] data = ((SnmpOctetString) obj).getString();
			for (int x = 0; x < data.length; x++) {
				byte b = data[x];
				if ((b < 32 && b != 9 && b != 10 && b != 13 && b != 0) || b == 127) {
					asHex = true;
					break;
				}
			}

			data = null;

			String encoding = asHex ? EventConstants.XML_ENCODING_BASE64
				: EventConstants.XML_ENCODING_TEXT;

			val.setType(EventConstants.TYPE_SNMP_OCTET_STRING);
			val.setEncoding(encoding);
			val.setContent(EventConstants.toString(encoding, obj));

			// DEBUG
			if (!asHex && log.isDebugEnabled()) {
				log.debug("snmpReceivedTrap: string varbind: "
					+ (((SnmpOctetString) obj).toString()));
			}
		} else {
			boolean found = false;
			for (int i = 0; i < m_syntaxToEvents.length; i++) {
				if (m_syntaxToEvents[i].getClassMatch() == null ||
						m_syntaxToEvents[i].m_classMatch.isInstance(obj)) {
					val.setType(m_syntaxToEvents[i].getType());
					val.setEncoding(m_syntaxToEvents[i].getEncoding());
					val.setContent(EventConstants.toString(
						m_syntaxToEvents[i].getType(), obj));
					found = true;
					break;
				}
			}
			if (!found) {
				throw new IllegalStateException("Internal error: fell through the " +
						"bottom of the loop.  The syntax-to-events array might not have a " +
						"catch-all for Object");
			}
		}

		Parm parm = new Parm();
		parm.setParmName(name);
		parm.setValue(val);

		return parm;
	}

