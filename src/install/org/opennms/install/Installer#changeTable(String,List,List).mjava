    public void changeTable(String table, List oldColumns, List newColumns)
	throws Exception {
	Statement st = m_dbconnection.createStatement();
	TreeMap columnChanges = new TreeMap();
	String[] oldColumnNames = new String[oldColumns.size()];

	int i;
	Iterator j;
      
	if (m_changed.contains(table)) {
	    return;
	}
	m_changed.add(table);

	System.out.println("SCHEMA DOES NOT MATCH");
	System.out.println("  - differences:");

	// XXX This doesn't check for old column rows that don't exist
	//     in newColumns.
	for (j = newColumns.iterator(); j.hasNext(); ) {
	    Column newColumn = (Column) j.next();
	    Column oldColumn = findColumn(oldColumns,
					  newColumn.getName());

	    if (oldColumn == null || !newColumn.equals(oldColumn)) {
		System.out.println("    - column \"" + newColumn.getName() +
				   "\" is different");
	    }

	    if (!columnChanges.containsKey(newColumn.getName())) {
		columnChanges.put(newColumn.getName(), new ColumnChange());
	    }

	    ColumnChange columnChange = (ColumnChange)
		columnChanges.get(newColumn.getName());
	    columnChange.setColumn(newColumn);

	    /*
	     * If the new column has a NOT NULL constraint, set a null
	     * replace value for the column.  Throw an exception if it
	     * is possible for null data to be inserted into the new
	     * column.  This would happen if there is not a null
	     * replacement and the column either didn't exist before or
	     * it did NOT have the NOT NULL constraint before.
	     */
	    if (newColumn.isNotNull()) {
		if (newColumn.getName().equals("eventsource")) {
		    columnChange.setNullReplace("OpenNMS.Eventd");
		} else if (newColumn.getName().equals("svcregainedeventid")
			   && table.equals("outages")) {
		    columnChange.setNullReplace(new Integer(0));
		} else if (newColumn.getName().equals("eventid") &&
			   table.equals("notifications")) {
		    columnChange.setNullReplace(new Integer(0));
		} else if (oldColumn == null) {
		    throw new Exception("Column " + newColumn.getName() +
					" in new table has NOT NULL " +
					"constraint, however this column " +
					"did not exist before and there is " +
					"no null replacement for this " +
					"column");
		} else if (!oldColumn.isNotNull()) {
		    throw new Exception("Column " + newColumn.getName() +
					" in new table has NOT NULL " +
					"constraint, however this column " +
					"did not have the NOT NULL " +
					"constraint before and there is " +
					"no null replacement for this " +
					"column");
		}
	    }
	}

	i = 0;
	for (j = oldColumns.iterator(); j.hasNext(); i++) {
	    Column oldColumn = (Column) j.next();

	    oldColumnNames[i] = oldColumn.getName();

	    if (columnChanges.containsKey(oldColumn.getName())) {
		ColumnChange columnChange = (ColumnChange)
		    columnChanges.get(oldColumn.getName());
		Column newColumn = (Column) columnChange.getColumn();
		if (newColumn.getType().indexOf("timestamp") != -1) {
		    columnChange.setUpgradeTimestamp(true);
		}
	    } else {
		System.out.println("    * WARNING: column \"" +
				   oldColumn.getName() + "\" exists in the " +
				   "database but is not in the new schema.  " +
				   "NOT REMOVING COLUMN");
	    }
	}

	String oldTable = table + "_old_" + System.currentTimeMillis();

	st.execute("ALTER TABLE " + table + " RENAME TO " + oldTable);

	try {
	    st.execute("CREATE TABLE " + table + "(" + getTableFromSQL(table) +
		       ")");

	    transformData(table, oldTable, columnChanges, oldColumnNames);

	    st.execute("GRANT ALL ON " + table + " TO " + m_user);

	    System.out.print("  - optimizing table " + table + "... ");
	    st.execute("VACUUM ANALYZE " + table);
	    System.out.println("DONE");
	} catch (Exception e) {
	    try {
		st.execute("DROP TABLE " + table + m_cascade);
		st.execute("ALTER TABLE " + oldTable + " RENAME TO " + table);
	    } catch (SQLException se) {
		throw new Exception("Got SQLException while trying to " +
				    "revert table changes due to original " +
				    "error: " + e + "\n" +
				    "SQLException while reverting table: " +
				    se, e);
	    }
	    throw e;
	}

	// We don't care if dropping the old table fails since we've
	// completed copying it, so it's outside of the try/catch block above.
	st.execute("DROP TABLE " + oldTable);

	System.out.println("  - completed updating table... ");
    }

