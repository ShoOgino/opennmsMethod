	public void readTables() throws Exception {
		BufferedReader r = new BufferedReader(new FileReader(m_create_sql));
		String line;

		m_tables = new LinkedList();
		m_seqmapping = new HashMap();
		m_sequences = new LinkedList();

		Pattern seqmappingPattern = Pattern.compile("\\s*--#\\s+install:\\s*"
				+ "(\\S+)\\s+(\\S+)\\s+" + "(\\S+)\\s*.*");
		Pattern createPattern = Pattern.compile("(?i)\\s*create\\b.*");
		Pattern insertPattern = Pattern.compile("(?i)INSERT INTO "
				+ "[\"']?([\\w_]+)[\"']?.*");
		Pattern dropPattern = Pattern.compile("(?i)DROP TABLE [\"']?"
				+ "([\\w_]+)[\"']?.*");

		while ((line = r.readLine()) != null) {
			Matcher m;

			if (line.matches("\\s*") || line.matches("\\s*\\\\.*")) {
				continue;
			}

			m = seqmappingPattern.matcher(line);
			if (m.matches()) {
				String[] a = { m.group(2), m.group(3) };
				m_seqmapping.put(m.group(1), a);
				continue;
			}

			if (line.matches("--.*")) {
				continue;
			}

			if (createPattern.matcher(line).matches()) {
				m = Pattern.compile(
						"(?i)\\s*create\\s+((?:unique )?\\w+)"
								+ "\\s+[\"']?(\\w+)[\"']?.*").matcher(line);
				if (m.matches()) {
					String type = m.group(1);
					String name = m.group(2).replaceAll("^[\"']", "")
							.replaceAll("[\"']$", "");

					if (type.toLowerCase().indexOf("table") != -1) {
						m_tables.add(name);
					} else if (type.toLowerCase().indexOf("sequence") != -1) {
						m_sequences.add(name);
						/*
						 * -- Not used, nothing in create.sql to get us here }
						 * else if (type.toLowerCase().indexOf("function") !=
						 * -1) { if (type.toLowerCase().indexOf("language 'c'") !=
						 * -1) { m_cfunctions.add(name); } else {
						 * m_functions.add(name); } } else if
						 * (type.toLowerCase().indexOf("trusted") != -1) { m =
						 * Pattern.compile("(?i)\\s*create\\s+trutsed " +
						 * "procedural language\\s+[\"']?" +
						 * "(\\w+)[\"']?.*").matcher(line); if (!m.matches()) {
						 * throw new Exception("Could not match name and " +
						 * "type of the trusted " + "procedural language in
						 * this" + "line: " + line); }
						 * m_languages.add(m.group(1));
						 */
					} else if (type.toLowerCase().matches(".*\\bindex\\b.*")) {
						m = Pattern.compile(
								"(?i)\\s*create\\s+(?:unique )?"
										+ "index\\s+[\"']?([\\w_]+)"
										+ "[\"']?.*").matcher(line);
						if (!m.matches()) {
							throw new Exception("Could not match name and "
									+ "type of the index " + "in this"
									+ "line: " + line);
						}
						m_indexes.add(m.group(1));
					} else {
						throw new Exception("Unknown CREATE encountered: "
								+ "CREATE " + type + " " + name);
					}
				} else {
					throw new Exception("Unknown CREATE encountered: " + line);
				}

				m_sql_l.add(line);
				continue;
			}

			m = insertPattern.matcher(line);
			if (m.matches()) {
				String table = m.group(1);
				if (!m_inserts.containsKey(table)) {
					m_inserts.put(table, new LinkedList());
				}
				((LinkedList) m_inserts.get(table)).add(line);

				continue;
			}

			if (line.toLowerCase().startsWith("select setval ")) {
				String table = "select_setval";
				if (!m_inserts.containsKey(table)) {
					m_inserts.put(table, new LinkedList());
				}
				((LinkedList) m_inserts.get(table)).add(line);

				m_sql_l.add(line);
				continue;
			}

			m = dropPattern.matcher(line);
			if (m.matches()) {
				m_drops.add(m.group(1));

				m_sql_l.add(line);
				continue;
			}

			// XXX should do something here to we can catch what we can't parse
			// m_out.println("unmatched line: " + line);

			m_sql_l.add(line);
		}
		r.close();

		m_sql = cleanText(m_sql_l);
	}

