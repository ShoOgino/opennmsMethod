    public void transformData(String table, String oldTable,
			      TreeMap columnChanges, String[] oldColumnNames)
	throws SQLException, ParseException, Exception {
	Statement st = m_dbconnection.createStatement();
	Iterator j;
	int i;

	String[] columns = (String[])
	    columnChanges.keySet().toArray(new String[0]);
	String[] questionMarks = new String[columns.length];

	for (i = 0; i < oldColumnNames.length; i++) {
	    ColumnChange c = (ColumnChange)
		columnChanges.get(oldColumnNames[i]);
	    c.setSelectIndex(i + 1);
	}

	for (i = 0; i < columns.length; i++) {
	    questionMarks[i] = "?";
	    ColumnChange c = (ColumnChange) columnChanges.get(columns[i]);
	    c.setPrepareIndex(i + 1);
	    c.setColumnType(((Column) c.getColumn()).getColumnSqlType());
	}

	/* Pull everything in from the old table and filter it to update
	   the data to any new formats. */

	m_out.print("  - transforming data into the new table...\r");

	if (table.equals("events")) {
	    st.execute("INSERT INTO events (eventid, eventuei, eventtime, " +
		       "eventsource, eventdpname, eventcreatetime, " +
		       "eventseverity, eventlog, eventdisplay) values " +
		       "(0, 'http://uei.opennms.org/dummyevent', now(), " +
		       "'OpenNMS.Eventd', 'localhost', now(), 1, 'Y', 'Y')");
	}

	ResultSet rs = st.executeQuery("SELECT count(*) FROM " + oldTable);
	rs.next();
	long num_rows = rs.getLong(1);

	PreparedStatement select = null;
	PreparedStatement insert = null;
	String order;
	if (table.equals("outages")) {
	    order = " ORDER BY iflostservice";
	} else {
	    order = "";
	}

	String dbcmd = "SELECT " + join(", ", oldColumnNames) + " FROM " +
	    oldTable + order;
	if (m_debug) {
	    m_out.println("  - performing select: " + dbcmd);
	}
	select = m_dbconnection.prepareStatement(dbcmd);
	// error =		      "Unable to prepare select from temp";

	dbcmd = "INSERT INTO " + table + " (" + join(", ", columns) +
	    ") values (" + join(", ", questionMarks) + ")";
	if (m_debug) {
	    m_out.println("  - performing insert: " + dbcmd);
	}
	insert = m_dbconnection.prepareStatement(dbcmd);
	// error = 	      "Unable to prepare insert into " + table);

	rs = select.executeQuery();
	m_dbconnection.setAutoCommit(false);

	String name;
	ColumnChange change;
	Object obj;
	SimpleDateFormat dateParser =
	    new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss");
	SimpleDateFormat dateFormatter =
	    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	char spin[] = { '/', '-', '\\', '|' };

	int current_row = 0;

	while (rs.next()) {
	    for (j = columnChanges.keySet().iterator(); j.hasNext(); ) {
		name = (String) j.next();
		change = (ColumnChange) columnChanges.get(name);
		
		if (change.getSelectIndex() > 0) {
		    obj = rs.getObject(change.getSelectIndex());
		    if (rs.wasNull()) {
			obj = null;
		    }
		} else {
		    if (m_debug) {
			m_out.println("    - don't know what to do " +
					   "for \"" +
					   name + "\", prepared column " +
					   change.getPrepareIndex() +
					   ": setting to null");
		    }
		    obj = null;
		}

		if (table.equals("outages") && name.equals("outageid")) {
		    obj = new Integer(current_row + 1);
		}
		if (obj == null && change.isNullReplace()) {
		    obj = change.getNullReplace();
		    if (m_debug) {
			m_out.println("    - " + name +
					   " was NULL but is a " +
					   "requires NULL replacement -- " +
					   "replacing with '" + obj + "'");
		    }
		}

		if (obj != null) {
		    if (change.isUpgradeTimestamp() &&
			!obj.getClass().equals(java.sql.Timestamp.class)) {
			if (m_debug) {
			    m_out.println("    - " + name +
					       " is an old-style timestamp");
			}
			String newObj =
			    dateFormatter.format(dateParser.parse((String)
								  obj));
			if (m_debug) {
			    m_out.println("    - " +
					       obj + " -> " + newObj);
			}

			obj = newObj;
		    }
		    if (m_debug) {
			m_out.println("    - " + name + " = " + obj);
		    }
		} else {
		    if (m_debug) {
			m_out.println("    - " + name + " = undefined");
		    }
		}

		if (obj == null) {
		    insert.setNull(change.getPrepareIndex(),
				   change.getColumnType());
		} else {
		    insert.setObject(change.getPrepareIndex(), obj);
		}
	    }

	    try {
		insert.execute();
	    } catch (SQLException e) {
		if (e.toString().indexOf("key referenced from " + table +
					 " not found in") == -1 &&
		    e.toString().indexOf("Cannot insert a duplicate key " +
					 "into unique index") == -1) {
		    throw e;
		    // error =	      "can't insert into " + table;
		}
	    }

	    current_row++;

	    if ((current_row % 20) == 0) {
		m_out.print("  - transforming data into the new " +
				 "table... " +
				 (int)Math.floor((current_row * 100) / num_rows) +
				 "%  [" + spin[(current_row / 20) % spin.length] + "]\r");
	    }
	}

	m_dbconnection.commit();
	m_dbconnection.setAutoCommit(true);

	m_out.println("  - transforming data into the new table... " +
			   "DONE           ");
    }

