	/**
	 * 
	 * The parseInteger32() method is used to decode an ASN.1 32-bit signed
	 * integer from the specified buffer.
	 *
	 * @param buf		The input buffer
	 * @param startOffset	The offset to start decoding in the buffer
	 *
	 * @return	Returns an Object array that contains the new offset,
	 *		ASN.1 type, and value. The first object is an Integer object
	 *		and contains the new offset for the next object in buf.
	 *		The second object is a Byte object that represents the 
	 *		decoded ASN.1 Type. The third object is an Integer 
	 *		and contains the actual	decoded value.
	 *
	 * @exception	AsnDecodingException	Thrown if an error occurs decoding
	 *			the buffer.
	 */
	public Object[] parseInteger32(byte[] buf, int startOffset) throws AsnDecodingException
	{
		//
		// parse the header first
		//
		Object [] hdrVals = parseHeader(buf, startOffset);

		startOffset   = ((Integer)hdrVals[0]).intValue();
		Byte asnType  = (Byte)hdrVals[1];
		int asnLength = ((Integer)hdrVals[2]).intValue();

		//
		// check for sufficent data
		//
		if((buf.length - startOffset) < asnLength)
			throw new AsnDecodingException("Buffer underflow error");

		//
		// check to see that we can actually decode
		// the value (must fit in integer == 32-bits)
		//
		if(asnLength > 4)
			throw new AsnDecodingException("Integer too large: cannot decode");

		//
		// check for negativity!
		//
		int asnValue = 0;
		if((buf[startOffset] & HIGH_BIT) == HIGH_BIT)
			asnValue = -1;

		//
		// extract the information from the buffer
		//
		while(asnLength-- > 0)
		{
			asnValue = (asnValue << 8) | byteToInt(buf[startOffset++]);
		}

		//
		// return the data!
		//
		Object [] rVals = new Object[3];
		rVals[0] = new Integer(startOffset);
		rVals[1] = asnType;			// java.lang.Byte()
		rVals[2] = new Integer(asnValue);

		return rVals;
	}

