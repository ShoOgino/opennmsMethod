	/**
	 *
	 * The buildUInteger32() method is used to encode an ASN.1 32-bit unsigned
	 * integer into the specified byte buffer.
	 *
	 * @param buf		The output buffer of encoded bytes.
	 * @param startOffset	The offset from the start of the buffer where the 
	 *			method should start writing the encoded data.
	 * @param asnType	The ASN.1 type to place in the buffer
	 * @param asnUInt32	The 32-bit unsigned integer to encode.
	 *
	 * @return	Returns the new offset for the next encoding routine.
	 *		If startOffset is subtracted from the return value
	 *		then the length of the encoded data can be determined.
	 *
	 * @exception	AsnEncodingException	Thrown if an error occurs encoding
	 *			the datatype.
	 * 
	 */
	public int buildUInteger32(byte[]	buf,
				   int		startOffset,
				   byte		asnType,
				   long		asnUInt32) throws AsnEncodingException
	{
		//
		// NOTE: the value is a 'long' which is 64 bits long, but we only use
		//	the lower order 32-bits! If the number is greater than 2^32 - 1
		//	the upper order bits will be lost!

		//
		// Store a copy of the value to mask off the
		// unnecessary bits. There should not be any
		// sequence of 9 consecutive 1's or 0 bits
		//
		long	mask   = 0xff800000L;
		int	intSz  = 4;		// int == 32-bits == 4 bytes in java
		boolean bAddNullByte = false;

		//
		// check to see if an additional (zero) byte is needed
		// Since an Integer is a signed 32-bit quantity, if the
		// passed long is greater than Integer.MAX_VALUE (2^31-1)
		// then it must have the high-bit (2^32) set!
		//
		// effectively checking to see if (asnUInt32 & 0x80000000L) != 0
		//
		if(asnUInt32 > (long)(Integer.MAX_VALUE))
		{
			bAddNullByte = true;
			intSz++;
		}


		//
		// check for and remove any sequence of 9 consecutive zeros
		// from the head of the number
		//
		// NOTE: 10/9/00 Weave - This use to also mask off any set
		//	of 9 consecutive 1's as well, but that didn't make
		//	any sense because it's unsigned. What if you wanted
		//	to send 0xffffffffL, masking off the ones would be
		// 	incorrect cause for unsigned there isn't going to
		//	be a sign extension.
		//
		while((asnUInt32 & mask) == 0 && intSz > 1)
		{
			--intSz;
			asnUInt32 = (asnUInt32 << 8);
		}

		//
		// build the header
		//
		startOffset = buildHeader(buf, startOffset, asnType, intSz);

		//
		// verify the buffer length
		//
		if((buf.length - startOffset) < intSz)
			throw new AsnEncodingException("Buffer overflow error");

		//
		// Add the null byte if necessary
		//
		if(bAddNullByte)
		{
			buf[startOffset++] = (byte)0;
			--intSz;
		}

		//
		// mask off and store the values
		//
		mask = 0xff000000L;
		while(intSz-- > 0)
		{
			byte b = (byte)((asnUInt32 & mask) >>> 24);
			buf[startOffset++] = b;
			asnUInt32 = (asnUInt32 << 8);
		}

		//
		// return the result
		//
		return startOffset;
	}	

