	/**
	 *
	 * The buildInteger32() method is used to encode an ASN.1 32-bit signed
	 * integer into the specified byte buffer. 
	 *
	 * @param buf		The output buffer of encoded bytes.
	 * @param startOffset	The offset from the start of the buffer where the 
	 *			method should start writing the encoded data.
	 * @param asnType	The ASN.1 type to place in the buffer
	 * @param asnInt32	The 32-bit signed integer to encode.
	 *
	 * @return	Returns the new offset for the next encoding routine.
	 *		If startOffset is subtracted from the return value
	 *		then the length of the encoded data can be determined.
	 *
	 * @exception	AsnEncodingException	Thrown if an error occurs encoding
	 *			the datatype.
	 * 
	 */
	public int buildInteger32(byte[]	buf,
				  int		startOffset,
				  byte		asnType,
				  int		asnInt32) throws AsnEncodingException
	{
		//
		// Store a copy of the value to mask off the
		// unnecessary bits. There should not be any
		// sequence of 9 consecutive 1's or 0 bits
		//
		int	mask   = 0xff800000;	// negative :)
		int	intSz  = 4;		// int == 32-bits == 4 bytes in java

		while(((asnInt32 & mask) == 0 || (asnInt32 & mask) == mask) && intSz > 1)
		{
			--intSz;
			asnInt32 = (asnInt32 << 8);
		}

		//
		// build the header
		//
		startOffset = buildHeader(buf, startOffset, asnType, intSz);

		//
		// verify the buffer length
		//
		if((buf.length - startOffset) < intSz)
			throw new AsnEncodingException("Insufficent buffer size");

		//
		// mask off and store the values
		//
		mask = 0xff000000;
		while(intSz-- > 0)
		{
			byte b = (byte)((asnInt32 & mask) >>> 24);
			buf[startOffset++] = b;
			asnInt32 = (asnInt32 << 8);
		}

		//
		// return the result
		//
		return startOffset;
	}	

