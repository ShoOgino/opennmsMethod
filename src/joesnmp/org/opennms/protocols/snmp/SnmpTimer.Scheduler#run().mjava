        /**
         * Runs in an infinite loop waiting for new runnables to expire or for
         * the m_exit variable to be set true. The m_sync in the parent class is
         * used to synchronize this method
         * 
         */
        public void run() {
            LinkedList toRun = new LinkedList();
            while (true) {
                //
                // syncronize on the object
                //
                synchronized (m_sync) {
                    if (m_exit)
                        return;

                    //
                    // if there are no elements on the list
                    // then wait
                    //
                    if (m_list.size() == 0) {
                        try {
                            m_sync.wait();
                        } catch (InterruptedException err) {
                            // Thread.currentThread().interrupt();
                            return;
                        }

                        //
                        // restart the loop
                        //
                        continue;
                    }

                    //
                    // find the smallest timeslice
                    // and run those in error
                    //
                    Date now = new Date();
                    boolean done = false;
                    long minTime = Long.MAX_VALUE;
                    ListIterator iter = m_list.listIterator(0);

                    while (!done && iter.hasNext()) {
                        try {
                            //
                            // get the next timeout element
                            //
                            TimeoutElement elem = (TimeoutElement) iter.next();
                            if (now.after(elem.m_when)) {
                                //
                                // The element has expried
                                //
                                toRun.add(elem.m_toRun);
                                iter.remove();
                            } else {
                                //
                                // find out if this time is less
                                // than the one currently stored
                                //
                                if (elem.m_when.getTime() < minTime)
                                    minTime = elem.m_when.getTime();
                            }
                        } catch (NoSuchElementException err) {
                            done = true;
                        } catch (ConcurrentModificationException err) {
                            done = true;
                        }
                    }

                    //
                    // if there are no elements to run
                    // then wait the minimum time until
                    // the syncronization object is signaled.
                    //
                    if (toRun.size() == 0) {
                        minTime -= now.getTime();
                        try {
                            if (minTime > 0)
                                m_sync.wait(minTime);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }

                } // end synchronization

                //
                // process the timeouts, if any
                //
                if (toRun.size() != 0) {
                    ListIterator iter = toRun.listIterator(0);
                    try {
                        while (true) {
                            Runnable runner = (Runnable) iter.next();
                            iter.remove();
                            runner.run();
                        }
                    } catch (NoSuchElementException err) {
                        // do nothing
                    } catch (Throwable err) {
                        //
                        // Bad, Bad Runnable!
                        //
                    }
                }

            } // end while loop

        }// end run method

