  /**
   * <p>Adjust column widths in an HTML table.</p>
   *
   * <p>The specification of column widths in CALS (a relative width
   * plus an optional absolute width) are incompatible with HTML column
   * widths. This method adjusts CALS column width specifiers in an
   * attempt to produce equivalent HTML specifiers.</p>
   *
   * <p>In order for this method to work, the CALS width specifications
   * should be placed in the "width" attribute of the &lt;col>s within
   * a &lt;colgroup>. Then the colgroup result tree fragment is passed
   * to this method.</p>
   *
   * <p>This method makes use of two parameters from the XSL stylesheet
   * that calls it: <code>nominal.table.width</code> and
   * <code>table.width</code>. The value of <code>nominal.table.width</code>
   * must be an absolute distance. The value of <code>table.width</code>
   * can be either absolute or relative.</p>
   *
   * <p>Presented with a mixture of relative and
   * absolute lengths, the table width is used to calculate
   * appropriate values. If the <code>table.width</code> is relative,
   * the nominal width is used for this calculation.</p>
   *
   * <p>There are three possible combinations of values:</p>
   *
   * <ol>
   * <li>There are no relative widths; in this case the absolute widths
   * are used in the HTML table.</li>
   * <li>There are no absolute widths; in this case the relative widths
   * are used in the HTML table.</li>
   * <li>There are a mixture of absolute and relative widths:
   *   <ol>
   *     <li>If the table width is absolute, all widths become absolute.</li>
   *     <li>If the table width is relative, make all the widths absolute
   *         relative to the nominal table width then turn them all
   *         back into relative widths.</li>
   *   </ol>
   * </li>
   * </ol>
   *
   * @param context The stylesheet context; supplied automatically by Saxon
   * @param rtf The result tree fragment containing the colgroup.
   *
   * @return The result tree fragment containing the adjusted colgroup.
   *
   */
  public static NodeSetValue adjustColumnWidths (Context context,
						 NodeSetValue rtf_ns) {

    FragmentValue rtf = (FragmentValue) rtf_ns;

    setupColumnWidths(context);

    try {
      Controller controller = context.getController();
      NamePool namePool = controller.getNamePool();

      ColumnScanEmitter csEmitter = new ColumnScanEmitter(namePool);
      rtf.replay(csEmitter);

      int numColumns = csEmitter.columnCount();
      String widths[] = csEmitter.columnWidths();

      float relTotal = 0;
      float relParts[] = new float[numColumns];

      float absTotal = 0;
      float absParts[] = new float[numColumns];

      for (int count = 0; count < numColumns; count++) {
	String width = widths[count];

	int pos = width.indexOf("*");
	if (pos >= 0) {
	  String relPart = width.substring(0, pos);
	  String absPart = width.substring(pos+1);

	  try {
	    float rel = Float.parseFloat(relPart);
	    relTotal += rel;
	    relParts[count] = rel;
	  } catch (NumberFormatException e) {
	    System.out.println(relPart + " is not a valid relative unit.");
	  }

	  int pixels = 0;
	  if (absPart != null && !absPart.equals("")) {
	    pixels = convertLength(absPart);
	  }

	  absTotal += pixels;
	  absParts[count] = pixels;
	} else {
	  relParts[count] = 0;

	  int pixels = 0;
	  if (width != null && !width.equals("")) {
	    pixels = convertLength(width);
	  }

	  absTotal += pixels;
	  absParts[count] = pixels;
	}
      }

      // Ok, now we have the relative widths and absolute widths in
      // two parallel arrays.
      //
      // - If there are no relative widths, output the absolute widths
      // - If there are no absolute widths, output the relative widths
      // - If there are a mixture of relative and absolute widths,
      //   - If the table width is absolute, turn these all into absolute
      //     widths.
      //   - If the table width is relative, turn these all into absolute
      //     widths in the nominalWidth and then turn them back into
      //     percentages.

      if (relTotal == 0) {
	for (int count = 0; count < numColumns; count++) {
	  Float f = new Float(absParts[count]);
	  if (foStylesheet) {
	    int pixels = f.intValue();
	    float inches = (float) pixels / pixelsPerInch;
	    widths[count] = inches + "in";
	  } else {
	    widths[count] = Integer.toString(f.intValue());
	  }
	}
      } else if (absTotal == 0) {
	for (int count = 0; count < numColumns; count++) {
	  float rel = relParts[count] / relTotal * 100;
	  Float f = new Float(rel);
	  widths[count] = Integer.toString(f.intValue()) + "%";
	}
      } else {
	int pixelWidth = nominalWidth;

	if (tableWidth.indexOf("%") <= 0) {
	  pixelWidth = convertLength(tableWidth);
	}

	if (pixelWidth <= absTotal) {
	  System.out.println("Table is wider than table width.");
	} else {
	  pixelWidth -= absTotal;
	}

	absTotal = 0;
	for (int count = 0; count < numColumns; count++) {
	  float rel = relParts[count] / relTotal * pixelWidth;
	  relParts[count] = rel + absParts[count];
	  absTotal += rel + absParts[count];
	}

	if (tableWidth.indexOf("%") <= 0) {
	  for (int count = 0; count < numColumns; count++) {
	    Float f = new Float(relParts[count]);
	    if (foStylesheet) {
	      int pixels = f.intValue();
	      float inches = (float) pixels / pixelsPerInch;
	      widths[count] = inches + "in";
	    } else {
	      widths[count] = Integer.toString(f.intValue());
	    }
	  }
	} else {
	  for (int count = 0; count < numColumns; count++) {
	    float rel = relParts[count] / absTotal * 100;
	    Float f = new Float(rel);
	    widths[count] = Integer.toString(f.intValue()) + "%";
	  }
	}
      }

      ColumnUpdateEmitter cuEmitter = new ColumnUpdateEmitter(controller,
							      namePool,
							      widths);

      rtf.replay(cuEmitter);
      return cuEmitter.getResultTreeFragment();
    } catch (TransformerException e) {
      // This "can't" happen.
      System.out.println("Transformer Exception in adjustColumnWidths");
      return rtf;
    }
  }

