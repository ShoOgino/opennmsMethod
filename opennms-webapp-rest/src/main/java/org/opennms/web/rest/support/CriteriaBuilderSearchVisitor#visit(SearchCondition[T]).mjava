	public void visit(SearchCondition<T> sc) {
		PrimitiveStatement statement = sc.getStatement();
		if (statement != null) {
			if (statement.getProperty() != null) {
				String name = getRealPropertyName(statement.getProperty());

				// TODO: Figure out how to use validators at some point
				//validatePropertyValue(name, originalValue);

				// Introspect the property type
				ClassValue clsValue = getPrimitiveFieldClass(statement, name, statement.getValue().getClass(), statement.getValueType(), statement.getValue());

				// If the property value is a String
				boolean isWildcard = false;
				if (String.class.equals(clsValue.getCls())) {
					// And if it's a FIQL wildcard
					if (SearchUtils.containsWildcard((String)clsValue.getValue())) {
						// Then mark it as a wildcard and replace the * wildcards with % wildcards
						isWildcard = true;
						clsValue.setValue(SearchUtils.toSqlWildcardString((String)clsValue.getValue(), isWildcardStringMatch()));
					}
				}

				switch(sc.getConditionType()) {
				case EQUALS:
					if (isWildcard) {
						m_criteriaBuilder.like(name, clsValue.getValue());
					} else {
						m_criteriaBuilder.eq(name, clsValue.getValue());
					}
					break;
				case NOT_EQUALS:
					if (isWildcard) {
						m_criteriaBuilder.not().like(name, clsValue.getValue());
					} else {
						m_criteriaBuilder.ne(name, clsValue.getValue());
					}
					break;
				case LESS_THAN:
					m_criteriaBuilder.lt(name, clsValue.getValue());
					break;
				case GREATER_THAN:
					m_criteriaBuilder.gt(name, clsValue.getValue());
					break;
				case LESS_OR_EQUALS:
					m_criteriaBuilder.le(name, clsValue.getValue());
					break;
				case GREATER_OR_EQUALS:
					m_criteriaBuilder.ge(name, clsValue.getValue());
					break;
				case OR:
				case AND:
				case CUSTOM:
				default:
					// TODO: What do we do here? Probably nothing, the SQL visitor skips it.
				}
			}
		} else {
			//boolean first = true;
			for (SearchCondition<T> condition : sc.getSearchConditions()) {
				Restriction current = Restrictions.all(m_criteriaBuilder.toCriteria().getRestrictions());

				// visit the children
				CriteriaBuilderSearchVisitor<T> newVisitor = new CriteriaBuilderSearchVisitor<T>(new CriteriaBuilder(m_class), m_class);
				condition.accept(newVisitor);
				Restriction additional = Restrictions.all(newVisitor.getQuery().toCriteria().getRestrictions());

				// Make a new CriteriaBuilder that will be the sum of the two sides of the search condition
				m_criteriaBuilder = new CriteriaBuilder(m_class);

				switch(sc.getConditionType()) {
				case OR:
					LOG.info("OR criteria: {} OR {}", current, additional);
					// .or() with current Criteria
					m_criteriaBuilder.or(current, additional);
				case AND:
					LOG.info("AND criteria: {} AND {}", current, additional);
					// .and() with current Criteria
					m_criteriaBuilder.and(current, additional);
				default:
					// TODO: What do we do here?
				}
			}
		}
	}

