	@Override
	public void visit(SearchCondition<T> sc) {
		PrimitiveStatement statement = sc.getStatement();
		if (statement != null) {
			if (statement.getProperty() != null) {
				String name = getRealPropertyName(statement.getProperty());

				// TODO: Figure out how to use validators at some point
				//validatePropertyValue(name, originalValue);

				// Introspect the property type
				ClassValue clsValue = getPrimitiveFieldClass(statement, name, statement.getValue().getClass(), statement.getValueType(), statement.getValue());

				// If the property value is a String
				boolean isWildcard = false;
				if (String.class.equals(clsValue.getCls())) {
					// And if it's a FIQL wildcard
					if (SearchUtils.containsWildcard((String)clsValue.getValue())) {
						// Then mark it as a wildcard and replace the * wildcards with % wildcards
						isWildcard = true;
						clsValue.setValue(SearchUtils.toSqlWildcardString((String)clsValue.getValue(), isWildcardStringMatch()));
					}
				}

				// TODO: Should we get the condition off of the statement instead??
				// I think they're always identical if the PrimitiveStatement has a
				// statement.
				//switch(statement.getCondition()) {

				switch(sc.getConditionType()) {
				case EQUALS:
					if (isWildcard) {
						m_criteriaBuilder.like(name, clsValue.getValue());
					} else {
						if (
							clsValue.getValue() == null || 
							NULL_VALUE.equals(clsValue.getValue()) ||
							NULL_DATE_VALUE.equals(clsValue.getValue())
						) {
							m_criteriaBuilder.isNull(name);
						} else {
							m_criteriaBuilder.eq(name, clsValue.getValue());
						}
					}
					break;
				case NOT_EQUALS:
					if (isWildcard) {
						m_criteriaBuilder.not().like(name, clsValue.getValue());
					} else {
						if (
							clsValue.getValue() == null || 
							NULL_VALUE.equals(clsValue.getValue()) ||
							NULL_DATE_VALUE.equals(clsValue.getValue())
						) {
							m_criteriaBuilder.isNotNull(name);
						} else {
							// Match any rows that do not match the value or are null
							m_criteriaBuilder.or(
								Restrictions.ne(name, clsValue.getValue()),
								Restrictions.isNull(name)
							);
						}
					}
					break;
				case LESS_THAN:
					// TODO: Check for null?
					m_criteriaBuilder.lt(name, clsValue.getValue());
					break;
				case GREATER_THAN:
					// TODO: Check for null?
					m_criteriaBuilder.gt(name, clsValue.getValue());
					break;
				case LESS_OR_EQUALS:
					// TODO: Check for null?
					m_criteriaBuilder.le(name, clsValue.getValue());
					break;
				case GREATER_OR_EQUALS:
					// TODO: Check for null?
					m_criteriaBuilder.ge(name, clsValue.getValue());
					break;
				case OR:
				case AND:
				case CUSTOM:
				default:
					// TODO: What do we do here? Probably nothing, the SQL visitor skips it.
				}
			}
		} else {
			List<Restriction> subRestrictions = new ArrayList<Restriction>();
			for (SearchCondition<T> condition : sc.getSearchConditions()) {
				// Create a new CriteriaBuilder
				CriteriaBuilder builder = null;
				try {
					// Try to use the same class as the outside CriteriaBuilder
					builder = m_criteriaBuilder.getClass().getConstructor(Class.class).newInstance(m_class);
				} catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {
					LOG.warn("Could not create " + m_criteriaBuilder.getClass().getSimpleName() + "; falling back to CriteriaBuilder: " + e.getClass().getSimpleName() + ": " + e.getMessage());
					builder = new CriteriaBuilder(m_class);
				}
				// Create a new visitor for the SearchCondition
				CriteriaBuilderSearchVisitor<T> newVisitor = new CriteriaBuilderSearchVisitor<T>(builder, m_class);

				// Visit the children
				condition.accept(newVisitor);

				// Fetch the rendered restrictions
				Collection<Restriction> restrictions = newVisitor.getQuery().toCriteria().getRestrictions();
				// If there are restrictions...
				if (restrictions != null && restrictions.size() > 0) {
					final Restriction subRestriction;
					// If there are multiple restrictions...
					if (restrictions.size() > 1) {
						// Wrap them in an AND restriction
						subRestriction = Restrictions.all(restrictions);
					} else {
						subRestriction = restrictions.iterator().next();
					}
					LOG.info(subRestriction.toString());
					subRestrictions.add(subRestriction);
				}
			}

			switch(sc.getConditionType()) {
			case OR:
				LOG.info("OR criteria");
				// .or() with current Criteria
				m_criteriaBuilder.or(subRestrictions.toArray(new Restriction[0]));
				break;
			case AND:
				LOG.info("AND criteria");
				// .and() with current Criteria
				m_criteriaBuilder.and(subRestrictions.toArray(new Restriction[0]));
				break;
			default:
				// TODO: What do we do here?
			}
		}
	}

