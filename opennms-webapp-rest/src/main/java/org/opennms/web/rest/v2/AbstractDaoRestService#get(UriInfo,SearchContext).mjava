	@GET
	@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.APPLICATION_ATOM_XML})
	public Response get(@Context final UriInfo uriInfo, @Context final SearchContext searchContext) {
		final MultivaluedMap<String, String> params = uriInfo.getQueryParameters();

		final CriteriaBuilder builder = getCriteriaBuilder();

		if (searchContext != null) {
			SearchCondition<T> condition = searchContext.getCondition(getDaoClass());
			if (condition != null) {
				SearchConditionVisitor<T,CriteriaBuilder> visitor = new CriteriaBuilderSearchVisitor<T>(builder, getDaoClass());
				condition.accept(visitor);
			}
		}

		// Apply limit, offset, orderBy, order params
		applyLimitOffsetOrderBy(params, builder);

		Criteria crit = builder.toCriteria();

		/*
		TODO: Figure out how to do stuff like this

		// Don't include deleted nodes by default
		final String type = params.getFirst("type");
		if (type == null) {
			final List<Restriction> restrictions = new ArrayList<Restriction>(crit.getRestrictions());
			restrictions.add(Restrictions.ne("type", "D"));
			crit.setRestrictions(restrictions);
		}
		 */

		final List<T> coll = getDao().findMatching(crit);

		// TODO: Figure out how to encapsulate lists in a wrapper object
		// Remove limit, offset and ordering for count
		/*
		crit.setLimit(null);
		crit.setOffset(null);
		crit.setOrders(new ArrayList<Order>());

		coll.setTotalCount(getDao().countMatching(crit));
		 */

		if (coll == null || coll.size() < 1) {
			return Response.status(Status.NOT_FOUND).build();
		} else {
			return Response.ok(coll).build();
		}
	}

