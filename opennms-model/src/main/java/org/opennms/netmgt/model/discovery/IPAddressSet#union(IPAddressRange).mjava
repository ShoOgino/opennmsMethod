    public IPAddressSet union(IPAddressRange range) {
        if (isEmpty()) {
            // 0. if current set is empty just make a new set containing the range
            return new IPAddressSet(range);
        } else if (range.overlaps(m_firstRange) || range.adjoins(m_firstRange)) {
            // 1. range overlaps or is adjacent to m_firstRange
            IPAddressRange newRange = union(range, m_firstRange);
            return (m_remainingRanges == null ? new IPAddressSet(newRange) : m_remainingRanges.union(newRange));
        } else if (range.comesBefore(m_firstRange)) {
            // 2. range comes entirely before and not adjacent m_firstRange
            return new IPAddressSet(range, this);
        } else {
            // 3. range comes entirely after and not adjacent to m_firstRange
            IPAddressSet remaining = m_remainingRanges == null ? new IPAddressSet(range) : m_remainingRanges.union(range);
            return new IPAddressSet(m_firstRange, remaining);
        }
    }

