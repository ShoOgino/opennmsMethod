    public void parseBFT(Integer nodeid, Map<Integer, Set<String>> bridgeForwardingTable) {
        LOG.info("parseBFT: -----------------------------------------------------");
        LOG.info("parseBFT: start: parsing bridge forwarding table for node {}", nodeid);

        // parsing bridge forwarding table
        for (final Entry<Integer, Set<String>> curEntry : bridgeForwardingTable.entrySet()) {
            BridgeTopologyPort bridgetopologyport = new BridgeTopologyPort(nodeid, curEntry.getKey(), curEntry.getValue());

            if (parsed(bridgetopologyport)) {
                LOG.info("parseBFT: node {}, port {} has been previuosly parsed. Skipping.", nodeid, curEntry.getKey());
                continue;
            }

            BridgeTopologyLinkCandidate topologycandidate = new BridgeTopologyLinkCandidate(bridgetopologyport);
            for (String mac : curEntry.getValue()) {
                if (bridgeAssociatedMacAddressMap.containsKey(mac)) {
                    for (BridgeTopologyPort swPort : bridgeAssociatedMacAddressMap.get(mac)) {
                        if (swPort.getNodeid().intValue() == nodeid) {
                            continue;
                        }
                        LOG.info("parseBFT: node {}, port {}: mac {} found on bridge adding target: targetnodeid {}, targetport {}", nodeid, curEntry.getKey(), mac, swPort.getNodeid(), swPort.getBridgePort());
                        topologycandidate.setLinkPortCandidate(swPort);
                        topologycandidate.addTarget(swPort.getNodeid());
                    }
                }
            }
            LOG.info("parseBFT: node {} port {} macs {} targets {} role {}",
                     topologycandidate.getBridgeTopologyPort().getNodeid(),
                     topologycandidate.getBridgeTopologyPort()
                     .getBridgePort(), topologycandidate.getMacs(),
                     topologycandidate.getTargets(), topologycandidate
                     .getRole());
            bridgeTopologyPortCandidates.add(parseBFTEntry(topologycandidate));
        }
        // first: cannot have two backbone from one bridge, so if a backbone and b with candidate, then b is direct
        Set<BridgeTopologyLinkCandidate> secondStep = new TreeSet<BridgeTopologyOld.BridgeTopologyLinkCandidate>();
        for (BridgeTopologyLinkCandidate candidateA : bridgeTopologyPortCandidates) {
            if (candidateA.getRole() != BridgePortRole.BACKBONE) {
                continue;
            }
            for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
                if (candidateB.getBridgeTopologyPort().getNodeid().intValue() != candidateA.getBridgeTopologyPort().getNodeid().intValue()) {
                    continue;
                }
                if (candidateB.getRole() != null) {
                    continue;
                }
                if (candidateB.getLinkPortCandidate() == null) {
                    continue;
                }
                if (candidateA.getTargets().contains(candidateB.getLinkPortCandidate().getNodeid())) {
                    LOG.info("parseBFT: rule A: only one backbone port: BACKBONE node {} port {} targets {}: setting port {} to DIRECT",
                             candidateA.getBridgeTopologyPort().getNodeid(),
                             candidateA.getBridgeTopologyPort().getBridgePort(),
                             candidateA.getTargets(), candidateB
                             .getBridgeTopologyPort().getBridgePort());
                    candidateB.setRole(BridgePortRole.DIRECT);
                    candidateB.setLinkPortCandidate(null);
                    secondStep.add(candidateB);
                }
            }
        }
        // second: if a contains mac and is direct and b contains mac: then b is backbone
        for (BridgeTopologyLinkCandidate candidateA : secondStep) {
            for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
                if (candidateB.getBridgeTopologyPort().getNodeid().intValue() == candidateA.getBridgeTopologyPort().getNodeid().intValue()) {
                    continue;
                }
                if (candidateB.getRole() == BridgePortRole.DIRECT) {
                    continue;
                }
                Set<String> otherMacs = new TreeSet<String>();
                for (String mac : candidateA.getMacs()) {
                    if (candidateB.getMacs().contains(mac)) {
                        otherMacs.add(mac);
                    }
                }
                if (otherMacs.isEmpty()) {
                    continue;
                }

                LOG.info("parseBFT: rule B: found DIRECT: node {} BACKBONE port {}: removing mac {} and adding target {}",
                         candidateB.getBridgeTopologyPort().getNodeid(),
                         candidateB.getBridgeTopologyPort().getBridgePort(),
                         otherMacs, candidateA.getBridgeTopologyPort()
                         .getNodeid());
                candidateB.removeMacs(otherMacs);
                candidateB.addTarget(candidateA.getBridgeTopologyPort().getNodeid());
            }
        }

        // reset all roles
        for (BridgeTopologyLinkCandidate candidate : bridgeTopologyPortCandidates) {
            candidate.setRole(null);
        }
        LOG.info("parseBFT: end: bridge forwarding table for node {}", nodeid);
    }

