	public void parseBFT(Integer nodeid, Map<Integer,Set<String>> bridgeForwardingTable) {
		LOG.info(
				"parseBFT: parsing node {},",
				nodeid);

		// parsing bridge forwarding table
		for (final Entry<Integer, Set<String>> curEntry : bridgeForwardingTable.entrySet()) {
			BridgeTopologyPort bridgetopologyport = new BridgeTopologyPort(
					nodeid, curEntry.getKey(), curEntry.getValue());

			if (parsed(bridgetopologyport)) {
				LOG.info(
						"parseBFT: node {}, port {} has been previuosly parsed. Skipping.",
						nodeid, curEntry.getKey());
				continue;
			}

			BridgeTopologyLinkCandidate topologycandidate = new BridgeTopologyLinkCandidate(
					bridgetopologyport);
			for (String mac : curEntry.getValue()) {
				if (bridgeAssociatedMacAddressMap.containsKey(mac)) {
					for (BridgeTopologyPort swPort : bridgeAssociatedMacAddressMap
							.get(mac)) {
						if (swPort.getNodeid().intValue() == nodeid)
							continue;
						LOG.info(
								"parseBFT: node {}, port {}: mac {} found on bridge adding target: targetnodeid {}, targetport {}",
								nodeid, curEntry.getKey(), mac,
								swPort.getNodeid(), swPort.getBridgePort());
						topologycandidate.setLinkPortCandidate(swPort);
						topologycandidate.addTarget(swPort.getNodeid());
					}
				}
			}
			bridgeTopologyPortCandidates.add(parseBFTEntry(topologycandidate));
		}
		// first: cannot have two backbone from one bridge, so if a backbone and
		// b with candidate, then b is direct
		Set<BridgeTopologyLinkCandidate> secondStep = new HashSet<BridgeTopology.BridgeTopologyLinkCandidate>();
		for (BridgeTopologyLinkCandidate candidateA : bridgeTopologyPortCandidates) {
			if (candidateA.getRole() != BridgePortRole.BACKBONE)
				continue;
			for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
				if (candidateB.getBridgeTopologyPort().getNodeid().intValue() != candidateA
						.getBridgeTopologyPort().getNodeid().intValue())
					continue;
				if (candidateB.getRole() != null)
					continue;
				if (candidateB.getLinkPortCandidate() == null)
					continue;
				if (candidateA.getTargets().contains(
						candidateB.getLinkPortCandidate().getNodeid())) {
					LOG.info(
							"parseBFT: rule A: node {} BACKBONE port {}: only one backbone port is allowed for targets {}: setting port {} to DIRECT",
							candidateA.getBridgeTopologyPort().getNodeid(),
							candidateA.getBridgeTopologyPort().getBridgePort(),
							candidateA.getTargets(), candidateB
									.getBridgeTopologyPort().getBridgePort());
					candidateB.setRole(BridgePortRole.DIRECT);
					candidateB.setLinkPortCandidate(null);
					secondStep.add(candidateB);
				}
			}
		}
		// second: if a contains mac and is direct and b contains mac: then b is
		// backbone
		for (BridgeTopologyLinkCandidate candidateA : secondStep) {
			if (candidateA.getRole() != BridgePortRole.DIRECT)
				continue;
			for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
				if (candidateB.getBridgeTopologyPort().getNodeid().intValue() == candidateA
						.getBridgeTopologyPort().getNodeid().intValue())
					continue;
				if (candidateB.getRole() == BridgePortRole.DIRECT)
					continue;
				Set<String> otherMacs = new HashSet<String>();
				for (String mac : candidateA.getMacs()) {
					if (candidateB.getMacs().contains(mac)) {
						otherMacs.add(mac);
					}
				}
				if (otherMacs.isEmpty())
					continue;

				LOG.info(
						"parseBFT: rule B: macs {}: node {} DIRECT port {}: removing from node {} BACKBONE port {} ",
						otherMacs, candidateA.getBridgeTopologyPort()
								.getNodeid(), candidateA
								.getBridgeTopologyPort().getBridgePort(),
						candidateB.getBridgeTopologyPort().getNodeid(),
						candidateB.getBridgeTopologyPort().getBridgePort());
				candidateB.removeMacs(otherMacs);
				candidateB.addTarget(candidateA.getBridgeTopologyPort()
						.getNodeid());
			}
		}

		for (BridgeTopologyLinkCandidate candidateA : bridgeTopologyPortCandidates) {
			if (parsed(candidateA.getBridgeTopologyPort()))
				continue;
			if (candidateA.getTargets().isEmpty()) {
				continue;
			}
			LOG.info(
					"parseBFT: bridgetobridge discovery: parsing nodeidA {}, portA {}, targetsA {}.",
					candidateA.getBridgeTopologyPort().getNodeid(), candidateA
							.getBridgeTopologyPort().getBridgePort(),
					candidateA.getTargets());
			for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
				if (parsed(candidateB
						.getBridgeTopologyPort()))
					continue;
				if (candidateB.getTargets().isEmpty())
					continue;
				if (candidateA.getBridgeTopologyPort().getNodeid().intValue() == candidateB
						.getBridgeTopologyPort().getNodeid().intValue())
					continue;
				LOG.info(
						"parseBFT: bridgetobridge discovery: parsing nodeidB {}, portB {}, targetsB {}.",
						candidateB.getBridgeTopologyPort().getNodeid(),
						candidateB.getBridgeTopologyPort().getBridgePort(),
						candidateB.getTargets());
				if (candidateA.getTargets().contains(
						candidateB.getBridgeTopologyPort().getNodeid())
						&& candidateB.getTargets().contains(
								candidateA.getBridgeTopologyPort().getNodeid())) {
					BridgeTopologyLink link = new BridgeTopologyLink(
							candidateA.getBridgeTopologyPort(),
							candidateB.getBridgeTopologyPort());
					if (link.getMacs().isEmpty()) {
						LOG.info(
							"parseBFT: bridgetobridge discovery: link found {}",
							link);
						bridgelinks.add(link);
					}
				}
			}
		}

		// reset all roles
		for (BridgeTopologyLinkCandidate candidate : bridgeTopologyPortCandidates) {
			candidate.setRole(null);
		}
	}

