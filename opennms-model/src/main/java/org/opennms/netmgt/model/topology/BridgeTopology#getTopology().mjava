    public List<BridgeTopologyLink> getTopology() {
        for (BridgeTopologyLinkCandidate candidateA : bridgeTopologyPortCandidates) {
            if (parsed(candidateA.getBridgeTopologyPort())) {
                continue;
            }
            if (candidateA.getTargets().isEmpty()) {
                continue;
            }
            for (BridgeTopologyLinkCandidate candidateB : bridgeTopologyPortCandidates) {
                if (parsed(candidateB.getBridgeTopologyPort())) {
                    continue;
                }
                if (candidateB.getTargets().isEmpty()) {
                    continue;
                }
                if (candidateA.getBridgeTopologyPort().getNodeid().intValue() >= candidateB.getBridgeTopologyPort().getNodeid().intValue()) {
                    continue;
                }
                LOG.info("getTopology: bridgetobridge discovery: parsing nodeidA {}, portA {}, targetsA {}.",
                         candidateA.getBridgeTopologyPort().getNodeid(),
                         candidateA.getBridgeTopologyPort().getBridgePort(),
                         candidateA.getTargets());
                LOG.info(
                         "getTopology: bridgetobridge discovery: parsing nodeidB {}, portB {}, targetsB {}.",
                         candidateB.getBridgeTopologyPort().getNodeid(),
                         candidateB.getBridgeTopologyPort().getBridgePort(),
                         candidateB.getTargets());
                if (candidateA.getTargets().contains(candidateB.getBridgeTopologyPort().getNodeid())
                         && candidateB.getTargets().contains(candidateA.getBridgeTopologyPort().getNodeid())) {
                    // this means that there is a path from A to B but this must be compatible
                    // A--C--D---E---B
                    // Target Intersection must be null
                    boolean linkFound=true;
                    for (Integer targetA: candidateA.getTargets()) {
                        if (targetA.intValue() == candidateB.getBridgeTopologyPort().getNodeid().intValue()) {
                            continue;
                        }
                        if (candidateB.getTargets().contains(targetA)) {
                            LOG.info(
                                     "getTopology: bridgetobridge discovery: bridge found {} between A and B: skipping",
                                     targetA,
                                     candidateA.getBridgeTopologyPort().getNodeid(),
                                     candidateB.getBridgeTopologyPort().getNodeid());
                            linkFound=false;
                            break;
                        }
                    }
                    if (linkFound) {
                        BridgeTopologyLink link = new BridgeTopologyLink(candidateA.getBridgeTopologyPort(), candidateB.getBridgeTopologyPort());
                        LOG.info("getTopology: bridgetobridge discovery: link found {}", link);
                        bridgelinks.add(link);
                    }
                }
            }
        }
        for (BridgeTopologyLinkCandidate candidate : bridgeTopologyPortCandidates) {
            if (parsed(candidate.getBridgeTopologyPort())) {
                continue;
            }
            LOG.info("getTopology: mac discovery: parsing nodeid {}, port {}, macs {}, targets {}.",
                     candidate.getBridgeTopologyPort().getNodeid(),
                     candidate.getBridgeTopologyPort().getBridgePort(),
                     candidate.getMacs(),
                     candidate.getTargets());
            final BridgeTopologyPort btp = new BridgeTopologyPort(
                     candidate.getBridgeTopologyPort().getNodeid(),
                     candidate.getBridgeTopologyPort().getBridgePort(),
                     candidate.getMacs());
            BridgeTopologyLink link = new BridgeTopologyLink(btp);
            LOG.info("getTopology: bridgetomac link found {}", link);
            bridgelinks.add(link);
        }
        return bridgelinks;
    }

