	private BridgeTopologyLinkCandidate parseBFTEntry(
			BridgeTopologyLinkCandidate topologyLinkCandidate) {
		/*
		 * This class is designed to get the topology on one bridge forwarding
		 * table at a time so this means that the rules are written considering
		 * port1 belonging always to the same bridge.
		 * 
		 * 
		 * We assume the following:
		 * 
		 * 1) there where no loops into the network (so there is a hierarchy)
		 * 
		 * Corollary 1
		 * 
		 * If exists there is only one backbone port from sw1 and sw2 If exists
		 * there is only one backbone port from sw2 and sw1
		 * 
		 * Corollary 2 There is only one "pseudo device" containing the bridge
		 * 
		 * Corollary 3 on a backbone port two different mac address must belong
		 * to the same pseudo device
		 */
		for (BridgeTopologyLinkCandidate linkcandidate : bridgeTopologyPortCandidates) {
			// regola same node non faccio niente
			if (linkcandidate.getBridgeTopologyPort().getNodeid().intValue() == topologyLinkCandidate
					.getBridgeTopologyPort().getNodeid().intValue()) {
				LOG.info(
						"parseBFTEntry: rule 0: same node candidate nodeid {}, port{}:  do nothing checking nodeid{}, port{}, macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				continue;
			}
			// regola intersezione nulla non faccio niente
			if (linkcandidate.intersectionNull(topologyLinkCandidate)) {
				LOG.info(
						"parseBFTEntry: rule 00: mac intesection null candidate nodeid {}, port{}: do nothing checking node {}, port {}: macs {}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				continue;
			}

			if (linkcandidate.getRole() == BridgePortRole.BACKBONE) {
				LOG.info(
						"parseBFTEntry: rule 1-d: setting candidate node {} port{} to DIRECT: checking node {}, BACKBONE port{}, macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				linkcandidate.removeMacs(topologyLinkCandidate.getMacs());
				topologyLinkCandidate.setRole(BridgePortRole.DIRECT);
				continue;
			}

			if (topologyLinkCandidate.getRole() == BridgePortRole.BACKBONE) {
				LOG.info(
						"parseBFTEntry: rule 1-r: candidate node{} BACKBONE port{}: setting node {} port{} macs{} to DIRECT",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				topologyLinkCandidate.removeMacs(linkcandidate.getMacs());
				linkcandidate.setRole(BridgePortRole.DIRECT);
				continue;
			}

			// regola della dipendenza assoluta new
			if (topologyLinkCandidate.strictContained(linkcandidate)) {
				LOG.info(
						"parseBFTEntry: rule 2-d: candidate node{} DIRECT port{} strict contained: checking node {} BACKBONE port {} macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());

				linkcandidate.setRole(BridgePortRole.BACKBONE);
				linkcandidate.removeMacs(topologyLinkCandidate.getMacs());
				linkcandidate.addTarget(topologyLinkCandidate
						.getBridgeTopologyPort().getNodeid());
				topologyLinkCandidate.setRole(BridgePortRole.DIRECT);
				continue;
			}

			// regola della dipendenza assoluta old
			if (linkcandidate.strictContained(topologyLinkCandidate)) {
				LOG.info(
						"parseBFTEntry: rule 2-r: candidate node{} BACKBONE port{} strict contains: checking node {} DIRECT port {} macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				topologyLinkCandidate.setRole(BridgePortRole.BACKBONE);
				topologyLinkCandidate.removeMacs(linkcandidate.getMacs());
				topologyLinkCandidate.addTarget(linkcandidate
						.getBridgeTopologyPort().getNodeid());
				linkcandidate.setRole(BridgePortRole.DIRECT);
				continue;
			}

			if (linkcandidate.getLinkPortCandidate() == null
					&& topologyLinkCandidate.getLinkPortCandidate() == null) {
				LOG.info(
						"parseBFTEntry: rule 3: set candidate each other candidate: candidate node{} port{}: checking node {} port {} macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());
				linkcandidate.setLinkPortCandidate(topologyLinkCandidate
						.getBridgeTopologyPort());
				topologyLinkCandidate.setLinkPortCandidate(linkcandidate
						.getBridgeTopologyPort());
				continue;
			}

			if (linkcandidate.getLinkPortCandidate() != null
					&& topologyLinkCandidate.getBridgeTopologyPort()
							.getNodeid().intValue() == linkcandidate
							.getLinkPortCandidate().getNodeid().intValue()
					&& topologyLinkCandidate.getBridgeTopologyPort()
							.getBridgePort().intValue() != linkcandidate
							.getLinkPortCandidate().getBridgePort().intValue()) {
				LOG.info(
						"parseBFTEntry: rule 4-d: candidate node{} DIRECT port{} strict contained: checking node {} BACKBONE port {} macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());

				linkcandidate.setRole(BridgePortRole.BACKBONE);
				linkcandidate.removeMacs(topologyLinkCandidate.getMacs());
				linkcandidate.addTarget(topologyLinkCandidate
						.getBridgeTopologyPort().getNodeid());

				topologyLinkCandidate.setRole(BridgePortRole.DIRECT);
				topologyLinkCandidate.setLinkPortCandidate(null);
				continue;
			}

			if (topologyLinkCandidate.getLinkPortCandidate() != null
					&& linkcandidate.getBridgeTopologyPort().getNodeid()
							.intValue() == topologyLinkCandidate
							.getLinkPortCandidate().getNodeid().intValue()
					&& linkcandidate.getBridgeTopologyPort().getBridgePort()
							.intValue() != topologyLinkCandidate
							.getLinkPortCandidate().getBridgePort().intValue()) {
				LOG.info(
						"parseBFTEntry: rule 4-r: candidate node{} BACKBONE port{} strict contains: checking node {} DIRECT port {} macs{}",
						topologyLinkCandidate.getBridgeTopologyPort()
								.getNodeid(), topologyLinkCandidate
								.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getBridgeTopologyPort().getNodeid(),
						linkcandidate.getBridgeTopologyPort().getBridgePort(),
						linkcandidate.getMacs());

				topologyLinkCandidate.setRole(BridgePortRole.BACKBONE);
				topologyLinkCandidate.removeMacs(linkcandidate.getMacs());
				topologyLinkCandidate.addTarget(linkcandidate
						.getBridgeTopologyPort().getNodeid());

				linkcandidate.setRole(BridgePortRole.DIRECT);
				linkcandidate.setLinkPortCandidate(null);
				continue;
			}
		}
		return topologyLinkCandidate;
	}

