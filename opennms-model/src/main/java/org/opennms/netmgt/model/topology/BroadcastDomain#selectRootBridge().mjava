    private Bridge selectRootBridge() {
        Bridge rootBridge= null;
        //if there is only one bridge....
        if (m_bridges.size() == 1) {
            LOG.debug("calculate: selectRootBridge: only one bridge in topology set root");
            rootBridge = m_bridges.iterator().next();
        }
        //if null try set the stp roots
        if (rootBridge == null) {
            LOG.debug("calculate: selectRootBridge: searching for stp root in topology");
            Set<String> rootBridgeIds=new HashSet<String>();
            for (Bridge bridge: m_bridges) {
                rootBridgeIds.addAll(bridge.getOtherStpRoots());
            }
            //well only one root bridge should be defined....
            //otherwise we need to skip calculation
            //so here is the place were we can
            //manage multi stp domains...
            //ignoring for the moment....
            for (String rootBridgeId: rootBridgeIds) {
                LOG.debug("calculate: selectRootBridge: searching for stp root found: {}", rootBridgeId);
                for (Bridge bridge: m_bridges) {
                    LOG.debug("calculate: selectRootBridge: searching for stp root found: {}, parsing bridge {}", rootBridgeId,bridge.getId());
                    if (bridge.hasBridgeId(rootBridgeId)) {
                        LOG.debug("calculate: selectRootBridge: found stp root bridge: {}", bridge.getId());
                        rootBridge = bridge;
                        break;
                    }
                }
            }
        }

        // no spanning tree root?
        // then find root among switches with
        // updated bft with max bft size
        if (m_rootBridgeId != null) {
            LOG.debug("calculate: selectRootBridge: mantaining old root bridge: {}", m_rootBridgeId);
            return getRootBridge();
        }
        // why I'm here?
        // not root bridge defined (this mean no calculation yet done...
        // so checking the best into not parsed
        if (rootBridge == null) {
            int size = 0;
            Integer rootNodeid = null;
            for (Integer nodeid:  m_notYetParsedBFTMap.keySet()) {
                int cursize = m_notYetParsedBFTMap.get(nodeid).size();
                if (size < cursize) {
                    rootNodeid = nodeid;
                    size = cursize;
                }
            }
            if (rootNodeid != null ) {
                for (Bridge bridge: m_bridges) {
                    if (bridge.getId().intValue() == rootNodeid.intValue()) {
                        rootBridge = bridge;
                        break;
                    }
                }
            }
        }
        
        // still not found...get the first
        if (rootBridge == null)
            rootBridge=m_bridges.iterator().next();
        
        return rootBridge;

    }

