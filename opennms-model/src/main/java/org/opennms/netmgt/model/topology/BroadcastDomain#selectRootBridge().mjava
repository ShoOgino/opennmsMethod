    private void selectRootBridge() {
        LOG.info("selectRootBridge: start");
        Bridge rootBridge= null;
        //if there is only one bridge....
        if (m_bridges.size() == 1) {
            rootBridge = m_bridges.iterator().next();
        }
        //if null try set the stp roots
        if (rootBridge == null) {
            Set<String> rootBridgeIds=new HashSet<String>();
            for (Bridge bridge: m_bridges) {
                rootBridgeIds.addAll(bridge.getOtherStpRoots());
            }
            //well only one root bridge should be defined....
            //otherwise we need to skip calculation
            //so here is the place were we can
            //manage multi stp domains...
            //ignoring for the moment....
            for (String rootBridgeId: rootBridgeIds) {
                for (Bridge bridge: m_bridges) {
                    if (bridge.hasBridgeId(rootBridgeId)) {
                        rootBridge = bridge;
                        break;
                    }
                }
            }
        }

        // no spanning tree root?
        // then find root among switches with
        // updated bft with max bft size
        if (rootBridge == null) {
            int size = 0;
            Integer rootNodeid = null;
            for (Integer nodeid:  m_notYetParsedBFTMap.keySet()) {
                int cursize = m_notYetParsedBFTMap.get(nodeid).size();
                if (size < cursize) {
                    rootNodeid = nodeid;
                    size = cursize;
                }
            }
            if (rootNodeid != null ) {
                for (Bridge bridge: m_bridges) {
                    if (bridge.getId().intValue() == rootNodeid.intValue()) {
                        rootBridge = bridge;
                        break;
                    }
                }
            }
        }
        
        // still not found...get the first
        if (rootBridge == null)
            rootBridge=m_bridges.iterator().next();
        
        m_rootBridgeId = rootBridge.getId();
        rootBridge.setRootBridge(true);
        rootBridge.setRootPort(null);
        if (m_notYetParsedBFTMap.containsKey(m_rootBridgeId)) {
            m_rootBridgeBFT = m_notYetParsedBFTMap.remove(m_rootBridgeId); 
            LOG.info("selectRootBridge: creating shared segment for root bridge in topology:  {}", m_rootBridgeId);
            Map<Integer, SharedSegment> rootleafs=new HashMap<Integer, SharedSegment>();
            for (BridgeMacLink link: m_rootBridgeBFT) {
                if (!rootleafs.containsKey(link.getBridgePort()))
                    rootleafs.put(link.getBridgePort(), new SharedSegment());
                rootleafs.get(link.getBridgePort()).add(link);
            }
            for (SharedSegment rootleaf: rootleafs.values()) 
                m_topology.add(rootleaf);
            LOG.info("selectRootBridge: created: shared segment for root bridge in topology:  {}", m_rootBridgeId);
        }  else
            m_rootBridgeBFT = getEffectiveBFT(rootBridge.getId());
        LOG.info("selectRootBridge: rootBridge is {}", m_rootBridgeId);

    }

