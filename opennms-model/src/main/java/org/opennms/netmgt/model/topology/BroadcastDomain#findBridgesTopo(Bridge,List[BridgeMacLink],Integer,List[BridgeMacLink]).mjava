    private void findBridgesTopo(Bridge rBridge, List<BridgeMacLink> rBFT, Integer xBridgeId, List<BridgeMacLink> xBFT) {
        LOG.info("findBridgesTopo: start:  calculate topology for nodeid {}, against {}", xBridgeId,rBridge.getId());
        BridgeTopologyHelper rx = new BridgeTopologyHelper(rBridge, rBFT, xBridgeId,xBFT);
        Integer rxDesignatedPort = rx.getFirstBridgeConnectionPort();
        if (rxDesignatedPort == null) {
            LOG.info("findBridgesTopo: cannot found top simple connection:  nodeid {}",rBridge.getId());
            return;
        }
        Integer xrDesignatedPort = rx.getSecondBridgeConnectionPort();
         if (xrDesignatedPort == null) {
             LOG.info("findBridgesTopo: cannot found bottom simple connection:  nodeid {}",xBridgeId);
             return;
        }
        LOG.info("findBridgesTopo: found top simple connection:  nodeid {}, port {}",rBridge.getId(),rxDesignatedPort);
        LOG.info("findBridgesTopo: found bottom simple connection:  nodeid {}, port {}",xBridgeId,xrDesignatedPort);
        //get the starting point shared segment of the top bridge
        // where the bridge is learned should not be null
        SharedSegment topSegment = getSharedSegment(rBridge.getId(),rxDesignatedPort);
        if (topSegment == null) {
            LOG.info("findBridgesTopo: created top segment:  for nodeid {}, port {}",rBridge.getId(),rxDesignatedPort);
            topSegment = new SharedSegment(rBridge.getId(),rxDesignatedPort);
            topSegment.assign(rx.getSimpleConnection().getLinks(),rx.getSimpleConnection().getDlink());
            m_topology.add(topSegment);
        }

        for (Bridge yBridge: getBridgeOnSharedSegment(topSegment)) {
            Integer yBridgeId = yBridge.getId();
            // X is a leaf of top segment: of course
            if (yBridgeId.intValue() == rBridge.getId().intValue()) {
                LOG.info("findBridgesTopo: nodeid {} is a leaf of top segment {}, sure", xBridgeId,yBridge.getId());
                continue;
            } 
            Integer yrDesignatedPort = yBridge.getRootPort();
            BridgeTopologyHelper   yx = new BridgeTopologyHelper(yBridge, getEffectiveBFT(yBridgeId),xBridgeId, xBFT);
            Integer  xyDesignatedPort = yx.getSecondBridgeConnectionPort();
            Integer   yxDesignatedPort = yx.getFirstBridgeConnectionPort();
            // X is a leaf of Y
            if (xyDesignatedPort == xrDesignatedPort && yxDesignatedPort != yrDesignatedPort) {
                LOG.info("findBridgesTopo: nodeid {} is a leaf of {}, going down", yBridge.getId(),xBridgeId);
                findBridgesTopo(yBridge, getEffectiveBFT(yBridge.getId()), xBridgeId, xBFT);
                return;
            }
            // Y is a leaf of X
            if (xyDesignatedPort == xrDesignatedPort && yxDesignatedPort != yrDesignatedPort) {
                //create a SharedSegment with root port
                SharedSegment leafSegment = new SharedSegment(xBridgeId, xyDesignatedPort);
                leafSegment.assign(yx.getSimpleConnection().getLinks(),yx.getSimpleConnection().getDlink());
                m_topology.add(leafSegment);
                topSegment.removeBridge(yBridge.getId());
            }            
            // this is a clear violation  of the topology tree rule
            if (xyDesignatedPort != xrDesignatedPort && yxDesignatedPort != yrDesignatedPort) {
                m_topology.clear();
                return;
            }            
        }
        // if we are here is because X is NOT a leaf of any bridge found
        // on topSegment so X is connected to top Segment by it's root 
        // port or rx is a direct connection
        topSegment.assign(rx.getSimpleConnection().getLinks(),rx.getSimpleConnection().getDlink());
        for (Integer xbridgePort: rx.getSecondBridgeTroughSet().keySet()) {
            SharedSegment xleafSegment = new SharedSegment(xBridgeId, xbridgePort);
            xleafSegment.setBridgeMacLinks(rx.getSecondBridgeTroughSet().get(xbridgePort));
            m_topology.add(xleafSegment);
        }
        LOG.info("findBridgesTopo: stop:  calculate topology for nodeid {}, {}", rBridge.getId(),xBridgeId);
    }

