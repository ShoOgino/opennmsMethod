    private void findBridgesTopo(Bridge rBridge, List<BridgeMacLink> rBFT, Integer xBridgeId, List<BridgeMacLink> xBFT) {
        LOG.info("findBridgesTopo: calculate topology for nodeid {}, against {}", xBridgeId,rBridge.getId());
        Bridge xBridge = null;
        for (Bridge bridge: m_bridges) {
            if (bridge.getId() == xBridgeId) {
                xBridge=bridge;
                break;
            }
        }
        if (xBridge == null) {
            LOG.error("findBridgesTopo: not found bridge for nodeid {} exiting....", xBridgeId);
        }
        //LOG.debug("findBridgesTopo: found bridge for nodeid {}, with address {}", xBridgeId,xBridge.getBridgeElements().iterator().next().getBaseBridgeAddress());
        
        BridgeTopologyHelper rx = new BridgeTopologyHelper(rBridge, rBFT, xBridgeId,xBFT);
        Integer rxDesignatedPort = rx.getFirstBridgeConnectionPort();
        if (rxDesignatedPort == null) {
            LOG.info("findBridgesTopo: cannot found top simple connection:  nodeid {}",rBridge.getId());
            return;
        }
        Integer xrDesignatedPort = rx.getSecondBridgeConnectionPort();
         if (xrDesignatedPort == null) {
             LOG.info("findBridgesTopo: cannot found bottom simple connection:  nodeid {}",xBridgeId);
             return;
        }
        LOG.info("findBridgesTopo: found simple connection:  nodeid {}, port {} <--> nodeid {}, port {}",rBridge.getId(),rxDesignatedPort,xBridgeId,xrDesignatedPort);
        LOG.info("findBridgesTopo: set root port {} for nodeid {}",xrDesignatedPort,xBridgeId);
//        xBridge.setRootPort(xrDesignatedPort);
//        xBridge.setRootBridge(false);
        //get the starting point shared segment of the top bridge
        // where the bridge is learned should not be null
        SharedSegment topSegment = getSharedSegment(rBridge.getId(),rxDesignatedPort);
        if (topSegment == null) {
            LOG.info("findBridgesTopo: created top segment:  for nodeid {}, port {}",rBridge.getId(),rxDesignatedPort);
            topSegment = new SharedSegment(rBridge.getId(),rxDesignatedPort);
            topSegment.assign(rx.getSimpleConnection().getLinks(),rx.getSimpleConnection().getDlink());
            m_topology.add(topSegment);
        }

        for (Bridge yBridge: getBridgeOnSharedSegment(topSegment)) {
            LOG.debug("findBridgesTopo: checking Bridge {} to see how is connected to topSegment", yBridge.getId());
            Integer yBridgeId = yBridge.getId();
            // X is a leaf of top segment: of course
            if (yBridgeId.intValue() == rBridge.getId().intValue()) {
                LOG.info("findBridgesTopo: nodeid {} is a leaf of top segment {}, sure", xBridgeId,yBridge.getId());
                continue;
            } 
            Integer yrDesignatedPort = yBridge.getRootPort();
            LOG.info("findBridgesTopo: found Y designated port:  nodeid {}, port {}",yBridgeId,yrDesignatedPort);
            BridgeTopologyHelper   yx = new BridgeTopologyHelper(yBridge, getEffectiveBFT(yBridgeId),xBridgeId, xBFT);
            Integer  xyDesignatedPort = yx.getSecondBridgeConnectionPort();
            Integer  yxDesignatedPort = yx.getFirstBridgeConnectionPort();
            LOG.info("findBridgesTopo: found simple connection:  nodeid {}, port {} <--> nodeid {}, port {}",xBridgeId,xyDesignatedPort,yBridgeId,yxDesignatedPort);
            // X is a leaf of Y then iterate
            if (xyDesignatedPort == xrDesignatedPort && yxDesignatedPort != yrDesignatedPort) {
                LOG.info("findBridgesTopo: nodeid {} is a leaf of {}, going down",xBridgeId,yBridge.getId());
                findBridgesTopo(yBridge, getEffectiveBFT(yBridge.getId()), xBridgeId, xBFT);
                return;
            }
            // Y is a leaf of X then remove Y from topSegment
            if (yxDesignatedPort == yrDesignatedPort && xyDesignatedPort != xrDesignatedPort) {
                //create a SharedSegment with root port
                LOG.info("findBridgesTopo: removing from top segment nodeid {} that is a leaf of {} ", yBridge.getId(),xBridgeId);
                SharedSegment leafSegment = new SharedSegment(xBridgeId, xyDesignatedPort);
                leafSegment.assign(yx.getSimpleConnection().getLinks(),yx.getSimpleConnection().getDlink());
                m_topology.add(leafSegment);
                topSegment.removeBridge(yBridge.getId());
            }            
            // this is a clear violation  of the topology tree rule
            if (xyDesignatedPort != xrDesignatedPort && yxDesignatedPort != yrDesignatedPort) {
                LOG.error("findBridgesTopo: topology mismatch. Clearing...topology");
                m_topology.clear();
                return;
            }            
        }
        // if we are here is because X is NOT a leaf of any bridge found
        // on topSegment so X is connected to top Segment by it's root 
        // port or rx is a direct connection
        topSegment.assign(rx.getSimpleConnection().getLinks(),rx.getSimpleConnection().getDlink());
        for (Integer xbridgePort: rx.getSecondBridgeTroughSet().keySet()) {
            SharedSegment xleafSegment = new SharedSegment(xBridgeId, xbridgePort);
            xleafSegment.setBridgeMacLinks(rx.getSecondBridgeTroughSet().get(xbridgePort));
            m_topology.add(xleafSegment);
        }
        LOG.info("findBridgesTopo: topology calculated for nodeid: {}", xBridgeId);
    }

