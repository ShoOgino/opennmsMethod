    public synchronized void calculate() {
        LOG.info("calculate: start:  calculate topology");
        m_calculating = true;
        m_topologyChanged=false;
        selectRootBridge();
        hierarchySetUp();

        // the root bridge is the only bridge in topology
        if (m_topology.isEmpty() && m_notYetParsedBFTMap.isEmpty() && m_rootBridgeBFT != null) {
            LOG.info("calculate: only root bridge in topology:  {}", m_rootBridgeId);
            m_calculating = false;
            LOG.info("calculate: stop:  calculate topology for nodeids {}", m_bridges);
            return;
        }
        Set<Integer> nodeids = new HashSet<Integer>();
        nodeids.addAll(m_notYetParsedBFTMap.keySet());
        for (Integer nodeid: nodeids) 
            findBridgesTopo(getRootBridge(), m_rootBridgeBFT, nodeid, m_notYetParsedBFTMap.remove(nodeid));
       
        m_calculating = false;
        LOG.info("calculate: stop:  calculate topology");

    }

