    public synchronized void calculate() {
        LOG.info("calculate: start:  calculate topology");
        m_calculating = true;
                
        Bridge electedRoot = selectRootBridge();
        if (electedRoot == null || electedRoot.getId() == null) {
            LOG.error("calculate: electedRoot should not be null");
            return;
        }
        setUpRoot(electedRoot);
        
        Set<Integer> nodetobeparsed=new HashSet<Integer>(m_notYetParsedBFTMap.keySet());
        for (Integer nodeid: nodetobeparsed) {
            LOG.info("calculate: start: calculate topology for nodeid {}",nodeid);
            Bridge xBridge = null;
            for (Bridge bridge: m_bridges) {
                if (bridge.getId().intValue() == nodeid.intValue()) {
                    xBridge=bridge;
                    break;
                }
            }
            if (xBridge == null) {
                LOG.error("calculate: not found bridge for nodeid {} exiting....", nodeid);
                m_topology.clear();
                return;
            }
            calculate(electedRoot, m_rootBridgeBFT, xBridge, new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(nodeid)));
            LOG.info("calculate: stop: calculate topology for nodeid {}",nodeid);
        }
        m_topologyChanged=false;
        m_calculating = false;
        LOG.info("calculate: stop:  calculate topology");

    }

