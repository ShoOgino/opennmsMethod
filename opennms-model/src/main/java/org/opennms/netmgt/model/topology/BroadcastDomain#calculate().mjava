    public synchronized void calculate() {
        LOG.info("calculate: start:  calculate topology");
        m_calculating = true;
                
        Bridge electedRoot = selectRootBridge();
        if (electedRoot == null || electedRoot.getId() == null) {
            LOG.error("calculate: electedRoot should not be null");
            return;
        }
        
        if (electedRoot.isRootBridge() && !m_notYetParsedBFTMap.containsKey(electedRoot.getId())) {
            LOG.info("calculate: selected root bridge: {}, is old root bridge with old bft",
                     electedRoot.getId());
        } else if (electedRoot.isRootBridge() && m_notYetParsedBFTMap.containsKey(electedRoot.getId())) {
            LOG.info("calculate: selected root bridge: {}, is old root bridge with new bft",
                     electedRoot.getId());
            m_rootBridgeBFT = new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(electedRoot.getId()));
            LOG.debug("calculate: set bft for root bridge {}  size:  {}",
                          electedRoot.getId(), m_rootBridgeBFT.size());
        } else if (!electedRoot.isRootBridge() && m_notYetParsedBFTMap.containsKey(electedRoot.getId())) {
            LOG.info("calculate: selected root bridge: {}, has new bft",
                         electedRoot.getId());
           List<BridgeMacLink>  electedRootBFT = new ArrayList<BridgeMacLink>(
                   m_notYetParsedBFTMap.remove(electedRoot.getId()));
           if (m_topology.isEmpty()) {
                Map<Integer, SharedSegment> rootleafs = new HashMap<Integer, SharedSegment>();
                for (BridgeMacLink link : electedRootBFT) {
                    if (link.getBridgeDot1qTpFdbStatus() != BridgeDot1qTpFdbStatus.DOT1D_TP_FDB_STATUS_LEARNED)
                        continue;
                    if (rootleafs.containsKey(link.getBridgePort()))
                        rootleafs.get(link.getBridgePort()).add(link);
                    else
                        rootleafs.put(link.getBridgePort(),
                                      new SharedSegment(link));
                }
                for (SharedSegment rootleaf : rootleafs.values()) {
                    LOG.info("calculate: adding shared segment to topology: root bridge {} port: {}, mac size: {}, bft size: {}",
                             rootleaf.getDesignatedBridge(),
                             rootleaf.getDesignatedPort(),
                             rootleaf.getMacsOnSegment().size(),
                             rootleaf.getBridgeMacLinks().size());
                    m_topology.add(rootleaf);
                }
                m_rootBridgeId = electedRoot.getId();
                electedRoot.setRootBridge(true);
                electedRoot.setRootPort(null);
           } else {
                LOG.info("calculate: find topology for new elected root bridge:  {}",
                         electedRoot.getId());
                calculate(getRootBridge(), m_rootBridgeBFT,
                                electedRoot, electedRootBFT);
                m_rootBridgeId = electedRoot.getId();
                electedRoot.setRootBridge(true);
                electedRoot.setRootPort(null);
                hierarchySetUp();
           }
           m_rootBridgeBFT = electedRootBFT;
           LOG.debug("calculate: set bft for root bridge {}  size:  {}",
                          electedRoot.getId(), m_rootBridgeBFT.size());
        } else if (!electedRoot.isRootBridge() && !m_notYetParsedBFTMap.containsKey(electedRoot.getId())){
            LOG.info("calculate: selected root bridge: {}, has old bft",
                     electedRoot.getId());
            m_rootBridgeId = electedRoot.getId();
            electedRoot.setRootBridge(true);
            electedRoot.setRootPort(null);
            hierarchySetUp();
            m_rootBridgeBFT = getEffectiveBFT(electedRoot);
            LOG.debug("calculate: set bft for root bridge {}  size:  {}",
                           electedRoot.getId(), m_rootBridgeBFT.size());
        }
        
        Set<Integer> nodetobeparsed=new HashSet<Integer>(m_notYetParsedBFTMap.keySet());
        for (Integer nodeid: nodetobeparsed) {
            LOG.info("calculate: start: calculate topology for nodeid {}",nodeid);
            Bridge xBridge = null;
            for (Bridge bridge: m_bridges) {
                if (bridge.getId().intValue() == nodeid.intValue()) {
                    xBridge=bridge;
                    break;
                }
            }
            if (xBridge == null) {
                LOG.error("calculate: not found bridge for nodeid {} exiting....", nodeid);
                m_topology.clear();
                return;
            }
            calculate(electedRoot, m_rootBridgeBFT, xBridge, new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(nodeid)));
            LOG.info("calculate: stop: calculate topology for nodeid {}",nodeid);
        }
        m_topologyChanged=false;
        m_calculating = false;
        LOG.info("calculate: stop:  calculate topology");

    }

