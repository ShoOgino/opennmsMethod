    public synchronized void calculate() {
        m_calculating = true;
        selectRootBridge();
        hierarchySetUp();

        // the root bridge is the only bridge in topology
        if (m_topology.isEmpty() && m_notYetParsedBFTMap.isEmpty() && m_rootBridgeBFT != null) {
            Map<Integer, SharedSegment> rootleafs=new HashMap<Integer, SharedSegment>();
            for (BridgeMacLink link: m_rootBridgeBFT) {
                if (!rootleafs.containsKey(link.getBridgePort()))
                    rootleafs.put(link.getBridgePort(), new SharedSegment());
                rootleafs.get(link.getBridgePort()).add(link);
            }
            for (SharedSegment rootleaf: rootleafs.values()) 
                m_topology.add(rootleaf);
            return;
        }
        Set<Integer> nodeids = new HashSet<Integer>();
        nodeids.addAll(m_notYetParsedBFTMap.keySet());
        for (Integer nodeid: nodeids) 
            findBridgesTopo(getRootBridge(), m_rootBridgeBFT, nodeid, m_notYetParsedBFTMap.remove(nodeid));
       
        m_calculating = false;
    }

