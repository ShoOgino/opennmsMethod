    /**
     * Stops the currently running service. If the service is not running then
     * the command is silently discarded.
     */
    @Override
    public synchronized void onStop() {
        m_status = STOP_PENDING;

        // shutdown and wait on the background processing thread to exit.
        LogUtils.debugf(this, "stop: closing communication paths.");

        try {
            if (m_registeredForTraps) {
                LogUtils.debugf(this, "stop: Closing SNMP trap session.");
                SnmpUtils.unregisterForTraps(this, getInetAddress(), getSnmpTrapPort());
                LogUtils.debugf(this, "stop: SNMP trap session closed.");
            } else {
            	LogUtils.debugf(this, "stop: not attemping to closing SNMP trap session--it was never opened");
            }

        } catch (final IOException e) {
            LogUtils.warnf(this, e, "stop: exception occurred closing session");
        } catch (final IllegalStateException e) {
            LogUtils.debugf(this, e, "stop: The SNMP session was already closed");
        }

        LogUtils.debugf(this, "stop: Stopping queue processor.");

        m_processor.stop();
        m_eventReader.close();

        m_status = STOPPED;

        LogUtils.debugf(this, "stop: Trapd stopped");
    }

