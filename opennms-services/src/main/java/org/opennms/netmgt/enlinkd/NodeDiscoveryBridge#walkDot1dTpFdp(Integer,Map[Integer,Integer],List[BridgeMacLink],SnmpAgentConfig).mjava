    private List<BridgeMacLink> walkDot1dTpFdp(final Integer vlan,
            final Map<Integer, Integer> bridgeifindex,
            List<BridgeMacLink> bft, SnmpAgentConfig peer) {
        String trackerName = "dot1dTbFdbPortTable";

        Dot1dTpFdbTableTracker stpPortTableTracker = new Dot1dTpFdbTableTracker() {

        	
            @Override
            public void processDot1dTpFdbRow(final Dot1dTpFdbRow row) {
                BridgeMacLink link = row.getLink();
                if (link.getBridgeDot1qTpFdbStatus() == null) {
                    LOG.warn("processDot1dTpFdbRow: node [{}]: mac {}: vlan {}: on port {}. row has null status. ",
                    		getNodeId(),
                             row.getDot1dTpFdbAddress(), vlan,
                             row.getDot1dTpFdbPort());
                    return;
                }
                if (link.getBridgePort() == null) {
                    LOG.warn("processDot1dTpFdbRow: node [{}]: mac {}: vlan {}: on port {} status {}. row has null bridge port.  ",
                    		getNodeId(),
                             row.getDot1dTpFdbAddress(), vlan,
                             row.getDot1dTpFdbPort(),
                             link.getBridgeDot1qTpFdbStatus());
                    return;
                }
                if (link.getMacAddress() == null
                        || !isValidBridgeAddress(link.getMacAddress())) {
                    LOG.warn("processDot1dTpFdbRow: node [{}]: mac {}: vlan {}: on port {} ifindex {} status {}. row has invalid mac.",
                    		getNodeId(),
                             row.getDot1dTpFdbAddress(), vlan,
                             row.getDot1dTpFdbPort(),
                             link.getBridgePortIfIndex(),
                             link.getBridgeDot1qTpFdbStatus());
                    return;
                }
                link.setVlan(vlan);

                if (!bridgeifindex.containsKey(link.getBridgePort())
                        && link.getBridgeDot1qTpFdbStatus() != BridgeDot1qTpFdbStatus.DOT1D_TP_FDB_STATUS_SELF) {
                    LOG.warn("processDot1dTpFdbRow: node [{}]: mac {}: vlan {}: on port {} ifindex {} status {}. row has invalid bridge port. no ifindex found. ",
                    		getNodeId(),
                             row.getDot1dTpFdbAddress(), vlan,
                             row.getDot1dTpFdbPort(),
                             link.getBridgePortIfIndex(),
                             link.getBridgeDot1qTpFdbStatus());
                    return;
                }
                link.setBridgePortIfIndex(bridgeifindex.get(link.getBridgePort()));
                LOG.debug("processDot1dTpFdbRow: node [{}]: mac {}: vlan {}: on port {} ifindex {} status {}. row processed.",
                		getNodeId(),
                         link.getMacAddress(), link.getVlan(),
                         link.getBridgePort(), link.getBridgePortIfIndex(),
                         link.getBridgeDot1qTpFdbStatus());
                bft.add(link);
            }
        };
        SnmpWalker walker = SnmpUtils.createWalker(peer, trackerName,
                                                   stpPortTableTracker);
        walker.start();

        try {
            walker.waitFor();
            if (walker.timedOut()) {
                LOG.info("run:Aborting Bridge Linkd node scan : Agent timed out while scanning the {} table",
                         trackerName);
                return bft;
            } else if (walker.failed()) {
                LOG.info("run:Aborting Bridge Linkd node scan : Agent failed while scanning the {} table: {}",
                         trackerName, walker.getErrorMessage());
                return bft;
            }
        } catch (final InterruptedException e) {
            LOG.error("run: Bridge Linkd node collection interrupted, exiting",
                      e);
            return bft;
        }
        return bft;
    }

