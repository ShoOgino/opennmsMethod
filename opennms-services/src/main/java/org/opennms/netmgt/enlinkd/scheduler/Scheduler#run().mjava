	/**
	 * The main method of the scheduler. This method is responsible for checking
	 * the runnable queues for ready objects and then enqueuing them into the
	 * thread pool for execution.
	 */
    @Override
    public void run() {

        synchronized (this) {
            m_status = RUNNING;
        }

        LOG.debug("run: scheduler running");

        // Loop until a fatal exception occurs or until
        // the thread is interrupted.
        //
        for (;;) {
            // block if there is nothing in the queue(s)
            // When something is added to the queue it
            // signals us to wakeup
            //
            synchronized (this) {
                if (m_status != RUNNING && m_status != PAUSED
                        && m_status != PAUSE_PENDING
                        && m_status != RESUME_PENDING) {
                    LOG.debug("run: status = {}, time to exit", m_status);
                    break;
                }

                if (m_scheduled == 0) {
                    try {
                        LOG.debug("run: no interfaces scheduled, waiting...");
                        wait();
                    } catch (InterruptedException ex) {
                        break;
                    }
                }
            }

            // cycle through the queues checking for
            // what's ready to run. The queues are keyed
            // by the interval, but the mapped elements
            // are peekable fifo queues.
            //
            int runned = 0;
            synchronized (m_queues) {
                // get an iterator so that we can cycle
                // through the queue elements.
                //
                for (Entry<Long, PeekableFifoQueue<ReadyRunnable>> entry : m_queues.entrySet()) {
                    // Peak for Runnable objects until
                    // there are no more ready runnables
                    //
                    // Also, only go through each queue once!
                    // if we didn't add a count then it would
                    // be possible to starve other queues.
                    //
                    PeekableFifoQueue<ReadyRunnable> in = entry.getValue();
                    ReadyRunnable readyRun = null;
                    int maxLoops = in.size();
                    do {
                        try {
                            readyRun = in.peek();
                            if (readyRun != null) {
                                // Pop the interface/readyRunnable from the
                                // queue for execution.
                                //
                                in.remove();

                                if (readyRun.isReady()) {
                                    LOG.debug("run: runnable {}, executing",
                                              readyRun.getInfo());

                                    // Add runnable to the execution queue
                                    m_runner.execute(readyRun);
                                    ++runned;
                                    
                                    // Increment the execution counter
                                    ++m_numTasksExecuted;

                                    // Thread Pool Statistics
                                    if (m_runner instanceof ThreadPoolExecutor) {
                                        ThreadPoolExecutor e = (ThreadPoolExecutor) m_runner;
                                        String ratio = String.format("%.3f", e.getTaskCount() > 0 ? new Double(e.getCompletedTaskCount())/new Double(e.getTaskCount()) : 0);
                                        LOG.debug("thread pool statistics: activeCount={}, taskCount={}, completedTaskCount={}, completedRatio={}, poolSize={}",
                                            e.getActiveCount(), e.getTaskCount(), e.getCompletedTaskCount(), ratio, e.getPoolSize());
                                    }

                                } else {
                                    in.add(readyRun);
                                }
                            }
                        } catch (InterruptedException ex) {
                            return; // jump all the way out
                        }
                    } while (--maxLoops > 0);
                }

            }

            // Wait for 1 second if there were no runnables
            // executed during this loop, otherwise just
            // start over.
            //
            synchronized (this) {
                m_scheduled -= runned;
                if (runned == 0) {
                    try {
                        wait(1000);
                    } catch (InterruptedException ex) {
                        break; // exit for loop
                    }
                }
            }

        } // end for(;;)

        LOG.debug("run: scheduler exiting, state = STOPPED");
        synchronized (this) {
            m_status = STOPPED;
        }

    } // end run

