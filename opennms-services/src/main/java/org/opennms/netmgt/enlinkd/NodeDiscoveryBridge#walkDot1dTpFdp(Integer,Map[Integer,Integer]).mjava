	private void walkDot1dTpFdp(final Integer vlan, final Map<Integer,Integer> bridgeifindex) {
		String trackerName = "dot1dTbFdbPortTable";

		Dot1dTpFdbTableTracker stpPortTableTracker = new Dot1dTpFdbTableTracker() {

			@Override
			public void processDot1dTpFdbRow(final Dot1dTpFdbRow row) {
				BridgeMacLink link = row.getLink();
				Integer ifindex = bridgeifindex.get(link.getBridgePort());
				LOG.debug("processDot1dTpFdbRow: found mac {}: vlan {}: on port {} ifindex {}", row.getDot1dTpFdbAddress(), vlan, row.getDot1dTpFdbPort(),ifindex);
				link.setVlan(vlan);
				link.setBridgePortIfIndex(ifindex);
				if (isValidBridgeAddress(link.getMacAddress())
						&& link.getBridgeDot1qTpFdbStatus() == BridgeMacLink.BridgeDot1qTpFdbStatus.DOT1D_TP_FDB_STATUS_LEARNED)
					m_linkd.getQueryManager().store(getNodeId(), link);
			}
		};
		SnmpWalker walker = SnmpUtils.createWalker(getPeer(), trackerName,
				stpPortTableTracker);
		walker.start();

		try {
			walker.waitFor();
			if (walker.timedOut()) {
				LOG.info("run:Aborting Bridge Linkd node scan : Agent timed out while scanning the {} table",
						trackerName);
				return;
			} else if (walker.failed()) {
				LOG.info("run:Aborting Bridge Linkd node scan : Agent failed while scanning the {} table: {}",
						trackerName, walker.getErrorMessage());
				return;
			}
		} catch (final InterruptedException e) {
			LOG.error("run: Bridge Linkd node collection interrupted, exiting",e);
			return;
		}
	}

