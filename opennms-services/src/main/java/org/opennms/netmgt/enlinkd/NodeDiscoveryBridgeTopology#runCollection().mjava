    @Override
    protected void runCollection() {
        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();
        Date now = new Date();
        m_domain = m_linkd.getQueryManager().getBridgeTopologyBroadcastDomain(getNodeId());
        if (m_domain == null ) {
            LOG.warn("run: no broadcast domain found for node: {}", getNodeId());
            return;
        }
        try {
        if (!m_domain.getLock(this)) {
            LOG.info("run: broadcast domain: is locked for calculation either on node {}....", getNodeId());
            return;
        }
        
        setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        
        if (!m_domain.hasRootBridge()) {
            LOG.info("run: node: {}, broadcast domain has no root bridge.", getNodeId());
        }  else {
            Integer rootBridgeId = m_domain.getRootBridgeId();
            LOG.info("run: node: {}, broadcast domain with root bridge: {}.", getNodeId(),rootBridgeId);
            m_rootBridgeBFT = m_linkd.getQueryManager().getBridgeTopologyRootBFT(rootBridgeId);
            LOG.info("run: node: {}, broadcast domain has root bridge with bft size: {}.", getNodeId(),m_rootBridgeBFT.size());
        }        
        
        for (Integer nodeid: m_domain.getBridgeNodesOnDomain()) {
            LOG.debug("run: node: {}, getting update bft for node {} on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().getBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.debug("run: node: {}, no update bft for node {} on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }
        if (m_notYetParsedBFTMap.isEmpty()) {
            LOG.info("run: node: {}, broadcast domain has no topology updates. No more action is needed.", getNodeId());
            return;
        }
        
        LOG.info("run: node: {}, getLock broadcast domain with topology change found.", getNodeId());
        LOG.info("run: node: {}, start: broadcast domain topology calculation.", getNodeId());
        calculate();
        LOG.info("run: node: {}, stop: broadcast domain topology calculated.", getNodeId());

        LOG.info("run: node: {}, saving broadcast domain root bridge: {} bft.", getNodeId(),m_domain.getRootBridgeId());
        m_linkd.getQueryManager().save(m_domain.getRootBridgeId(), m_rootBridgeBFT);

        LOG.info("run: node: {}, saving broadcast domain topology.", getNodeId());
        m_linkd.getQueryManager().store(m_domain);
        LOG.info("run: node: {}, saved broadcast domain topology.", getNodeId());
        
        for (Integer nodeid: m_domain.getBridgeNodesOnDomain()) {
           LOG.info("run: reconcile topology for node: {} on Broadcast Domain",nodeid);
           m_linkd.getQueryManager().reconcileBridgeTopology(nodeid, now);
        }
        } catch (Exception e) {
            LOG.error("run: node: {}, got exception",e);
           
        } finally {
            m_domain.releaseLock(this);
            LOG.info("run: node: {}, releaseLock broadcast domain.", getNodeId());
        }
    }

