    @Override
    public void loadBridgeTopology() {
        List<SharedSegment> segments = new ArrayList<SharedSegment>();
        for (BridgeMacLink link : m_bridgeMacLinkDao.findAll()) {
            link.setBridgeDot1qTpFdbStatus(BridgeDot1qTpFdbStatus.DOT1D_TP_FDB_STATUS_LEARNED);
            for (SharedSegment segment : segments) {
                if (segment.containsMac(link.getMacAddress())
                        || segment.containsPort(link.getNode().getId(),
                                                link.getBridgePort())) {
                    segment.add(link);
                    break;
                }
            }
            SharedSegment segment = new SharedSegment();
            segment.add(link);
            segments.add(segment);
        }

        for (BridgeBridgeLink link : m_bridgeBridgeLinkDao.findAll()) {
            for (SharedSegment segment : segments) {
                if (segment.containsPort(link.getNode().getId(),
                                         link.getBridgePort())
                     || segment.containsPort(link.getDesignatedNode().getId(),
                                             link.getDesignatedPort())) {
                    segment.add(link);
                    break;
                }
            }
            SharedSegment segment = new SharedSegment();
            segment.add(link);
            segments.add(segment);
        }
        Set<Set<Integer>> nodelinked = new HashSet<Set<Integer>>();
        for (SharedSegment segmentA: segments) {
            if (segmentA.getBridgeIdsOnSegment().size() == 1)
                continue;
            System.out.println("--------");
            System.out.println("nodelinked: "+nodelinked);
            System.out.println("nodes on segment: " + segmentA.getBridgeIdsOnSegment());
            boolean tobeadded = true;
            Set<Integer> intersection=new HashSet<Integer>(segmentA.getBridgeIdsOnSegment());
            for (Set<Integer> nodes : nodelinked) {
                System.out.println("nodes on set: " + nodes);
                intersection.retainAll(nodes);
                System.out.println("intersection: "+intersection);
                if (!intersection.isEmpty()) {
                    nodes.addAll(segmentA.getBridgeIdsOnSegment());
                    tobeadded=false;
                    break;
                }
            }
            if (tobeadded)
                nodelinked.add(new HashSet<Integer>(segmentA.getBridgeIdsOnSegment()));
        }
        
        System.out.println(nodelinked);
        Set<BroadcastDomain> domains = new HashSet<BroadcastDomain>();
        for (Set<Integer> nodes : nodelinked) {
            BroadcastDomain domain = new BroadcastDomain();
            for (Integer nodeid: nodes)
                domain.addBridge(new Bridge(nodeid));
            domains.add(domain);
        }
        // Assign the segment to domain and add to single nodes
        for (SharedSegment segment : segments) {
            System.out.println("Adding segment: " + segment.getBridgeIdsOnSegment());
            BroadcastDomain domain = null;
            for (BroadcastDomain cdomain: domains) {
                System.out.println("Parsing domain: " + cdomain.getBridgeNodesOnDomain());
                if (cdomain.containsAtleastOne(segment.getBridgeIdsOnSegment())) {
                    domain = cdomain;
                    System.out.println("Matched domain: "+cdomain.getBridgeNodesOnDomain());
                    break;
                }
            }
            if (domain == null) {
                domain = new BroadcastDomain();
                domains.add(domain);
            }
            domain.loadTopologyEntry(segment);
        }

        m_bridgeTopologyDao.load(domains);
    }

