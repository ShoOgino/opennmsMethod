    private Bridge electRootBridge() {
        //if null try set the stp roots
        Set<String> rootBridgeIds=new HashSet<String>();
        for (BridgeElement bridge: m_bridgeelements ) {
            if (InetAddressUtils.isValidStpBridgeId(bridge.getStpDesignatedRoot()) && !bridge.getBaseBridgeAddress().equals(InetAddressUtils.getBridgeAddressFromStpBridgeId(bridge.getStpDesignatedRoot()))) {
                rootBridgeIds.add(InetAddressUtils.getBridgeAddressFromStpBridgeId(bridge.getStpDesignatedRoot()));
                LOG.info("calculate: node [{}]: electRootBridge: bridge [{}]: stp root {} on the BroadcastDomain.", 
                		getNodeId(),
                		bridge.getNode().getId(),
                		bridge.getStpDesignatedRoot());
            }
        }
        //well only one root bridge should be defined....
        //otherwise we need to skip calculation
        //so here is the place were we can
        //manage multi stp domains...
        //ignoring for the moment....
        for (String rootBridgeId: rootBridgeIds) {
            for (BridgeElement bridge: m_bridgeelements) {
                LOG.debug("calculate: node [{}]: electRootBridge: parsing stp root {}, bridge[{}]: base address {}, "
                        + "against bridge: {}", 
                        getNodeId(),
                        rootBridgeId,
                        bridge.getNode().getId(),
                        bridge.getBaseBridgeAddress());
                if (bridge.getBaseBridgeAddress().equals((rootBridgeId))) {
                    LOG.debug("calculate: node [{}]: electRootBridge: bridge [{}]: bridge base address: {}. Root bridge.", 
                            getNodeId(),
                            bridge.getNode().getId(),
                            bridge.getBaseBridgeAddress());
                    return m_domain.getBridge(bridge.getNode().getId());
                }
            }
        }

        return null;
    }

