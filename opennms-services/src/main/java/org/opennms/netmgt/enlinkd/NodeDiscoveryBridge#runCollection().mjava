    protected void runCollection() {
        LOG.info("run: start discovery operations for node: [{}]",
                 getNodeId());
        final Date now = new Date();

        Map<Integer, String> vlanmap = getVtpVlanMap(getPeer());
        if (vlanmap.isEmpty())
            vlanmap.put(null, null);

        List<BridgeMacLink> bft = new ArrayList<BridgeMacLink>();
        Map<Integer, Integer> bridgeifindex = new HashMap<Integer, Integer>();

        String community = getPeer().getReadCommunity();
        for (Entry<Integer, String> entry : vlanmap.entrySet()) {
            LOG.debug("run: node [{}] cisco vtp: setting peer community for VLAN {}",
            		 getNodeId(),
                      entry.getValue());
            SnmpAgentConfig peer = getPeer();
            if (entry.getKey() != null)
                peer.setReadCommunity(community + "@" + entry.getKey());
            LOG.debug("run: walking dot1d basedata on node [{}}, vlan [{}], vlanname {}.",
                      getNodeId(), entry.getKey(), entry.getValue());

            BridgeElement bridge = getDot1dBridgeBase(peer);
            if (bridge != null) {
                bridge.setVlan(entry.getKey());
                bridge.setVlanname(entry.getValue());
                m_linkd.getQueryManager().store(getNodeId(), bridge);
            } else {
                LOG.debug("run: no dot1d data found on node [{}], vlan [{}], vlanname {}. skipping other operations",
                          getNodeId(), entry.getKey(), entry.getValue());
                continue;
            }

            Map<Integer,Integer> vlanbridgetoifindex = walkDot1dBasePortTable(peer);
            LOG.debug("run: found on node: [{}] vlan: [{}], bridge ifindex map {}",
                      getNodeId(), entry.getValue(), vlanbridgetoifindex);
            if (!isValidStpBridgeId(bridge.getStpDesignatedRoot())) {
                LOG.info("run: node [{}]: invalid designated root: spanning tree not supported.",
                         getNodeId());
            } else if (bridge.getBaseBridgeAddress().equals(getBridgeAddressFromStpBridgeId(bridge.getStpDesignatedRoot()))) {
                LOG.info("run: node [{}]: designated root {} is itself. Skipping store.",
                		 getNodeId(),
                         bridge.getStpDesignatedRoot());
            } else {
                for (BridgeStpLink stplink: walkSpanningTree(peer,
                                 bridge.getBaseBridgeAddress())) {
                    stplink.setVlan(entry.getKey());
                    stplink.setStpPortIfIndex(vlanbridgetoifindex.get(stplink.getStpPort()));
                    m_linkd.getQueryManager().store(getNodeId(), stplink);

                }
            }

            bridgeifindex.putAll(vlanbridgetoifindex);
            bft = walkDot1dTpFdp(entry.getKey(), bridgeifindex, bft, peer);
        }
		
        LOG.debug("run: node [{}]: bridge ifindex map {}",
                  getNodeId(), bridgeifindex);
        bft = walkDot1qTpFdb(getPeer(),bridgeifindex, bft);
        LOG.debug("run: node [{}]: bft size:{}", getNodeId(), bft.size());

        if (bft.size() > 0) {
            LOG.debug("run: node [{}]: updating topology", getNodeId());
        	m_linkd.getQueryManager().store(getNodeId(), bft);
        	m_linkd.scheduleBridgeTopologyDiscovery(getNodeId());
        }
        LOG.debug("run: node [{}]: deleting older the time {}", getNodeId(), now);
        m_linkd.collectedBft(getNodeId());
        m_linkd.getQueryManager().reconcileBridge(getNodeId(), now);
        LOG.info("run: end: node discovery operations for bridge: '{}'",
                 getNodeId());
    }

