    protected  void calculate() {
        LOG.info("calculate: start:  calculate topology");

        for (Bridge xBridge: m_notYetParsedBFTMap.keySet()) {
            LOG.info("calculate: bridge: {} has an updated bft. Clear bridge topology", xBridge.getId());
            clearTopologyForBridge(xBridge);
        }        

        Bridge electedRoot = electRootBridge();
        if (electedRoot == null || electedRoot.getId() == null) {
            LOG.error("calculate: electedRoot should not be null");
            return;
        }
        setUpRoot(electedRoot);
        
        Set<Bridge> nodetobeparsed = new HashSet<Bridge>(m_notYetParsedBFTMap.keySet());
        for (Bridge xBridge: nodetobeparsed) {
            LOG.info("calculate: start: calculate topology for nodeid {}",xBridge.getId());
            calculate(electedRoot, m_rootBridgeBFT, xBridge, new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(xBridge)));
            LOG.info("calculate: stop: calculate topology for nodeid {}",xBridge.getId());
        }
        LOG.info("calculate: stop:  calculate topology");
    }

