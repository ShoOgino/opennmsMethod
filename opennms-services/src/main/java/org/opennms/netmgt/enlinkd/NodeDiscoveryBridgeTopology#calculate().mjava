    protected  void calculate() {
        LOG.info("calculate: start:  calculate topology");

        Bridge electedRoot = null;
        if (m_domain.getBridges().size() == 1) {
            LOG.debug("calculate: node [{}]: electRootBridge: only one bridge in domain {}, electing to root", 
            		getNodeId(),
            		m_domain.getBridgeNodesOnDomain());
            electedRoot = m_domain.getBridges().iterator().next();
        } else {
        	electedRoot = electRootBridge();
        } 
        if (electedRoot == null) {
	        // no spanning tree root?
	        // why I'm here?
	        // not root bridge defined (this mean no calculation yet done...
	        // so checking the best into not parsed
	        int size=0;
	        if (m_domain.calculateRootBFT() != null )
	            size = m_domain.calculateRootBFT().size();
	        
	        Bridge rootBridge = null;
	        for (Bridge bridge:  m_notYetParsedBFTMap.keySet()) {
	            if (size < m_notYetParsedBFTMap.get(bridge).size()) {
	                rootBridge = bridge;
	                size = m_notYetParsedBFTMap.get(bridge).size();
	            }
	        }
	        if (rootBridge != null ) {
	            LOG.debug("calculate: node [{}]: electRootBridge: elected bridge {} with max bft size \"{}\" in topology",
	                    getNodeId(),
	                    rootBridge.getId(), 
	                    size);
	            electedRoot = rootBridge;
	        }
        }

        if (electedRoot == null && m_domain.hasRootBridge()) {
            LOG.debug("calculate: node [{}]: electRootBridge: mantaining old root bridge: {}", 
                    getNodeId(),
                    m_domain.getRootBridgeId());
            electedRoot = m_domain.getRootBridge();
        } else {
        	electedRoot = m_domain.getBridges().iterator().next();
        }

        if (electedRoot == null || electedRoot.getId() == null) {
            LOG.error("calculate: [{}]: electedRootBridge should not be null",
                    getNodeId()
            		);
            return;
        }

        List<BridgeMacLink> rootBft = m_notYetParsedBFTMap.remove(electedRoot);

        if (m_domain.getRootBridge().getId() == electedRoot.getId() && rootBft == null) {
            LOG.info("calculate: node [{}]: elected root bridge: [{}], old root bridge. no updated bft",
                    getNodeId(), 
            		electedRoot.getId());
        } else if (m_domain.getRootBridge().getId() == electedRoot.getId()) {
            LOG.info("calculate: node [{}]: elected root bridge: [{}], old root bridge. updated bft",
                    getNodeId(), 
                     electedRoot.getId());
            if (m_domain.getTopology().isEmpty()) {
                LOG.info("calculate: node [{}]: elected root bridge: [{}], clean topology found. Adding root shared segments",
                        getNodeId(), 
                         electedRoot.getId());
                loadFirstLevelSharedSegment(rootBft);
            }
         } else if ( rootBft != null ) {
            LOG.info("calculate: node [{}]: elected root bridge: [{}], new root. updated bft",
                    getNodeId(), 
                     electedRoot.getId());
           if (m_domain.getTopology().isEmpty()) {
               LOG.info("calculate: node [{}]: new elected root bridge: [{}], is the first bridge in topology. Adding root shared segments",
                       getNodeId(), 
                        electedRoot.getId());
                loadFirstLevelSharedSegment(rootBft);
                electedRoot.setRootBridge(true);
                electedRoot.setRootPort(null);
         } else {
                LOG.info("calculate: node [{}]: root bridge: [{}]. Old root bridge: [{}]",
                        getNodeId(), 
                         electedRoot.getId(),m_domain.getRootBridgeId());
                calculate(m_domain.getRootBridge(), m_domain.calculateRootBFT(),
                                electedRoot, rootBft);
                m_domain.hierarchySetUp(electedRoot);
           }
        } else {
            LOG.info("calculate: node [{}]: elected root bridge: [{}], is new root bridge with old bft",
                    getNodeId(), 
                     electedRoot.getId());
            m_domain.hierarchySetUp(electedRoot);
        }


        
        for (Bridge xBridge: m_notYetParsedBFTMap.keySet()) {
            LOG.info("calculate: node[{}]: bridge: [{}] has an updated bft. Clear bridge topology {}", 
            		getNodeId(),
            		xBridge.getId(),
            		m_domain.getBridgeNodesOnDomain());
            m_domain.clearTopologyForBridge(xBridge.getId());
        }        

        
        Set<Bridge> nodetobeparsed = new HashSet<Bridge>(m_notYetParsedBFTMap.keySet());
        for (Bridge xBridge: nodetobeparsed) {
            LOG.info("calculate: start: calculate topology for nodeid {}",xBridge.getId());
            calculate(electedRoot, m_domain.calculateRootBFT(), xBridge, new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(xBridge)));
            LOG.info("calculate: stop: calculate topology for nodeid {}",xBridge.getId());
        }
        LOG.info("calculate: stop:  calculate topology");
    }

