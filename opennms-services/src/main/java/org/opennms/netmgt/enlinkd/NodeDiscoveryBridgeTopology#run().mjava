    @Override
    public void run() {
        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: {}, already parsed. Skipping Calculation....rescheduling");
            reschedule();
            return;
        }
        
        Set<String> incomingSet = new HashSet<String>();
        for (BridgeMacLink link : m_linkd.getQueryManager().getBridgeTopologyUpdateBFT(getNodeId())) {
            incomingSet.add(link.getMacAddress());
        }

        Map<Integer,List<BridgeMacLink>> nodeBftMap = m_linkd.getQueryManager().getUpdateBftMap();
        Set<Integer> updatednodes= new HashSet<Integer>();
        updatednodes.add(getNodeId());
        for (Integer curNodeId: nodeBftMap.keySet()) {
            if (curNodeId.intValue() == getNodeId())
                continue;
            Set<String>retainedSet = new HashSet<String>();
            for (BridgeMacLink link: nodeBftMap.get(curNodeId)) {
                retainedSet.add(link.getMacAddress());
            }
            LOG.debug("run: node: {}, parsing updated bft node: {}, macs {}", getNodeId(), curNodeId,retainedSet);
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, retained: {}", getNodeId(), retainedSet);
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                updatednodes.add(curNodeId);
                LOG.debug("run: node: {}, found on same domain of node: {}", getNodeId(), curNodeId);
            }
        }

        LOG.debug("run: node: {}. incomingset: {}", getNodeId(), incomingSet);
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
            LOG.debug("run: node: {}, parsing domain with nodes: {}, macs: {}", getNodeId(), domain.getBridgeNodesOnDomain(),domain.getMacsOnDomain());
            Set<String>retainedSet = new HashSet<String>(
                                                          domain.getMacsOnDomain());
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, retained: {}", getNodeId(), retainedSet);
            // should contain at list 10 or 10% of the all size
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                m_domain = domain;
                LOG.debug("run: node: {}, domain found!",getNodeId());
                continue;
            }
            for (Integer curNodeId: updatednodes) {
                if (domain.containBridgeId(curNodeId)) {
                    LOG.debug("run: remove node: {}, on not other domain {}!",curNodeId,
                              domain);
                    if (!domain.getLock(this)) {
                        LOG.info("run: broadcast domain {}: is locked for calculation cannot remove node {}....scheduling with time interval {}", 
                                 domain,
                                 curNodeId, getInitialSleepTime());
                        schedule();
                        return;
                    }
                    domain.removeBridge(curNodeId);
                    domain.releaseLock(this);
                }
            }
        }

        Date now = new Date();
        if (m_domain == null) {
            LOG.info("run: node: {} Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_linkd.getQueryManager().save(m_domain);
        } else if (!m_domain.hasRootBridge()) {
            LOG.error("run: node: {}, broadcast domain has no root bridge. Clearing domain", getNodeId());
            for (Integer nodeid: m_domain.getBridgeNodesOnDomain()) {
                LOG.info("run: reconcile topology for node: {} on Broadcast Domain",nodeid);
                m_linkd.getQueryManager().reconcileBridgeTopology(nodeid, now);
             }
            m_domain.clear();
            LOG.info("run: node: {} Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_linkd.getQueryManager().save(m_domain);
        } else {
            Integer rootBridgeId = m_domain.getRootBridgeId();
            m_rootBridgeBFT = m_linkd.getQueryManager().getBridgeTopologyRootBFT(rootBridgeId);
            if (m_rootBridgeBFT == null) {
                LOG.warn("run: node: {}, broadcast domain has root bridge {}, with null bft. Clearing domain", getNodeId(), rootBridgeId);
                for (Integer nodeid: m_domain.getBridgeNodesOnDomain()) {
                    LOG.info("run: reconcile topology for node: {} on Broadcast Domain",nodeid);
                    m_linkd.getQueryManager().reconcileBridgeTopology(nodeid, now);
                 }
                m_domain.clear();
                LOG.info("run: node: {} Creating a new Domain", getNodeId());
                m_domain = new BroadcastDomain();
                m_linkd.getQueryManager().save(m_domain);
            } else {
                LOG.info("run: node: {}, broadcast domain has root bridge {}, with bft size: {}.", getNodeId(), 
                         rootBridgeId,
                         m_rootBridgeBFT.size());
            }
        }        
        
        if (!m_domain.getLock(this)) {
            LOG.info("run: broadcast domain: is locked for calculation either on node {}....scheduling with time interval {}", 
                     getNodeId(), getInitialSleepTime());
            schedule();
            return;
        }
        LOG.info("run: node: {}, getLock broadcast domain for nodes: {}, and macs: {}.", getNodeId(), 
                 m_domain.getBridgeNodesOnDomain(), m_domain.getMacsOnDomain());        

        for (Integer curNode: updatednodes)
            sendStartEvent(curNode);

        for (Integer curNodeId: nodeBftMap.keySet()) {
            if (updatednodes.contains(curNodeId))
                m_domain.addBridge(new Bridge(curNodeId));
            else
                m_domain.removeBridge(curNodeId);
        }
        m_linkd.getQueryManager().cleanBroadcastDomains();
        
        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();
        
        setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        
        for (Integer nodeid: updatednodes) {
            LOG.debug("run: node: {}, getting update bft for node {} on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().useBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.warn("run: node: {}, no update bft for node {} on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }

        if (m_notYetParsedBFTMap.isEmpty()) {
            LOG.info("run: node: {}, broadcast domain has no topology updates. No more action is needed.", getNodeId());
            return;
        }
        LOG.info("run: node: {}, start: broadcast domain topology calculation.", getNodeId());
        try {
            calculate();
        } catch (Exception e) {
            LOG.error("run: node: {}, got exception",e);           
        }
        LOG.info("run: node: {}, stop: broadcast domain topology calculated.", getNodeId());

        LOG.info("run: node: {}, saving broadcast domain root bridge: {} bft.", getNodeId(),m_domain.getRootBridgeId());
        m_linkd.getQueryManager().save(m_domain.getRootBridgeId(), m_rootBridgeBFT);

        LOG.info("run: node: {}, saving broadcast domain topology.", getNodeId());
        m_linkd.getQueryManager().store(m_domain);
        LOG.info("run: node: {}, saved broadcast domain topology.", getNodeId());
        
        for (Integer nodeid: m_domain.getBridgeNodesOnDomain()) {
           LOG.info("run: reconcile topology for node: {} on Broadcast Domain",nodeid);
           m_linkd.getQueryManager().reconcileBridgeTopology(nodeid, now);
        }
        for (Integer curNode: updatednodes)
            sendCompletedEvent(curNode);
        m_domain.releaseLock(this);
        LOG.info("run: node: {}, releaseLock broadcast domain for nodes: {}.", getNodeId(),
                 m_domain.getBridgeNodesOnDomain());
        m_runned = true;
        reschedule();        
    }

