    @Override
    public void run() {

        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: [{}], no bft.Exiting Bridge Topology Discovery", getNodeId());
            return;
        }

    	List<BridgeMacLink> links =  m_linkd.
        		getQueryManager().
        		getBridgeTopologyUpdateBFT(
        				getNodeId());
    	if (links == null || links.size() == 0) {
            LOG.info("run: node: [{}]. no updates macs found.", getNodeId());
            return;
    	}
    	Date now = new Date();
                
        Set<String> incomingSet = new HashSet<String>();
        synchronized (links) {
            for (BridgeMacLink link : links) {
                incomingSet.add(link.getMacAddress());
            }            
        }
        LOG.debug("run: node: [{}]. macs found: {}", getNodeId(), incomingSet);

        LOG.info("run: node: [{}], getting broadcast domain. Start", getNodeId());
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
            LOG.debug("run: node: [{}], parsing domain with nodes: {}, macs: {}", getNodeId(), domain.getBridgeNodesOnDomain(),domain.getMacsOnDomain());
            Set<String>retainedSet = new HashSet<String>(
                                                          domain.getMacsOnDomain());
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: [{}], retained: {}", getNodeId(), retainedSet);
            // should contain at list 5 or 10% of the all size
            if (retainedSet.size() > 5
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                LOG.debug("run: node: [{}], domain {} found!",getNodeId(), domain.getBridgeNodesOnDomain());
                    m_domain = domain;
            }
        }
        if (m_domain == null) {
            LOG.debug("run: node: [{}] Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_linkd.getQueryManager().save(m_domain);
        } else if (!m_domain.hasRootBridge()) {
            LOG.debug("run: node: [{}] Domain without root, clearing topology", getNodeId());
            m_domain.clearTopology();
        }
        LOG.info("run: node: [{}], getting broadcast domain. End", getNodeId());
                
        Map<Integer,List<BridgeMacLink>> nodeBftMap = m_linkd.getQueryManager().getUpdateBftMap();
        Set<Integer> nodeswithupdatedbftonbroadcastdomain = getAllNodesWithUpdatedBFTOnDomain(incomingSet,nodeBftMap);

        LOG.info("run: node: [{}], clean broadcast domains. Start", getNodeId());
        boolean stop = false;
        boolean clean = false;
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
        	if (m_domain == domain)
        		continue;
            LOG.debug("run: node [{}]: cleaning broadcast domain {}.",
            		getNodeId(),
                      domain.getBridgeNodesOnDomain());
            for (Integer curNodeId: nodeswithupdatedbftonbroadcastdomain) {
                if (domain.containBridgeId(curNodeId)) {
                    LOG.debug("run: node [{}]: node [{}]: removing from broadcast domain {}!",
                    		getNodeId(),
                    		  curNodeId,
                              domain.getBridgeNodesOnDomain());
                    if (!domain.getLock(this)) {
                        LOG.info("run: node [{}]: node [{}]: broadcast domain {}: is locked. cannot clear topology.", 
                        		getNodeId(),
                                 curNodeId,                                  
                                 domain.getBridgeNodesOnDomain());
                        stop=true;
                        continue;
                    }
                    domain.clearTopologyForBridge(curNodeId);
                    domain.removeBridge(curNodeId);
                    m_linkd.getQueryManager().store(domain,now);
                    domain.releaseLock(this);
                    clean=true;
                }
            }
        }
        if (clean)
            m_linkd.getQueryManager().cleanBroadcastDomains();
        LOG.info("run: node: [{}], clean broadcast domains. End", getNodeId());
        
        if (stop) {
            LOG.info("run: node [{}]: at least one other broadcast domain locked. scheduling with time interval {}", 
                    getNodeId(), 
                    getInitialSleepTime());
        	schedule();
        	return;        	
        }

        if (!m_domain.getLock(this)) {
            LOG.info("run: node [{}]: broadcast domain locked. scheduling with time interval {}", 
                    getNodeId(), 
                    getInitialSleepTime());
                schedule();
                return;         
        }

        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();        
        for (Integer nodeid: nodeswithupdatedbftonbroadcastdomain) {
            sendStartEvent(nodeid);
            m_domain.addBridge(new Bridge(nodeid));
            LOG.debug("run: node: [{}], getting update bft for node [{}] on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().useBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.debug("run: node: [{}], no update bft for node [{}] on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }
        
        for (Integer nodeid: nodeBftMap.keySet()) {
            if (nodeswithupdatedbftonbroadcastdomain.contains(nodeid))
                continue;
            LOG.info("run: node [{}]: bridge [{}] with updated bft. Not even more on broadcast domain {}: clear topology.", 
            		getNodeId(),
                     nodeid,                                  
                     m_domain.getBridgeNodesOnDomain());
            m_domain.clearTopologyForBridge(nodeid);
            m_domain.removeBridge(nodeid);
        }
        m_linkd.getQueryManager().cleanBroadcastDomains();
        
        m_domain.setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        

        if (m_notYetParsedBFTMap.isEmpty()) {
            LOG.info("run: node: [{}], broadcast domain has no topology updates. No more action is needed.", getNodeId());
        } else {
            calculate();
        }
        LOG.info("run: node: [{}], saving Topology.", getNodeId());
        m_linkd.getQueryManager().store(m_domain,now);
        LOG.info("run: node: [{}], saved Topology.", getNodeId());
        
        for (Integer curNode: nodeswithupdatedbftonbroadcastdomain)
            sendCompletedEvent(curNode);
        m_domain.releaseLock(this);
        LOG.info("run: node: {}, releaseLock broadcast domain: {}.", getNodeId(),
                 m_domain.getBridgeNodesOnDomain());
    }

