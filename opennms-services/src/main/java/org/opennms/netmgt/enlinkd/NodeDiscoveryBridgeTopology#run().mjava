    @Override
    public void run() {

        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: {}, no bft.Exiting Bridge Topology Discovery", getNodeId());
            return;
        }

    	List<BridgeMacLink> links =  m_linkd.
        		getQueryManager().
        		getBridgeTopologyUpdateBFT(
        				getNodeId());
    	if (links == null || links.size() == 0) {
            LOG.debug("run: node: {}. no updates macs found.", getNodeId());
            return;
    	}
    	Date now = new Date();
                
        Set<String> incomingSet = new HashSet<String>();
        for (BridgeMacLink link : links) {
            incomingSet.add(link.getMacAddress());
        }
        LOG.debug("run: node: {}. macs found: {}", getNodeId(), incomingSet);

        Set<Integer> nodeswithupdatedbftonbroadcastdomain= new HashSet<Integer>();
        nodeswithupdatedbftonbroadcastdomain.add(getNodeId());

        Map<Integer,List<BridgeMacLink>> nodeBftMap = m_linkd.getQueryManager().getUpdateBftMap();
        LOG.info("run: node: {}, getting nodes with updated bft on broadcast domain. Start", getNodeId());
        for (Integer curNodeId: nodeBftMap.keySet()) {
            if (curNodeId.intValue() == getNodeId())
                continue;
            Set<String>retainedSet = new HashSet<String>();
            for (BridgeMacLink link: nodeBftMap.get(curNodeId)) {
                retainedSet.add(link.getMacAddress());
            }
            LOG.debug("run: node: {}, parsing updated bft node: {}, macs {}", getNodeId(), curNodeId,retainedSet);
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, node: {} - common mac address set: {}", getNodeId(), curNodeId, retainedSet);
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                nodeswithupdatedbftonbroadcastdomain.add(curNodeId);
                LOG.info("run: node: {}, node: {} - put on same broadcast domain, common macs: {} ", getNodeId(), 
                         curNodeId,
                         retainedSet);
            }
        }
        LOG.info("run: node: {}, getting nodes with updated bft on broadcast domain. End", getNodeId());

        LOG.info("run: node: {}, getting broadcast domain. Start", getNodeId());
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
            LOG.debug("run: node: {}, parsing domain with nodes: {}, macs: {}", getNodeId(), domain.getBridgeNodesOnDomain(),domain.getMacsOnDomain());
            Set<String>retainedSet = new HashSet<String>(
                                                          domain.getMacsOnDomain());
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, retained: {}", getNodeId(), retainedSet);
            // should contain at list 10 or 10% of the all size
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                m_domain = domain;
                LOG.debug("run: node: {}, domain found!",getNodeId());
                continue;
            }
            for (Integer curNodeId: nodeswithupdatedbftonbroadcastdomain) {
                if (domain.containBridgeId(curNodeId)) {
                    LOG.debug("run: remove node: {}, on not other domain {}!",curNodeId,
                              domain);
                    if (!domain.getLock(this)) {
                        LOG.info("run: broadcast domain {}: is locked for calculation cannot clear topology for node {}....scheduling with time interval {}", 
                                 domain,
                                 curNodeId, getInitialSleepTime());
                        schedule();
                        return;
                    }
                    NodeDiscoveryBridgeTopology ndbt = new NodeDiscoveryBridgeTopology(m_linkd, m_linkd.getNode(curNodeId));
                    ndbt.setDomain(domain);
                    ndbt.clearTopologyForBridge(domain.getBridge(curNodeId));
                    m_linkd.getQueryManager().store(domain,now);
                    m_linkd.getQueryManager().save(domain.getRootBridgeId(), ndbt.getRootBridgeBFT());
                    domain.removeBridge(curNodeId);
                    domain.releaseLock(this);
                }
            }
        }
        boolean cleardomain = false;        
        if (m_domain == null) {
            LOG.info("run: node: {} Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_domain.getLock(this);
            m_linkd.getQueryManager().save(m_domain);
        } else  if (!m_domain.getLock(this)) {
            LOG.info("run: broadcast domain: is locked for calculation either on node {}....scheduling with time interval {}", 
                     getNodeId(), getInitialSleepTime());
            schedule();
            return;
        } else if (!m_domain.hasRootBridge()) {
            cleardomain = true;
            LOG.error("run: node: {}, broadcast domain has no root bridge. Clearing domain", getNodeId());
        } else if (m_linkd.getQueryManager().getBridgeTopologyRootBFT(m_domain.getRootBridgeId()) == null){
            cleardomain = true;
            LOG.warn("run: node: {}, broadcast domain has root bridge {}, with null bft. Clearing domain", getNodeId(), m_domain.getRootBridgeId());
        } else {
            m_rootBridgeBFT = m_linkd.getQueryManager().getBridgeTopologyRootBFT(m_domain.getRootBridgeId());
        }      

        
        if (cleardomain) {
            LOG.info("run: node: {} Creating a new Domain", getNodeId());
            m_domain.clearTopology();
            m_linkd.getQueryManager().store(m_domain, now);
            m_domain.clear();
            m_domain.releaseLock(this);
            m_domain = new BroadcastDomain();
            m_domain.getLock(this);
            m_linkd.getQueryManager().save(m_domain);
        } 
        LOG.info("run: node: {}, getting broadcast domain. End", getNodeId());
        
        for (Integer curNode: nodeswithupdatedbftonbroadcastdomain)
            sendStartEvent(curNode);

        for (Integer curNodeId: nodeBftMap.keySet()) {
            if (nodeswithupdatedbftonbroadcastdomain.contains(curNodeId))
                m_domain.addBridge(new Bridge(curNodeId));
            else
                m_domain.removeBridge(curNodeId);
        }
        m_linkd.getQueryManager().cleanBroadcastDomains();
        
        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();
        
        setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        
        for (Integer nodeid: nodeswithupdatedbftonbroadcastdomain) {
            LOG.debug("run: node: {}, getting update bft for node {} on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().useBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.warn("run: node: {}, no update bft for node {} on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }

        if (m_notYetParsedBFTMap.isEmpty()) {
            LOG.info("run: node: {}, broadcast domain has no topology updates. No more action is needed.", getNodeId());
            return;
        }
        LOG.info("run: node: {}, start: broadcast domain topology calculation.", getNodeId());
        try {
            calculate();
        } catch (Exception e) {
            LOG.error("run: node: {}, got exception",e);           
        }
        LOG.info("run: node: {}, stop: broadcast domain topology calculated.", getNodeId());

        LOG.info("run: node: {}, saving broadcast domain root bridge: {} bft.", getNodeId(),m_domain.getRootBridgeId());
        m_linkd.getQueryManager().save(m_domain.getRootBridgeId(), m_rootBridgeBFT);

        LOG.info("run: node: {}, saving broadcast domain topology.", getNodeId());
        m_linkd.getQueryManager().store(m_domain,now);
        LOG.info("run: node: {}, saved broadcast domain topology.", getNodeId());
        
        for (Integer curNode: nodeswithupdatedbftonbroadcastdomain)
            sendCompletedEvent(curNode);
        m_domain.releaseLock(this);
        LOG.info("run: node: {}, releaseLock broadcast domain for nodes: {}.", getNodeId(),
                 m_domain.getBridgeNodesOnDomain());
    }

