    @Override
    public void run() {

        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: {}, no bft.Exiting Bridge Topology Discovery", getNodeId());
            return;
        }

    	List<BridgeMacLink> links =  m_linkd.
        		getQueryManager().
        		getBridgeTopologyUpdateBFT(
        				getNodeId());
    	if (links == null || links.size() == 0) {
            LOG.info("run: node: {}. no updates macs found.", getNodeId());
            return;
    	}
    	Date now = new Date();
                
        Set<String> incomingSet = new HashSet<String>();
        synchronized (links) {
            for (BridgeMacLink link : links) {
                incomingSet.add(link.getMacAddress());
            }            
        }
        LOG.debug("run: node: {}. macs found: {}", getNodeId(), incomingSet);

        LOG.info("run: node: {}, getting broadcast domain. Start", getNodeId());
        m_domain = getBroadcastDomain(incomingSet);

        if (m_domain == null) {
            LOG.debug("run: node: {} Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_linkd.getQueryManager().save(m_domain);
        }
        LOG.info("run: node: {}, getting broadcast domain. End", getNodeId());
        LOG.debug("run: node: {}, Print Persisted Topology. {} ", getNodeId(),m_domain.printTopology());
                
        Map<Integer,List<BridgeMacLink>> nodeBftMap = m_linkd.getQueryManager().getUpdateBftMap();

        Set<Integer> nodeswithupdatedbftonbroadcastdomain = getAllNodesWithUpdatedBFTOnDomain(incomingSet,nodeBftMap);
 
        boolean stop = false;
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
        	if (m_domain == domain)
        		continue;
            LOG.debug("run: node [{}]: cleaning broadcast domain {}.",
            		getNodeId(),
                      domain.getBridgeNodesOnDomain());
            for (Integer curNodeId: nodeswithupdatedbftonbroadcastdomain) {
                if (domain.containBridgeId(curNodeId)) {
                    LOG.debug("run: node [{}]: node [{}]: removing from broadcast domain {}!",
                    		getNodeId(),
                    		  curNodeId,
                              domain.getBridgeNodesOnDomain());
                    if (!domain.getLock(this)) {
                        LOG.info("run: node [{}]: node [{}]: broadcast domain {}: is locked. cannot clear topology.", 
                        		getNodeId(),
                                 curNodeId,                                  
                                 domain.getBridgeNodesOnDomain());
                        stop=true;
                        continue;
                    }
                    domain.clearTopologyForBridge(curNodeId);
                    domain.removeBridge(curNodeId);
                    m_linkd.getQueryManager().store(domain,now);
                    domain.releaseLock(this);
                    m_linkd.getQueryManager().cleanBroadcastDomains();
                }
            }
        }
        
        if (stop || !m_domain.getLock(this)) {
            LOG.info("run: node [{}]: broadcast domain locked. scheduling with time interval {}", 
                    getNodeId(), 
                    getInitialSleepTime());
        	schedule();
        	return;        	
        }
        
        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();        
        for (Integer nodeid: nodeswithupdatedbftonbroadcastdomain) {
            sendStartEvent(nodeid);
            m_domain.addBridge(new Bridge(nodeid));
            LOG.debug("run: node: [{}], getting update bft for node [{}] on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().useBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.debug("run: node: [{}], no update bft for node [{}] on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }
        
        for (Integer nodeid: nodeBftMap.keySet()) {
        	if (nodeswithupdatedbftonbroadcastdomain.contains(nodeid))
        		continue;
            LOG.info("run: node [{}]: bridge [{}] with updated bft. Not even more on broadcast domain {}: clear topology.", 
            		getNodeId(),
                     nodeid,                                  
                     m_domain.getBridgeNodesOnDomain());
            m_domain.clearTopologyForBridge(nodeid);
        	m_domain.removeBridge(nodeid);
        }
        m_linkd.getQueryManager().store(m_domain,now);
        m_linkd.getQueryManager().cleanBroadcastDomains();
        
        setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        

        if (m_notYetParsedBFTMap.isEmpty()) {
            LOG.info("run: node: [{}], broadcast domain has no topology updates. No more action is needed.", getNodeId());
            return;
        }
        
        calculate();
        LOG.debug("run: node: {}, Print Calculated Topology. {} ", getNodeId(),m_domain.printTopology());
       
        LOG.info("run: node: [{}], saving Topology.", getNodeId());
        m_linkd.getQueryManager().store(m_domain,now);
        LOG.info("run: node: [{}], saved Topology.", getNodeId());
        
        for (Integer curNode: nodeswithupdatedbftonbroadcastdomain)
            sendCompletedEvent(curNode);
        m_domain.releaseLock(this);
        LOG.info("run: node: {}, releaseLock broadcast domain: {}.", getNodeId(),
                 m_domain.getBridgeNodesOnDomain());
    }

