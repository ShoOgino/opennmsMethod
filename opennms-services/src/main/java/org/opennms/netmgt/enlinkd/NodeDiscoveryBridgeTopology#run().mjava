    @Override
    public void run() {
        if (!m_linkd.getQueryManager().hasUpdatedBft(getNodeId())) {
            LOG.info("run: node: {}, already parsed. Skipping Calculation....rescheduling");
            reschedule();
            return;
        }
        
        Set<String> incomingSet = new HashSet<String>();
        for (BridgeMacLink link : m_linkd.getQueryManager().getBridgeTopologyUpdateBFT(getNodeId())) {
            incomingSet.add(link.getMacAddress());
        }

        Map<Integer,List<BridgeMacLink>> nodeBftMap = m_linkd.getQueryManager().getUpdateBftMap();
        Set<Integer> updatednodes= new HashSet<Integer>();
        updatednodes.add(getNodeId());
        for (Integer curNodeId: nodeBftMap.keySet()) {
            Set<String>retainedSet = new HashSet<String>();
            for (BridgeMacLink link: nodeBftMap.get(curNodeId)) {
                retainedSet.add(link.getMacAddress());
            }
            LOG.debug("run: node: {}, parsing updated bft node: {}, macs {}", getNodeId(), curNodeId,retainedSet);
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, retained: {}", getNodeId(), retainedSet);
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                updatednodes.add(curNodeId);
                LOG.debug("run: node: {}, found on same domain of node: {}", getNodeId(), curNodeId);
            }
        }

        LOG.debug("run: node: {}. incomingset: {}", getNodeId(), incomingSet);
        for (BroadcastDomain domain : m_linkd.getQueryManager().getAllBroadcastDomains()) {
            LOG.debug("run: node: {}, parsing domain with nodes: {}, macs: {}", getNodeId(), domain.getBridgeNodesOnDomain(),domain.getMacsOnDomain());
            Set<String>retainedSet = new HashSet<String>(
                                                          domain.getMacsOnDomain());
            retainedSet.retainAll(incomingSet);
            LOG.debug("run: node: {}, retained: {}", getNodeId(), retainedSet);
            // should contain at list 10 or 10% of the all size
            if (retainedSet.size() > 10
                    || retainedSet.size() >= incomingSet.size() * 0.1) {
                m_domain = domain;
                LOG.debug("run: node: {}, domain found!");
                continue;
            }
            for (Integer curNodeId: updatednodes) {
                if (domain.containBridgeId(curNodeId))
                    domain.removeBridge(curNodeId);
            }
        }

        if (m_domain == null) {
            LOG.info("run: node: {} Creating a new Domain", getNodeId());
            m_domain = new BroadcastDomain();
            m_linkd.getQueryManager().save(m_domain);
        }

        for (Integer curNodeId: updatednodes)
            m_domain.addBridge(new Bridge(curNodeId));


        if (!m_domain.getLock(this)) {
            LOG.info("run: broadcast domain: is locked for calculation either on node {}....scheduling with time interval {}", 
                     getNodeId(), getInitialSleepTime());
            schedule();
            return;
        }
        LOG.info("run: node: {}, getLock broadcast domain for nodes: {}, and macs: {}.", getNodeId(), 
                 m_domain.getBridgeNodesOnDomain(), m_domain.getMacsOnDomain());
        for (Integer curNode: updatednodes)
            sendStartEvent(curNode);
        
        m_notYetParsedBFTMap = new HashMap<Bridge, List<BridgeMacLink>>();
        
        if (!m_domain.hasRootBridge()) {
            LOG.info("run: node: {}, broadcast domain has no root bridge.", getNodeId());
        }  else {
            Integer rootBridgeId = m_domain.getRootBridgeId();
            m_rootBridgeBFT = m_linkd.getQueryManager().getBridgeTopologyRootBFT(rootBridgeId);
            LOG.info("run: node: {}, broadcast domain has root bridge {}, with bft size: {}.", getNodeId(), rootBridgeId, m_rootBridgeBFT.size());
        }        
        setBridgeElements(m_linkd.getQueryManager().getBridgeElements(m_domain.getBridgeNodesOnDomain()));
        
        for (Integer nodeid: updatednodes) {
            LOG.debug("run: node: {}, getting update bft for node {} on domain", getNodeId(),nodeid);
            List<BridgeMacLink> bft = m_linkd.getQueryManager().useBridgeTopologyUpdateBFT(nodeid);
            if (bft == null || bft.isEmpty()) {
                LOG.warn("run: node: {}, no update bft for node {} on domain", getNodeId(),nodeid);
                continue;
            }
            m_notYetParsedBFTMap.put(m_domain.getBridge(nodeid), bft);
        }

        runCollection();
        sendCompletedEvent(getNodeId());
        for (Integer curNode: updatednodes)
            sendCompletedEvent(curNode);
        m_domain.releaseLock(this);
        LOG.info("run: node: {}, releaseLock broadcast domain for nodes: {}.", getNodeId(),m_domain.getBridgeNodesOnDomain());
        m_runned = true;
        reschedule();
        
    }

