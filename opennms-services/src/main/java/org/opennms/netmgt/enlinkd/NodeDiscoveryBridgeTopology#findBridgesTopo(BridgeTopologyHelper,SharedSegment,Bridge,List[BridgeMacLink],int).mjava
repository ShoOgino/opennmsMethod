    // here we assume that rbridge exists in topology
    // while xBridge is to be added
    private boolean findBridgesTopo(BridgeTopologyHelper rx,SharedSegment topSegment, Bridge xBridge, List<BridgeMacLink> xBFT, int level) {
        level++;
        if (level == 30) {
            LOG.warn("calculate: node [{}]: level {}: bridge: [{}], too many iteration on topology exiting.....",
            		getNodeId(),
            		level,
            		xBridge.getId());
            return false;
        }
        LOG.debug("calculate: node [{}]: level {}: bridge: [{}], top segment: designated port {}, designated root {}",
        		getNodeId(),
        		level,
        		xBridge.getId(),
        		topSegment.getDesignatedPort(),
                 topSegment.getDesignatedBridge());

        Set<Integer> portsAdded=new HashSet<Integer>();
        List<Map<Integer,List<BridgeMacLink>>> throughSets=new ArrayList<Map<Integer,List<BridgeMacLink>>>();
        Map<Integer,List<BridgeMacLink>> bftSets=new HashMap<Integer,List<BridgeMacLink>>();
        for (Bridge yBridge: m_domain.getBridgeOnSharedSegment(topSegment)) {
            bftSets.put(yBridge.getId(), m_domain.calculateBFT(yBridge));
        }
        
        for (Bridge yBridge: m_domain.getBridgeOnSharedSegment(topSegment)) {
            Integer yBridgeId = yBridge.getId();
            // X is a leaf of top segment: of course
            if (yBridgeId.intValue() == topSegment.getDesignatedBridge().intValue()) {
                continue;
            } 
            LOG.debug("calculate: node [{}]: level {}: bridge: {}, check simple connection with Bridge [{}] found on topSegment",
            		getNodeId(),
                      level,
                      xBridge.getId(), 
                      yBridge.getId());
            Integer yrDesignatedPort = yBridge.getRootPort();
            LOG.debug("calculate: node [{}]: level {}: bridge: {}, found Y designated port:  Y bridge: {}, port: {}",
            		getNodeId(),
                     level,xBridge.getId(),yBridgeId,yrDesignatedPort);
            BridgeTopologyHelper   yx = new BridgeTopologyHelper(yBridge,bftSets.get(yBridgeId) ,xBridge, xBFT);
            Integer  xyDesignatedPort = yx.getSecondBridgeConnectionPort();
            Integer  yxDesignatedPort = yx.getFirstBridgeConnectionPort();
            LOG.debug("calculate: node [{}]: level {}: found simple connection:  X bridge {}, port {} <--> Y bridge {}, port {}",
               		getNodeId(),
               	                     level,xBridge.getId(),xyDesignatedPort,yBridgeId,yxDesignatedPort);
            // X is a leaf of Y then iterate
            if (xyDesignatedPort == rx.getSecondBridgeConnectionPort() && yxDesignatedPort != yrDesignatedPort) {
                LOG.debug("calculate: node [{}]: level {}: Bridge: [{}] is a leaf of Bridge: [{}], going one level down",
                		getNodeId(),
                		level,xBridge.getId(),yBridge.getId());
                if (!findBridgesTopo(yx,m_domain.getSharedSegment(yBridgeId, yxDesignatedPort), xBridge, xBFT,level))
                	return false;
                return true;
            }
            // Y is a leaf of X then remove Y from topSegment
            if (yxDesignatedPort == yrDesignatedPort && xyDesignatedPort != rx.getSecondBridgeConnectionPort()) {
                //create a SharedSegment with root port
                LOG.debug("calculate: node [{}]: level {}: bridge: [{}] is a leaf of Bridge: [{}], creating shared segment for port {}", 
                		getNodeId(), 
                		level,yBridge.getId(),xBridge.getId(),xyDesignatedPort);
                SharedSegment leafSegment = new SharedSegment(m_domain,yx.getSimpleConnection().getDlink());
                leafSegment.setBridgeMacLinks(yx.getSimpleConnection().getLinks());
                leafSegment.setDesignatedBridge(xBridge.getId());
                m_domain.add(leafSegment);
                portsAdded.add(xyDesignatedPort);
                
                LOG.debug("calculate: node [{}]: level {}: removing through set {} macs from top segment", 
                		getNodeId(), 
                         level, yx.getFirstBridgeTroughSet());
                topSegment.removeMacs(yx.getFirstBridgeTroughSet());
                LOG.debug("calculate: node [{}]: level {}: removing Bridge {} from top segment", 
                		getNodeId(), 
                         level,yBridge.getId());
                topSegment.removeBridge(yBridgeId);
            }            
            // this is a clear violation  of the topology tree rule
            if (xyDesignatedPort != rx.getSecondBridgeConnectionPort() && yxDesignatedPort != yrDesignatedPort) {
                LOG.warn("calculate: node [{}]: level {}: topology mismatch. Clearing...topology",
                		getNodeId(), 
                		level);
                return false;
            }            
            throughSets.add(yx.getFirstBridgeTroughSet());
        }
        // if we are here is because X is NOT a leaf of any bridge found
        // on topSegment so X is connected to top Segment by it's root 
        // port or rx is a direct connection
        LOG.debug("calculate: node [{}]: level {}: bridge: [{}], removing through set {} macs from top segment", 
        		getNodeId(), 
                 level, xBridge.getId(), rx.getSecondBridgeTroughSet());
        topSegment.removeMacs(rx.getSecondBridgeTroughSet());
        topSegment.assign(rx.getSimpleConnection().getLinks(),rx.getSimpleConnection().getDlink());
        LOG.debug("calculate: node [{}]: level {}: bridge: [{}], assigning links to top segment: bridge {} port: {}, mac : {}, bft: {}",
        		getNodeId(), 
                 level, xBridge.getId(),topSegment.getDesignatedBridge(),
                 topSegment.getDesignatedPort(), topSegment.getMacsOnSegment(), topSegment.getBridgeMacLinks());
        LOG.debug("calculate: node [{}]: level {}: bridge: [{}], removing {} through sets from top segment", 
        		getNodeId(), 
                 level,xBridge.getId(),throughSets);
        for (Map<Integer, List<BridgeMacLink>> throughSet: throughSets)
            topSegment.removeMacs(throughSet);
        for (Integer xbridgePort : rx.getSecondBridgeTroughSet().keySet()) {
            if (portsAdded.contains(xbridgePort))
                continue;
            SharedSegment xleafSegment = new SharedSegment(m_domain);
            xleafSegment.setBridgeMacLinks(rx.getSecondBridgeTroughSet().get(xbridgePort));
            xleafSegment.setDesignatedBridge(xBridge.getId());  
            LOG.debug("calculate: node [{}]: level {}: adding shared segment to topology: root bridge {} port: {}, mac: {}, bft: {}",
            		getNodeId(), 
                     level,
                     xleafSegment.getDesignatedBridge(),
                     xleafSegment.getDesignatedPort(),
                     xleafSegment.getMacsOnSegment(),
                     xleafSegment.getBridgeMacLinks());
            m_domain.add(xleafSegment);
        }
        return true;
    }

