    // here we assume that rbridge exists in topology
    // while xBridge is to be added
    private boolean findBridgesTopo(BridgeTopologyHelper rx,SharedSegment topSegment, Bridge xBridge, List<BridgeMacLink> xBFT, int level) {
        level++;
        LOG.debug("calculate: node: [{}], level: {}, bridge: [{}], topo top segment found: [ids {}, designated bridge [{}, port {}], macs {}",
        		getNodeId(),
        		level,
        		xBridge.getId(),
        		topSegment.getBridgeIdsOnSegment(),
                        topSegment.getDesignatedBridge(),
        		topSegment.getDesignatedPort(),
        		topSegment.getMacsOnSegment());
        if (level == 30) {
            LOG.warn("calculate: node: [{}]: level: {}, bridge: [{}], too many iteration on topology exiting.....",
            		getNodeId(),
            		level,
            		xBridge.getId());
            return false;
        }

        Set<Integer> portsAdded=new HashSet<Integer>();
        Set<String> macsOnSegment=rx.getSimpleConnection().getMacs();
        Map<Integer,List<BridgeMacLink>> bftSets=new HashMap<Integer,List<BridgeMacLink>>();
        for (Bridge yBridge: m_domain.getBridgeOnSharedSegment(topSegment)) {
            bftSets.put(yBridge.getId(), m_domain.calculateBFT(yBridge));
        }
        
        for (Bridge yBridge: m_domain.getBridgeOnSharedSegment(topSegment)) {
            Integer yBridgeId = yBridge.getId();
            // X is a leaf of top segment: of course
            if (yBridgeId.intValue() == topSegment.getDesignatedBridge().intValue()) {
                continue;
            } 
            LOG.debug("calculate: node: [{}], level: {}, bridges: [{},{}]. Searching simple connection",
            		getNodeId(),
                      level,
                      xBridge.getId(), 
                      yBridge.getId());
            Integer yrDesignatedPort = yBridge.getRootPort();
            LOG.debug("calculate: node: [{}], level: {}, bridge: [{}], bridge: [{}, designated port: {}]",
            		getNodeId(),
                     level,
                     xBridge.getId(),
                     yBridgeId,
                     yrDesignatedPort);
            BridgeTopologyHelper   yx = new BridgeTopologyHelper(yBridge,bftSets.get(yBridgeId) ,xBridge, xBFT);
            Integer  xyDesignatedPort = yx.getSecondBridgeConnectionPort();
            Integer  yxDesignatedPort = yx.getFirstBridgeConnectionPort();
            // X is a leaf of Y then iterate
            if (xyDesignatedPort == rx.getSecondBridgeConnectionPort() && yxDesignatedPort != yrDesignatedPort) {
                LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}] is a leaf of bridge: [{}], going one level down",
                		getNodeId(),
                		level,xBridge.getId(),yBridge.getId());
                if (!findBridgesTopo(yx,m_domain.getSharedSegment(yBridgeId, yxDesignatedPort), xBridge, xBFT,level))
                	return false;
                return true;
            }
            // Y is a leaf of X then remove Y from topSegment
            if (yxDesignatedPort == yrDesignatedPort && xyDesignatedPort != rx.getSecondBridgeConnectionPort()) {
                //create a SharedSegment with root port
                LOG.debug("calculate: node: [{}], level: {}, bridge: [{},designated port [{}]]: is 'up' for bridge: [{}].", 
                		getNodeId(), 
                		level,
                		xBridge.getId(),
                		xyDesignatedPort,
                                yBridge.getId());
                SharedSegment leafSegment = m_domain.getSharedSegment(xBridge.getId(), xyDesignatedPort);
                if (leafSegment == null) {
                    leafSegment = new SharedSegment(m_domain,yx.getSimpleConnection().getDlink(),yx.getSimpleConnection().getMacs());
                    leafSegment.setDesignatedBridge(xBridge.getId());
                    m_domain.add(leafSegment);
                } else {
                    leafSegment.assign(yx.getSimpleConnection().getMacs(),yx.getSimpleConnection().getDlink());
                }
                portsAdded.add(xyDesignatedPort);
                
                LOG.debug("calculate: node: [{}], level: {}, bridge: [{}]. bridge [{}, through set {}]. removing from top segment.", 
                		getNodeId(), 
                         level,
                         xBridge.getId(),
                         yBridge.getId(), 
                         yx.getFirstBridgeTroughSet());
//                topSegment.removeMacs(yx.getFirstBridgeTroughSet());
                LOG.debug("calculate: node: [{}], level: {}, bridge [{}]. Remove bridge [{}] from top segment.", 
                		getNodeId(), 
                         level,
                         xBridge.getId(),
                         yBridge.getId());
                topSegment.removeBridge(yBridgeId);
            }            
            // this is a clear violation  of the topology tree rule
            if (xyDesignatedPort != rx.getSecondBridgeConnectionPort() && yxDesignatedPort != yrDesignatedPort) {
                LOG.warn("calculate: node: [{}]: level {}: bridge [{}]. Topology mismatch. Clearing...topology",
                		getNodeId(), 
                		level,
                		xBridge.getId());
                return false;
            }            
            macsOnSegment.retainAll(yx.getSimpleConnection().getMacs());
        }
        // if we are here is because X is NOT a leaf of any bridge found
        // on topSegment so X is connected to top Segment by it's root 
        // port or rx is a direct connection
        LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}]. removing through set {} from top segment", 
        		getNodeId(), 
                 level, xBridge.getId(), rx.getSecondBridgeTroughSet());
        topSegment.removeMacs(rx.getSecondBridgeTroughSet());
        LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}]. assign macs {} to top segment", 
        		getNodeId(), 
                 level,xBridge.getId(),rx.getSimpleConnection().getMacs());
        topSegment.assign(macsOnSegment,rx.getSimpleConnection().getDlink());
//        LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}]. removing through sets {} from top segment", 
//        		getNodeId(), 
//                 level,xBridge.getId(),throughSets);
//        topSegment.removeMacs(throughSets);
        LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}]. resulting top segment: [ids {}, designated bridge [{}, port: {}], mac : {}]",
        		getNodeId(), 
                 level, xBridge.getId(),
                 topSegment.getBridgeIdsOnSegment(), topSegment.getDesignatedBridge(),
                 topSegment.getDesignatedPort(), topSegment.getMacsOnSegment());
        for (Integer xbridgePort : rx.getSecondBridgeTroughSetBft().keySet()) {
            if (portsAdded.contains(xbridgePort))
                continue;
            SharedSegment xleafSegment = new SharedSegment(m_domain,rx.getSecondBridgeTroughSetBft().get(xbridgePort));
            xleafSegment.setDesignatedBridge(xBridge.getId());  
            m_domain.add(xleafSegment);
            LOG.debug("calculate: node: [{}]: level: {}, bridge: [{}]. Add shared segment. "
            		+ "[ designated bridge:[{}], "
            		+ "port:{}, "
            		+ "mac: {}]",
            		getNodeId(), 
                     level,
                     xBridge.getId(),
                     xleafSegment.getDesignatedBridge(),
                     xleafSegment.getDesignatedPort(),
                     xleafSegment.getMacsOnSegment());
        }
        addForwarding(m_domain, rx.getFirstBridgeForwarders());
        return true;
    }

