	protected Map<Integer,Integer> walkDot1d(Integer vlan, String vlanname) {
		LOG.debug("run: Bridge Linkd node scan : ready to walk dot1d data on {}, vlan {}, vlanname {}.",
				str(getPeer().getAddress()),vlan,vlanname);
		String trackerName = "dot1dbase";
		final Dot1dBaseTracker dot1dbase = new Dot1dBaseTracker();
		SnmpWalker walker = SnmpUtils.createWalker(getPeer(), trackerName,
				dot1dbase);
		walker.start();

		try {
			walker.waitFor();
			if (walker.timedOut()) {
				LOG.info("run:Aborting Bridge Linkd node scan : Agent timed out while scanning the {} table",
						trackerName);
				return new HashMap<Integer, Integer>();
			} else if (walker.failed()) {
				LOG.info("run:Aborting Bridge Linkd node scan : Agent failed while scanning the {} table: {}",
						trackerName, walker.getErrorMessage());
				return new HashMap<Integer, Integer>();
			}
		} catch (final InterruptedException e) {
			LOG.error("run: Bridge Linkd node collection interrupted, exiting",e);
			return new HashMap<Integer, Integer>();
		}

		BridgeElement bridge = dot1dbase.getBridgeElement();
		bridge.setVlan(vlan);
		bridge.setVlanname(vlanname);
		if (bridge.getBaseBridgeAddress() == null) {
			LOG.info("run: base bridge address is null: bridge mib not supported on: {}",
					str(getPeer().getAddress()));
			return new HashMap<Integer, Integer>();
		}

		if (!isValidBridgeAddress(bridge.getBaseBridgeAddress())) {
			LOG.info("run: bridge not supported, base address identifier {} is not valid on: {}",
					dot1dbase.getBridgeAddress(), str(getPeer().getAddress()));
			return new HashMap<Integer, Integer>();
		}

		if (bridge.getBaseNumPorts() == 0) {
			LOG.info("run: bridge {} has 0 port active, on: {}",
					dot1dbase.getBridgeAddress(), str(getPeer().getAddress()));
			return new HashMap<Integer, Integer>();
		}
		LOG.info("run: bridge {} has is if type {}, on: {}", dot1dbase
				.getBridgeAddress(), BridgeDot1dBaseType.getTypeString(dot1dbase.getBridgeType()),str(getPeer().getAddress()));

		if (bridge.getBaseType() ==  BridgeDot1dBaseType.DOT1DBASETYPE_SOURCEROUTE_ONLY) {
			LOG.info("run: {}: source route only type bridge, on: {}",
					dot1dbase.getBridgeAddress(), str(getPeer().getAddress()));
			return new HashMap<Integer, Integer>();
		}
		m_linkd.getQueryManager().store(getNodeId(), bridge);
		
		Map<Integer,Integer> bridgetoifindex = walkDot1dBasePortTable();
                LOG.debug("run: found on node: '{}' vlan: '{}', bridge ifindex map {}",getNodeId(), vlanname, bridgetoifindex);

		if (!isValidStpBridgeId(bridge.getStpDesignatedRoot())) {
			LOG.info("run: invalid Stp designated root: spanning tree not supported on: {}",
					str(getPeer().getAddress()));
		} else if (bridge.getBaseBridgeAddress().equals(getBridgeAddressFromStpBridgeId(bridge.getStpDesignatedRoot()))) {
			LOG.info("run: designated root of spanning tree is itself on bridge {}, on: {}",
					bridge.getStpDesignatedRoot(),
					str(getPeer().getAddress()));
		} else {
			walkSpanningTree(bridge.getBaseBridgeAddress(),vlan, bridgetoifindex);
		}
		walkDot1dTpFdp(vlan,bridgetoifindex);
		return bridgetoifindex;
	}

