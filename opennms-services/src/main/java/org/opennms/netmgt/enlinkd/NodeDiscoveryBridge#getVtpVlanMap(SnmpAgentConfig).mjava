    private Map<Integer, String> getVtpVlanMap(SnmpAgentConfig peer) {

        final Map<Integer, String> vlanmap = new HashMap<Integer, String>();
        final CiscoVtpTracker vtpStatus = new CiscoVtpTracker();
        
        try {
            m_linkd.getLocationAwareSnmpClient().walk(peer, vtpStatus).
            withDescription("vtpVersion").
            withLocation(getLocation()).
            execute().
            get();
       } catch (ExecutionException e) {
           LOG.info("run: Agent error while scanning the vtpVersion table", e);
           return vlanmap;
       } catch (final InterruptedException e) {
           LOG.info("run: Bridge Linkd node collection interrupted, exiting",
                     e);
           return vlanmap;
       }

        if (vtpStatus.getVtpVersion() == null) {
            LOG.info("run: node [{}]: cisco vtp mib not supported.", getNodeId());
            return vlanmap;
        }

        LOG.info("run: node [{}]: cisco vtp mib supported.", getNodeId());
        LOG.debug("run: node [{}]: walking cisco vtp.", getNodeId());

        final CiscoVtpVlanTableTracker ciscoVtpVlanTableTracker = new CiscoVtpVlanTableTracker() {
            @Override
            public void processCiscoVtpVlanRow(final CiscoVtpVlanRow row) {
                if (row.isTypeEthernet() && row.isStatusOperational()) {
                    vlanmap.put(row.getVlanIndex(), row.getVlanName());
                }
            }
        };
        try {
            m_linkd.getLocationAwareSnmpClient().walk(peer, ciscoVtpVlanTableTracker).
            withDescription("ciscoVtpVlan").
            withLocation(getLocation()).
            execute().
            get();
        } catch (ExecutionException e) {
            LOG.error("run: collection execution failed, exiting",e);
        } catch (final InterruptedException e) {
            LOG.error("run: Bridge Linkd node collection interrupted, exiting",
                      e);
        }
        return vlanmap;
    }

