    private void setUpRoot(Bridge electedRoot) {
        if (electedRoot.isRootBridge() && !m_notYetParsedBFTMap.containsKey(electedRoot)) {
            LOG.info("calculate: elected root bridge: {}, is old root bridge with old bft",
                     electedRoot.getId());
        } else if (electedRoot.isRootBridge() && m_notYetParsedBFTMap.containsKey(electedRoot)) {
            LOG.info("calculate: elected root bridge: {}, is old root bridge with new bft",
                     electedRoot.getId());
            m_rootBridgeBFT=new ArrayList<BridgeMacLink>(m_notYetParsedBFTMap.remove(electedRoot));
            LOG.debug("calculate: updated new bft for root bridge {}  size:  {}",
                          electedRoot.getId(), m_rootBridgeBFT.size());
            if (m_domain.getTopology().isEmpty()) {
                LOG.info("calculate: elected root bridge: {}, clean topology found. Adding level 0 shared segments",
                         electedRoot.getId());
                loadFirstLevelSharedSegment(m_rootBridgeBFT);
            }
        } else if (!electedRoot.isRootBridge() && m_notYetParsedBFTMap.containsKey(electedRoot)) {
            LOG.info("calculate: elected root bridge: {}, is new root bridge and has new bft",
                         electedRoot.getId());
           List<BridgeMacLink>  electedRootBFT = new ArrayList<BridgeMacLink>(
                   m_notYetParsedBFTMap.remove(electedRoot));
           if (m_domain.getTopology().isEmpty()) {
               LOG.info("calculate: new elected root bridge: {}, is the first bridge in topology. Adding level 0 shared segments",
                        electedRoot.getId());
                loadFirstLevelSharedSegment(electedRootBFT);
                electedRoot.setRootBridge(true);
                electedRoot.setRootPort(null);
           } else {
                LOG.info("calculate: find topology of new elected root bridge:  {} with old root as root bridge: {}",
                         electedRoot.getId(),m_domain.getRootBridgeId());
                calculate(m_domain.getRootBridge(), m_rootBridgeBFT,
                                electedRoot, electedRootBFT);
                m_domain.hierarchySetUp(electedRoot);
           }
           m_rootBridgeBFT = electedRootBFT;
           LOG.debug("calculate: set bft for root bridge {}  size:  {}",
                          electedRoot.getId(), m_rootBridgeBFT.size());
        } else if (!electedRoot.isRootBridge() && !m_notYetParsedBFTMap.containsKey(electedRoot)){
            LOG.info("calculate: elected root bridge: {}, is new root bridge with old bft",
                     electedRoot.getId());
            m_domain.hierarchySetUp(electedRoot);
            m_rootBridgeBFT =m_domain.getBFT(electedRoot);
            LOG.debug("calculate: set bft for root bridge {}  size:  {}",
                           electedRoot.getId(), m_rootBridgeBFT.size());
        }
        
    }    

