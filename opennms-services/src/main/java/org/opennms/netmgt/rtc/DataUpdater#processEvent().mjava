    /**
     * Read the event UEI, node ID, interface and service - depending on the UEI,
     * read event parms, if necessary, and call appropriate methods on the data
     * manager to update data
     */
    private void processEvent() {
        ThreadCategory log = ThreadCategory.getInstance(DataUpdater.class);

        if (m_event == null) {
            if (log.isDebugEnabled())
                log.debug("Event is null, nothing to process");
            return;
        }

        String eventUEI = m_event.getUei();
        if (eventUEI == null) {
            // huh? should only get registered events
            if (log.isDebugEnabled())
                log.debug("Event received with null UEI, ignoring event");
            return;
        }

        long nodeid = -1;
        if (m_event.hasNodeid()) {
            nodeid = m_event.getNodeid();
        }

        InetAddress ip = m_event.getInterfaceAddress();

        String svcName = m_event.getService();

        long eventTime = -1;
        String eventTimeStr = m_event.getTime();
        try {
            java.util.Date date = EventConstants.parseToDate(eventTimeStr);
            eventTime = date.getTime();
        } catch (ParseException pe) {
            log.warn("Failed to convert time " + eventTime + " to java.util.Date, Setting current time instead", pe);

            eventTime = (new java.util.Date()).getTime();
        }

        if (log.isDebugEnabled())
            log.debug("Event UEI: " + eventUEI + "\tnodeid: " + nodeid + "\tip: " + InetAddressUtils.str(ip) + "\tsvcName: " + svcName + "\teventTime: " + eventTimeStr);

        //
        //
        // Check for any of the following UEIs:
        //
        // outageCreated
        // outageResolved
        // nodeGainedService
        // serviceDeleted
        // interfaceReparented
        // subscribe
        // unsubscribe
        //
        if (eventUEI.equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {
            handleNodeGainedService(nodeid, ip, svcName);
        } else if (eventUEI.equals(EventConstants.OUTAGE_CREATED_EVENT_UEI)) {
            handleOutageCreated(nodeid, ip, svcName, eventTime);
        } else if (eventUEI.equals(EventConstants.OUTAGE_RESOLVED_EVENT_UEI)) {
            handleOutageResolved(nodeid, ip, svcName, eventTime);
        } else if (eventUEI.equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {
            handleServiceDeleted(nodeid, ip, svcName);
        } else if (eventUEI.equals(EventConstants.SERVICE_UNMANAGED_EVENT_UEI)) {
            handleServiceDeleted(nodeid, ip, svcName);
        } else if (eventUEI.equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {
            handleInterfaceReparented(ip, m_event.getParmCollection());
        } else if (eventUEI.equals(EventConstants.RTC_SUBSCRIBE_EVENT_UEI)) {
            handleRtcSubscribe(m_event.getParmCollection());
        } else if (eventUEI.equals(EventConstants.RTC_UNSUBSCRIBE_EVENT_UEI)) {
            handleRtcUnsubscribe(m_event.getParmCollection());
        } else if (eventUEI.equals(EventConstants.ASSET_INFO_CHANGED_EVENT_UEI)) {
            handleAssetInfoChangedEvent(nodeid);
        } else if (eventUEI.equals(EventConstants.NODE_CATEGORY_MEMBERSHIP_CHANGED_EVENT_UEI)) {
        	handleNodeCategoryMembershipChanged(nodeid);
        } else {
            if (log.isDebugEnabled())
                log.debug("Event subscribed for not handled?!: " + eventUEI);
        }

        RTCManager.getInstance().incrementCounter();
    }

