    /**
     * Optimized method for calculating the category statistics
     * that aims to reduce the number of calls to the database.
     */
    @Override
    public synchronized EuiLevel getEuiLevel(RTCCategory category) {
        final Header header = new Header();
        header.setVer("1.9a");
        header.setMstation("");

        // current time
        final Date curDate = new Date();
        final long curTime = curDate.getTime();

        // get the rolling window
        final long rWindow = 24L * 60L * 60L * 1000L;

        LOG.debug("Retrieving availability statistics for {} with current date: {} and rolling window: {}",
                    category.getLabel(), curDate, rWindow);

        // create the data
        final EuiLevel level = new EuiLevel();

        // set created in m_header and add to level
        header.setCreated(EventConstants.formatToString(curDate));
        level.setHeader(header);

        final Category levelCat = new Category();

        // category label
        levelCat.setCatlabel(category.getLabel());

        double outageTimeInCategory = 0.0;
        int numServicesInCategory = 0;

        // window bounds
        final Date windowStart = new Date(curTime - rWindow);
        final Date windowEnd = new Date(curTime);

        final Collection<Integer> nodes = getNodes(category);
        final List<String> serviceNames = category.getServiceCollection();

        // retrieve all of the services in this category, grouped by node
        final Map<Integer, List<OnmsMonitoredService>> servicesByNode = getServices(nodes, serviceNames);

        // flatten the list of services in this category
        final List<OnmsMonitoredService> allServices = Lists.newLinkedList();
        servicesByNode.values().forEach(allServices::addAll);

        // retrieve the outages associated with the list of services that fall within our window
        final Map<Integer, List<OnmsOutage>> outagesByService = getOutages(allServices, windowStart, windowEnd);

        // calculate the node level statistics
        for (final int nodeID : nodes) {
            List<OnmsMonitoredService> services = servicesByNode.get(nodeID);
            if (services == null) {
                // Use an empty list if this particular node has no services
                services = Lists.newArrayList();
            }

            // sum the outage time for all of the node's services
            final double outageTime = services.stream()
                    .mapToDouble(service -> getOutageTimeInWindow(outagesByService.get(service.getId()), windowStart, windowEnd))
                    .sum();

            // count the number of services that are currently down
            final long numServicesDown = services.stream()
                    .filter(service -> hasOngoingOutage(outagesByService.get(service.getId())))
                    .count();

            final Node levelNode = new Node();
            levelNode.setNodeid(nodeID);

            // value for this node for this category
            levelNode.setNodevalue(RTCUtils.getOutagePercentage(outageTime, rWindow, services.size()));

            // node service count
            levelNode.setNodesvccount(services.size());

            // node service down count
            levelNode.setNodesvcdowncount(numServicesDown);

            // add the node
            levelCat.addNode(levelNode);

            // update the category statistics
            numServicesInCategory += services.size();
            outageTimeInCategory += outageTime;
        }

        // calculate the outage percentage using tallied values
        levelCat.setCatvalue(RTCUtils.getOutagePercentage(outageTimeInCategory, rWindow, numServicesInCategory));

        // add category
        level.addCategory(levelCat);

        LOG.debug("Done retrieving availability statistics for {} with {} services.", category.getLabel(), numServicesInCategory);

        return level;
    }

