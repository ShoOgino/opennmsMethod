    /**
     * Check the timer tasks. Reset any of the timer tasks if they need to be
     * reset (indicated by their being set to null on timer task completion). If
     * the events counter has exceeded maxEventsBeforeResend, send data out and
     * reset timers
     */
    public synchronized void checkTimerTasksOnEventReceipt() {
        ThreadCategory log = ThreadCategory.getInstance(getClass());

        if (log.isDebugEnabled())
            log.debug("checkTimerTasksOnEventReceipt: Checking if timer tasks need to be reset or data needs to be sent out");

        // cancel user timer
        boolean ret = m_userTask.cancel();
        if (log.isDebugEnabled())
            log.debug("checkTimerTasksOnEventReceipt: " + USERTIMER + " cancelled: " + ret);

        // Check the counter to see if timers need to be started afresh
        if (m_counter == -1) {
            m_counter = 0;

            //
            // set timers
            //

            // set the low threshold timer task
            if (m_lowTtask == null) {
                try {

                    m_timer.schedule((m_lowTtask = new RTCTimerTask(LOWT_TASK)), m_lowThresholdInterval);
                    if (log.isDebugEnabled())
                        log.debug("checkTimerTasksOnEventReceipt: " + LOWT_TASK + " scheduled");
                } catch (IllegalStateException isE) {
                    log.error("checkTimerTasksOnEventReceipt: Illegal State adding new RTCTimerTask", isE);
                }
            }

            // set the high threshold timer task only if currently null
            if (m_highTtask == null) {
                try {
                    m_timer.schedule((m_highTtask = new RTCTimerTask(HIGHT_TASK)), m_highThresholdInterval);
                    if (log.isDebugEnabled())
                        log.debug("checkTimerTasksOnEventReceipt: " + HIGHT_TASK + " scheduled");
                } catch (IllegalStateException isE) {
                    log.error("checkTimerTasksOnEventReceipt: Illegal State adding new RTCTimerTask", isE);
                }
            }
        }

        if (MAX_EVENTS_BEFORE_RESEND > 0 && m_counter >= MAX_EVENTS_BEFORE_RESEND) {
            if (log.isDebugEnabled())
                log.debug("checkTimerTasksOnEventReceipt: max events before resend limit reached, resetting timers");

            // send the category information out and reset all timers
            if (m_lowTtask != null) {
                ret = m_lowTtask.cancel();
                if (log.isDebugEnabled())
                    log.debug("checkTimerTasksOnEventReceipt: " + LOWT_TASK + " cancelled: " + ret);

                m_lowTtask = null;
            }

            if (m_highTtask != null) {
                ret = m_highTtask.cancel();
                if (log.isDebugEnabled())
                    log.debug("checkTimerTasksOnEventReceipt: " + HIGHT_TASK + " cancelled: " + ret);
                m_highTtask = null;
            }

            if (log.isDebugEnabled())
                log.debug("checkTimerTasksOnEventReceipt: max events before resend limit reached, sending data to listeners");

            m_dataSender.notifyToSend();

            if (log.isDebugEnabled())
                log.debug("checkTimerTasksOnEventReceipt: max events before resend limit reached, datasender notified to send data");

            m_counter = -1;
        } else if (m_counter != 0) {
            // reset the low threshold timer since getting here means
            // we got an event before the low threshold timer
            // went off
            if (m_lowTtask != null) {
                ret = m_lowTtask.cancel();
                if (log.isDebugEnabled())
                    log.debug("checkTimerTasksOnEventReceipt: " + LOWT_TASK + " cancelled: " + ret);
                m_lowTtask = null;
            }

            try {
                m_timer.schedule((m_lowTtask = new RTCTimerTask(LOWT_TASK)), m_lowThresholdInterval);
                if (log.isDebugEnabled())
                    log.debug("checkTimerTasksOnEventReceipt: " + LOWT_TASK + " scheduled");
            } catch (IllegalStateException isE) {
                log.error("checkTimerTasksOnEventReceipt: Illegal State adding new RTCTimerTask", isE);
            }
        }

    }

