    /**
     * Handles a completed task.
     * 
     * <P>
     * If the low threshold or high threshold timers expire, send category data
     * out and set both timer(task)s to null so they can be reset when the next
     * event comes in
     * <P>
     * 
     * <P>
     * If the user refresh timer is the one that expired, send category data out
     * and reset the user timer(task)
     * <P>
     * 
     * @param tt
     *            the task that is finishing.
     */
    private synchronized void timerTaskComplete(RTCTimerTask tt) {
        ThreadCategory log = ThreadCategory.getInstance(getClass());

        if (log.isDebugEnabled())
            log.debug("TimerTask \'" + tt.getID() + "\' complete, status: " + getStatus());

        if (tt.getID().equals(LOWT_TASK)) {
            // cancel user timer
            boolean ret = m_userTask.cancel();
            if (log.isDebugEnabled())
                log.debug("timerTaskComplete: " + USERTIMER + " cancelled: " + ret);

            // send out the info and reset both timers
            if (m_highTtask != null) {
                ret = m_highTtask.cancel();
                if (log.isDebugEnabled())
                    log.debug("timerTaskComplete: " + HIGHT_TASK + " cancelled: " + ret);

                m_highTtask = null;
            }

            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

            m_lowTtask = null;

            m_counter = -1;

            // reset the user timer
            m_timer.schedule((m_userTask = new RTCTimerTask(USERTIMER)), 0, m_userRefreshInterval);
            if (log.isDebugEnabled())
                log.debug("timerTaskComplete: " + USERTIMER + " scheduled");
        } else if (tt.getID().equals(HIGHT_TASK)) {
            // cancel user timer
            boolean ret = m_userTask.cancel();
            if (log.isDebugEnabled())
                log.debug("timerTaskComplete: " + USERTIMER + " cancelled: " + ret);

            // send the category information out reset all timers
            if (m_lowTtask != null) {
                ret = m_lowTtask.cancel();
                if (log.isDebugEnabled())
                    log.debug("timerTaskComplete: " + LOWT_TASK + " cancelled: " + ret);

                m_lowTtask = null;
            }

            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

            m_highTtask = null;

            m_counter = -1;

            // reset the user timer
            m_timer.schedule((m_userTask = new RTCTimerTask(USERTIMER)), 0, m_userRefreshInterval);
            if (log.isDebugEnabled())
                log.debug("timerTaskComplete: " + USERTIMER + " scheduled");
        } else if (tt.getID().equals(USERTIMER)) {
            // send if not pasued
            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

        }
    }

