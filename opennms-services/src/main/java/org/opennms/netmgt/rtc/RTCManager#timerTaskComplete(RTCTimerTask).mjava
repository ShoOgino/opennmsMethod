    /**
     * Handles a completed task.
     * 
     * <P>
     * If the low threshold or high threshold timers expire, send category data
     * out and set both timer(task)s to null so they can be reset when the next
     * event comes in
     * <P>
     * 
     * <P>
     * If the user refresh timer is the one that expired, send category data out
     * and reset the user timer(task)
     * <P>
     * 
     * @param tt
     *            the task that is finishing.
     */
    private synchronized void timerTaskComplete(RTCTimerTask tt) {
        LOG.debug("TimerTask \'{}\' complete, status: {}", tt.getID(), getStatus());

        if (tt.getID().equals(LOWT_TASK)) {
            // cancel user timer
            boolean ret = m_userTask.cancel();
            LOG.debug("timerTaskComplete: {} cancelled: {}", USERTIMER, ret);

            // send out the info and reset both timers
            if (m_highTtask != null) {
                ret = m_highTtask.cancel();
                LOG.debug("timerTaskComplete: {} cancelled: {}", HIGHT_TASK, ret);

                m_highTtask = null;
            }

            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

            m_lowTtask = null;

            m_counter = -1;

            // reset the user timer
            m_timer.schedule((m_userTask = new RTCTimerTask(USERTIMER)), 0, m_userRefreshInterval);
            LOG.debug("timerTaskComplete: {} scheduled", USERTIMER);
        } else if (tt.getID().equals(HIGHT_TASK)) {
            // cancel user timer
            boolean ret = m_userTask.cancel();
            LOG.debug("timerTaskComplete: {} cancelled: {}", USERTIMER, ret);

            // send the category information out reset all timers
            if (m_lowTtask != null) {
                ret = m_lowTtask.cancel();
                LOG.debug("timerTaskComplete: {} cancelled: {}", LOWT_TASK, ret);

                m_lowTtask = null;
            }

            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

            m_highTtask = null;

            m_counter = -1;

            // reset the user timer
            m_timer.schedule((m_userTask = new RTCTimerTask(USERTIMER)), 0, m_userRefreshInterval);
            LOG.debug("timerTaskComplete: {} scheduled", USERTIMER);
        } else if (tt.getID().equals(USERTIMER)) {
            // send if not pasued
            if (isRunning()) {
                m_dataSender.notifyToSend();
            }

        }
    }

