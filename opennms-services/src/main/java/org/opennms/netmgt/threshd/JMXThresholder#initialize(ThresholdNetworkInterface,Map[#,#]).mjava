    /**
     * {@inheritDoc}
     *
     * Responsible for performing all necessary initialization for the specified
     * interface in preparation for thresholding.
     */
    @Override
    public void initialize(ThresholdNetworkInterface iface, Map<?,?> parameters) {
        // Get interface address from NetworkInterface
        if (iface.getType() != NetworkInterface.TYPE_INET) {
            throw new RuntimeException("Unsupported interface type, only TYPE_INET currently supported");
        }

        InetAddress ipAddr = (InetAddress) iface.getAddress();

        // Retrieve the name of the thresholding group associated
        // with this interface.
        String groupName = ParameterMap.getKeyedString(parameters, "thresholding-group", serviceName);

        // Get the threshold group's RRD repository path
        String repository = null;
        try {
            repository = ThresholdingConfigFactory.getInstance().getRrdRepository(groupName);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Thresholding group '" + groupName + "' does not exist.");
        }

        // Add RRD repository as an attribute of the interface for retrieval
        // by the check() method.
        iface.setAttribute(RRD_REPOSITORY_KEY, repository);

        // Retrieve the collection of Threshold objects associated with
        // the defined thresholding group and build two maps, one consisting
        // of node level ThresholdEntity objects and another consisting of
        // interface level ThresholdEntity objects both keyed by datasource
        // name.
        //
        // Each ThresholdEntity can wrap one high Threshold and one low
        // Threshold castor-generated object for a single datasource.
        // If more than one high or more than one low threshold is defined
        // for a single datasource a warning messages is generated. Only
        // the first threshold in such a scenario will be used for thresholding.
        //
        Map<String, ThresholdEntity> nodeMap   = new HashMap<String, ThresholdEntity>();
        Map<String, ThresholdEntity> baseIfMap = new HashMap<String, ThresholdEntity>();
        try {
            for (Basethresholddef thresh : ThresholdingConfigFactory.getInstance().getThresholds(groupName)) {
                // See if map entry already exists for this datasource
                // If not, create a new one.
                boolean newEntity = false;
                ThresholdEntity thresholdEntity = null;
                try {
                    BaseThresholdDefConfigWrapper wrapper=BaseThresholdDefConfigWrapper.getConfigWrapper(thresh);
                    if (wrapper.getDsType().equals("node")) {
                        thresholdEntity = nodeMap.get(wrapper.getDatasourceExpression());
                    } else if (wrapper.getDsType().equals("if")) {
                        thresholdEntity = baseIfMap.get(wrapper.getDatasourceExpression());
                    }
    
                    // Found entry?
                    if (thresholdEntity == null) {
                        // Nope, create a new one
                        newEntity = true;
                        thresholdEntity = new ThresholdEntity();
                    }
    
                    try {
                        thresholdEntity.addThreshold(wrapper);
                    } catch (IllegalStateException e) {
                        log().warn("Encountered duplicate " + thresh.getType() + " for datasource " + wrapper.getDatasourceExpression(), e);
                    }
 
                    // Add new entity to the map
                    if (newEntity) {
                        if (thresh.getDsType().equals("node")) {
                            nodeMap.put(wrapper.getDatasourceExpression(), thresholdEntity);
                        } else if (thresh.getDsType().equals("if")) {
                            baseIfMap.put(wrapper.getDatasourceExpression(), thresholdEntity);
                        }
                    }
                } catch (ThresholdExpressionException e) {
                    log().warn("Could not parse threshold expression: "+e.getMessage(), e);
                }

            }
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Thresholding group '" + groupName + "' does not exist.");
        }

        // Add node and interface thresholding maps as attributes of the
        // interface for retrieval by the check() method.
        iface.setAttribute(NODE_THRESHOLD_MAP_KEY,    nodeMap);
        iface.setAttribute(BASE_IF_THRESHOLD_MAP_KEY, baseIfMap);

        // Now create an empty map which will hold interface level
        // ThresholdEntity objects for each of the node's interfaces.
        // This map will be keyed by the interface's iflabel and will
        // contain as a value a map of ThresholdEntity objects keyed
        // by datasource name.
        iface.setAttribute(ALL_IF_THRESHOLD_MAP_KEY, new HashMap<String,Map<String,ThresholdEntity>>());

        final DBUtils d = new DBUtils(getClass());
        // Get database connection in order to retrieve the nodeid and
        // ifIndex from the database for this interface.
        Connection dbConn = null;
        try {
            dbConn = DataSourceFactory.getInstance().getConnection();
            d.watch(dbConn);
        } catch (SQLException e) {
            log().error("initialize: Failed getting connection to the database: " + e, e);
            throw new UndeclaredThrowableException(e);
        }

        int nodeId = -1;

        // All database calls wrapped in try/finally block so we make
        // certain that the connection will be closed when we are
        // finished.
        try {
            // Prepare & execute the SQL statement to get the 'nodeid',
            // 'ifIndex' and 'isSnmpPrimary' fields from the ipInterface table.
            PreparedStatement stmt = null;
            final String hostAddress = InetAddressUtils.str(ipAddr);
			try {
                stmt = dbConn.prepareStatement(SQL_GET_NODEID);
                d.watch(stmt);
                stmt.setString(1, hostAddress); // interface address
                ResultSet rs = stmt.executeQuery();
                d.watch(rs);
                if (rs.next()) {
                    nodeId = rs.getInt(1);
                    if (rs.wasNull()) {
                        nodeId = -1;
                    }
                }
            } catch (SQLException e) {
                if (log().isDebugEnabled()) {
                    log().debug("initialize: SQL exception!!: " + e, e);
                }
                throw new RuntimeException("SQL exception while attempting to retrieve node id for interface " + hostAddress + ": " + e, e);
            }

            // RuntimeException is thrown if any of the following are true:
            // - node id is invalid
            // - primaryIfIndex is invalid
            // - Interface is not the primary SNMP interface for the node
            if (nodeId == -1) {
                throw new RuntimeException("Unable to retrieve node id for interface " + hostAddress);
            }

        } finally {
            d.cleanUp();
        }

        // Add nodeId as an attribute of the interface for retrieval
        // by the check() method.
        iface.setAttribute(NODE_ID_KEY, Integer.valueOf(nodeId));

        // Debug
        final String hostAddress = InetAddressUtils.str(ipAddr);
		if (log().isDebugEnabled()) {
            log().debug("initialize: dumping node thresholds defined for " + hostAddress + "/" + groupName + ":");
            Iterator<ThresholdEntity> iter = nodeMap.values().iterator();
            while (iter.hasNext()) {
                log().debug(iter.next().toString());
            }

            log().debug("initialize: dumping interface thresholds defined for " + hostAddress + "/" + groupName + ":");
            iter = baseIfMap.values().iterator();
            while (iter.hasNext()) {
                log().debug(iter.next().toString());
            }
        }

        if (log().isDebugEnabled()) {
            log().debug("initialize: initialization completed for " + hostAddress);
        }
        
        return;
    }

