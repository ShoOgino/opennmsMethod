    /*
     * Apply thresholds definitions for specified service using attributesMap as current values.
     * Return a list of events to be send if some thresholds must be triggered or be rearmed.
     */
    /** {@inheritDoc} */
    public List<Event> applyThresholds(String svcName, Map<String, Double> attributes) {
        LatencyCollectionResource latencyResource = new LatencyCollectionResource(svcName, m_hostAddress);
        LatencyCollectionAttributeType latencyType = new LatencyCollectionAttributeType();
        Map<String, CollectionAttribute> attributesMap = new HashMap<String, CollectionAttribute>();
        for (final Entry<String, Double> entry : attributes.entrySet()) {
            final String ds = entry.getKey();
            attributesMap.put(ds, new LatencyCollectionAttribute(latencyResource, latencyType, ds, entry.getValue()));
        }
        //The timestamp is irrelevant; latency is never a COUNTER (which is the only reason the date is used).  
        //Yes, we have to know a little too much about the implementation details of CollectionResourceWrapper to say that, but
        // we have little choice
        CollectionResourceWrapper resourceWrapper = new CollectionResourceWrapper(new Date(), m_nodeId, m_hostAddress, m_serviceName, m_repository, latencyResource, attributesMap, m_resourceStorageDao);
        return Collections.unmodifiableList(applyThresholds(resourceWrapper, attributesMap));
    }

