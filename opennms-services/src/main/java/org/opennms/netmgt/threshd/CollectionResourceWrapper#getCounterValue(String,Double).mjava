    /*
     * This will return the rate based on configured collection step
     */
    private Double getCounterValue(String id, Double current) {
        synchronized (m_localCache) {

        if (m_localCache.containsKey(id) == false) {
            // Atomically replace the CacheEntry with the new value
            // If the sysUpTime was changed, the "last" value must be null (to force update the cache).
            CacheEntry last = m_counterReset ? null : s_cache.put(id, new CacheEntry(m_collectionTimestamp, current));
            LOG.debug("getCounterValue: id={}, last={}, current={}", id, (last==null ? last : last.m_value +"@"+ last.m_timestamp), current);
            if (last == null) {
                m_localCache.put(id, Double.NaN);
                LOG.info("getCounterValue: unknown last value for {}, ignoring current", id);
            } else {                
                Double delta = current.doubleValue() - last.m_value.doubleValue();
                // wrapped counter handling(negative delta), rrd style
                if (delta < 0) {
                    double newDelta = delta.doubleValue();
                    // 2-phase adjustment method
                    // try 32-bit adjustment
                    newDelta += Math.pow(2, 32);
                    if (newDelta < 0) {
                        // try 64-bit adjustment
                        newDelta += Math.pow(2, 64) - Math.pow(2, 32);
                    }
                    LOG.info("getCounterValue: {}(counter) wrapped counter adjusted last={}@{}, current={}, olddelta={}, newdelta={}", id, last.m_value, last.m_timestamp, current, delta, newDelta);
                    delta = newDelta;
                }
                // Get the interval between when this current collection was taken, and the last time this
                // value was collected (and had a counter rate calculated for it).
                // If the interval is zero, than the current rate must returned as 0.0 since there can be 
                // no delta across a time interval of zero.
                long interval = ( m_collectionTimestamp.getTime() - last.m_timestamp.getTime() ) / 1000;
                if (interval > 0) {
                    final Double value = (delta/interval);
                    LOG.debug("getCounterValue: id={}, value={}, delta={}, interval={}", id, value, delta, interval);
                    m_localCache.put(id, value);
                } else {
                    LOG.info("getCounterValue: invalid zero-length rate interval for {}, returning rate of zero", id);
                    m_localCache.put(id, 0.0);
                    // Restore the original value inside the static cache
                    s_cache.put(id, last);
                }
            }
        }
        Double value = m_localCache.get(id);
        // This is just a sanity check, we should never have a value of null for the value at this point
        if (value == null) {
            LOG.error("getCounterValue: value was not calculated correctly for {}, using NaN", id);
            m_localCache.put(id, Double.NaN);
            return Double.NaN;
        } else {
            return value;
        }

        }
    }

