    /*
     * This will return the rate based on configured collection step
     */
    private Double getCounterValue(String id, Double current) {
        synchronized (m_localCache) {

        if (m_localCache.containsKey(id) == false) {
            // Atomically replace the CacheEntry with the new value
            CacheEntry last = s_cache.put(id, new CacheEntry(m_collectionTimestamp, current));
            if (log().isDebugEnabled()) {
                log().debug("getCounterValue: id=" + id + ", last=" + 
                		(last==null ? last : last.value +"@"+last.timestamp) + 
                		", current=" + current);
            }
            if (last == null) {
                log().info("getCounterValue: unknown last value, ignoring current");
                m_localCache.put(id, Double.NaN);
            } else {                
                Double delta = current.doubleValue() - last.value.doubleValue();
                // wrapped counter handling(negative delta), rrd style
                if (delta < 0) {
                    double newDelta = delta.doubleValue();
                    // 2-phase adjustment method
                    // try 32-bit adjustment
                    newDelta += Math.pow(2, 32);
                    if (newDelta < 0) {
                        // try 64-bit adjustment
                        newDelta += Math.pow(2, 64) - Math.pow(2, 32);
                    }
                    log().info("getCounterValue: " + id + 
                    		"(counter) wrapped counter adjusted last=" + 
                    		last.value +"@"+last.timestamp +
                    		", current=" + current + 
                    		", olddelta=" + delta + 
                    		", newdelta=" + newDelta);
                    delta = newDelta;
                }
                // Get the interval between when this current collection was taken, and the last time this
                // value was collected (and had a counter rate calculated for it).
                // If the interval is zero, than the current rate must returned as 0.0 since there can be 
                // no delta across a time interval of zero.
                long interval = ( m_collectionTimestamp.getTime() - last.timestamp.getTime() ) / 1000;
                if (interval > 0) {
                    m_localCache.put(id, delta / interval);
                } else {
                    log().warn("getCounterValue: invalid zero-length rate interval for " + id + ", returning rate of zero");
                    m_localCache.put(id, 0.0);
                    // Restore the original value inside the static cache
                    s_cache.put(id, last);
                }
            }
        }
        Double value = m_localCache.get(id);
        // This is just a sanity check, we should never have a value of null for the value at this point
        if (value == null) {
            log().error("getCounterValue: value was not calculated correctly for " + id + ", using NaN");
            m_localCache.put(id, Double.NaN);
            return Double.NaN;
        } else {
            return value;
        }

        }
    }

