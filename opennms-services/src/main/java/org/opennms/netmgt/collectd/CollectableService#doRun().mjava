    private void doRun() {
        // Process any outstanding updates.
        if (processUpdates() == ABORT_COLLECTION) {
            LOG.debug("run: Aborting because processUpdates returned ABORT_COLLECTION (probably marked for deletion) for {}", this);
            return;
        }

        // Update last scheduled poll time; if we are not doing strict interval,
        // it is the current time; if we are, it is the previous time plus the
        // interval
        if (m_lastScheduledCollectionTime == 0 || !m_usingStrictInterval) {
            m_lastScheduledCollectionTime = System.currentTimeMillis();
        } else {
            m_lastScheduledCollectionTime += m_spec.getInterval();
        }

        /*
         * Check scheduled outages to see if any apply indicating
         * that the collection should be skipped.
         */
        if (!m_spec.scheduledOutage(m_agent)) {
            try {
                doCollection();
                updateStatus(CollectionStatus.SUCCEEDED, null);
            } catch (CollectionTimedOut e) {
                LOG.info(e.getMessage());
                updateStatus(CollectionStatus.FAILED, e);
            } catch (CollectionWarning e) {
                LOG.warn(e.getMessage(), e);
                updateStatus(CollectionStatus.FAILED, e);
            } catch (CollectionUnknown e) {
                LOG.warn(e.getMessage(), e);
                // Omit any status updates
            } catch (CollectionException e) {
                LOG.error(e.getMessage(), e);
                updateStatus(CollectionStatus.FAILED, e);
            } catch (Throwable e) {
                LOG.error(e.getMessage(), e);
                updateStatus(CollectionStatus.FAILED, new CollectionException("Collection failed unexpectedly: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e));
            }
        }

        // If we are doing strict interval, determine how long the collection
        // has taken, so we can cut that off of the service interval
        long diff = 0;
        if (m_usingStrictInterval) {
            diff = System.currentTimeMillis() - m_lastScheduledCollectionTime;
            diff = Math.min(diff, m_spec.getInterval());
        }
    	// Reschedule the service
        m_scheduler.schedule(m_spec.getInterval() - diff, getReadyRunnable());
    }

