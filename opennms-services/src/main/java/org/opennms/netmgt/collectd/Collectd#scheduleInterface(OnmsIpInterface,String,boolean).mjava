    private void scheduleInterface(OnmsIpInterface iface, String svcName, boolean existing) {
        
        final String ipAddress = str(iface.getIpAddress());
        if (ipAddress == null) {
        	LOG.warn("Unable to schedule interface {}, could not determine IP address.", iface);
        	return;
        }

		instrumentation().beginScheduleInterface(iface.getNode().getId(), ipAddress, svcName);
        try {
        
        Collection<CollectionSpecification> matchingSpecs = getSpecificationsForInterface(iface, svcName);
        StringBuffer sb;
        
        LOG.debug("scheduleInterface: found {} matching specs for interface: {}", matchingSpecs.size(), iface);

        for (CollectionSpecification spec : matchingSpecs) {

            if (existing == false) {
                /*
                 * It is possible that both a nodeGainedService and a
                 * primarySnmpInterfaceChanged event are generated for an
                 * interface during a rescan. To handle this scenario we must
                 * verify that the ipAddress/pkg pair identified by this event
                 * does not already exist in the collectable services list.
                 */
                if (alreadyScheduled(iface, spec)) {
                    LOG.debug("scheduleInterface: svc/pkgName {}/{} already in collectable service list, skipping.", iface, spec);
                    continue;
                }
            }

            try {
                /*
                 * Criteria checks have all passed. The interface/service pair
                 * can be scheduled.
                 */
                LOG.debug("scheduleInterface: now scheduling interface: {}/{}", iface, svcName);
                CollectableService cSvc = null;

                /*
                 * Create a new SnmpCollector object representing this node,
                 * interface, service and package pairing
                 */

                cSvc = new CollectableService(
                    iface, 
                    m_ifaceDao, 
                    spec, 
                    getScheduler(),
                    m_schedulingCompletedFlag,
                    m_transTemplate.getTransactionManager()
                );

                // Add new collectable service to the collectable service list.
                m_collectableServices.add(cSvc);

                // Schedule the collectable service for immediate collection
                getScheduler().schedule(0, cSvc.getReadyRunnable());

                LOG.debug("scheduleInterface: {}/{} collection, scheduled", iface, svcName);
            } catch (CollectionInitializationException e) {
                sb = new StringBuffer();
                sb.append("scheduleInterface: Unable to schedule ");
                sb.append(iface);
                sb.append('/');
                sb.append(svcName);
                sb.append(", reason: ");
                sb.append(e.getMessage());

                // Only log the stack trace if TRACE level logging is enabled.
                // Fixes bug NMS-3324.
                // http://issues.opennms.org/browse/NMS-3324
                if (LOG.isTraceEnabled()) {
                    LOG.trace(sb.toString(), e);
                } else {
                    LOG.info(sb.toString());
                }
            } catch (Throwable t) {
                LOG.error("scheduleInterface: Uncaught exception, failed to schedule interface {}/{}.", iface, svcName, t);
            }
        } // end while more specifications exist
        
        } finally {
            instrumentation().endScheduleInterface(iface.getNode().getId(), ipAddress, svcName);
        }
    }

