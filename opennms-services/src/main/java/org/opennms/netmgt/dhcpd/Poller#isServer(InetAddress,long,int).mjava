    /**
     * <p>
     * This method actually tests the remote host to determine if it is
     * running a functional DHCP server.
     * </p>
     * <p>
     * Formats a DHCP query and encodes it in a client request message which
     * is sent to the DHCP daemon over the established TCP socket connection.
     * If a matching DHCP response packet is not received from the DHCP daemon
     * within the specified timeout the client request message will be re-sent
     * up to the specified number of retries.
     * </p>
     * <p>
     * If a response is received from the DHCP daemon it is validated to
     * ensure that:
     * </p>
     * <ul>
     * <li>The DHCP response packet was sent from the remote host to which the
     * original request packet was directed.</li>
     * <li>The XID of the DHCP response packet matches the XID of the original
     * DHCP request packet.</li>
     * </ul>
     * <p>
     * If the response validates 'true' is returned. Otherwise the request is
     * resent until max retry count is exceeded.
     * </p>
     * <p>
     * Before returning, a client disconnect message (remote host field set to
     * zero) is sent to the DHCP daemon.
     * </p>
     * 
     * @return response time in milliseconds if the specified host responded
     *         with a valid DHCP offer datagram within the context of the
     *         specified timeout and retry values or negative one (-1)
     *         otherwise.
     */
    static long isServer(InetAddress host, long timeout, int retries) throws IOException {
        ThreadCategory log = ThreadCategory.getInstance(Poller.class);

        boolean isDhcpServer = false;
        // List of DHCP queries to try. The default when extended
        // mode = false must be listed first. (DISCOVER)
        byte[] typeList = { (byte) DHCPMessage.DISCOVER, (byte) DHCPMessage.INFORM, (byte) DHCPMessage.REQUEST };
        String[] typeName = { "DISCOVER", "INFORM", "REQUEST" };
        DhcpdConfigFactory dcf = DhcpdConfigFactory.getInstance();
        if (!paramsChecked) {
            String s_extendedMode = dcf.getExtendedMode();
            if (s_extendedMode == null) {
                extendedMode = false;
            } else {
                extendedMode = Boolean.parseBoolean(s_extendedMode);
            }
            if (log.isDebugEnabled()) {
                log.debug("isServer: DHCP extended mode is " + extendedMode);
            }
            
            String hwAddressStr = dcf.getMacAddress();
            if (log.isDebugEnabled()) {
                log.debug("isServer: DHCP query hardware/MAC address is " + hwAddressStr);
            }
            setHwAddress(hwAddressStr);
            
            String myIpStr = dcf.getMyIpAddress();
            if (log.isDebugEnabled()) {
                log.debug("isServer: DHCP relay agent address is " + myIpStr);
            }
            if (myIpStr == null || myIpStr.equals("") || myIpStr.equalsIgnoreCase("broadcast")) {
                // do nothing
            } else if (IpValidator.isIpValid(myIpStr)) {
                s_myIpAddress = setIpAddress(myIpStr);
                relayMode = true;
            }
            
            if (extendedMode == true) {
                String requestStr = dcf.getRequestIpAddress();
                if (log.isDebugEnabled()) {
                    log.debug("isServer: REQUEST query target is " + requestStr);
                }
                if (requestStr == null || requestStr.equals("") || requestStr.equalsIgnoreCase("targetSubnet")) {
                    // do nothing
                } else if (requestStr.equalsIgnoreCase("targetHost")) {
                    targetOffset = false;
                } else if (IpValidator.isIpValid(requestStr)) {
                    s_requestIpAddress = setIpAddress(requestStr);
                    reqTargetIp = false;
                    targetOffset = false;
                }
                if (log.isDebugEnabled()) {
                    log.debug("REQUEST query options are: reqTargetIp = " + reqTargetIp + ", targetOffset = " + targetOffset);
                }
            }
            paramsChecked = true;
        }

        int j = 1;
        if (extendedMode == true) {
            j = typeList.length;
        }

        if (timeout < 500) {
            timeout = 500;
        }

        Poller p = new Poller(timeout);
        long responseTime = -1;
        try {
            pollit: for (int i = 0; i < j; i++) {

                Message ping = getPollingRequest(host, (byte) typeList[i]);

                int rt = retries;
                while (rt >= 0 && !isDhcpServer) {
                    if (log.isDebugEnabled()) {
                        log.debug("isServer: sending DHCP " + typeName[i] + " query to host " + host.getHostAddress() + " with Xid: " + ping.getMessage().getXid());
                    }
                    
                    long start = System.currentTimeMillis();
                    p.m_outs.writeObject(ping);
                    long end;

                    do {
                        Message resp = null;
                        try {
                            resp = (Message) p.m_ins.readObject();
                        } catch (InterruptedIOException ex) {
                            resp = null;
                        }

                        if (resp != null) {
                            responseTime = System.currentTimeMillis() - start;

                            // DEBUG only
                            if (log.isDebugEnabled()) {
                                log.debug("isServer: got a DHCP response from host " + resp.getAddress().getHostAddress() + " with Xid: " + resp.getMessage().getXid());
                            }

                            if (host.equals(resp.getAddress()) && ping.getMessage().getXid() == resp.getMessage().getXid()) {
                                // Inspect response message to see if it is a valid DHCP response
                                byte[] type = resp.getMessage().getOption(MESSAGE_TYPE);
                                if (log.isDebugEnabled()) {
                                    if (type[0] == DHCPMessage.OFFER) {
                                        log.debug("isServer: got a DHCP OFFER response, validating...");
                                    } else if (type[0] == DHCPMessage.ACK) {
                                        log.debug("isServer: got a DHCP ACK response, validating...");
                                    } else if (type[0] == DHCPMessage.NAK) {
                                        log.debug("isServer: got a DHCP NAK response, validating...");
                                    }
                                }

                                // accept offer or ACK or NAK
                                if (type[0] == DHCPMessage.OFFER || (extendedMode == true && (type[0] == DHCPMessage.ACK || type[0] == DHCPMessage.NAK))) {
                                    if (log.isDebugEnabled()) {
                                        log.debug("isServer: got a valid DHCP response. responseTime= " + responseTime + "ms");
                                    }
                                    
                                    isDhcpServer = true;
                                    break pollit;
                                }
                            }
                        }

                        end = System.currentTimeMillis();

                    } while ((end - start) < timeout);

                    if (log.isDebugEnabled()) {
                        if (!isDhcpServer) {
                            log.debug("Timed out waiting for DHCP response, remaining retries: " + rt);
                        }
                    }

                    --rt;
                }
            }

            if (log.isDebugEnabled()) {
                log.debug("Sending disconnect request");
            }
            p.m_outs.writeObject(getDisconnectRequest());
            if (log.isDebugEnabled()) {
                log.debug("wait half a sec before closing connection");
            }
            Thread.sleep(500);
            p.close();
        } catch (IOException ex) {
            log.error("IO Exception caught.", ex);
            p.close();
            throw ex;
        } catch (Throwable t) {
            log.error("Unexpected Exception caught.", t);
            p.close();
            throw new UndeclaredThrowableException(t);
        }

        // Return response time if the remote box IS a DHCP
        // server or -1 if the remote box is NOT a DHCP server.
        if (isDhcpServer) {
            return responseTime;
        } else {
            return -1;
        }
    }

