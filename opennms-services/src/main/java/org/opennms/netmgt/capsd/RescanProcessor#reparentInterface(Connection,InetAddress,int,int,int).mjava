    /**
     * This method is responsible for reparenting an interface's database table
     * entries under its new node identifier. The following tables are updated:
     * 
     * ipInterface snmpInterface ifServices
     * 
     * @param dbc
     *            Database connection
     * @param ifAddr
     *            Interface to be reparented.
     * @param newNodeId
     *            Interface's new node identifier
     * @param oldNodeId
     *            Interfaces' old node identifier
     * 
     * @throws SQLException
     *             if a database error occurs during reparenting.
     */
    private static void reparentInterface(final Connection dbc, final InetAddress ifAddr, final int ifIndex, final int newNodeId, final int oldNodeId) throws SQLException {
        String ipaddr = str(ifAddr);
        final DBUtils d = new DBUtils(RescanProcessor.class);

        try {
            final PreparedStatement ifLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_LOOKUP);
            d.watch(ifLookupStmt);
            final PreparedStatement ifDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_DELETE);
            d.watch(ifDeleteStmt);
            final PreparedStatement ipInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);
            d.watch(ipInterfaceStmt);
            final PreparedStatement snmpIfLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_LOOKUP);
            d.watch(snmpIfLookupStmt);
            final PreparedStatement snmpIfDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_DELETE);
            d.watch(snmpIfDeleteStmt);
            final PreparedStatement snmpInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);
            d.watch(snmpInterfaceStmt);
            final PreparedStatement ifServicesLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_LOOKUP);
            d.watch(ifServicesLookupStmt);
            final PreparedStatement ifServicesDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_DELETE);
            d.watch(ifServicesDeleteStmt);
            final PreparedStatement ifServicesStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);
            d.watch(ifServicesStmt);

            LOG.debug("reparentInterface: reparenting address/ifIndex/nodeID: {}/{}/{}", ipaddr, ifIndex, newNodeId);

            /*
             * SNMP interface
             *
             * NOTE: Only reparent SNMP interfaces if we have valid ifIndex
             */
            if (ifIndex < 1) {
                LOG.debug("reparentInterface: don't have a valid ifIndex, skipping snmpInterface table reparenting.");
            } else {
                /*
                 * NOTE: Now that the snmpInterface table is uniquely keyed
                 * by nodeId and ifIndex we must only reparent the
                 * old entry if there isn't already an entry with
                 * the same nodeid/ifindex pairing. If it can't
                 * be reparented it will be deleted.
                 */

                /*
                 * Look for matching nodeid/ifindex for the entry to be
                 * reparented
                 */
                snmpIfLookupStmt.setInt(1, newNodeId);
                snmpIfLookupStmt.setInt(2, ifIndex);
                final ResultSet rs = snmpIfLookupStmt.executeQuery();
                d.watch(rs);
                if (rs.next()) {
                    /*
                     * Looks like we got a match so just delete
                     * the entry from the old node
                     */
                    LOG.debug("reparentInterface: interface with ifindex {} already exists under new node {} in snmpinterface table, deleting from under old node {}", ifIndex, newNodeId, oldNodeId);

                    snmpIfDeleteStmt.setInt(1, oldNodeId);
                    snmpIfDeleteStmt.setInt(2, ifIndex);

                    snmpIfDeleteStmt.executeUpdate();
                } else {
                    /*
                     * Update the 'snmpinterface' table entry so that this
                     * interface's nodeID is set to the value of reparentNodeID
                     */
                    LOG.debug("reparentInterface: interface with ifindex {} does not yet exist under new node {} in snmpinterface table, reparenting.", ifIndex, newNodeId);

                    snmpInterfaceStmt.setInt(1, newNodeId);
                    snmpInterfaceStmt.setInt(2, oldNodeId);
                    snmpInterfaceStmt.setInt(3, ifIndex);

                    // execute and log
                    snmpInterfaceStmt.executeUpdate();
                }
            }

            // Look for matching nodeid/ifindex for the entry to be reparented
            ifLookupStmt.setInt(1, newNodeId);
            ifLookupStmt.setString(2, ipaddr);
            final ResultSet rs = ifLookupStmt.executeQuery();
            d.watch(rs);
            if (rs.next()) {
                /*
                 * Looks like we got a match so just delete
                 * the entry from the old node
                 */
                LOG.debug("reparentInterface: interface with ifindex {} already exists under new node {} in ipinterface table, deleting from under old node {}", ifIndex, newNodeId, oldNodeId);

                ifDeleteStmt.setInt(1, oldNodeId);
                ifDeleteStmt.setString(2, ipaddr);

                ifDeleteStmt.executeUpdate();
            } else {
                /*
                 * Update the 'ipinterface' table entry so that this
                 * interface's nodeID is set to the value of reparentNodeID
                 */
                LOG.debug("reparentInterface: interface with ifindex {} does not yet exist under new node {} in ipinterface table, reparenting.", ifIndex, newNodeId);

                ipInterfaceStmt.setInt(1, newNodeId);
                ipInterfaceStmt.setInt(2, oldNodeId);
                ipInterfaceStmt.setString(3, ipaddr);

                // execute and log
                ipInterfaceStmt.executeUpdate();
            }

            // Look for matching nodeid/ifindex for the entry to be reparented
            ifServicesLookupStmt.setInt(1, newNodeId);
            ifServicesLookupStmt.setString(2, ipaddr);
            ifServicesLookupStmt.setInt(3, ifIndex);
            final ResultSet rsServicesLookup = ifServicesLookupStmt.executeQuery();
            d.watch(rsServicesLookup);
            if (rsServicesLookup.next()) {
                /*
                 * Looks like we got a match so just delete
                 * the entry from the old node
                 */
                LOG.debug("reparentInterface: interface with ifindex {} already exists under new node {} in ifservices table, deleting from under old node {}", ifIndex, newNodeId, oldNodeId);

                ifServicesDeleteStmt.setInt(1, oldNodeId);
                ifServicesDeleteStmt.setString(2, ipaddr);

                ifServicesDeleteStmt.executeUpdate();
            } else {
                /*
                 * Update the 'snmpinterface' table entry so that this
                 * interface's nodeID is set to the value of reparentNodeID
                 */
                LOG.debug("reparentInterface: interface with ifindex {} does not yet exist under new node {} in ifservices table, reparenting.", ifIndex, newNodeId);

                /*
                 * Update the 'nodeID' field of all 'ifservices' table entries
                 * for the reparented interfaces.
                 */
                ifServicesStmt.setInt(1, newNodeId);
                ifServicesStmt.setInt(2, oldNodeId);
                ifServicesStmt.setString(3, ipaddr);

                // execute and log
                ifServicesStmt.executeUpdate();
            }

            LOG.debug("reparentInterface: reparented {} : ifIndex: {} : oldNodeID: {} newNodeID: {}", ipaddr, ifIndex, oldNodeId, newNodeId);
        } catch (final SQLException sqlE) {
            LOG.error("SQLException while reparenting addr/ifindex/nodeid {}/{}/{}", ipaddr, ifIndex, oldNodeId);
            throw sqlE;
        } finally {
            d.cleanUp();
        }
    }

