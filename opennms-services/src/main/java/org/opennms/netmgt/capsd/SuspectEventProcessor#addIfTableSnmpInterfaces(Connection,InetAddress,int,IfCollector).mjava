    private boolean addIfTableSnmpInterfaces(Connection dbc, InetAddress ifaddr,
            int nodeId, IfCollector collector)
            throws SQLException {
        if (!collector.hasSnmpCollection()) {
            return false;
        }
        
        IfSnmpCollector snmpc = collector.getSnmpCollector();

        if (!snmpc.hasIfTable()) {
            return false;
        }

        boolean addedSnmpInterfaceEntry = false;

        for (IfTableEntry ifte : snmpc.getIfTable().getEntries()) {
            // index
            if (ifte.getIfIndex() == null) {
                continue;
            }
            final int xifIndex = ifte.getIfIndex().intValue();

            /*
             * address WARNING: IfSnmpCollector.getIfAddressAndMask() ONLY
             * returns the FIRST IP address and mask for a given interface as
             * specified in the ipAddrTable.
             */
            InetAddress[] addrs = null;
            if (snmpc.hasIpAddrTable()) {
                addrs = snmpc.getIfAddressAndMask(xifIndex);
            }

            // At some point back in the day this was done with ifType
            // Skip loopback interfaces
            if (addrs != null && addrs[0].isLoopbackAddress()) {
                continue;
            }

            final DbSnmpInterfaceEntry snmpEntry =
                DbSnmpInterfaceEntry.create(nodeId, xifIndex);

            if (addrs == null) {
                // No IP associated with the interface
                snmpEntry.setCollect("N");

            } else {
                // IP address
                if (addrs[0].equals(ifaddr)) {
                    addedSnmpInterfaceEntry = true;
                }

                // netmask
                if (addrs[1] != null) {
                    snmpEntry.setNetmask(addrs[1]);
                }
                
                snmpEntry.setCollect("C");
            }

            // description
            final String str = ifte.getIfDescr();
            if (log().isDebugEnabled() && addrs != null) {
                log().debug("SuspectEventProcessor: "
                        + str(addrs[0]) + " has ifDescription: "
                        + str);
            }
            if (str != null && str.length() > 0) {
                snmpEntry.setDescription(str);
            }

            // physical address
            String physAddr = null;
            try {
                physAddr = ifte.getPhysAddr();
                if (log().isDebugEnabled() && addrs != null) {
                    log().debug("SuspectEventProcessor: "
                            + str(addrs[0])
                            + " has physical address: -" + physAddr + "-");
                }
            } catch (IllegalArgumentException iae) {
                physAddr = null;
                if (log().isDebugEnabled() && addrs != null) {
                    log().debug("ifPhysAddress." + ifte.getIfIndex() + " on node "
                               + nodeId + " / " + str(addrs[0])
                               + " could not be converted to a hex string (not a PhysAddr / OCTET STRING?), setting to null.");
                }
                StringBuffer errMsg = new StringBuffer("SNMP agent bug on node ");
                errMsg.append(nodeId).append(" / ").append(str(ifaddr));
                errMsg.append(": wrong type for physical address (see bug 2740). ");
                errMsg.append("Working around, but expect trouble with this node.");
                log().warn(errMsg.toString());
            }
            if (physAddr != null && physAddr.length() == 12) {
                snmpEntry.setPhysicalAddress(physAddr);
            }

            if (ifte.getIfType() == null) {
                snmpEntry.setType(0);
            } else {
                snmpEntry.setType(ifte.getIfType().intValue());
            }
            
            
            IfXTableEntry ifxte = snmpc.hasIfXTable() ? snmpc.getIfXTable().getEntry(xifIndex) : null;
            
            long speed = getInterfaceSpeed(ifte, ifxte);

            // speed
            snmpEntry.setSpeed(speed);


            // admin status
            if (ifte.getIfAdminStatus() == null) {
                snmpEntry.setAdminStatus(0);
            } else {
                snmpEntry.setAdminStatus(ifte.getIfAdminStatus().intValue());
            }

            // oper status
            if (ifte.getIfOperStatus() == null) {
                snmpEntry.setOperationalStatus(0);
            } else {
                snmpEntry.setOperationalStatus(ifte.getIfOperStatus().intValue());
            }

            // name (from interface extensions table)
            String ifName = snmpc.getIfName(xifIndex);
            if (ifName != null && ifName.length() > 0) {
                snmpEntry.setName(ifName);
            }

            // alias (from interface extensions table)
            final String ifAlias = snmpc.getIfAlias(xifIndex);
            if (ifAlias != null && ifAlias.length() > 0) {
                snmpEntry.setAlias(ifAlias);
            }

            snmpEntry.store(dbc);
        }
        return addedSnmpInterfaceEntry;
    }

