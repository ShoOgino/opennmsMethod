    /**
     * This method is responsible for updating the node table using the most
     * recent data collected from the node's managed interfaces.
     * 
     * @param dbc
     *            Database connection
     * @param now
     *            Date object representing the time of the rescan.
     * @param dbNodeEntry
     *            DbNodeEntry object representing existing values in the
     *            database
     * @param currPrimarySnmpIf
     *            Primary SNMP interface address based on latest collection
     * @param dbIpInterfaces
     *            Array of DbIpInterfaceEntry objects representing all the
     *            interfaces retrieved from the database for this node.
     * @param collectorMap
     *            Map of IfCollector objects...one per managed interface.
     * 
     * @return DbNodeEntry object representing the updated values from the node
     *         table in the database.
     * 
     * @throws SQLException
     *             if there is a problem updating the node table.
     */
    private DbNodeEntry updateNode(final Connection dbc, final Date now, final DbNodeEntry dbNodeEntry, final InetAddress currPrimarySnmpIf, final DbIpInterfaceEntry[] dbIpInterfaces, final Map<String, IfCollector> collectorMap) throws SQLException {
        LOG.debug("updateNode: updating node id {}", dbNodeEntry.getNodeId());

        /*
         * Clone the existing dbNodeEntry so we have all the original
         * values of the 'node' table fields in case we need to generate
         * 'node***Changed' events following the update.
         */
        final DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);

        /*
         * Create node which represents the most recently retrieved
         * information in the collector for this node
         */
        final DbNodeEntry currNodeEntry = DbNodeEntry.create();
        currNodeEntry.setNodeType(NodeType.ACTIVE);

        // Set node label and SMB info based on latest collection
        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);

        // Set SNMP info
        if (currPrimarySnmpIf != null) {
            /*
             * We prefer to use the collector for the primary SNMP interface
             * to update SNMP data in the node table. However a collector
             * for the primary SNMP interface may not exist in the map if
             * a node has only recently had SNMP support enabled or if the
             * new primary SNMP interface was only recently added to the
             * node. At any rate if it exists use it, if not use the
             * first collector which supports SNMP.
             */
            final String addr = str(currPrimarySnmpIf);
            IfCollector primaryIfc = addr == null? null : collectorMap.get(addr);
            if (primaryIfc == null) {
                for (IfCollector tmp : collectorMap.values()) {
                    if (tmp.getSnmpCollector() != null) {
                        primaryIfc = tmp;
                        break;
                    }
                }
            }

            /*
             * Sanity check...should always have a primary interface
             * collector at this point
             */
            if (primaryIfc == null) {
                LOG.error("updateNode: failed to determine primary interface collector for node {}", dbNodeEntry.getNodeId());
                throw new RuntimeException("Update node failed for node " + dbNodeEntry.getNodeId() + ", unable to determine primary interface collector.");
            }

            final IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();
            if (snmpc != null && snmpc.hasSystemGroup()) {
                SystemGroup sysgrp = snmpc.getSystemGroup();

                // sysObjectId
                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());

                // sysName
                final String sysName = sysgrp.getSysName();
                if (sysName != null && sysName.length() > 0) {
                    currNodeEntry.setSystemName(sysName);
                }

                // sysDescription
                final String sysDescr = sysgrp.getSysDescr();
                if (sysDescr != null && sysDescr.length() > 0) {
                    currNodeEntry.setSystemDescription(sysDescr);
                }

                // sysLocation
                final String sysLocation = sysgrp.getSysLocation();
                if (sysLocation != null && sysLocation.length() > 0) {
                    currNodeEntry.setSystemLocation(sysLocation);
                }

                // sysContact
                final String sysContact = sysgrp.getSysContact();
                if (sysContact != null && sysContact.length() > 0) {
                    currNodeEntry.setSystemContact(sysContact);
                }
            }
        }

        /*
         * Currently, we do not use the ParentId except in mapping.
         * Unfortunately, this is never
         * set in the currNodeEntry so it gets reset here. As a workaround,
         * setting it to the old value.
         */

        currNodeEntry.updateParentId(dbNodeEntry.getParentId());

        // Update any fields which have changed
        LOG.debug("updateNode: -------dumping old node-------: {}", dbNodeEntry);
        LOG.debug("updateNode: -------dumping new node-------: {}", currNodeEntry);
        dbNodeEntry.updateParentId(currNodeEntry.getParentId());
        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());
        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());
        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());
        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());
        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());
        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());
        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());
        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());
        dbNodeEntry.updateOS(currNodeEntry.getOS());
        dbNodeEntry.setLastPoll(now);

        /*
         * Only update node label/source if original node entry is
         * not set to user-defined.
         */
        if (dbNodeEntry.getLabelSource() != NodeLabelSource.USER) {
            dbNodeEntry.updateLabel(currNodeEntry.getLabel());
            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());
        }

        // Set event flags
        final boolean nodeLabelChangedFlag = dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged();
        final boolean nodeInfoChangedFlag = dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged();

        // Call store to update the database
        dbNodeEntry.store(dbc);

        // Create nodeLabelChanged event if necessary
        if (nodeLabelChangedFlag) {
            m_eventList.add(createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry));
        }

        // Create nodeInfoChangedEvent if necessary
        if (nodeInfoChangedFlag) {
            m_eventList.add(createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry));
        }

        return dbNodeEntry;
    }

