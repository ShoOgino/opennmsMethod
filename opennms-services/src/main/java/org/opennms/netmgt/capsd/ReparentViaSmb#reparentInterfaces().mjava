    /**
     * This method is responsible for reparenting interfaces belonging to
     * duplicate nodes under the appropriate reparent node id. During this
     * processing the reparented interface map is generated. This map contains a
     * list of reparented interfaces associated with each reparent node. This
     * list will make it possible to generate 'interfaceReparented' events for
     * each reparented interface.
     * 
     * During reparenting the 'ipInterface', 'snmpInterface', and 'ifServices'
     * tables are all updated to reflect the new parent node id for the
     * reparented interface.
     * 
     * @throws SQLException
     *             if error occurs updating the database
     */
    private void reparentInterfaces() throws SQLException {
        Category log = ThreadCategory.getInstance(getClass());
        List<LightWeightIfEntry> reparentedIfList = null;
        m_reparentedIfMap = null;
        final DBUtils d = new DBUtils(getClass());

        try {
            PreparedStatement ipInterfaceStmt = m_connection.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);
            d.watch(ipInterfaceStmt);
            PreparedStatement snmpInterfaceStmt = m_connection.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);
            d.watch(snmpInterfaceStmt);
            PreparedStatement ifServicesStmt = m_connection.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);
            d.watch(ifServicesStmt);

            Set<LightWeightNodeEntry> keys = m_reparentNodeMap.keySet();
            Iterator<LightWeightNodeEntry> iter = keys.iterator();

            while (iter.hasNext()) {
                LightWeightNodeEntry reparentNode = iter.next();
                int reparentNodeID = reparentNode.getNodeId();

                // Now construct a "heavier weight" DbNodeEntry object for this
                // node...sysName, sysDescription and other fields from the node
                // table will be necessary later when the reparentInterface
                // event is generated.
                reparentNode.setHeavyWeightNodeEntry(DbNodeEntry.get(reparentNodeID));

                // Retrieve duplicate node list for this reparent node key
                List<LightWeightNodeEntry> dupList = m_reparentNodeMap.get(reparentNode);
                log.debug("ReparentViaSmb.retrieveNodeData: duplicate node list retrieved, list size=" + dupList.size());

                Iterator<LightWeightNodeEntry> dupIter = dupList.iterator();
                while (dupIter.hasNext()) {
                    LightWeightNodeEntry dupNode = dupIter.next();
                    int dupNodeID = dupNode.getNodeId();

                    try {
                        if (log.isDebugEnabled())
                            log.debug("reparentInterfaces: reparenting all interfaces/services for nodeID " + dupNodeID + " under reparent nodeID " + reparentNodeID);

                        //
                        // Prior to reparenting the interfaces associated with the
                        // duplicate node retrieve a list of the node's interface
                        // IP addresses and add them to the m_reparentedIfMap. This
                        // list will allow us to generate 'interfaceReparented'
                        // events for each one
                        //
                        PreparedStatement stmt = m_connection.prepareStatement(SQL_DB_RETRIEVE_INTERFACES);
                        d.watch(stmt);
                        stmt.setInt(1, dupNodeID);

                        // Issue database query
                        if (log.isDebugEnabled())
                            log.debug("reparentInterfaces: issuing db query...");
                        ResultSet rs = stmt.executeQuery();
                        d.watch(rs);

                        // Process result set
                        // Build list of LightWeightIfEntry objects representing
                        // each of the
                        // interfaces pulled from the 'ipInterface' table
                        while (rs.next()) {
                            String ifAddress = rs.getString(1);
                            String hostName = rs.getString(2);

                            LightWeightIfEntry lwIfEntry = new LightWeightIfEntry(ifAddress, hostName, reparentNodeID, dupNodeID);

                            if (reparentedIfList == null) {
                                reparentedIfList = new ArrayList<LightWeightIfEntry>();
                            }
                            reparentedIfList.add(lwIfEntry);

                            if (log.isDebugEnabled())
                                log.debug("reparentInterfaces: will reparent " + lwIfEntry.getAddress() + " : oldNodeId: " + lwIfEntry.getOldParentNodeId() + " newNodeId: " + lwIfEntry.getParentNodeId());
                        }


                        // Update the 'ipInterface' table so that all interfaces
                        // associated with the duplicate node are reparented.
                        ipInterfaceStmt.setInt(1, reparentNodeID);
                        ipInterfaceStmt.setInt(2, dupNodeID);

                        // execute and log
                        ipInterfaceStmt.executeUpdate();

                        // Update the 'snmpinterface' table so that all interfaces
                        // associated with the duplicate node are reparented
                        snmpInterfaceStmt.setInt(1, reparentNodeID);
                        snmpInterfaceStmt.setInt(2, dupNodeID);

                        // execute and log
                        snmpInterfaceStmt.executeUpdate();

                        // Update the 'ifservices' table so that all services
                        // associated
                        // with the duplicate node are reparented
                        ifServicesStmt.setInt(1, reparentNodeID);
                        ifServicesStmt.setInt(2, dupNodeID);

                        // execute and log
                        ifServicesStmt.executeUpdate();
                    } catch (SQLException sqlE) {
                        log.error("SQLException while reparenting duplicate node w/ nodeID " + dupNodeID);
                        throw sqlE;
                    }

                    // 
                    // Now that all the interfaces have been reparented...lets
                    // delete this duplicate node from the 'node' table
                    //
                    if (log.isDebugEnabled())
                        log.debug("reparentInterfaces: deleting duplicate node id: " + dupNodeID);
                    PreparedStatement deleteNodeStmt = m_connection.prepareStatement(SQL_DB_DELETE_NODE);
                    d.watch(deleteNodeStmt);
                    deleteNodeStmt.setInt(1, dupNodeID);

                    // execute update
                    deleteNodeStmt.executeUpdate();

                } // end while(dupIter.hasNext())

                // Should have a reparented interface list now...add it to
                // the reparented interface map with the reparent node as the key
                if (reparentedIfList != null && !reparentedIfList.isEmpty()) {
                    if (m_reparentedIfMap == null) {
                        m_reparentedIfMap = new HashMap<LightWeightNodeEntry, List<LightWeightIfEntry>>();
                    }

                    m_reparentedIfMap.put(reparentNode, reparentedIfList);
                }
            } // end while(iter.hasNext())
        } finally {
            d.cleanUp();
        }
    }

