    /**
     * This method is responsible for updating the ifservices table entry for a
     * specific interface.
     * 
     * @param dbc
     *            Database Connection.
     * @param node
     *            Node entry for the node being rescanned.
     * @param dbIpIfEntry
     *            interface entry of the updating interface.
     * @param isNewIpEntry
     *            if the dbIpIfEntry is a new entry.
     * @param protocols
     *            Protocols supported by the interface.
     * 
     * @throws SQLException
     *             if there is a problem updating the ifservices table.
     */
    private void updateServiceInfo(final Connection dbc, final DbNodeEntry node, final DbIpInterfaceEntry dbIpIfEntry, final boolean isNewIpEntry, final List<SupportedProtocol> protocols) throws SQLException {
        final CapsdConfig cFactory = CapsdConfigFactory.getInstance();
        final PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();
        org.opennms.netmgt.config.poller.Package ipPkg = null;

        final InetAddress ifaddr = dbIpIfEntry.getIfAddress();

        // Retrieve from the database the interface's service list
        DbIfServiceEntry[] dbSupportedServices = dbIpIfEntry.getServices(dbc);

        final int ifIndex = dbIpIfEntry.getIfIndex();

        if (LOG.isDebugEnabled()) {
            if (ifIndex == -1) {
                LOG.debug("updateServiceInfo: Retrieving interface's service list from database for host {}", dbIpIfEntry.getHostname());
            } else {
                LOG.debug("updateServiceInfo: Retrieving interface's service list from database for host {} ifindex {}", dbIpIfEntry.getHostname(), ifIndex);
            }
        }

        /*
         * add newly supported protocols
         *		
         * NOTE!!!!!: (reference internal bug# 201)
         * If the ip is 'managed', the service can still be 'not polled'
         * based on the poller configuration - at this point the ip is already
         * in the database, so package filter evaluation should go through OK
         */
        if (LOG.isDebugEnabled()) {
            LOG.debug("updateServiceInfo: Checking for new services on host {}", dbIpIfEntry.getHostname());
        }

        final Iterator<SupportedProtocol> iproto = protocols.iterator();
        while (iproto.hasNext()) {
            final SupportedProtocol p = iproto.next();
            final Number sid = m_capsdDbSyncer.getServiceId(p.getProtocolName());

            /*
             * Only adding newly supported services so check against the service
             * list retrieved from the database
             */
            boolean found = false;
            for (int i = 0; i < dbSupportedServices.length && !found; i++) {
                if (dbSupportedServices[i].getServiceId() == sid.intValue()) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                final DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());

                // now fill in the entry
                final String ifaddrString = str(ifaddr);
                if (cFactory.isAddressUnmanaged(ifaddr)) {
                    ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
                } else {
                    ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);
                    if (ipPkg == null) {
                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                    } else if (isServicePolledLocally(ifaddrString, p.getProtocolName(), ipPkg)) {
                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
                    } else if (isServicePolled(ifaddrString, p.getProtocolName(), ipPkg)) {
                        ifSvcEntry.setStatus(DbIpInterfaceEntry.STATE_REMOTE);
                    } else {
                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                    }
                }

                /*
                 * Set qualifier if available. Currently the qualifier field
                 * is used to store the port at which the protocol was found.
                 */
                if (p.getQualifiers() != null && p.getQualifiers().get("port") != null) {
                    try {
                        final Integer port = (Integer) p.getQualifiers().get("port");
                        LOG.debug("updateServiceInfo: got a port qualifier: {} for service: {}", port, p.getProtocolName());
                        ifSvcEntry.setQualifier(port.toString());
                    } catch (final ClassCastException ccE) {
                        // Do nothing
                    }
                }

                ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
                ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);

                if (ifIndex != -1) {
                    ifSvcEntry.setIfIndex(ifIndex);
                }

                ifSvcEntry.store();

                LOG.debug("updateIfServices: update service: {} for interface:{} on node:{}", p.getProtocolName(), ifaddrString, node.getNodeId());

                // Generate nodeGainedService event
                m_eventList.add(createNodeGainedServiceEvent(node, dbIpIfEntry, p.getProtocolName()));

                /*
                 * If this interface already existed in the database and SNMP
                 * service has been gained then create interfaceSupportsSNMP
                 * event
                 */
                if (!isNewIpEntry && p.getProtocolName().equalsIgnoreCase("SNMP")) {
                    m_eventList.add(createInterfaceSupportsSNMPEvent(dbIpIfEntry));
                }
            }
            // Update the supported services list
            dbSupportedServices = dbIpIfEntry.getServices(dbc);
        } // end while(more protocols)

        if (m_forceRescan) {
            updateServicesOnForcedRescan(node, dbIpIfEntry, dbSupportedServices);
        }
    }

