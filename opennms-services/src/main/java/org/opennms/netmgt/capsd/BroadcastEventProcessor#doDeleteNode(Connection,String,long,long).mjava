    /**
     * Mark as deleted the specified node, its associated interfaces and
     * services.
     * 
     * @param dbConn
     *            the connection to the database
     * @param source
     *            the source for any events to send
     * @param nodeid
     *            the nodeid to be deleted
     * @param txNo
     *            a transaction id to associate with this deletion
     * 
     * @return the list of events that need to be sent in response to the node
     *         being deleted
     * @throws SQLException
     *             if any exception occurs communicating with the database
     */
    private List<Event> doDeleteNode(Connection dbConn, String source, long nodeid, long txNo) throws SQLException {
        List<Event> eventsToSend = new LinkedList<Event>();
        eventsToSend.addAll(markInterfacesAndServicesDeleted(dbConn, source, nodeid, txNo));
        eventsToSend.addAll(markNodeDeleted(dbConn, source, nodeid, txNo));
        
        //Note: left this call to deleteAlarmsForNode because I wanted to indicate that alarms are now 
        //deleted by the DB with a delete cascade fk constraint on the alarm table
        //when the node is actually deleted.  We have to leave this in here for Capsd because
        //it only flags the node as deleted whereas the provisioner actually deletes the node.
        deleteAlarmsForNode(dbConn, nodeid);
        return eventsToSend;
    }

