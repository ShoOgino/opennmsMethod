    private InetAddress updatePrimarySnmpInterface(final Connection dbc, final DbNodeEntry dbNodeEntry, final Map<String, IfCollector> collectorMap, final InetAddress oldPriIf) throws SQLException {
        /*
         * Now that all interfaces have been added to the
         * database we can update the 'primarySnmpInterface'
         * field of the ipInterface table. Necessary because
         * the IP address must already be in the database
         * to evaluate against a filter rule.
         *
         * First create a list of eligible loopback interfaces
         * and a list of all eligible interfaces. Test in the
         * following order:
         * 
         * 1) strict = true (interface must be part of a Collectd
         * package) and loopback.
         * 
         * 2) strict = true and all eligible interfaces.
         * strict = false and loopback.
         * 
         * 4) strict = false and all eligible interfaces.
         */
        FilterDaoFactory.getInstance().flushActiveIpAddressListCache();
        final IfSnmpCollector snmpc = findSnmpCollector(collectorMap);
        final List<InetAddress> snmpLBAddresses = buildLBSnmpAddressList(collectorMap, snmpc);
        final List<InetAddress> snmpAddresses = buildSnmpAddressList(collectorMap, snmpc);

        // first set the value of issnmpprimary for secondaries
        for (final InetAddress addr : snmpAddresses) {
            final String addrString = str(addr);
            if (m_capsdDbSyncer.isServiceCollectionEnabled(addrString, "SNMP")) {
                final DBUtils d = new DBUtils(RescanProcessor.class);
                try {
                    final PreparedStatement stmt = dbc.prepareStatement("UPDATE ipInterface SET isSnmpPrimary='S' WHERE nodeId=? AND ipAddr=? AND isManaged!='D'");
                    d.watch(stmt);
                    stmt.setInt(1, dbNodeEntry.getNodeId());
                    stmt.setString(2, addrString);
                    stmt.executeUpdate();
                    LOG.debug("updatePrimarySnmpInterface: updated {} to secondary.", addrString);
                } finally {
                    d.cleanUp();
                }
            }
        }

        InetAddress newSnmpPrimaryIf = m_capsdDbSyncer.determinePrimarySnmpInterface(snmpLBAddresses, true);
        String psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " loopback addresses";

        if (newSnmpPrimaryIf == null) {
            newSnmpPrimaryIf = m_capsdDbSyncer.determinePrimarySnmpInterface(snmpAddresses, true);
            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " addresses";
        }

        if (newSnmpPrimaryIf == null) {
            newSnmpPrimaryIf = m_capsdDbSyncer.determinePrimarySnmpInterface(snmpLBAddresses, false);
            psiType = "DB loopback addresses";
        }

        if (newSnmpPrimaryIf == null) {
            newSnmpPrimaryIf = m_capsdDbSyncer.determinePrimarySnmpInterface(snmpAddresses, false);
            psiType = "DB addresses";
        }

        if (newSnmpPrimaryIf == null) {
            newSnmpPrimaryIf = snmpc.getCollectorTargetAddress();
            psiType = "SNMP collector target address";
        }

        if (newSnmpPrimaryIf != null) {
            LOG.debug("updatePrimarySnmpInterface: primary SNMP interface is: {}, selected from {}", newSnmpPrimaryIf, psiType);
            SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, oldPriIf);
        } else {
            LOG.debug("SuspectEventProcessor: Unable to determine a primary SNMP interface");
        }   

        /*
         * Now that we've identified the new primary SNMP
         * interface we can determine if it is necessary to
         * generate certain SNMP data collection related
         * events
         */
        generateSnmpDataCollectionEvents(dbNodeEntry, oldPriIf, newSnmpPrimaryIf);
        return newSnmpPrimaryIf;
    }

