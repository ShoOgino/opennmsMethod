    /**
     * The main collection routine of the class. This method is used to poll the
     * address, and any additional interfaces discovered via SNMP.
     */
    public void run() {
        if (log().isDebugEnabled()) {
            log().debug("IfCollector.run: run method invoked to collect information for address " + InetAddressUtils.str(m_target));
        }

        // Now go throught the successful plugin checks
        // and see if either SMB, MSExchange, or SNMP is
        // supported on the target node
        //
        boolean isSnmp = false;
        boolean isSnmpV2 = false;
        boolean isSmb = false;
        boolean hasExchange = false;

        probe(m_target, m_protocols);
        m_previouslyProbed.add(m_target);

        // First run the plugins to find out all the capabilities
        // for the interface
        //
        Iterator<SupportedProtocol> iter = m_protocols.iterator();
        while (iter.hasNext()) {
            SupportedProtocol proto = iter.next();
            if (proto.getProtocolName().equalsIgnoreCase("snmp")) {
                isSnmp = true;
            } else if (proto.getProtocolName().equalsIgnoreCase("smb")) {
                isSmb = true;
            } else if (proto.getProtocolName().equalsIgnoreCase("msexchange")) {
                isSmb = true;
                hasExchange = true;
            }
        }

        // collect the SMB information
        //
        if (isSmb) {
            log().debug("IfCollector.run: starting SMB collection");

            try {
                m_smbCollector = new IfSmbCollector(m_target, hasExchange);
                m_smbCollector.run();
            } catch (Throwable t) {
                m_smbCollector = null;
                log().warn("IfCollector.run: Caught an exception when collecting SMB information from target " + InetAddressUtils.str(m_target), t);
            }

            log().debug("IfCollector.run: SMB collection completed");
        }

        // collect the snmp information if necessary
        //
        if ((isSnmp || isSnmpV2) && m_doSnmpCollection) {
            log().debug("IfCollector.run: starting SNMP collection");

            try {
                m_snmpCollector = new IfSnmpCollector(m_target);
                m_snmpCollector.run();

                if (m_snmpCollector.hasIpAddrTable() && m_snmpCollector.hasIfTable()) {
                    m_subTargets = new TreeMap<InetAddress, List<SupportedProtocol>>(new InetAddressComparator());
                    m_nonIpInterfaces = new ArrayList<Integer>();

                    // Iterate over ifTable entries
                    //
                    for (IfTableEntry ifEntry : m_snmpCollector.getIfTable()) {

                        // Get the ifIndex
                        //
                        Integer ifIndex = ifEntry.getIfIndex();
                        if (ifIndex == null)
                            continue;

                        // Get list of all IP addresses for the current ifIndex
                        //
                        int index = ifIndex.intValue();
                        List<InetAddress> ipAddrs = m_snmpCollector.getIpAddrTable().getIpAddresses(index);
                        if (ipAddrs == null || ipAddrs.size() == 0) {
                            // Non IP interface
                            InetAddress nonIpAddr = null;
                            nonIpAddr = InetAddressUtils.addr("0.0.0.0");

                            if (ipAddrs == null) {
                                ipAddrs = new ArrayList<InetAddress>();
                            }
                            ipAddrs.add(nonIpAddr);
                        }

                        // Iterate over this interface's IP address list
                        //
                        Iterator<InetAddress> s = ipAddrs.iterator();
                        while (s.hasNext()) {
                            InetAddress subtarget = s.next();

                            // if the target failed to convert or if it
                            // is equal to the current target then skip it
                            //
                            if (subtarget == null || subtarget.equals(m_target) || m_previouslyProbed.contains(subtarget))
                                continue;

                            // now find the ifType
                            //
                            Integer ifType = ifEntry.getIfType();

                            // lookup of if type failed, next!
                            //
                            if (ifType == null)
                                continue;

                            // now check for loopback
                            if (subtarget.isLoopbackAddress()) {
                                // Skip if loopback
                                if (log().isDebugEnabled()) {
                                    log().debug("ifCollector.run: Loopback interface: " + InetAddressUtils.str(subtarget) + ", skipping...");
                                }
                                continue;
                            }

                            // now check for non-IP interface
                            //
                            if (InetAddressUtils.str(subtarget).equals("0.0.0.0")) {
                                // its a non-IP interface...add its ifIndex to
                                // the non-IP interface list
                                //
                                m_nonIpInterfaces.add(ifIndex);
                                continue;
                            }

                            // ok it appears to be ok, so probe it!
                            //
                            List<SupportedProtocol> probelist = new ArrayList<SupportedProtocol>();
                            if (log().isDebugEnabled()) {
                                log().debug("----------------------------------------------------------------------------------------");
                                log().debug("ifCollector.run: probing subtarget " + InetAddressUtils.str(subtarget));
                            }
                            probe(subtarget, probelist);
                            m_previouslyProbed.add(subtarget);

                            if (log().isDebugEnabled()) {
                                log().debug("ifCollector.run: adding subtarget " + InetAddressUtils.str(subtarget) + " # supported protocols: " + probelist.size());
                                log().debug("----------------------------------------------------------------------------------------");
                            }
                            m_subTargets.put(subtarget, probelist);
                        } // end while(more ip addresses)
                    } // end while(more interfaces)
                } // end if(ipAddrTable and ifTable entries collected)

                else if (m_snmpCollector.hasIpAddrTable()) {
                    m_subTargets = new TreeMap<InetAddress, List<SupportedProtocol>>(new InetAddressComparator());

                    List<InetAddress> ipAddrs = m_snmpCollector.getIpAddrTable().getIpAddresses();
                    // Iterate over this interface's IP address list
                    //
                    Iterator<InetAddress> s = ipAddrs.iterator();
                    while (s.hasNext()) {
                        InetAddress subtarget = s.next();

                        // if the target failed to convert or if it
                        // is equal to the current target then skip it
                        //
                        if (subtarget == null || subtarget.equals(m_target)) {
                            continue;
                        }

                        // now check for loopback
                        if (subtarget.isLoopbackAddress()) {
                            // Skip if loopback
                            if (log().isDebugEnabled()) {
                                log().debug("ifCollector.run: Loopback interface: " + InetAddressUtils.str(subtarget) + ", skipping...");
                            }
                            continue;
                        }


                        // ok it appears to be ok, so probe it!
                        //
                        List<SupportedProtocol> probelist = new ArrayList<SupportedProtocol>();
                        if (log().isDebugEnabled()) {
                            log().debug("----------------------------------------------------------------------------------------");
                            log().debug("ifCollector.run: probing subtarget " + InetAddressUtils.str(subtarget));
                        }
                        probe(subtarget, probelist);
                        m_previouslyProbed.add(subtarget);
                        
                        if (log().isDebugEnabled()) {
                            log().debug("ifCollector.run: adding subtarget " + InetAddressUtils.str(subtarget) + " # supported protocols: " + probelist.size());
                            log().debug("----------------------------------------------------------------------------------------");
                        }
                        m_subTargets.put(subtarget, probelist);
                    } // end while(more ip addresses)
                } // end if(ipAddrTable entries collected)
            } // end try()
            catch (Throwable t) {
                m_snmpCollector = null;
                log().warn("IfCollector.run: Caught an exception when collecting SNMP information from target " + InetAddressUtils.str(m_target), t);
            }

            log().debug("IfCollector.run: SNMP collection completed");
        } // end if(SNMP supported)

        if (log().isDebugEnabled()) {
            log().debug("IfCollector.run: run method exiting after collecting information from address " + InetAddressUtils.str(m_target));
        }
    }

