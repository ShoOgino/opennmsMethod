    /**
     * This method is responsble for inserting new entries into the
     * ipInterface table for each interface found to be associated with the
     * suspect interface during the capabilities scan.
     * 
     * @param dbc
     *            Database connection.
     * @param node
     *            DbNodeEntry object representing the suspect interface's
     *            parent node table entry
     * @param useExistingNode
     *            False if a new node was created for the suspect interface.
     *            True if an existing node entry was found under which the the
     *            suspect interface is to be added.
     * @param ifaddr
     *            Suspect interface
     * @param collector
     *            Interface collector containing SMB and SNMP info collected
     *            from the remote device.
     * @throws SQLException
     *             if an error occurs adding interfaces to the ipInterface
     *             table.
     */
    private void addInterfaces(Connection dbc, DbNodeEntry node,
            boolean useExistingNode, InetAddress ifaddr, IfCollector collector)
            throws SQLException {
        CapsdConfig cFactory = CapsdConfigFactory.getInstance();

        Date now = new Date();

        int nodeId = node.getNodeId();

        DbIpInterfaceEntry ipIfEntry = DbIpInterfaceEntry.create(nodeId,
                                                                 ifaddr);
        ipIfEntry.setLastPoll(now);
        ipIfEntry.setHostname(ifaddr.getHostName());

        /*
         * NOTE: (reference internal bug# 201) If the ip is 'managed', it
         * might still be 'not polled' based on the poller configuration The
         * package filter evaluation requires that the ip be in the database -
         * at this point the ip is NOT in db, so insert as active and update
         * afterward Try to avoid re-evaluating the ip against filters for
         * each service, try to get the first package here and use that for
         * service evaluation
         */
        boolean addrUnmanaged = cFactory.isAddressUnmanaged(ifaddr);
        if (addrUnmanaged) {
            log().debug("addInterfaces: " + ifaddr + " is unmanaged");
            ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
        } else {
            log().debug("addInterfaces: " + ifaddr + " is managed");
            ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);
        }

        ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

        ipIfEntry.store(dbc);

        // now update if necessary
        org.opennms.netmgt.config.poller.Package ipPkg =
            getPackageForNewInterface(dbc, ifaddr, ipIfEntry, addrUnmanaged);
        
        int ifIndex = addSnmpInterfaces(dbc, ifaddr, nodeId, collector,
                                        ipIfEntry);

        // Add supported protocols
        addSupportedProtocols(node, ifaddr,
                              collector.getSupportedProtocols(),
                              addrUnmanaged, ifIndex, ipPkg);

        /*
         * If the useExistingNode flag is true, then we're done. The interface
         * is most likely an alias and the subinterfaces collected via SNMP
         * should already be in the database.
         */
        if (useExistingNode == true) {
            return;
        }

        getSubInterfacesForNewInterface(dbc, node, ifaddr, collector, now,
                                        nodeId, ifIndex);
    }

