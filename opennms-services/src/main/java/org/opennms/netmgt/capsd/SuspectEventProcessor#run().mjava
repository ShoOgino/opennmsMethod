    /**
     * This is where all the work of the class is done.
     */
    @Override
    public void run() {

        // Convert interface InetAddress object
        //
        InetAddress ifaddr = null;
        ifaddr = addr(m_suspectIf);
        if (ifaddr == null) {
            log().warn(
                     "SuspectEventProcessor: Failed to convert interface address "
                             + m_suspectIf + " to InetAddress");
            return;
        }

        // collect the information
        //
        if (log().isDebugEnabled())
            log().debug("SuspectEventProcessor: running collection for "
                    + str(ifaddr));

        IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true);
        collector.run();

        // Track changes to primary SNMP interface
        InetAddress oldSnmpPrimaryIf = null;
        InetAddress newSnmpPrimaryIf = null;

        // Update the database
        //
        boolean updateCompleted = false;
        boolean useExistingNode = false;
        DbNodeEntry entryNode = null;
        try {
            // Synchronize on the Capsd sync lock so we can check if
            // the interface is already in the database and perform
            // the necessary inserts in one atomic operation
            //	
            // The RescanProcessor class is also synchronizing on this
            // lock prior to performing database inserts or updates.
            Connection dbc = null;
            synchronized (Capsd.getDbSyncLock()) {
                // Get database connection
                //
                try {
                    dbc = DataSourceFactory.getInstance().getConnection();

                    // Only add the node/interface to the database if
                    // it isn't already in the database
                    if (!m_capsdDbSyncer.isInterfaceInDB(dbc, ifaddr)) {
                        // Using the interface collector object determine
                        // if this interface belongs under a node already
                        // in the database.
                        //
                        entryNode = getExistingNodeEntry(dbc, collector);

                        if (entryNode == null) {
                            // Create a node entry for the new interface
                            //
                            entryNode = createNode(dbc, ifaddr, collector);
                        } else {
                            // Will use existing node entry
                            //
                            useExistingNode = true;
                        }

                        // Get old primary SNMP interface(s) (if one or more
                        // exists)
                        //
                        List<InetAddress> oldPriIfs = getPrimarySnmpInterfaceFromDb(dbc,
                                                                       entryNode);

                        // Add interfaces
                        //
                        addInterfaces(dbc, entryNode, useExistingNode,
                                      ifaddr, collector);

                        // Now that all interfaces have been added to the
                        // database we can update the 'primarySnmpInterface'
                        // field of the ipInterface table. Necessary because
                        // the IP address must already be in the database
                        // to evaluate against a filter rule.
                        //
                        // Determine primary SNMP interface from the lists of
                        // possible addresses
                        // in this order: loopback interfaces in
                        // collectd-configuration.xml,
                        // other interfaces in collectd-configuration.xml,
                        // loopback interfaces,
                        // other interfaces
                        //
                        boolean strict = true;
                        CollectdConfigFactory.getInstance().rebuildPackageIpListMap();
                        List<InetAddress> lbAddressList = buildLBSnmpAddressList(collector);
                        List<InetAddress> addressList = buildSnmpAddressList(collector);
                        // first set the value of issnmpprimary for
                        // secondaries
                        Iterator<InetAddress> iter = addressList.iterator();
                        while (iter.hasNext()) {
                            InetAddress addr = iter.next();
                            if (CollectdConfigFactory.getInstance().isServiceCollectionEnabled(str(addr), "SNMP")) {
                                final DBUtils d = new DBUtils(getClass());
                                try {
                                    PreparedStatement stmt = dbc.prepareStatement("UPDATE ipInterface SET isSnmpPrimary='S' WHERE nodeId=? AND ipAddr=? AND isManaged!='D'");
                                    d.watch(stmt);
                                    stmt.setInt(1, entryNode.getNodeId());
                                    stmt.setString(2, str(addr));

                                    stmt.executeUpdate();
                                    log().debug("updated " + str(addr) + " to secondary.");
                                } finally {
                                    d.cleanUp();
                                }
                            }
                        }
                        String psiType = null;
                        if (lbAddressList != null) {
                            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(lbAddressList, strict);
                            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " loopback addresses";
                        }
                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(addressList, strict);
                            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " addresses";
                        }
                        strict = false;
                        if ((newSnmpPrimaryIf == null) && (lbAddressList != null)) {
                            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(lbAddressList, strict);
                            psiType = "DB loopback addresses";
                        }
                        if (newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(addressList, strict);
                            psiType = "DB addresses";
                        }
                        if (collector.hasSnmpCollection() && newSnmpPrimaryIf == null) {
                            newSnmpPrimaryIf = ifaddr;
                            psiType = "New suspect ip address";
                        }

                        if (log().isDebugEnabled()) {
                            if (newSnmpPrimaryIf == null) {
                                log().debug("No primary SNMP interface found");
                            } else {
                                log().debug("primary SNMP interface is: "
                                        + newSnmpPrimaryIf
                                        + ", selected from " + psiType);
                            }
                        }
                        // iterate over list of old primaries. There should
                        // only be
                        // one or none, but in case there are more, this will
                        // clear
                        // out the extras.
                        Iterator<InetAddress> opiter = oldPriIfs.iterator();
                        if (opiter.hasNext()) {
                            while (opiter.hasNext()) {
                                setPrimarySnmpInterface(
                                                        dbc,
                                                        entryNode,
                                                        newSnmpPrimaryIf,
                                                        opiter.next());
                            }
                        } else {
                            setPrimarySnmpInterface(dbc, entryNode,
                                                    newSnmpPrimaryIf, null);
                        }
                        // Update
                        updateCompleted = true;
                    }
                } finally {
                    if (dbc != null) {
                        try {
                            dbc.close();
                        } catch (SQLException e) {
                            if (log().isInfoEnabled())
                                log().info(
                                         "run: an sql exception occured closing the database connection",
                                         e);
                        }
                    }
                    dbc = null;
                }
            }

        } // end try
        catch (Throwable t) {
            log().error("Error writing records", t);
        }
        finally {
        	// remove the interface we've just scanned from the tracker set
        	synchronized(m_queuedSuspectTracker) {
        		m_queuedSuspectTracker.remove(str(ifaddr));
        	}
        }

        // Send events
        //
        if (updateCompleted) {
            if (!useExistingNode)
                createAndSendNodeAddedEvent(entryNode);

            sendInterfaceEvents(entryNode, useExistingNode, ifaddr, collector);

            if (useExistingNode) {
                generateSnmpDataCollectionEvents(entryNode, oldSnmpPrimaryIf,
                                                 newSnmpPrimaryIf);
            }

        }

        // send suspectScanCompleted event regardless of scan outcome
    	if (log().isDebugEnabled()) {
    		log().debug("sendInterfaceEvents: sending suspect scan completed event for " + str(ifaddr));
    		log().debug("SuspectEventProcessor for " + m_suspectIf + " completed.");
    	}
    	createAndSendSuspectScanCompletedEvent(ifaddr);
    } // end run

