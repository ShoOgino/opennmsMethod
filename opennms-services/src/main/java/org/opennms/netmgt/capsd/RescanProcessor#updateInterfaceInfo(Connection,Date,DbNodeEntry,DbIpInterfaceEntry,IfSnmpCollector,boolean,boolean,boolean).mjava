    /**
     * This method is responsible for updating the ipinterface table entry for a
     * specific interface.
     * 
     * @param dbc
     *            Database Connection.
     * @param now
     *            Date/time to be associated with the update.
     * @param node
     *            Node entry for the node being rescanned.
     * @param dbIpIfEntry
     *            interface entry of the updating interface.
     * @param snmpc
     *            SNMP collector or null if SNMP not supported.
     * @param isNewIpEntry
     *            if dbIpIfEntry is a new entry.
     * @param isReparented
     *            if dbIpIfentry is reparented.
     * @param doesSnmp
     *            if node supports SNMP.
     * 
     * @throws SQLException
     *             if there is a problem updating the ipinterface table.
     */
    private void updateInterfaceInfo(Connection dbc, Date now, DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, IfSnmpCollector snmpc, boolean isNewIpEntry, boolean isReparented, boolean doesSnmp) throws SQLException {
        Category log = ThreadCategory.getInstance(getClass());

        CapsdConfig cFactory = CapsdConfigFactory.getInstance();
        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();

        DbIpInterfaceEntry currIpIfEntry;

        InetAddress ifaddr = dbIpIfEntry.getIfAddress();

        int ifIndex = -1;

        /*
         * Clone the existing database entry so we have access to the values
         * of the database fields associated with the interface in the event
         * that something has changed.
         */
        DbIpInterfaceEntry originalIpIfEntry = DbIpInterfaceEntry.clone(dbIpIfEntry);

        /*
         * Create IP interface entry representing latest information
         * retrieved for the interface via the collector
         */
        if (doesSnmp) {
            if (snmpc.hasIpAddrTable()) {
                ifIndex = snmpc.getIfIndex(ifaddr);
            }
            if (ifIndex == -1) {
                if (log.isDebugEnabled()) {
                    log.debug("updateInterfaceInfo: interface " + ifaddr.getHostAddress() + " has no valid ifIndex. Assume this is a lame SNMP host with no ipAddrTable");
                }
                ifIndex = CapsdConfigFactory.LAME_SNMP_HOST_IFINDEX;
            }
            currIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr, ifIndex);
        } else {
            currIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
        }

        // Hostname
        currIpIfEntry.setHostname(ifaddr.getHostName());

        /*
         * Managed state
         * NOTE: (reference internal bug# 201)
         * If the ip is 'managed', it might still be 'not polled' based
         * on the poller configuration.
         *
         * Try to avoid re-evaluating the ip against filters for
         * each service, try to get the first package here and use
         * that for service evaluation
         *
         * At this point IF the ip is already in the database, package filter
         * evaluation should go through OK. New interfaces will be dealt with
         * later
         */
        org.opennms.netmgt.config.poller.Package ipPkg = null;

        if (cFactory.isAddressUnmanaged(ifaddr)) {
            currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
        } else {
            boolean ipToBePolled = false;
            ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
            if (ipPkg != null) {
                ipToBePolled = true;
            }

            if (ipToBePolled) {
                currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);
            } else {
                currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
            }

            if (log.isDebugEnabled()) {
                log.debug("updateInterfaceInfo: interface " + ifaddr.getHostAddress() + " to be polled = " + ipToBePolled);
            }
        }

        /*
         * If SNMP data collection is available set SNMP Primary state
         * as well as ifIndex and ifStatus.
         *
         * For all interfaces simply set 'isSnmpPrimary' field to
         * not eligible for now. Following the interface updates
         * the primary and secondary SNMP interfaces will be
         * determined and the value of the 'isSnmpPrimary' field
         * set accordingly for each interface. The old primary
         * interface should have already been saved for future
         * reference.
         */
        if (doesSnmp && snmpc != null && snmpc.hasIpAddrTable()) {
            if (ifIndex != -1) {
                if (snmpc.hasIfTable()) {
                    int status = snmpc.getAdminStatus(ifIndex);
                    currIpIfEntry.setStatus(status);
                }
            } else {
                // No ifIndex found
                log.debug("updateInterfaceInfo:  No ifIndex found for " + ifaddr.getHostAddress() + ". Not eligible for primary SNMP interface");
            }
            currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
        } else if (doesSnmp) {
            currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
        }

        // Update any fields which have changed
        dbIpIfEntry.setLastPoll(now);
        dbIpIfEntry.updateHostname(currIpIfEntry.getHostname());
        dbIpIfEntry.updateManagedState(currIpIfEntry.getManagedState());
        dbIpIfEntry.updateStatus(currIpIfEntry.getStatus());
        dbIpIfEntry.updatePrimaryState(currIpIfEntry.getPrimaryState());
        dbIpIfEntry.updateIfIndex(currIpIfEntry.getIfIndex());

        /*
         * Set event flags
         * NOTE: Must set these flags prior to call to
         * DbIpInterfaceEntry.store()
         * method which will cause the change map to be cleared.
         */
        boolean ifIndexChangedFlag = false;
        boolean ipHostnameChangedFlag = false;

        if (dbIpIfEntry.hasIfIndexChanged()) {
            ifIndexChangedFlag = true;
        }

        if (dbIpIfEntry.hasHostnameChanged()) {
            ipHostnameChangedFlag = true;
        }

        // Update the database
        dbIpIfEntry.store(dbc);

        /*
         * If the interface was not already in the database under
         * the node being rescanned or some other node send a
         * nodeGainedInterface event.
         */
        if (isNewIpEntry && !isReparented) {
            createNodeGainedInterfaceEvent(dbIpIfEntry);
        }

        // InterfaceIndexChanged event
        if (log.isDebugEnabled()) {
            log.debug("updateInterfaceInfo: ifIndex changed: " + ifIndexChangedFlag);
        }
        if (ifIndexChangedFlag) {
            createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);
            m_ifIndexOnNodeChangedFlag = true;
        }

        // IPHostNameChanged event
        if (log.isDebugEnabled()) {
            log.debug("updateInterfaceInfo: hostname changed: " + ipHostnameChangedFlag);
        }
        if (ipHostnameChangedFlag) {
            createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);
        }
        if (isNewIpEntry) {
            /*
             * If it's new, the packageIpListMap needs to be rebuilt,
             * polling status rechecked, and ismanaged updated if necessary
             */
            boolean ipToBePolled = false;
            log.debug("updateInterfaceInfo: rebuilding PackageIpListMap for new interface " + ifaddr.getHostAddress());
            PollerConfigFactory.getInstance().rebuildPackageIpListMap();
            ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
            if (ipPkg != null) {
                ipToBePolled = true;
            }
            log.debug("updateInterfaceInfo: interface " + ifaddr.getHostAddress() + " to be polled: " + ipToBePolled);
            if (ipToBePolled) {
                PreparedStatement stmt = dbc.prepareStatement(SQL_DB_UPDATE_ISMANAGED);
                stmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_MANAGED }));
                stmt.setInt(2, dbIpIfEntry.getNodeId());
                stmt.setString(3, ifaddr.getHostAddress());
                try {
                    stmt.executeUpdate();
                    log.debug("updateInterfaceInfo: updated managed state for new interface " + ifaddr.getHostAddress() + " on node " + dbIpIfEntry.getNodeId() + " to managed");
                } catch (SQLException sqlE) {
                    throw sqlE;
                } finally {
                    try {
                        stmt.close();
                    } catch (Exception e) {
                        // Ignore
                    }
                }
            }
        }
    }

