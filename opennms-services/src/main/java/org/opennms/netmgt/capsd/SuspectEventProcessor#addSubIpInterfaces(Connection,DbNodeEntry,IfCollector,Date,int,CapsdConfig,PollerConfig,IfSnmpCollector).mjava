    private void addSubIpInterfaces(Connection dbc, DbNodeEntry node,
            IfCollector collector, Date now, int nodeId, CapsdConfig cFactory,
            PollerConfig pollerCfgFactory, IfSnmpCollector snmpc) throws SQLException {
        
        if (!snmpc.hasIpAddrTable()) {
            return;
        }
        
        Map<InetAddress, List<SupportedProtocol>> extraTargets = collector.getAdditionalTargets();
        for(InetAddress xifaddr : extraTargets.keySet()) {

            if (log().isDebugEnabled()) {
                log().debug("addInterfaces: adding interface "
                        + xifaddr.getHostAddress());
            }

            DbIpInterfaceEntry xipIfEntry = DbIpInterfaceEntry.create(nodeId,
                                                                      xifaddr);
            xipIfEntry.setLastPoll(now);
            xipIfEntry.setHostname(xifaddr.getHostName());

            /*
             * NOTE: (reference internal bug# 201) If the ip is 'managed', it
             * might still be 'not polled' based on the poller configuration.
             * The package filter evaluation requires that the ip be in the
             * database - at this point the ip is NOT in db, so insert as
             * active and update afterward. Try to avoid re-evaluating the ip
             * against filters for each service, try to get the first package
             * here and use that for service evaluation.
             */
            boolean xaddrUnmanaged = cFactory.isAddressUnmanaged(xifaddr);
            if (xaddrUnmanaged) {
                xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
            } else {
                xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);
            }

            /*
             * Just set primary state to not eligible for now. The primary
             * SNMP interface won't be selected until after all interfaces
             * have been inserted into the database. This is because the
             * interface must already be in the database for filter rule
             * evaluation to succeed.
             */
            xipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
            int xifIndex = -1;
            if ((xifIndex = snmpc.getIfIndex(xifaddr)) != -1) {
                /*
                 * XXX I'm not sure if it is always safe to call setIfIndex
                 * here.  We should only do it if an snmpInterface entry
                 * was previously created for this ifIndex.  It was likely done
                 * by addSnmpInterfaces, but I have't checked to make sure that
                 * all cases are covered. - dj@opennms.org 
                 */
                xipIfEntry.setIfIndex(xifIndex);
                int status = snmpc.getAdminStatus(xifIndex);
                if (status != -1) {
                    xipIfEntry.setStatus(status);
                }

                if (!supportsSnmp(extraTargets.get(xifaddr))) {
                    log().debug("addInterfaces: Interface doesn't support SNMP. "
                            + xifaddr.getHostAddress()
                            + " set to not eligible");
                }
            } else {
                /*
                 * No ifIndex found so set primary state to NOT_ELIGIBLE
                 */
                log().debug("addInterfaces: No ifIndex found. "
                        + xifaddr.getHostAddress() + " set to not eligible");
            }

            xipIfEntry.store(dbc);

            // now update if necessary
            org.opennms.netmgt.config.poller.Package xipPkg = null;
            if (!xaddrUnmanaged) {
                // The newly discoveried IP addr is not in the Package
                // IPList
                // Mapping yet, so rebuild the list.
                //
                PollerConfigFactory.getInstance().rebuildPackageIpListMap();

                boolean xipToBePolled = false;
                xipPkg = pollerCfgFactory.getFirstPackageMatch(xifaddr.getHostAddress());
                if (xipPkg != null) {
                    xipToBePolled = true;
                }

                if (!xipToBePolled) {
                    // update ismanaged to 'N' in ipinterface
                    xipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
                    xipIfEntry.store(dbc);
                }
            }

            // add the supported protocols
            addSupportedProtocols(node, xifaddr,
                                  extraTargets.get(xifaddr),
                                  xaddrUnmanaged, xifIndex, xipPkg);
        }
    }

