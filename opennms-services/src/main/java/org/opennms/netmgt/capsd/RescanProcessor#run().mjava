    /**
     * This is where all the work of the class is done.
     */
    public void run() {
        // perform rescan of the node
        DbNodeEntry dbNodeEntry = getNode();
        
        if (dbNodeEntry == null) {
            return;
        }
        
        if (dbNodeEntry.getForeignSource() != null) {
            log().info("Skipping rescan of node "+getNodeId()+" since it was imported with foreign source "+dbNodeEntry.getForeignSource());
            return;
        }
        
        if (log().isDebugEnabled()) {
            log().debug("start rescanning node: " + getNodeId());
        }

        DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);
        
        if (dbInterfaces == null) {
            log().debug("no interfaces found in the database to rescan for node: "
                      + getNodeId());
            return;
        }

        // this indicates whether or not we found an iface the responds to snmp
        boolean doesSnmp = true;
        
        IpAddrTable ipAddTable = null;
        List<InetAddress> prevAddrList = null;
        boolean snmpcAgree = false;
        boolean gotSnmpc = false;
        Map<String, IfCollector> collectorMap =
            new HashMap<String, IfCollector>();
        Map<String, IfCollector> nonSnmpCollectorMap =
            new HashMap<String, IfCollector>();
        Set<InetAddress> probedAddrs = new HashSet<InetAddress>();

        boolean gotSnmpCollection = false;
        DbIpInterfaceEntry oldPrimarySnmpInterface =
            DbNodeEntry.getPrimarySnmpInterface(dbInterfaces);
        if (oldPrimarySnmpInterface != null) {
            gotSnmpCollection =
                scanPrimarySnmpInterface(oldPrimarySnmpInterface, collectorMap,
                                         probedAddrs);
        }

        if (!gotSnmpCollection) {
            /*
             * Run collector for each retrieved interface and add result
             * to a collector map.
             */
            for (int i = 0; i < dbInterfaces.length; i++) {
                log().info("run: Running collector for interface "+i+" of "+dbInterfaces.length);
                InetAddress ifaddr = dbInterfaces[i].getIfAddress();

                /*
                 * collect the information from the interface.
                 * NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
                 */
                if (!scannableInterface(dbInterfaces, ifaddr)) {
                    log().debug("run: skipping scan of address: "+ifaddr.getHostAddress());
                    continue;
                }

                if (log().isDebugEnabled()) {
                    log().debug("running collection for " + ifaddr.getHostAddress());
                }

                IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true, probedAddrs);
                collector.run();

                IfSnmpCollector snmpc = collector.getSnmpCollector();
                if (snmpc != null) {
                    gotSnmpc = true;
                }
                if (snmpc != null && snmpc.hasIpAddrTable()
                        && snmpc.getIfIndex(snmpc.getCollectorTargetAddress()) != -1) {
                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        gotSnmpCollection = true;
                        if (log().isDebugEnabled()) {
                            log().debug("SNMP data collected via "
                                      + ifaddr.getHostAddress());
                            log().debug("Adding " + ifaddr.getHostAddress()
                                      + " to collectorMap for node: "
                                      + getNodeId());
                        }
                        snmpcAgree = false;
                        break;
                    } else if (ipAddTable == null) {
                        snmpcAgree = true;
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        ipAddTable = snmpc.getIpAddrTable();
                        prevAddrList = ipAddTable.getIpAddresses();

                        if (log().isDebugEnabled()) {
                            log().debug("SNMP data collected via "
                                      + ifaddr.getHostAddress()
                                      + " does not agree with database.  "
                                      + "Tentatively adding to the "
                                      + "collectorMap and continuing");
                            for(InetAddress a : prevAddrList) {
                                log().debug("IP address in list = " + a);
                            }
                        }
                    } else if (ipAddTable != null && snmpcAgree == true) {
                        ipAddTable = snmpc.getIpAddrTable();
                        List<InetAddress> addrList = ipAddTable.getIpAddresses();

                        boolean listMatch = true;
                        String jstring = null;
                        String kstring = null;
                        Iterator<InetAddress> j = prevAddrList.iterator();
                        Iterator<InetAddress> k = addrList.iterator();
                        while (j.hasNext()) {
                            jstring = j.next().toString();
                            if (k.hasNext()) {
                                kstring = k.next().toString();
                                if (jstring.equals(kstring)) {
                                    if (log().isDebugEnabled()) {
                                        log().debug(jstring + " = " + kstring);
                                    }
                                } else {
                                    if (log().isDebugEnabled()) {
                                        log().debug(jstring + " != " + kstring);
                                    }
                                    listMatch = false;
                                }
                            } else {
                                listMatch = false;
                            }
                        }
                        if (k.hasNext()) {
                            listMatch = false;
                        }
                        if (listMatch) {
                            log().debug("Current and previous address lists match");
                        } else {
                            log().debug("Current and previous address lists "
                                      + "DO NOT match");
                            snmpcAgree = false;
                        }
                        collector.deleteSnmpCollector();
                    }
                    if (snmpcAgree == false) {
                        if (log().isDebugEnabled()) {
                            log().debug("SNMP data collected via "
                                      + ifaddr.getHostAddress()
                                      + " does not agree with database or with "
                                      + "other interface(s) on this node.");
                        }
                    }
                } else {
                    /*
                     * Build a non-SNMP collectorMap, skipping 127.*.*.*
                     * and 0.0.0.0
                     */
                    nonSnmpCollectorMap.put(ifaddr.getHostAddress(), collector);
                    if (log().isDebugEnabled()) {
                        log().debug("Adding " + ifaddr.getHostAddress()
                                  + " to nonSnmpCollectorMap for node: "
                                  + getNodeId());
                    }
                }
            }
        }

        if (!gotSnmpCollection && snmpcAgree == false) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, and
             * multiple interface collections don't agree with each other.
             * First check for lame SNMP host, otherwise use the
             * nonSnmpCollectorMap and set doesSnmp = false
             */
            collectorMap = nonSnmpCollectorMap;
            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {
                doesSnmp = true;
                if (log().isDebugEnabled()) {
                    log().debug("node " + getNodeId()
                              + " appears to be a lame SNMP host... "
                              + "Proceeding");
                }
            } else {
                doesSnmp = false;
                if (log().isDebugEnabled()) {
                    if (gotSnmpc == false) {
                        log().debug("Could not collect SNMP data for node: "
                                  + getNodeId());
                    } else {
                        log().debug("Not using SNMP data for node: "
                                  + getNodeId() + ".  "
                                  + "Collection does not agree with database.");
                    }
                }
            }
        } else if (snmpcAgree == true) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, but
             * all collections we DID get agree with each other.
             * May want to create an event here
             */
            if (log().isDebugEnabled()) {
                log().debug("SNMP collection for node: "
                          + getNodeId()
                          + " does not agree with database, but there is no "
                          + "conflict among the interfaces on this node which "
                          + "respond to SNMP. Proceeding...");
            }
            createSnmpConflictsWithDbEvent(dbNodeEntry);
        }

        // Update the database
        Date now = null;
        Connection dbc = null;
        boolean updateCompleted = false;
        try {
            /*
             * Synchronize on the Capsd sync lock so we can check if
             * the interface is already in the database and perform
             * the necessary inserts in one atomic operation
             *	
             * The SuspectEventProcessor class is also synchronizing on this
             * lock prior to performing database inserts or updates.
             */
            log().debug("Waiting for capsd dbLock to process "
                      + getNodeId());
            synchronized (Capsd.getDbSyncLock()) {
                log().debug("Got capsd dbLock. processing "
                          + getNodeId());
                // Get database connection
                dbc = DataSourceFactory.getInstance().getConnection();

                /*
                 * There is a slight possibility that the node being rescanned
                 * has been deleted (due to reparenting) by another thread
                 * between the time this rescan was started and the database
                 * sync lock was grabbed. Verify that the current nodeid is
                 * still valid (ie, not deleted) before continuing.
                 */
                if (!isNodeDeleted(dbc, getNodeId())) {
                    // Update interface information
                    now = new Date();
                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap,
                                     doesSnmp);
                    
                    if (doesSnmp) {
                        InetAddress oldPriIf = null;
                        if (oldPrimarySnmpInterface != null) {
                            oldPriIf = oldPrimarySnmpInterface.getIfAddress();
                        }
                        InetAddress newSnmpPrimaryIf =
                            updatePrimarySnmpInterface(dbc, dbNodeEntry,
                                                       collectorMap, oldPriIf);

                            updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf,
                                       dbInterfaces, collectorMap);
                    }
                    updateCompleted = true;
                    createRescanCompletedEvent(dbNodeEntry);
                }
            }
        } catch (Throwable t) {
            log().error("Error updating records for node ID " + getNodeId() + ": " + t, t);
        } finally {
            // Finished with the database connection, close it.
            try {
                if (dbc != null) {
                    dbc.close();
                }
            } catch (SQLException e) {
                log().error("Error closing connection: " + e, e);
            }
            
            // Remove the node we just scanned from the tracker set
            synchronized (m_queuedRescanTracker) {
                m_queuedRescanTracker.remove(getNodeId());
            }
        }

        // Send events associcatd with the rescan
        if (updateCompleted) {
            // Send all events created during rescan process to eventd
            for (Event event : m_eventList) {
                try {
                    EventIpcManagerFactory.getIpcManager().sendNow(event);
                } catch (Throwable t) {
                    log().warn("run: unexpected throwable exception caught "
                             + "while sending event: " + t, t);
                }
            }
        }

        if (log().isDebugEnabled()) {
            log().debug((m_forceRescan ? "Forced r" : "R") + "escan "
                      + "for node w/ nodeid " + getNodeId()
                      + " completed.");
        }
    }

