    /**
     * This is where all the work of the class is done.
     */
    @Override
    public void run() {
        // perform rescan of the node
        final DbNodeEntry dbNodeEntry = getNode();

        if (dbNodeEntry == null) {
            return;
        }

        if (dbNodeEntry.getForeignSource() != null) {
            LOG.info("Skipping rescan of node {} since it was imported with foreign source {}", getNodeId(), dbNodeEntry.getForeignSource());
            return;
        }

        LOG.debug("start rescanning node: {}", getNodeId());

        final DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);

        if (dbInterfaces == null) {
            LOG.debug("no interfaces found in the database to rescan for node: {}", getNodeId());
            return;
        }

        // this indicates whether or not we found an iface the responds to snmp
        boolean doesSnmp = true;

        IpAddrTable ipAddTable = null;
        List<InetAddress> prevAddrList = null;
        boolean snmpcAgree = false;
        boolean gotSnmpc = false;
        Map<String, IfCollector> collectorMap = new HashMap<String, IfCollector>();
        final Map<String, IfCollector> nonSnmpCollectorMap = new HashMap<String, IfCollector>();
        final Set<InetAddress> probedAddrs = new HashSet<InetAddress>();

        boolean gotSnmpCollection = false;
        final DbIpInterfaceEntry oldPrimarySnmpInterface = DbNodeEntry.getPrimarySnmpInterface(dbInterfaces);
        if (oldPrimarySnmpInterface != null) {
            gotSnmpCollection = scanPrimarySnmpInterface(oldPrimarySnmpInterface, collectorMap, probedAddrs);
        }

        if (!gotSnmpCollection) {
            /*
             * Run collector for each retrieved interface and add result
             * to a collector map.
             */
            for (int i = 0; i < dbInterfaces.length; i++) {
                LOG.info("run: Running collector for interface {} of {}", i, dbInterfaces.length);
                final InetAddress ifaddr = dbInterfaces[i].getIfAddress();
                final String ifaddrString = str(ifaddr);

                /*
                 * collect the information from the interface.
                 * NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
                 */
                if (!scannableInterface(dbInterfaces, ifaddr)) {
                    LOG.debug("run: skipping scan of address: {}", ifaddrString);
                    continue;
                }

                if (ifaddrString == null) {
                    LOG.debug("run: unable to scan inet address: {}", ifaddr);
                    continue;
                }

                LOG.debug("running collection for {}", ifaddrString);

                final IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true, probedAddrs);
                collector.run();

                final IfSnmpCollector snmpc = collector.getSnmpCollector();
                if (snmpc != null) {
                    gotSnmpc = true;
                }
                if (snmpc != null && snmpc.hasIpAddrTable() && snmpc.getIfIndex(snmpc.getCollectorTargetAddress()) != -1) {
                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {
                        collectorMap.put(ifaddrString, collector);
                        gotSnmpCollection = true;
                        LOG.debug("SNMP data collected via {}", ifaddrString);
                        LOG.debug("Adding {} to collectorMap for node: {}", ifaddrString, getNodeId());
                        snmpcAgree = false;
                        break;
                    } else if (ipAddTable == null) {
                        snmpcAgree = true;
                        collectorMap.put(ifaddrString, collector);
                        ipAddTable = snmpc.getIpAddrTable();
                        prevAddrList = ipAddTable.getIpAddresses();

                        if (LOG.isDebugEnabled()) {
                            LOG.debug("SNMP data collected via {} does not agree with database.  Tentatively adding to the collectorMap and continuing", ifaddrString);
                            for(final InetAddress a : prevAddrList) {
                                LOG.debug("IP address in list = {}", a);
                            }
                        }
                    } else if (ipAddTable != null && snmpcAgree == true) {
                        ipAddTable = snmpc.getIpAddrTable();
                        final List<InetAddress> addrList = ipAddTable.getIpAddresses();

                        boolean listMatch = addrList.size() == prevAddrList.size() && addrList.containsAll(prevAddrList);
                        if (listMatch) {
                            LOG.debug("Current and previous address lists match");
                        } else {
                            LOG.debug("Current and previous address lists DO NOT match");
                            snmpcAgree = false;
                        }
                        collector.deleteSnmpCollector();
                    }
                    if (snmpcAgree == false) {
                        LOG.debug("SNMP data collected via {} does not agree with database or with other interface(s) on this node.", ifaddrString);
                    }
                } else {
                    /*
                     * Build a non-SNMP collectorMap, skipping 127.*.*.*
                     * and 0.0.0.0
                     */
                    nonSnmpCollectorMap.put(ifaddrString, collector);
                    LOG.debug("Adding {} to nonSnmpCollectorMap for node: {}", ifaddrString, getNodeId());
                }
            }
        }

        if (!gotSnmpCollection && snmpcAgree == false) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, and
             * multiple interface collections don't agree with each other.
             * First check for lame SNMP host, otherwise use the
             * nonSnmpCollectorMap and set doesSnmp = false
             */
            collectorMap = nonSnmpCollectorMap;
            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {
                doesSnmp = true;
                LOG.debug("node {} appears to be a lame SNMP host... Proceeding", getNodeId());
            } else {
                doesSnmp = false;
                if (LOG.isDebugEnabled()) {
                    if (gotSnmpc == false) {
                        LOG.debug("Could not collect SNMP data for node: {}", getNodeId());
                    } else {
                        LOG.debug("Not using SNMP data for node: {}.  Collection does not agree with database.", getNodeId());
                    }
                }
            }
        } else if (snmpcAgree == true) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, but
             * all collections we DID get agree with each other.
             * May want to create an event here
             */
            LOG.debug("SNMP collection for node: {} does not agree with database, but there is no conflict among the interfaces on this node which respond to SNMP. Proceeding...", getNodeId());
            m_eventList.add(createSnmpConflictsWithDbEvent(dbNodeEntry));
        }

        final DBUtils d = new DBUtils();

        // Update the database
        boolean updateCompleted = false;
        try {
            /*
             * Synchronize on the Capsd sync lock so we can check if
             * the interface is already in the database and perform
             * the necessary inserts in one atomic operation
             *	
             * The SuspectEventProcessor class is also synchronizing on this
             * lock prior to performing database inserts or updates.
             */
            LOG.debug("Waiting for capsd dbLock to process {}", getNodeId());
            synchronized (Capsd.getDbSyncLock()) {
                LOG.debug("Got capsd dbLock. processing {}", getNodeId());
                // Get database connection
                final Connection dbc = DataSourceFactory.getInstance().getConnection();
                d.watch(dbc);

                /*
                 * There is a slight possibility that the node being rescanned
                 * has been deleted (due to reparenting) by another thread
                 * between the time this rescan was started and the database
                 * sync lock was grabbed. Verify that the current nodeid is
                 * still valid (ie, not deleted) before continuing.
                 */
                if (!isNodeDeleted(dbc, getNodeId())) {
                    // Update interface information
                    final Date now = new Date();
                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap, doesSnmp);

                    if (doesSnmp) {
                        InetAddress oldPriIf = null;
                        if (oldPrimarySnmpInterface != null) {
                            oldPriIf = oldPrimarySnmpInterface.getIfAddress();
                        }
                        final InetAddress newSnmpPrimaryIf = updatePrimarySnmpInterface(dbc, dbNodeEntry, collectorMap, oldPriIf);
                        updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf, dbInterfaces, collectorMap);
                    }
                    updateCompleted = true;
                    m_eventList.add(createRescanCompletedEvent(dbNodeEntry));
                }
            }
        } catch (final Throwable t) {
            LOG.error("Error updating records for node ID {}", getNodeId(), t);
        } finally {
            // Finished with the database connection, close it.
            d.cleanUp();

            // Remove the node we just scanned from the tracker set
            synchronized (s_queuedRescanTracker) {
                s_queuedRescanTracker.remove(getNodeId());
            }
        }

        // Send events associcatd with the rescan
        if (updateCompleted) {
            // Send all events created during rescan process to eventd
            for (final Event event : m_eventList) {
                try {
                    EventIpcManagerFactory.getIpcManager().sendNow(event);
                } catch (final Throwable t) {
                    LOG.warn("run: unexpected throwable exception caught while sending event", t);
                }
            }
        }

        LOG.debug("{}escan for node w/ nodeid {} completed.", (m_forceRescan ? "Forced r" : "R"), getNodeId());
    }

