    /**
     * This is where all the work of the class is done.
     */
    public void run() {
        Category log = ThreadCategory.getInstance(RescanProcessor.class);

        // perform rescan of the node
        DbNodeEntry dbNodeEntry = getNode();
        
        if (dbNodeEntry == null) {
            return;
        }
        
        if (dbNodeEntry.getForeignSource() != null) {
            log.info("Skipping rescan of node "+m_scheduledNode.getNodeId()+" since it was imported with foreign source "+dbNodeEntry.getForeignSource());
            return;
        }
        
        if (log.isDebugEnabled()) {
            log.debug("start rescanning node: " + m_scheduledNode.getNodeId());
        }

        DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);
        
        if (dbInterfaces == null) {
            log.debug("no interfaces found in the database to rescan for node: "
                      + m_scheduledNode.getNodeId());
            return;
        }

        // this indicates whether or not we found an iface the responds to snmp
        boolean doesSnmp = true;
        
        IfSnmpCollector prevSnmpc = null;
        IpAddrTable ipAddTable = null;
        List prevAddrList = null;
        boolean snmpcAgree = false;
        boolean gotSnmpc = false;
        Map<String, IfCollector> collectorMap =
            new HashMap<String, IfCollector>();
        Map<String, IfCollector> nonSnmpCollectorMap =
            new HashMap<String, IfCollector>();
        Set probedAddrs = new HashSet();

        boolean gotSnmpCollection = false;
        DbIpInterfaceEntry oldPrimarySnmpInterface =
            DbNodeEntry.getPrimarySnmpInterface(dbInterfaces);
        if (oldPrimarySnmpInterface != null) {
            gotSnmpCollection =
                scanPrimarySnmpInterface(log, oldPrimarySnmpInterface,
                                         collectorMap, probedAddrs);
        }

        if (!gotSnmpCollection) {
            /*
             * Run collector for each retrieved interface and add result
             * to a collector map.
             */
            for (int i = 0; i < dbInterfaces.length; i++) {
                InetAddress ifaddr = dbInterfaces[i].getIfAddress();

                /*
                 * collect the information from the interface.
                 * NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
                 */
                if (ifaddr.getHostAddress().startsWith("127")
                        || ifaddr.getHostAddress().equals("0.0.0.0")) {
                    continue;
                }

                if (log.isDebugEnabled()) {
                    log.debug("running collection for "
                              + ifaddr.getHostAddress());
                }

                IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true,
                                                        probedAddrs);
                collector.run();

                IfSnmpCollector snmpc = collector.getSnmpCollector();
                if (snmpc != null) {
                    gotSnmpc = true;
                }
                if (snmpc != null && snmpc.hasIpAddrTable()
                        && snmpc.getIfIndex(snmpc.getCollectorTargetAddress()) != -1) {
                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        gotSnmpCollection = true;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via "
                                      + ifaddr.getHostAddress());
                            log.debug("Adding " + ifaddr.getHostAddress()
                                      + " to collectorMap for node: "
                                      + m_scheduledNode.getNodeId());
                        }
                        snmpcAgree = false;
                        break;
                    } else if (ipAddTable == null) {
                        snmpcAgree = true;
                        collectorMap.put(ifaddr.getHostAddress(), collector);
                        ipAddTable = snmpc.getIpAddrTable();
                        prevAddrList =
                            IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        prevSnmpc = snmpc;
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via "
                                      + ifaddr.getHostAddress()
                                      + " does not agree with database.  "
                                      + "Tentatively adding to the "
                                      + "collectorMap and continuing");
                            Iterator h = prevAddrList.iterator();
                            while (h.hasNext()) {
                                log.debug("IP address in list = " + h.next());
                            }
                        }
                    } else if (ipAddTable != null && snmpcAgree == true) {
                        ipAddTable = snmpc.getIpAddrTable();
                        List addrList =
                            IpAddrTable.getIpAddresses(ipAddTable.getEntries());
                        boolean listMatch = true;
                        String jstring = null;
                        String kstring = null;
                        Iterator j = prevAddrList.iterator();
                        Iterator k = addrList.iterator();
                        while (j.hasNext()) {
                            jstring = j.next().toString();
                            if (k.hasNext()) {
                                kstring = k.next().toString();
                                if (jstring.equals(kstring)) {
                                    if (log.isDebugEnabled()) {
                                        log.debug(jstring + " = " + kstring);
                                    }
                                } else {
                                    if (log.isDebugEnabled()) {
                                        log.debug(jstring + " != " + kstring);
                                    }
                                    listMatch = false;
                                }
                            } else {
                                listMatch = false;
                            }
                        }
                        if (k.hasNext()) {
                            listMatch = false;
                        }
                        if (listMatch) {
                            log.debug("Current and previous address lists match");
                        } else {
                            log.debug("Current and previous address lists "
                                      + "DO NOT match");
                            snmpcAgree = false;
                        }
                        collector.deleteSnmpCollector();
                    }
                    if (snmpcAgree == false) {
                        if (log.isDebugEnabled()) {
                            log.debug("SNMP data collected via "
                                      + ifaddr.getHostAddress()
                                      + " does not agree with database or with "
                                      + "other interface(s) on this node.");
                        }
                    }
                } else {
                    /*
                     * Build a non-SNMP collectorMap, skipping 127.*.*.*
                     * and 0.0.0.0
                     */
                    nonSnmpCollectorMap.put(ifaddr.getHostAddress(), collector);
                    if (log.isDebugEnabled()) {
                        log.debug("Adding " + ifaddr.getHostAddress()
                                  + " to nonSnmpCollectorMap for node: "
                                  + m_scheduledNode.getNodeId());
                    }
                }
            }
        }

        if (!gotSnmpCollection && snmpcAgree == false) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, and
             * multiple interface collections don't agree with each other.
             * First check for lame SNMP host, otherwise use the
             * nonSnmpCollectorMap and set doesSnmp = false
             */
            collectorMap = nonSnmpCollectorMap;
            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {
                doesSnmp = true;
                if (log.isDebugEnabled()) {
                    log.debug("node " + m_scheduledNode.getNodeId()
                              + " appears to be a lame SNMP host... "
                              + "Proceeding");
                }
            } else {
                doesSnmp = false;
                if (log.isDebugEnabled()) {
                    if (gotSnmpc == false) {
                        log.debug("Could not collect SNMP data for node: "
                                  + m_scheduledNode.getNodeId());
                    } else {
                        log.debug("Not using SNMP data for node: "
                                  + m_scheduledNode.getNodeId() + ".  "
                                  + "Collection does not agree with database.");
                    }
                }
            }
        } else if (snmpcAgree == true) {
            /*
             * We didn't get a collection from a primary snmp interface,
             * and we didn't get a collection that agrees with the db, but
             * all collections we DID get agree with each other.
             * May want to create an event here
             */
            if (log.isDebugEnabled()) {
                log.debug("SNMP collection for node: "
                          + m_scheduledNode.getNodeId()
                          + " does not agree with database, but there is no "
                          + "conflict among the interfaces on this node which "
                          + "respond to SNMP. Proceeding...");
            }
            createSnmpConflictsWithDbEvent(dbNodeEntry);
        }

        // Update the database
        Date now = null;
        Connection dbc = null;
        boolean updateCompleted = false;
        try {
            /*
             * Synchronize on the Capsd sync lock so we can check if
             * the interface is already in the database and perform
             * the necessary inserts in one atomic operation
             *	
             * The SuspectEventProcessor class is also synchronizing on this
             * lock prior to performing database inserts or updates.
             */
            log.debug("Waiting for capsd dbLock to process "
                      + m_scheduledNode.getNodeId());
            synchronized (Capsd.getDbSyncLock()) {
                log.debug("Got capsd dbLock. processing "
                          + m_scheduledNode.getNodeId());
                // Get database connection
                dbc = DataSourceFactory.getInstance().getConnection();

                /*
                 * There is a slight possibility that the node being rescanned
                 * has been deleted (due to reparenting) by another thread
                 * between the time this rescan was started and the database
                 * sync lock was grabbed. Verify that the current nodeid is
                 * still valid (ie, not deleted) before continuing.
                 */
                if (!isNodeDeleted(dbc, m_scheduledNode.getNodeId())) {
                    // Update interface information
                    now = new Date();
                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap,
                                     doesSnmp);
                    
                    if (doesSnmp) {
                        InetAddress oldPriIf = null;
                        if (oldPrimarySnmpInterface != null) {
                            oldPriIf = oldPrimarySnmpInterface.getIfAddress();
                        }
                        InetAddress newSnmpPrimaryIf =
                            updatePrimarySnmpInterface(dbc, dbNodeEntry,
                                                       collectorMap, oldPriIf);

                        DbNodeEntry updatedNodeEntry =
                            updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf,
                                       dbInterfaces, collectorMap);
                    }
                    updateCompleted = true;
                    createRescanCompletedEvent(dbNodeEntry);
                }
            }
        } catch (Throwable t) {
            log.error("Error updating records for node ID " + m_scheduledNode.getNodeId() + ": " + t, t);
        } finally {
            // Finished with the database connection, close it.
            try {
                if (dbc != null) {
                    dbc.close();
                }
            } catch (SQLException e) {
                log.error("Error closing connection: " + e, e);
            }
        }

        // Send events associcatd with the rescan
        if (updateCompleted) {
            // Send all events created during rescan process to eventd
            for (Event event : m_eventList) {
                try {
                    EventIpcManagerFactory.getIpcManager().sendNow(event);
                } catch (Throwable t) {
                    log.warn("run: unexpected throwable exception caught "
                             + "while sending event: " + t, t);
                }
            }
        }

        // Update the schedule information for the rescanned node
        m_scheduledNode.setLastScanned(now);
        m_scheduledNode.setScheduled(false);

        if (log.isDebugEnabled()) {
            log.debug((m_forceRescan ? "Forced r" : "R") + "escan "
                      + "for node w/ nodeid " + m_scheduledNode.getNodeId()
                      + " completed.");
        }
    }

