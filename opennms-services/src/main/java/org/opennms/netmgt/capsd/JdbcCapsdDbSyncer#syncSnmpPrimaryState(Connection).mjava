    /**
     * <p>syncSnmpPrimaryState</p>
     *
     * @param conn a {@link java.sql.Connection} object.
     * @throws java.sql.SQLException if any.
     */
    public synchronized void syncSnmpPrimaryState(Connection conn) throws SQLException {
        if (conn == null) {
            throw new IllegalArgumentException("Sync failed...must have valid database connection.");
        }
    
        /*
         * Retrieve all non-deleted SNMP-supporting IP interfaces from the
         * ipInterface table and build a map of nodes to interface entry list
         */
        LOG.debug("syncSnmpPrimaryState: building map of nodes to interfaces...");
    
        Map<Integer, List<LightWeightIfEntry>> nodes = new HashMap<Integer, List<LightWeightIfEntry>>();

        final DBUtils d = new DBUtils(getClass());
        try {
            // prepare the SQL statement to query the database
            PreparedStatement ipRetStmt = conn.prepareStatement(SQL_DB_RETRIEVE_SNMP_IP_INTERFACES);
            d.watch(ipRetStmt);
            ResultSet result = ipRetStmt.executeQuery();
            d.watch(result);
    
            // Iterate over result set and build map of interface
            // entries keyed by node id.
            List<LightWeightIfEntry> ifList = new ArrayList<LightWeightIfEntry>();
            while (result.next()) {
                // Node Id
                int nodeId = result.getInt(1);
    
                // IP address
                String address = result.getString(2);
                if (address == null) {
                    LOG.warn("invalid ipInterface table entry, no IP address, skipping...");
                    continue;
                }
    
                // ifIndex
                int ifIndex = result.getInt(6);
                if (result.wasNull()) {
                    LOG.debug("ipInterface table entry for address {} does not have a valid ifIndex ", address);
                    ifIndex = LightWeightIfEntry.NULL_IFINDEX;
                } else if (ifIndex < 1) {
                    if (ifIndex == CapsdConfig.LAME_SNMP_HOST_IFINDEX) {
                        LOG.debug("Using ifIndex = {} for address {}", CapsdConfig.LAME_SNMP_HOST_IFINDEX, address);
                    } else {
                        LOG.debug("ipInterface table entry for address {} does not have a valid ifIndex ", address);
                        ifIndex = LightWeightIfEntry.NULL_IFINDEX;
                    } 
                }
    
                // Primary SNMP State
                char primarySnmpState = DbIpInterfaceEntry.SNMP_UNKNOWN;
                String str = result.getString(4);
                if (str != null) {
                    primarySnmpState = str.charAt(0);
                }
    
                // ifType
                int ifType = result.getInt(5);
                if (result.wasNull()) {
                    LOG.debug("snmpInterface table entry for address {} does not have a valid ifType", address);
                    ifType = LightWeightIfEntry.NULL_IFTYPE;
                }
    
                // New node or existing node?
                ifList = nodes.get(Integer.valueOf(nodeId));
                if (ifList == null) {
                    // Create new interface entry list
                    ifList = new ArrayList<LightWeightIfEntry>();
                    ifList.add(new LightWeightIfEntry(nodeId, ifIndex, address, DbIpInterfaceEntry.STATE_UNKNOWN, primarySnmpState, ifType));
    
                    // Add interface entry list to the map
                    nodes.put(nodeId, ifList);
                } else {
                    // Just add the current interface to the
                    // node's interface list
                    ifList.add(new LightWeightIfEntry(nodeId, ifIndex, address, DbIpInterfaceEntry.STATE_UNKNOWN, primarySnmpState, ifType));
                }
            }
        } finally {
            d.cleanUp();
        }

        /*
         * Iterate over the nodes in the map and determine what the primary
         * SNMP interface for each node should be. Keep track of those
         * interfaces whose primary SNMP interface state has changed so that
         * the database can be updated accordingly.
         */
        LOG.debug("syncSnmpPrimaryState: iterating over nodes in map and checking primary SNMP interface, node count: {}", nodes.size());
        Iterator<Integer> niter = nodes.keySet().iterator();
        while (niter.hasNext()) {
            // Get the nodeid (key)
            Integer nId = niter.next();
            LOG.debug("building SNMP address list for node {}", nId);
    
            // Lookup the interface list (value)
            List<LightWeightIfEntry> ifEntries = nodes.get(nId);
    
            /*
             * From the interface entries build a list of InetAddress objects
             * eligible to be the primary SNMP interface for the node, and a
             * list of loopback InetAddress objects eligible to be the primary
             * SNMP interface for the node.
             */
            List<InetAddress> addressList = new ArrayList<InetAddress>();
            List<InetAddress> lbAddressList = new ArrayList<InetAddress>();
            for (LightWeightIfEntry lwIf : ifEntries) {
                /*
                 * Skip interfaces which do not have a valid (non-null) ifIndex
                 * as they are not eligible to be the primary SNMP interface
                 */
                if (lwIf.getIfIndex() == LightWeightIfEntry.NULL_IFINDEX) {
                    LOG.debug("skipping address {}: does not have a valid ifIndex.", lwIf.getAddress());
                    continue;
                }
    
                InetAddress addr = InetAddressUtils.addr(lwIf.getAddress());
                addressList.add(addr);
                if (lwIf.getIfType() == LightWeightIfEntry.LOOPBACK_IFTYPE) {
                    lbAddressList.add(addr);
                }
            }
    
            /*
             * Determine primary SNMP interface from the lists of possible addresses
             * in this order: loopback interfaces in collectd-configuration.xml,
             * other interfaces in collectd-configuration.xml, loopback interfaces in
             * the database, other interfaces in the database.
             */
            boolean strict = true;
            InetAddress primarySnmpIf = null;
            String psiType = null;
            if (lbAddressList != null) {
                primarySnmpIf = determinePrimarySnmpInterface(lbAddressList, strict);
                psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " loopback addresses";
            }
            if (primarySnmpIf == null) {
                primarySnmpIf = determinePrimarySnmpInterface(addressList, strict);
                psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + " addresses";
            }
            strict = false;
            if ((primarySnmpIf == null) && (lbAddressList != null)){
                primarySnmpIf = determinePrimarySnmpInterface(lbAddressList, strict);
                psiType = "DB loopback addresses";
            }
            if (primarySnmpIf == null) {
                primarySnmpIf = determinePrimarySnmpInterface(addressList, strict);
                psiType = "DB addresses";
            }
    
            if (LOG.isDebugEnabled()) {
                if(primarySnmpIf == null) {
                    LOG.debug("syncSnmpPrimaryState: No primary SNMP interface found for node {}", nId);
                } else {
                    LOG.debug("syncSnmpPrimaryState: primary SNMP interface for node {} is: {}, selected from {}", nId, primarySnmpIf, psiType);
                }
            }
    
            /*
             * Iterate back over interface list and update primary SNMP
             * iinterface state for this node...if the primary SNMP interface
             * state has changed, update the database to reflect the new state.
             */
            for (LightWeightIfEntry lwIf : ifEntries) {
                if (lwIf.getIfIndex() == LightWeightIfEntry.NULL_IFINDEX) {
                    lwIf.setSnmpPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
                } else if (primarySnmpIf == null || !lwIf.getAddress().equals(InetAddressUtils.str(primarySnmpIf))) {
                    if (getCollectdConfig().isServiceCollectionEnabled(lwIf.getAddress(), "SNMP")) {
                        lwIf.setSnmpPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
                    } else {
                        lwIf.setSnmpPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
                    }
                } else {
                    lwIf.setSnmpPrimaryState(DbIpInterfaceEntry.SNMP_PRIMARY);
                }
    
                // Has SNMP primary state changed?
                if (lwIf.hasSnmpPrimaryStateChanged()) {
                    LOG.debug("syncSnmpPrimaryState: updating {}/{}, marking with state: {}", lwIf.getNodeId(), lwIf.getAddress(), lwIf.getSnmpPrimaryState());

                    try {
                        // prepare the SQL statement to query the database
                        PreparedStatement updateStmt = conn.prepareStatement(SQL_DB_UPDATE_SNMP_PRIMARY_STATE);
                        d.watch(updateStmt);
                        updateStmt.setString(1, new String(new char[] { lwIf.getSnmpPrimaryState() }));
                        updateStmt.setInt(2, lwIf.getNodeId());
                        updateStmt.setString(3, lwIf.getAddress());
    
                        updateStmt.executeUpdate();
                    } finally {
                        d.cleanUp();
                    }
                }
            }
        }
    
        LOG.debug("syncSnmpPrimaryState: sync completed.");
    }

