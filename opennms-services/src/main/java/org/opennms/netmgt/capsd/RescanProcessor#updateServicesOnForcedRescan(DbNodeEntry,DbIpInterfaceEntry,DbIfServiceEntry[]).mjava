    /**
     * This method is responsible for updating the status of services for an
     * interface during a forced rescan
     * 
     * @param node
     *            Node entry for the node being rescanned
     * @param dbIpIfEntry
     *            interface entry of the updating interface
     * @param dbSupportedServices
     *            services on the updating interface
     * 
     * @throws SQLException
     *             if there is a problem updating the snmpInterface table.
     */
    private void updateServicesOnForcedRescan(DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, DbIfServiceEntry[] dbSupportedServices) throws SQLException {
        /*
         * Now process previously existing protocols to update polling status.
         * Additional checks on forced rescan for existing services go here.
         * Specifically, has service been forced managed/unmanaged or has
         * polling status changed?
         */

        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();
        CapsdConfig cFactory = CapsdConfigFactory.getInstance();
        InetAddress ifaddr = dbIpIfEntry.getIfAddress();
        org.opennms.netmgt.config.poller.Package ipPkg = null;

        boolean ipToBePolled = false;
        final String ifaddrString = str(ifaddr);
        ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);
        if (ipPkg != null) {
            ipToBePolled = true;
        }

        LOG.debug("updateServicesOnForcedRescan: Checking status of existing services on host {}", ifaddr);

        // Get service names from database
        java.sql.Connection ctest = null;
        ResultSet rs = null;
        Map<Integer, String> serviceNames = new HashMap<Integer, String>();
        final DBUtils d = new DBUtils(RescanProcessor.class);
        try {
            ctest = DataSourceFactory.getInstance().getConnection();
            d.watch(ctest);
            PreparedStatement loadStmt = ctest.prepareStatement(SQL_RETRIEVE_SERVICE_IDS);
            d.watch(loadStmt);

            // go ahead and load the service table
            rs = loadStmt.executeQuery();
            d.watch(rs);
            while (rs.next()) {
                Integer id = Integer.valueOf(rs.getInt(1));
                String name = rs.getString(2);
                serviceNames.put(id, name);
            }
        } catch (Throwable t) {
            LOG.error("Error reading services table", t);
        } finally {
            d.cleanUp();
        }

        for (int i = 0; i < dbSupportedServices.length; i++) {
            Integer id = dbSupportedServices[i].getServiceId();
            String sn = (serviceNames.get(id)).toString();

            DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.get(node.getNodeId(), ifaddr, dbSupportedServices[i].getServiceId());
            LOG.debug("updateServicesOnForcedRescan: old status for nodeId " + node.getNodeId() + ", ifaddr " + ifaddr + ", serviceId " + dbSupportedServices[i].getServiceId() + " = " + ifSvcEntry.getStatus());

            // now fill in the entry

            boolean svcChangeToActive = false;
            boolean svcChangeToNotPolled = false;
            boolean svcChangeToForced = false;
            if (!cFactory.isAddressUnmanaged(ifaddr)) {
                boolean svcToBePolled = false;
                if (ipToBePolled) {
                    if (ipPkg == null) {
                        ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddrString);
                    }
                    if (ipPkg != null) {
                        LOG.debug("updateServicesOnForcedRescan: Is service to be polled for package = " + ipPkg.getName() + ", service = " + sn);
                        svcToBePolled = pollerCfgFactory.isPolled(sn, ipPkg);
                        if (!svcToBePolled) {
                            LOG.debug("updateServicesOnForcedRescan: Is service to be polled for ifaddr = " + ifaddrString + ", service = " + sn);
                            svcToBePolled = pollerCfgFactory.isPolled(ifaddrString, sn);
                        }
                        if (!svcToBePolled) {
                            LOG.debug("updateServicesOnForcedRescan: Service not to be polled");
                        }
                    } else {
                        LOG.debug("updateServicesOnForcedRescan: No poller package found");
                    }
                } else {
                    LOG.debug("updateServicesOnForcedRescan: Service not polled because interface is not polled");
                        
                }

                if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_FORCED) {
                    if (svcToBePolled) {
                        // Do nothing
                        LOG.debug("updateServicesOnForcedRescan: status = FORCED. No action taken.");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = FORCED. Changed to NOT_POLLED");
                    }
                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_SUSPEND) {
                    if (svcToBePolled) {
                        // change the status to "F"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_FORCED);
                        svcChangeToForced = true;
                        LOG.debug("updateServicesOnForcedRescan: status = SUSPEND. Changed to FORCED");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = SUSPEND. Changed to NOT_POLLED");
                    }
                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_RESUME) {
                    if (svcToBePolled) {
                        // change the status to "A"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);
                        svcChangeToActive = true;
                        LOG.debug("updateServicesOnForcedRescan: status = RESUME. Changed to ACTIVE");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = RESUME. Changed to NOT_POLLED");
                    }
                } else if (svcToBePolled && ifSvcEntry.getStatus() != DbIfServiceEntry.STATUS_ACTIVE) {
                    // set the status to "A"
                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);
                    svcChangeToActive = true;
                    LOG.debug("updateServicesOnForcedRescan: New status = ACTIVE");
                } else if (!svcToBePolled && ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_ACTIVE) {
                    // set the status to "N"
                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                    svcChangeToNotPolled = true;
                    LOG.debug("updateServicesOnForcedRescan: New status = NOT_POLLED");
                } else {
                    LOG.debug("updateServicesOnForcedRescan: Status Unchanged");
                }
            }

            if (svcChangeToActive) {
                ifSvcEntry.store();
                m_eventList.add(createResumePollingServiceEvent(node, dbIpIfEntry, sn));
            } else if (svcChangeToNotPolled || svcChangeToForced) {
                ifSvcEntry.store();
                m_eventList.add(createSuspendPollingServiceEvent(node, dbIpIfEntry, sn));
            }
        }
    }

