    /**
     * This method is responsible for updating the status of services for an
     * interface during a forced rescan
     * 
     * @param node
     *            Node entry for the node being rescanned
     * @param dbIpIfEntry
     *            interface entry of the updating interface
     * @param dbSupportedServices
     *            services on the updating interface
     * 
     * @throws SQLException
     *             if there is a problem updating the snmpInterface table.
     */
    private void updateServicesOnForcedRescan(final DbNodeEntry node, final DbIpInterfaceEntry dbIpIfEntry, final DbIfServiceEntry[] dbSupportedServices) throws SQLException {
        /*
         * Now process previously existing protocols to update polling status.
         * Additional checks on forced rescan for existing services go here.
         * Specifically, has service been forced managed/unmanaged or has
         * polling status changed?
         */

        final PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();
        final CapsdConfig cFactory = CapsdConfigFactory.getInstance();
        final InetAddress ifaddr = dbIpIfEntry.getIfAddress();
        final String ifaddrString = str(ifaddr);

        org.opennms.netmgt.config.poller.Package ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);

        boolean ipToBePolled = (ipPkg != null);

        LOG.debug("updateServicesOnForcedRescan: Checking status of existing services on host {}", ifaddr);

        // Get service names from database
        final Map<Integer, String> serviceNames = new HashMap<Integer, String>();
        final DBUtils d = new DBUtils(RescanProcessor.class);
        try {
            final Connection ctest = DataSourceFactory.getInstance().getConnection();
            d.watch(ctest);
            final PreparedStatement loadStmt = ctest.prepareStatement(SQL_RETRIEVE_SERVICE_IDS);
            d.watch(loadStmt);

            // go ahead and load the service table
            final ResultSet rs = loadStmt.executeQuery();
            d.watch(rs);
            while (rs.next()) {
                final Integer id = Integer.valueOf(rs.getInt(1));
                final String name = rs.getString(2);
                serviceNames.put(id, name);
            }
        } catch (final Exception e) {
            LOG.error("Error reading services table", e);
        } finally {
            d.cleanUp();
        }

        for (int i = 0; i < dbSupportedServices.length; i++) {
            final Integer id = dbSupportedServices[i].getServiceId();
            final String sn = (serviceNames.get(id)).toString();

            final DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.get(node.getNodeId(), ifaddr, dbSupportedServices[i].getServiceId());
            LOG.debug("updateServicesOnForcedRescan: old status for nodeId {}, ifaddr {}, serviceId {} = {}", node.getNodeId(), ifaddr, dbSupportedServices[i].getServiceId(), ifSvcEntry.getStatus());

            // now fill in the entry

            boolean svcChangeToActive = false;
            boolean svcChangeToNotPolled = false;
            boolean svcChangeToForced = false;
            if (!cFactory.isAddressUnmanaged(ifaddr)) {
                boolean svcToBePolled = false;
                if (ipToBePolled) {
                    if (ipPkg == null) {
                        ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddrString);
                    }
                    if (ipPkg != null) {
                        LOG.debug("updateServicesOnForcedRescan: Is service to be polled for package = {}, service = {}", ipPkg.getName(), sn);
                        svcToBePolled = pollerCfgFactory.isPolled(sn, ipPkg);
                        if (!svcToBePolled) {
                            LOG.debug("updateServicesOnForcedRescan: Is service to be polled for ifaddr = {}, service = {}", ifaddrString, sn);
                            svcToBePolled = pollerCfgFactory.isPolled(ifaddrString, sn);
                        }
                        if (!svcToBePolled) {
                            LOG.debug("updateServicesOnForcedRescan: Service not to be polled");
                        }
                    } else {
                        LOG.debug("updateServicesOnForcedRescan: No poller package found");
                    }
                } else {
                    LOG.debug("updateServicesOnForcedRescan: Service not polled because interface is not polled");

                }

                if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_FORCED) {
                    if (svcToBePolled) {
                        // Do nothing
                        LOG.debug("updateServicesOnForcedRescan: status = FORCED. No action taken.");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = FORCED. Changed to NOT_POLLED");
                    }
                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_SUSPEND) {
                    if (svcToBePolled) {
                        // change the status to "F"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_FORCED);
                        svcChangeToForced = true;
                        LOG.debug("updateServicesOnForcedRescan: status = SUSPEND. Changed to FORCED");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = SUSPEND. Changed to NOT_POLLED");
                    }
                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_RESUME) {
                    if (svcToBePolled) {
                        // change the status to "A"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);
                        svcChangeToActive = true;
                        LOG.debug("updateServicesOnForcedRescan: status = RESUME. Changed to ACTIVE");
                    } else {
                        // change the status to "N"
                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                        svcChangeToNotPolled = true;
                        LOG.debug("updateServicesOnForcedRescan: status = RESUME. Changed to NOT_POLLED");
                    }
                } else if (svcToBePolled && ifSvcEntry.getStatus() != DbIfServiceEntry.STATUS_ACTIVE) {
                    // set the status to "A"
                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);
                    svcChangeToActive = true;
                    LOG.debug("updateServicesOnForcedRescan: New status = ACTIVE");
                } else if (!svcToBePolled && ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_ACTIVE) {
                    // set the status to "N"
                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
                    svcChangeToNotPolled = true;
                    LOG.debug("updateServicesOnForcedRescan: New status = NOT_POLLED");
                } else {
                    LOG.debug("updateServicesOnForcedRescan: Status Unchanged");
                }
            }

            if (svcChangeToActive) {
                ifSvcEntry.store();
                m_eventList.add(createResumePollingServiceEvent(node, dbIpIfEntry, sn));
            } else if (svcChangeToNotPolled || svcChangeToForced) {
                ifSvcEntry.store();
                m_eventList.add(createSuspendPollingServiceEvent(node, dbIpIfEntry, sn));
            }
        }
    }

