    /**
     * The main method of the scheduler. This method is responsible for checking
     * the runnable queues for ready objects and then enqueuing them into the
     * thread pool for execution.
     */
    @Override
    public void run() {
        synchronized (this) {
            m_status = RUNNING;
        }

        if (LOG.isDebugEnabled())
            LOG.debug("Scheduler.run: scheduler running");

        // Loop until a fatal exception occurs or until
        // the thread is interrupted.
        //
        boolean firstPass = true;
        for (;;) {
            // Status check
            //
            synchronized (this) {
                if (m_status != RUNNING && m_status != PAUSED && m_status != PAUSE_PENDING && m_status != RESUME_PENDING) {
                    if (LOG.isDebugEnabled())
                        LOG.debug("Scheduler.run: status = " + m_status + ", time to exit");
                    break;
                }
            }

            // If this is the first pass we want to pause momentarily
            // This allows the rest of the background processes to come
            // up and stabilize before we start generating events from rescans.
            //
            if (firstPass) {
                firstPass = false;
                synchronized (this) {
                    try {
                        if (LOG.isDebugEnabled())
                            LOG.debug("Scheduler.run: initial sleep configured for " + m_initialSleep + "ms...sleeping...");
                        wait(m_initialSleep);
                    } catch (InterruptedException ex) {
                        if (LOG.isDebugEnabled())
                            LOG.debug("Scheduler.run: interrupted exception during initial sleep...exiting.");
                        break; // exit for loop
                    }
                }
            }

            // iterate over the known node list, add any
            // nodes ready for rescan to the rescan queue
            // for processing.
            //
            int added = 0;

            synchronized (m_knownNodes) {
                if (LOG.isDebugEnabled())
                    LOG.debug("Scheduler.run: iterating over known nodes list to schedule...");
                Iterator<NodeInfo> iter = m_knownNodes.iterator();
                while (iter.hasNext()) {
                    NodeInfo node = iter.next();

                    // Don't schedule if already scheduled
                    if (node.isScheduled())
                        continue;

                    // Don't schedule if its not time for rescan yet
                    if (!node.timeForRescan())
                        continue;

                    // Must be time for a rescan!
                    //
                    try {
                        node.setScheduled(true); // Mark node as scheduled

                        // Special Case...perform SMB reparenting if nodeid
                        // of the scheduled node is -1
                        //
                        if (node.getNodeId() == SMB_REPARENTING_IDENTIFIER) {
                            if (LOG.isDebugEnabled())
                                LOG.debug("Scheduler.run: time for reparenting via SMB...");

                            Connection db = null;
                            try {
                                db = DataSourceFactory.getInstance().getConnection();

                                ReparentViaSmb reparenter = new ReparentViaSmb(db);
                                try {
                                    reparenter.sync();
                                } catch (SQLException sqlE) {
                                    LOG.error("Unexpected database error during SMB reparenting", sqlE);
                                } catch (Throwable t) {
                                    LOG.error("Unexpected error during SMB reparenting", t);
                                }
                            } catch (SQLException sqlE) {
                                LOG.error("Unable to get database connection from the factory.", sqlE);
                            } finally {
                                if (db != null) {
                                    try {
                                        db.close();
                                    } catch (Throwable e) {
                                    }
                                }
                            }

                            // Update the schedule information for the SMB
                            // reparenting node
                            // 
                            node.setLastScanned(new Date());
                            node.setScheduled(false);

                            if (LOG.isDebugEnabled())
                                LOG.debug("Scheduler.run: SMB reparenting completed...");
                        }
                        // Otherwise just add the NodeInfo to the queue which will create
                        // a rescanProcessor and run it
                        //
                        else {
                            if (LOG.isDebugEnabled())
                                LOG.debug("Scheduler.run: adding node " + node.getNodeId() + " to the rescan queue.");
                            m_rescanQ.execute(node);
                            added++;
                        }
                    } catch (RejectedExecutionException e) {
                        LOG.info("Scheduler.schedule: failed to add new node to rescan queue", e);
                        throw new UndeclaredThrowableException(e);
                    }
                }
            }

            // Wait for 60 seconds if there were no nodes
            // added to the rescan queue during this loop,
            // otherwise just start over.
            //
            synchronized (this) {
                if (added == 0) {
                    try {
                        wait(60000);
                    } catch (InterruptedException ex) {
                        break; // exit for loop
                    }
                }
            }

        } // end for(;;)

        LOG.debug("Scheduler.run: scheduler exiting, state = STOPPED");
        synchronized (this) {
            m_status = STOPPED;
        }

    } // end run

