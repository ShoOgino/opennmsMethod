    /**
     * This method is responsible for updating all of the interface's associated
     * with a node.
     * 
     * @param dbc
     *            Database connection.
     * @param now
     *            Date/time to be associated with the update.
     * @param node
     *            Node entry for the node being rescanned
     * @param collectorMap
     *            Map of IfCollector objects associated with the node.
     * @param doesSnmp
     *            Indicates that the interface does support SNMP
     * 
     * @throws SQLException
     *             if there is a problem updating the ipInterface table.
     */
    private void updateInterfaces(final Connection dbc, final Date now, final DbNodeEntry node, final Map<String, IfCollector> collectorMap, final boolean doesSnmp) throws SQLException {
        /*
         * make sure we have a current PackageIpListMap
         * this was getting done once for each managed ip
         * interface in updateInterfaceInfo. Seems more
         * efficient to just do it once here, and then later
         * for new interfaces (which aren't in the DB yet at
         * this point) in updateInterfaceInfo.
         */
        LOG.debug("updateInterfaces: Rebuilding PackageIpListMap");
        final PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();
        pollerCfgFactory.rebuildPackageIpListMap();

        /*
         * List of update interfaces
         * This list is maintained so that for nodes with multiple
         * interfaces which support SNMP, interfaces are not updated
         * more than once.
         */
        final List<InetAddress> updatedIfList = new ArrayList<InetAddress>();

        IfSnmpCollector snmpCollector = null;

        if (doesSnmp) {
            /*
             * Reset modification flags. These flags are set by
             * the updateInterface() method when changes have been
             * detected which warrant further action (such as
             * generating an event).
             */
            m_ifIndexOnNodeChangedFlag = false;
            m_snmpIfTableChangedFlag = false;

            /*
             * Determine if any of the interface collector objects have
             * an SNMP collector associated with them. If so, use the first
             * interface with SNMP data collected to update all SNMP-found
             * interfaces.
             */
            IfCollector collectorWithSnmp = null;
            for (final IfCollector tmp : collectorMap.values()) {
                if (tmp.getSnmpCollector() != null) {
                    collectorWithSnmp = tmp;
                    break;
                }
            }

            if (collectorWithSnmp != null) {
                snmpCollector = collectorWithSnmp.getSnmpCollector();

                updateInterface(dbc, now, node, collectorWithSnmp.getTarget(), collectorWithSnmp.getTarget(), collectorWithSnmp.getSupportedProtocols(), snmpCollector, doesSnmp);
                updatedIfList.add(collectorWithSnmp.getTarget());

                // Update subtargets
                if (collectorWithSnmp.hasAdditionalTargets()) {
                    final Map<InetAddress, List<SupportedProtocol>> subTargets = collectorWithSnmp.getAdditionalTargets();
                    for (final Map.Entry<InetAddress,List<SupportedProtocol>> entry : subTargets.entrySet()) {
                        updateInterface(dbc, now, node, collectorWithSnmp.getTarget(), entry.getKey(), entry.getValue(), snmpCollector, doesSnmp);
                        updatedIfList.add(entry.getKey());
                    }
                }

                // Add any new non-IP interfaces
                if (collectorWithSnmp.hasNonIpInterfaces()) {
                    for(final Integer ifIndex : collectorWithSnmp.getNonIpInterfaces()) {
                        updateNonIpInterface(dbc, now, node, ifIndex.intValue(), snmpCollector);
                    }
                }
            }
        }

        /*
         * Majority of interfaces should have been updated by this
         * point (provided the node supports SNMP). Only non-SNMP
         * interfaces and those associated with the node via
         * SMB (NetBIOS name) should remain. Loop through collector
         * map and update any remaining interfaces. Use the
         * updatedIfList object to filter out any interfaces which
         * have already been updated
         */

        // Iterate over interfaces from collection map
        for (final IfCollector ifc : collectorMap.values()) {
            // Update target
            final InetAddress ifaddr = ifc.getTarget();
            if (!updatedIfList.contains(ifaddr)) {
                updateInterface(dbc, now, node, ifc.getTarget(), ifaddr, ifc.getSupportedProtocols(), snmpCollector, doesSnmp);
                updatedIfList.add(ifaddr);
            }

            // Update subtargets
            if (ifc.hasAdditionalTargets()) {
                final Map<InetAddress, List<SupportedProtocol>> subTargets = ifc.getAdditionalTargets();
                for (final Map.Entry<InetAddress,List<SupportedProtocol>> entry : subTargets.entrySet()) {
                    final InetAddress subIf = entry.getKey();
                    if (!updatedIfList.contains(subIf)) {
                        updateInterface(dbc, now, node, ifc.getTarget(), subIf, entry.getValue(), snmpCollector, doesSnmp);
                        updatedIfList.add(subIf);
                    }
                }
            }
        }
    }

