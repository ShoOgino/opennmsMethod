    /**
     * {@inheritDoc}
     *
     * Returns true if the protocol defined by this plugin is supported. If the
     * protocol is not supported then a false value is returned to the caller.
     * The qualifier map passed to the method is used by the plugin to return
     * additional information by key-name. These key-value pairs can be added to
     * service events if needed.
     */
    @Override
    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {
        int retries = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_RETRY, DEFAULT_RETRY);
        int timeout = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_TIMEOUT, DEFAULT_TIMEOUT);
        int port    = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_PORT, DEFAULT_PORT);

        // verify the port
        //
        if (port == -1) {
            throw new IllegalArgumentException("The port must be specified when doing SSL certificate discovery");
        }

        boolean hasSSLCert = false;
        for (int attempts = 0; attempts <= retries && !hasSSLCert; attempts++) {
            Socket socket = null;
            try {
                // create a connected socket
                //
                socket = new Socket();
                socket.connect(new InetSocketAddress(address, port), timeout);
                socket.setSoTimeout(timeout);
                LogUtils.debugf(this, "Connected to host: %s on port: %s", address, port);
                SSLSocket sslSocket = (SSLSocket) getSocketWrapper().wrapSocket(socket);
                hasSSLCert = sslSocket.getSession().isValid();
            } catch (ConnectException e) {
                // Connection refused!! Continue to retry.
                //
                LogUtils.debugf(this, "Connection refused to %s:%s", InetAddressUtils.str(address), port);
                hasSSLCert = false;
            } catch (NoRouteToHostException e) {
                // No Route to host!!!
                //
                e.fillInStackTrace();
                LogUtils.infof(this, e, "Could not connect to host %s, no route to host", InetAddressUtils.str(address));
                hasSSLCert = false;
                throw new UndeclaredThrowableException(e);
            } catch (InterruptedIOException e) {
                // This is an expected exception
                //
                LogUtils.debugf(this, "Did not connect to host within timeout: %d, attempt: %d", timeout, attempts);
                hasSSLCert = false;
            } catch (IOException e) {
                LogUtils.infof(this, e, "An expected I/O exception occured connecting to host %s on port %d", InetAddressUtils.str(address), port);
                hasSSLCert = false;
            } catch (Throwable t) {
                hasSSLCert = false;
                LogUtils.warnf(this, t, "An undeclared throwable exception was caught connecting to host %s on port %d", InetAddressUtils.str(address), port);
            } finally {
                try {
                    if (socket != null) {
                        socket.close();
                    }
                } catch (IOException e) {
                }
            }
        }
        return hasSSLCert;
    }

