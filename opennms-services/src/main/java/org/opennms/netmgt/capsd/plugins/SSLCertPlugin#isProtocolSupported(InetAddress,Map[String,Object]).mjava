    /**
     * {@inheritDoc}
     *
     * Returns true if the protocol defined by this plugin is supported. If the
     * protocol is not supported then a false value is returned to the caller.
     * The qualifier map passed to the method is used by the plugin to return
     * additional information by key-name. These key-value pairs can be added to
     * service events if needed.
     */
    @Override
    public boolean isProtocolSupported(InetAddress address, Map<String, Object> qualifiers) {
        int retries = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_RETRY, DEFAULT_RETRY);
        int timeout = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_TIMEOUT, DEFAULT_TIMEOUT);
        int port    = ParameterMap.getKeyedInteger(qualifiers, PARAMETER_PORT, DEFAULT_PORT);

        // verify the port
        //
        if (port == -1) {
            throw new IllegalArgumentException("The port must be specified when doing SSL certificate discovery");
        }

        boolean hasSSLCert = false;
        for (int attempts = 0; attempts <= retries && !hasSSLCert; attempts++) {
            Socket socket = null;
            try {
                // create a connected socket
                //
                socket = new Socket();
                socket.connect(new InetSocketAddress(address, port), timeout);
                socket.setSoTimeout(timeout);
                LOG.debug("Connected to host: {} on port: {}", address, port);
                SSLSocket sslSocket = (SSLSocket) getSocketWrapper().wrapSocket(socket);
                hasSSLCert = sslSocket.getSession().isValid();
            } catch (ConnectException e) {
                // Connection refused!! Continue to retry.
                //
                LOG.debug("Connection refused to {}:{}", InetAddressUtils.str(address), port);
                hasSSLCert = false;
            } catch (NoRouteToHostException e) {
                // No Route to host!!!
                //
                e.fillInStackTrace();
                LOG.info("Could not connect to host {}, no route to host", InetAddressUtils.str(address), e);
                hasSSLCert = false;
                throw new UndeclaredThrowableException(e);
            } catch (InterruptedIOException e) {
                // This is an expected exception
                //
                LOG.debug("Did not connect to host within timeout: {}, attempt: {}", timeout, attempts);
                hasSSLCert = false;
            } catch (IOException e) {
                LOG.info("An expected I/O exception occured connecting to host {} on port {}", InetAddressUtils.str(address), port, e);
                hasSSLCert = false;
            } catch (Throwable t) {
                hasSSLCert = false;
                LOG.warn("An undeclared throwable exception was caught connecting to host {} on port {}", InetAddressUtils.str(address), port, t);
            } finally {
                try {
                    if (socket != null) {
                        socket.close();
                    }
                } catch (IOException e) {
                }
            }
        }
        return hasSSLCert;
    }

