    /**
     * <p>syncManagementState</p>
     *
     * @param conn a {@link java.sql.Connection} object.
     * @throws java.sql.SQLException if any.
     */
    public void syncManagementState(Connection conn) throws SQLException {
        boolean verifyServer = getOpennmsServerConfig().verifyServer();
        String localServer = getOpennmsServerConfig().getServerName();
    
        if (log().isDebugEnabled()) {
            log().debug("syncManagementState: local server: " + localServer + " verify server: " + verifyServer);
        }
    
        if (conn == null) {
            log().error("CapsdConfigFactory.syncManagementState: Sync failed...must have valid database connection.");
            return;
        }
    
        // Get default management state.
        //
        String managementPolicy = getCapsdConfig().getConfiguration().getManagementPolicy();
        boolean managedByDefault = (managementPolicy == null || managementPolicy.equalsIgnoreCase("managed"));
        if (log().isDebugEnabled()) {
            log().debug("syncManagementState: managed_by_default: " + managedByDefault);
        }
    
        //
        // Retrieve list of interfaces and their managed status from the
        // database
        // NOTE: Interfaces with an 'isManaged' field equal to 'D' (Deleted) or
        // 'F' (Forced Unmanaged) are
        // not eligible to be managed and will not be included in the interfaces
        // retrieved from the database. Likewise, interfaces with IP address of
        // '0.0.0.0' will also be excluded by the SQL query.
        //
    
        // prepare the SQL statement to query the database
        PreparedStatement ipRetStmt = null;
        final DBUtils d = new DBUtils(getClass());
        List<LightWeightIfEntry> ifList = new ArrayList<LightWeightIfEntry>();

        try {
            if (verifyServer) {
                ipRetStmt = conn.prepareStatement(SQL_DB_RETRIEVE_IP_INTERFACE_IN_LOCAL_SERVER);
                d.watch(ipRetStmt);
                ipRetStmt.setString(1, localServer);
            } else {
                ipRetStmt = conn.prepareStatement(SQL_DB_RETRIEVE_IP_INTERFACE);
                d.watch(ipRetStmt);
            }
        
            ResultSet result = null;
            
            // run the statement
            result = ipRetStmt.executeQuery();
            d.watch(result);
    
            // Build array list of CapsdInterface objects representing each
            // of the interfaces retrieved from the database
            while (result.next()) {
                // Node Id
                int nodeId = result.getInt(1);
    
                // IP address
                String address = result.getString(2);
                if (address == null) {
                    log().warn("invalid ipInterface table entry, no IP address, skipping...");
                    continue;
                }
    
                // Management State
                char managedState = DbIpInterfaceEntry.STATE_UNKNOWN;
                String str = result.getString(3);
                if (str != null) {
                    managedState = str.charAt(0);
                }
    
                ifList.add(new LightWeightIfEntry(nodeId, LightWeightIfEntry.NULL_IFINDEX, address, managedState, DbIpInterfaceEntry.SNMP_UNKNOWN, LightWeightIfEntry.NULL_IFTYPE));
            }
        } finally {
            d.cleanUp();
        }

        try {
            // For efficiency, prepare the SQL statements in advance
            PreparedStatement ifUpdateStmt = conn.prepareStatement(SQL_DB_UPDATE_IP_INTERFACE);
            d.watch(ifUpdateStmt);
            PreparedStatement allSvcUpdateStmt = conn.prepareStatement(SQL_DB_UPDATE_ALL_SERVICES_FOR_NIP);
            d.watch(allSvcUpdateStmt);
            PreparedStatement svcRetStmt = conn.prepareStatement(SQL_DB_RETRIEVE_IF_SERVICES);
            d.watch(svcRetStmt);
            PreparedStatement svcUpdateStmt = conn.prepareStatement(SQL_DB_UPDATE_SERVICE_FOR_NIP);
            d.watch(svcUpdateStmt);
    
            /*
             * Loop through interface list and determine if there has been a
             * change in the managed status of the interface based on the
             * newly loaded package configuration data.
             */
            for (LightWeightIfEntry ifEntry : ifList) {
                String ipaddress = ifEntry.getAddress();
    
                // Convert to InetAddress object
                InetAddress ifAddress = null;
                ifAddress = InetAddressUtils.addr(ipaddress);
            	if (ifAddress == null) {
                    log().warn("Failed converting ip address " + ipaddress + " to InetAddress.");
                    continue;
                }
    
                // Check interface address against Capsd config information to
                // determine
                // if interface management state should be managed or unmanaged.
                boolean address_is_unmanaged = getCapsdConfig().isAddressUnmanaged(ifAddress);
                if (log().isDebugEnabled()) {
                    log().debug("syncManagementState: " + ipaddress + " unmanaged based on capsd config?: " + address_is_unmanaged);
                }
    
                if (address_is_unmanaged) {
                    // Interface not managed, check current
                    // management state for this interface.
                    if (ifEntry.getManagementState() != DbIpInterfaceEntry.STATE_UNMANAGED) {
                        // Update management state to unmanaged for the
                        // interface as well as for its services.
    
                        // Update the 'ipInterface' table
                        ifUpdateStmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_UNMANAGED }));
                        ifUpdateStmt.setInt(2, ifEntry.getNodeId());
                        ifUpdateStmt.setString(3, ipaddress);
                        ifUpdateStmt.executeUpdate();
    
                        // Update the 'ifServices' table
                        allSvcUpdateStmt.setString(1, new String(new char[] { DbIfServiceEntry.STATUS_UNMANAGED }));
                        allSvcUpdateStmt.setInt(2, ifEntry.getNodeId());
                        allSvcUpdateStmt.setString(3, ipaddress);
                        allSvcUpdateStmt.executeUpdate();
    
                        if (log().isDebugEnabled()) {
                            log().debug("syncManagementState: update completed for node/interface: " + ifEntry.getNodeId() + "/" + ipaddress + " to unmanaged");
                        }
                    }
                } else {
                    /*
                     * Interface should be managed - check the status against
                     * poller config to see if interface will be polled
                     * 
                     * NOTE: Try to avoid re-evaluating the ip against filters
                     * for each service, try to get the first package here and
                     * for that for service evaluation
                     */
                    final PollerConfig pollerConfig = getPollerConfig();
                    pollerConfig.getReadLock().lock();
                    try {
                        org.opennms.netmgt.config.poller.Package ipPkg = pollerConfig.getFirstPackageMatch(ipaddress);
                        boolean ipToBePolled = false;
                        if (ipPkg != null) {
                            ipToBePolled = true;
                        }
        
                        if (log().isDebugEnabled()) {
                            log().debug("syncManagementState: " + ipaddress + " to be polled based on poller config?: " + ipToBePolled);
                        }
        
                        if ((ifEntry.getManagementState() == DbIpInterfaceEntry.STATE_MANAGED && ipToBePolled) || (ifEntry.getManagementState() == DbIpInterfaceEntry.STATE_NOT_POLLED && !ipToBePolled)) {
                            // current status is right
                            if (log().isDebugEnabled()) {
                                log().debug("syncManagementState: " + ipaddress + " - no change in status");
                            }
                        } else {
                            if (ipToBePolled) {
                                ifUpdateStmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_MANAGED }));
                            } else {
                                ifUpdateStmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_NOT_POLLED }));
                            }
        
                            ifUpdateStmt.setInt(2, ifEntry.getNodeId());
                            ifUpdateStmt.setString(3, ipaddress);
                            ifUpdateStmt.executeUpdate();
        
                            if (log().isDebugEnabled()) {
                                log().debug("syncManagementState: update completed for node/interface: " + ifEntry.getNodeId() + "/" + ipaddress);
                            }
                        }
        
                        // get services for this nodeid/ip and update
                        svcRetStmt.setInt(1, ifEntry.getNodeId());
                        svcRetStmt.setString(2, ipaddress);
        
                        ResultSet svcRS = svcRetStmt.executeQuery();
                        d.watch(svcRS);
                        while (svcRS.next()) {
                            int svcId = svcRS.getInt(1);
        
                            char svcStatus = DbIfServiceEntry.STATUS_UNKNOWN;
                            String str = svcRS.getString(2);
                            if (str != null) {
                                svcStatus = str.charAt(0);
                            }
        
                            String svcName = getServiceName(svcId);
                            /*
                             * try the first package that had the ip first, if
                             * service is not enabled, try all packages
                             */
                            char oldStatus = svcStatus;
                            char newStatus = 'U';
                            boolean svcToBePolledLocally = isServicePolledLocally(ipaddress, svcName, ipPkg);
                            boolean svcToBePolledRemotely = isServicePolled(ipaddress, svcName, ipPkg);
                            
                            if (log().isDebugEnabled()) {
                                log().debug("syncManagementState: " + ipaddress + "/" + svcName + " to be polled based on poller config?: " + svcToBePolledLocally);
                            }
        
                            if ((svcStatus == DbIfServiceEntry.STATUS_ACTIVE && svcToBePolledLocally) || (svcStatus == DbIfServiceEntry.STATUS_NOT_POLLED && !ipToBePolled)) {
                                // current status is right
                                if (log().isDebugEnabled()) {
                                    log().debug("syncManagementState: " + ifEntry.getNodeId() + "/" + ipaddress + "/" + svcName + " status = " + svcStatus + " - no change in status");
                                }
                            } else {
                                // Update the 'ifServices' table
                                if (svcStatus == DbIfServiceEntry.STATUS_SUSPEND && svcToBePolledLocally) {
                                    svcUpdateStmt.setString(1, new String(new char[] { DbIfServiceEntry.STATUS_FORCED }));
                                    newStatus = 'F';
                                } else if (svcToBePolledLocally) {
                                    svcUpdateStmt.setString(1, new String(new char[] { DbIfServiceEntry.STATUS_ACTIVE }));
                                    newStatus = 'A';
                                } else if (svcToBePolledRemotely) {
                                    svcUpdateStmt.setString(1, new String(new char[] { DbIfServiceEntry.STATUS_REMOTE }));
                                    newStatus = 'X';
                                } else {
                                    svcUpdateStmt.setString(1, new String(new char[] { DbIfServiceEntry.STATUS_NOT_POLLED }));
                                    newStatus = 'N';
                                }
                                svcUpdateStmt.setInt(2, ifEntry.getNodeId());
                                svcUpdateStmt.setString(3, ipaddress);
                                svcUpdateStmt.setInt(4, svcId);
                                svcUpdateStmt.executeUpdate();
        
                                if (log().isDebugEnabled()) {
                                    log().debug("syncManagementState: update completed for node/interface/svc: " + ifEntry.getNodeId() + "/" + ipaddress + "/" + svcName + " status changed from " + oldStatus + " to " + newStatus);
                                }
                            }
        
                        } // end ifservices result
                    } finally {
                        pollerConfig.getReadLock().unlock();
                    }
                } // interface managed
            } // end while
        } finally {
            d.cleanUp();
        }
    }

