    /**
     * Builds a list of InetAddress objects representing each of the interfaces
     * from the collector map object which support SNMP and have a valid ifIndex
     * and have an IfType of loopback.
     * 
     * This is part of a feature to choose a non 127.*.*.* loopback address as
     * the primary SNMP interface.
     * 
     * @param collectorMap
     *            Map of IfCollector objects containing data collected from all
     *            of the node's interfaces.
     * @param snmpc
     *            Reference to SNMP collection object
     * 
     * @return List of InetAddress objects.
     */
    private static List<InetAddress> buildLBSnmpAddressList(Map<String, IfCollector> collectorMap, IfSnmpCollector snmpc) {
        List<InetAddress> addresses = new ArrayList<InetAddress>();

        // Verify that we have SNMP info
        if (snmpc == null) {
            log().debug("buildLBSnmpAddressList: no SNMP info available...");
            return addresses;
        }
        if (!snmpc.hasIfTable()) {
            log().debug("buildLBSnmpAddressList: no SNMP ifTable available...");
            return addresses;
        }

        /*
         * To be eligible to be the primary SNMP interface for a node:
         * 
         * 1. The interface must support SNMP
         * 2. The interface must have a valid ifIndex.
         */
        Collection<IfCollector> values = collectorMap.values();
        Iterator<IfCollector> iter = values.iterator();
        while (iter.hasNext()) {
            IfCollector ifc = iter.next();

            // Add eligible target.
            InetAddress ifaddr = ifc.getTarget();

            if (addresses.contains(ifaddr) == false) {
                if (SuspectEventProcessor.supportsSnmp(ifc.getSupportedProtocols()) && SuspectEventProcessor.hasIfIndex(ifaddr, snmpc) && SuspectEventProcessor.getIfType(ifaddr, snmpc) == 24) {
                    if (log().isDebugEnabled()) {
                        log().debug("buildLBSnmpAddressList: adding target interface " + str(ifaddr) + " temporarily marked as primary!");
                    }
                    addresses.add(ifaddr);
                }
            }

            // Now go through list of sub-targets
            if (ifc.hasAdditionalTargets()) {
                Map<InetAddress, List<SupportedProtocol>> subTargets = ifc.getAdditionalTargets();
                for(InetAddress xifaddr : subTargets.keySet()) {

                    if (addresses.contains(xifaddr) == false) {
                        if (SuspectEventProcessor.supportsSnmp(subTargets.get(xifaddr)) && SuspectEventProcessor.hasIfIndex(xifaddr, snmpc) && SuspectEventProcessor.getIfType(xifaddr, snmpc) == 24) {
                            if (log().isDebugEnabled()) {
                                log().debug("buildLBSnmpAddressList: adding subtarget interface " + str(xifaddr) + " temporarily marked as primary!");
                            }
                            addresses.add(xifaddr);
                        }
                    }
                }
            }
        }

        return addresses;
    }

