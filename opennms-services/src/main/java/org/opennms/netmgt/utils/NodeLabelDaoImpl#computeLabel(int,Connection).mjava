    /**
     * This method determines what label should be associated with a particular
     * node.
     *
     * Algorithm for determining a node's label is as follows: 1) If node has a
     * NetBIOS name associated with it, the NetBIOS name is used as the node's
     * label. 2) If no NetBIOS name available, retrieve all the 'ipinterface'
     * table entries associated with the node with an 'isManaged' field value of
     * 'M' 3) Find the primary interface where "primary" is defined as the
     * managed interface with the smallest IP address (each IP address is
     * converted to an integer value -- the IP address with the smallest integer
     * value wins). 4) IF the primary interface's IP host name is known it
     * becomes the node's label. ELSE IF the node's MIB-II sysName value is
     * known it becomes the node's label ELSE the primary interface's IP address
     * becomes the node's label.
     *
     * NOTE: If for some reason a node has no "managed" interfaces null is
     * returned for the NodeLabel.
     *
     * @param nodeID
     *            Unique identifier of the node to be updated.
     * @param dbConnection
     *            SQL database connection
     * @return NodeLabel Object containing label and source values or null if
     *         node does not have a primary interface.
     * @throws java.sql.SQLException if any.
     * 
     * @deprecated Update this to use modern DAO methods instead of raw SQL
     */
    @Override
    public NodeLabel computeLabel(final int nodeID, final Connection dbConnection) throws SQLException {
        // Issue SQL query to retrieve NetBIOS name associated with the node
        String netbiosName = null;
        
        OnmsNode node = nodeDao.get(nodeID);
        
        netbiosName = node.getNetBiosName();
        
        if (netbiosName != null) {
        	// Truncate sysName if it exceeds max node label length
            if (netbiosName.length() > MAX_NODE_LABEL_LENGTH) {
                netbiosName = netbiosName.substring(0, MAX_NODE_LABEL_LENGTH);
            }
            return new NodeLabelJDBCImpl(netbiosName, NodeLabelSource.NETBIOS);
        }
        
        LOG.debug("NodeLabel.computeLabel: returning NetBIOS name as nodeLabel: {}", netbiosName);
                    
        // OK, if we get this far the node has no NetBIOS name associated with it so,
        // retrieve the primary interface select method property which indicates
        // the method to use for determining which interface on a multi-interface
        // system is to be deemed the primary interface. The primary interface
        // will then determine what the node's label is.
        String method = System.getProperty(NodeLabelJDBCImpl.PROP_PRIMARY_INTERFACE_SELECT_METHOD);
        if (method == null) {
            method = DEFAULT_SELECT_METHOD;
        }

        if (!method.equals(SELECT_METHOD_MIN) && !method.equals(SELECT_METHOD_MAX)) {
		LOG.warn("Interface selection method is '{}'.  Valid values are 'min' & 'max'.  Will use default value: {}", method, DEFAULT_SELECT_METHOD);
            method = DEFAULT_SELECT_METHOD;
        }

        List<InetAddress> ipv4AddrList = new ArrayList<InetAddress>();
        List<String> ipHostNameList = new ArrayList<String>();

        final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsIpInterface.class)
        .setAliases(Arrays.asList(new Alias[] {
            new Alias("ipInterfaces","ipInterfaces", JoinType.LEFT_JOIN)
        }))
        .addRestriction(new EqRestriction("ipInterfaces.nodeId", nodeID))
        .addRestriction(new EqRestriction("ipInterfaces.isManaged", "M"));
        
        List<OnmsIpInterface> ints = ipInterfaceDao.findMatching(criteria);
        
        for (OnmsIpInterface one: ints) {
        	InetAddress inetAddr = one.getIpAddress();
        	ipv4AddrList.add(inetAddr);
        	String hostName = one.getIpHostName();
        	if (hostName == null || hostName.equals(inetAddr.toString()))
                ipHostNameList.add("");
            else
                ipHostNameList.add(hostName);
        }
        
        InetAddress primaryAddr = selectPrimaryAddress(ipv4AddrList, method);

        // Make sure we found a primary address!!!
        // If no primary address was found it means that this node has no
        // managed interfaces. So lets go after all the non-managed interfaces
        // and select the primary interface from them.
        if (primaryAddr == null) {
        	LOG.debug("NodeLabel.computeLabel: unable to find a primary address for node {}, returning null", nodeID);

            ipv4AddrList.clear();
            ipHostNameList.clear();
            
            final org.opennms.core.criteria.Criteria crit = new org.opennms.core.criteria.Criteria(OnmsIpInterface.class)
            .setAliases(Arrays.asList(new Alias[] {
                new Alias("ipInterfaces","ipInterfaces", JoinType.LEFT_JOIN)
            }))
            .addRestriction(new EqRestriction("ipInterfaces.nodeId", nodeID))
            .addRestriction(new NeRestriction("ipInterfaces.isManaged", "M"));
            
            List<OnmsIpInterface> sec = ipInterfaceDao.findMatching(crit);
            
            for (OnmsIpInterface two : sec) {
            	InetAddress inetAddr = two.getIpAddress();
            	ipv4AddrList.add(inetAddr);
            	String hostName = two.getIpHostName();
            	if (hostName == null || hostName.equals(inetAddr.toString()))
                    ipHostNameList.add("");
                else
                    ipHostNameList.add(hostName);
            	
            }

            primaryAddr = selectPrimaryAddress(ipv4AddrList, method);
        }

        if (primaryAddr == null) {
            LOG.warn("Could not find primary interface for node {}, cannot compute nodelabel", nodeID);
            return new NodeLabelJDBCImpl("Unknown", NodeLabelSource.UNKNOWN);
        }

        // We now know the IP address of the primary interface so
        // now see if it has a IP host name
        int index = ipv4AddrList.indexOf(primaryAddr);
        String primaryHostName = ipHostNameList.get(index);

        // If length of string is > 0 then the primary interface has a hostname
        if (primaryHostName.length() != 0) {
            // Truncate host name if it exceeds max node label length
            if (primaryHostName.length() > MAX_NODE_LABEL_LENGTH) {
                primaryHostName = primaryHostName.substring(0, MAX_NODE_LABEL_LENGTH);
            }

            return new NodeLabelJDBCImpl(primaryHostName, NodeLabelSource.HOSTNAME);
        }

        // If we get this far either the primary interface does not have
        // a host name or the node does not have a primary interface...
        // so we need to use the node's sysName if available...

        // retrieve sysName for the node
        String primarySysName = null;
        
        OnmsNode sysNode = nodeDao.get(nodeID);
        primarySysName = sysNode.getSysName();

        if (primarySysName != null && primarySysName.length() > 0) {
            // Truncate sysName if it exceeds max node label length
            if (primarySysName.length() > MAX_NODE_LABEL_LENGTH) {
                primarySysName = primarySysName.substring(0, MAX_NODE_LABEL_LENGTH);
            }

            return new NodeLabelJDBCImpl(primarySysName, NodeLabelSource.SYSNAME);
        }

        // If we get this far the node has no sysName either so we need to
        // use the ipAddress as the nodeLabel
        return new NodeLabelJDBCImpl(InetAddressUtils.str(primaryAddr), NodeLabelSource.ADDRESS);
    }

