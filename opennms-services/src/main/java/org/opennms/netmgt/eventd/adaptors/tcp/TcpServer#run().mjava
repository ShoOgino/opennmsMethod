    /**
     * The logic execution context to accept and process incomming connection
     * requests. When a new connection is received a new thread of control is
     * crated to process the connection. This method encapsulates that control
     * logic so that it can be executed in it's own java thread.
     */
    public void run() {
        // get the thread context for the ability to stop the process
        m_context = Thread.currentThread();
        synchronized (m_context) {
            m_context.notifyAll();
        }

        // get the log information
        ThreadCategory.setPrefix(m_logPrefix);
        
        // check to see if the thread has already been stopped.
        if (m_stop) {
            log().debug("Stop flag set on thread startup");

            try {
                if (m_tcpSock != null) {
                    m_tcpSock.close();
                }

                log().debug("The socket has been closed");
            } catch (Exception e) {
                log().warn("An exception occured closing the socket: " + e, e);
            }

            log().debug("Thread exiting");

            return;
        }

        if (log().isDebugEnabled()) {
            log().debug("Server connection processor started on port " + m_tcpPort);
        }

        /*
         *
         * Set the initial timeout on the socket. This allows
         * the thread to wakeup every 1/2 second and check the
         * shutdown status.
         */
        try {
            m_tcpSock.setSoTimeout(500);
        } catch (SocketException e) {
            if (!m_stop) {
                log().warn("An I/O exception occured setting the socket timeout: " + e, e);
            }

            if (log().isDebugEnabled()) {
                log().debug("Thread exiting due to socket error: " + e, e);
            }

            return;
        }
        
        // used to avoid seeing the trace message repeatedly
        boolean ioInterrupted = false;

        /*
         * Check the status of the fiber and respond
         * correctly. When the fiber enters a STOPPED or
         * STOP PENDING state then shutdown occurs by exiting
         * the while loop
         */
        while (m_parent.getStatus() != Fiber.STOPPED && m_parent.getStatus() != Fiber.STOP_PENDING && !m_stop) {
            try {
                if (log().isDebugEnabled() && !ioInterrupted) {
                    log().debug("Waiting for new connection");
                }

                /*
                 * Get the newbie socket connection from the client.
                 * After accepting the connection start up a thread
                 * to process the request
                 */
                Socket newbie = m_tcpSock.accept();
                ioInterrupted = false; // reset the flag

                // build a connection string for the thread identifier
                StringBuffer connection = new StringBuffer(newbie.getInetAddress().getHostAddress());
                connection.append(":").append(newbie.getPort());

                if (log().isDebugEnabled()) {
                    log().debug("New connection accepted from " + connection);
                }

                // start a new handler
                TcpStreamHandler handler = new TcpStreamHandler(m_parent, newbie, m_handlers, m_recsPerConn);
                Thread processor = new Thread(handler, m_parent.getName() + "[" + connection + "]");
                synchronized (processor) {
                    processor.start();
                    try {
                        processor.wait();
                    } catch (InterruptedException e) {
                        log().warn("The thread was interrupted: " + e, e);
                    }
                }

                log().debug("A new stream handler thread has been started");

                // add the handler to the list
                m_receivers.add(handler);
            } catch (InterruptedIOException e) {
                /*
                 * do nothing on interrupted I/O
                 * DON'T Continue, the end of the loop
                 * checks and removes terminated threads
                 */
                ioInterrupted = true;
            } catch (IOException e) {
                log().error("Server Socket I/O Error: " + e, e);
                break;
            }

            /*
             * Go through the threads in the list of
             * receivers and find the dead ones. When
             * they are no longer alive just remove them
             * from the list.
             */
            Iterator<TcpStreamHandler> i = m_receivers.iterator();
            while (i.hasNext()) {
                TcpStreamHandler t = i.next();
                if (!t.isAlive()) {
                    i.remove();
                }
            }
        }

        // Either a fatal I/O error has occured or the service has been stopped.
        try {
            log().debug("closing the server socket connection");

            m_tcpSock.close();
        } catch (Throwable t) {
            log().error("An I/O Error Occcured Closing the Server Socket: " + t, t);
        }

        // Log the termination of this runnable
        log().debug("TCP Server Shutdown");
    }

