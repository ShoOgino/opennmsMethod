    /**
     * The execution context.
     */
    public void run() {
        // get the thread context right off
        m_context = Thread.currentThread();
        synchronized (m_context) {
            m_context.notifyAll();
        }

        /*
         * Check the stop flag, if it is set then go a head and exit
         * before doing any work on the socket
         */
        if (m_stop) {
            LogUtils.debugf(this, "Stop flag set before thread startup, thread exiting");

            return;
        } else {
            LogUtils.debugf(this, "Thread started, remote is %s", InetAddressUtils.str(m_connection.getInetAddress()));
        }

        // get the input stream
        InputStream socketIn = null;
        try {
            m_connection.setSoTimeout(500); // needed in case connection closed!
            socketIn = new BufferedInputStream(m_connection.getInputStream());
        } catch (final IOException e) {
            if (!m_stop) {
                LogUtils.warnf(this, e, "An I/O Exception occured.");
            }
            m_xchange.add(e);

            LogUtils.debugf(this, "Thread exiting due to socket exception, stop flag = %s", Boolean.valueOf(m_stop));

            return;
        }

        int level = 8;
        int ch = 0;
        boolean moreInput = true;
        while (moreInput) {
            // check to see if the thread is interrupted
            if (Thread.interrupted()) {
                LogUtils.debugf(this, "Thread Interrupted");
                break;
            }

            try {
                ch = socketIn.read();
                if (ch == -1) {
                    moreInput = false;
                    continue;
                }

            } catch (final InterruptedIOException e) {
                // this was expected
                continue;
            } catch (final EOFException e) {
                m_xchange.add(e);
                moreInput = false;
                continue;
            } catch (final IOException e) {
                m_xchange.add(e);
                if (!m_stop) {
                    LogUtils.warnf(this, e, "An I/O error occured reading from the remote host.");
                }
                moreInput = false;
                continue;
            }

            try {
                level = m_tokenizer[level].next((char) ch);
            } catch (final IOException e) {
                if (!m_stop) {
                    LogUtils.warnf(this, e, "An I/O error occured writing to the processor stream.");
                    LogUtils.warnf(this, "Discarding the remainder of the event contents");
                    try {
                        /*
                         * this will discard current stream
                         * and cause all forwards to be discarded.
                         */
                        closeStream();
                    } catch (final IOException e2) {
                    }
                } else {
                    m_xchange.add(e);
                    moreInput = false;
                }
            }
        }

        // ensure that the receiver knows that no new element is coming!
        try {
            if (m_out != null) {
                m_out.close();
            }
        } catch (final IOException e) {
            if (!m_stop) {
                LogUtils.warnf(this, e, "An I/O Error occured closing the processor stream.");
            }
        }

        m_xchange.add(new EOFException("No More Input"));

        LogUtils.debugf(this, "Thread Terminated");

    }

