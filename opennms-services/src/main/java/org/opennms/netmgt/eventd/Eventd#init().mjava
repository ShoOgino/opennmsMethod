    public void init() {
        ThreadCategory.setPrefix(LOG4J_CATEGORY);
        Category log = ThreadCategory.getInstance();

        if (m_dataSource == null) {
            throw new IllegalStateException("dataSource not initialized");
        }

        // Get a database connection and create the service table map
        java.sql.Connection tempConn = null;
        try {
            tempConn = m_dataSource.getConnection();

            // create the service table map
            PreparedStatement stmt = tempConn.prepareStatement(EventdConstants.SQL_DB_SVC_TABLE_READ);
            ResultSet rset = stmt.executeQuery();
            while (rset.next()) {
                int svcid = rset.getInt(1);
                String svcname = rset.getString(2);

                m_serviceTableMap.put(svcname, new Integer(svcid));
            }

            rset.close();
            stmt.close();
        } catch (SQLException sqlE) {
            throw new UndeclaredThrowableException(sqlE);
        } finally {
            try {
                if (tempConn != null) {
                    tempConn.close();
                }
            } catch (SQLException sqlE) {
                log.warn("An error occured closing the database connection, ignoring", sqlE);
            }
        }

        // Create all the threads

        m_tcpReceiver = null;
        m_udpReceiver = null;
        try {
            String timeoutReq = m_eFactory.getSocketSoTimeoutRequired();
            m_tcpReceiver = new TcpEventReceiver(m_eFactory.getTCPPort());
            m_udpReceiver = new UdpEventReceiver(m_eFactory.getUDPPort());

            m_tcpReceiver.addEventHandler(this);
            m_udpReceiver.addEventHandler(this);

        } catch (IOException e) {
            log.error("Error starting up the TCP/UDP threads of eventd", e);
            throw new UndeclaredThrowableException(e);
        }


    }

