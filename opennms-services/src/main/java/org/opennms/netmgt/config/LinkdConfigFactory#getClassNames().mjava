	private void getClassNames() throws IOException, MarshalException,
			ValidationException {

		Category log = ThreadCategory.getInstance(LinkdConfigFactory.class);
		if (classNameLoaded)
			return;

		updateFromFile();
		oidMask2className.clear();
		List excludedOids = new ArrayList();

		Vendor[] vendors = m_linkdconfiguration.getVlans().getVendor();
		for (int i = 0; i < vendors.length; i++) {
			SnmpObjectId curRootSysOid = new SnmpObjectId(vendors[i]
					.getSysoidRootMask());
			String curClassName = vendors[i].getClassName();

			String[] specifics = vendors[i].getSpecific();
			for (int js = 0; js < specifics.length; js++) {
				SnmpObjectId oidMask = new SnmpObjectId(specifics[js]);
				oidMask.prepend(curRootSysOid);
				oidMask2className.put(oidMask.toString(), curClassName);
				if (log.isDebugEnabled())
					log.debug("getClassNames:  adding class " + curClassName
							+ " for oid " + oidMask.toString());

			}

			ExcludeRange[] excludeds = vendors[i].getExcludeRange();
			for (int je = 0; je < excludeds.length; je++) {
				SnmpObjectId snmpBeginOid = new SnmpObjectId(excludeds[je]
						.getBegin());
				SnmpObjectId snmpEndOid = new SnmpObjectId(excludeds[je]
						.getEnd());
				SnmpObjectId snmpRootOid = getRootOid(snmpBeginOid);
				if (snmpBeginOid.getLength() == snmpEndOid.getLength()
						&& snmpRootOid.isRootOf(snmpEndOid)) {
					SnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);
					while (snmpCurOid.compare(snmpEndOid) <= 0) {
						excludedOids.add(snmpCurOid.toString());
						if (log.isDebugEnabled())
							log.debug("getClassNames:  signing excluded class "
									+ curClassName
									+ " for oid "
									+ curRootSysOid.toString().concat(
											snmpCurOid.toString()));
						int lastCurCipher = snmpCurOid.getLastIdentifier();
						lastCurCipher++;
						int[] identifiers = snmpCurOid.getIdentifiers();
						identifiers[identifiers.length - 1] = lastCurCipher;
						snmpCurOid.setIdentifiers(identifiers);
					}
				}
			}

			IncludeRange[] includeds = vendors[i].getIncludeRange();
			for (int ji = 0; ji < includeds.length; ji++) {
				SnmpObjectId snmpBeginOid = new SnmpObjectId(includeds[ji]
						.getBegin());
				SnmpObjectId snmpEndOid = new SnmpObjectId(includeds[ji]
						.getEnd());
				SnmpObjectId rootOid = getRootOid(snmpBeginOid);
				if (snmpBeginOid.getLength() == snmpEndOid.getLength()
						&& rootOid.isRootOf(snmpEndOid)) {
					SnmpObjectId snmpCurOid = new SnmpObjectId(snmpBeginOid);
					while (snmpCurOid.compare(snmpEndOid) <= 0) {
						if (!excludedOids.contains(snmpBeginOid.toString())) {
							SnmpObjectId oidMask = new SnmpObjectId(
									snmpBeginOid);
							oidMask.prepend(curRootSysOid);
							oidMask2className.put(oidMask.toString(),
									curClassName);
							if (log.isDebugEnabled())
								log.debug("getClassNames:  adding class "
										+ curClassName + " for oid "
										+ oidMask.toString());
						}
						int lastCipher = snmpBeginOid.getLastIdentifier();
						lastCipher++;
						int[] identifiers = snmpBeginOid.getIdentifiers();
						identifiers[identifiers.length - 1] = lastCipher;
						snmpCurOid.setIdentifiers(identifiers);
					}
				}
			}
		}
		classNameLoaded = true;
	}

