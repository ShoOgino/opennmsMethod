    /**
     * Combine specific and range elements so that AMIPeerFactory has to spend
     * less time iterating all these elements.
     * TODO This really should be pulled up into PeerFactory somehow, but I'm not sure how (given that "Definition" is different for both
     * Snmp and AMI.  Maybe some sort of visitor methodology would work.  The basic logic should be fine as it's all IP address manipulation
     *
     * @throws UnknownHostException
     */
    private void optimize() throws UnknownHostException {
        getWriteLock().lock();
        
        try {
            // First pass: Remove empty definition elements
            for (final Iterator<Definition> definitionsIterator = m_config.getDefinitionCollection().iterator(); definitionsIterator.hasNext();) {
                final Definition definition = definitionsIterator.next();
                if (definition.getSpecificCount() == 0
                    && definition.getRangeCount() == 0) {
                    LogUtils.debugf(this, "optimize: Removing empty definition element");
                    definitionsIterator.remove();
                }
            }
    
            // Second pass: Replace single IP range elements with specific elements
            for (Definition definition : m_config.getDefinitionCollection()) {
                for (Iterator<Range> rangesIterator = definition.getRangeCollection().iterator(); rangesIterator.hasNext();) {
                    Range range = rangesIterator.next();
                    if (range.getBegin().equals(range.getEnd())) {
                        definition.addSpecific(range.getBegin());
                        rangesIterator.remove();
                    }
                }
            }
    
            // Third pass: Sort specific and range elements for improved XML
            // readability and then combine them into fewer elements where possible
            for (final Definition definition : m_config.getDefinitionCollection()) {
                // Sort specifics
                final TreeMap<Integer,String> specificsMap = new TreeMap<Integer,String>();
                for (final String specific : definition.getSpecificCollection()) {
                    specificsMap.put(new Integer(new IPv4Address(specific).getAddress()), specific.trim());
                }
    
                // Sort ranges
                final TreeMap<Integer,Range> rangesMap = new TreeMap<Integer,Range>();
                for (final Range range : definition.getRangeCollection()) {
                    rangesMap.put(new IPv4Address(range.getBegin()).getAddress(), range);
                }
    
                // Combine consecutive specifics into ranges
                Integer priorSpecific = null;
                Range addedRange = null;
                for (final Integer specific : specificsMap.keySet()) {
                    if (priorSpecific == null) {
                        priorSpecific = specific;
                        continue;
                    }
    
                    final int specificInt = specific.intValue();
                    final int priorSpecificInt = priorSpecific.intValue();
    
                    if (specificInt == priorSpecificInt + 1) {
                        if (addedRange == null) {
                            addedRange = new Range();
                            addedRange.setBegin(IPv4Address.addressToString(priorSpecificInt));
                            rangesMap.put(priorSpecific, addedRange);
                            specificsMap.remove(priorSpecific);
                        }
    
                        addedRange.setEnd(IPv4Address.addressToString(specificInt));
                        specificsMap.remove(specific);
                    }
                    else {
                        addedRange = null;
                    }
    
                    priorSpecific = specific;
                }
    
                // Move specifics to ranges
                for (final Integer specific : new ArrayList<Integer>(specificsMap.keySet())) {
                    final int specificInt = specific.intValue();
                    for (final Integer begin : new ArrayList<Integer>(rangesMap.keySet())) {
                        final int beginInt = begin.intValue();
    
                        if (specificInt < beginInt - 1) {
                            continue;
                        }
    
                        final Range range = rangesMap.get(begin);
    
                        final int endInt = new IPv4Address(range.getEnd()).getAddress();
    
                        if (specificInt > endInt + 1)
                            continue;
    
                        if (specificInt >= beginInt && specificInt <= endInt) {
                            specificsMap.remove(specific);
                            break;
                        }
    
                        if (specificInt == beginInt - 1) {
                            rangesMap.remove(begin);
                            rangesMap.put(specific, range);
                            range.setBegin(IPv4Address.addressToString(specificInt));
                            specificsMap.remove(specific);
                            break;
                        }
    
                        if (specificInt == endInt + 1) {
                            range.setEnd(IPv4Address.addressToString(specificInt));
                            specificsMap.remove(specific);
                            break;
                        }
                    }
                }
    
                // Combine consecutive ranges
                Range priorRange = null;
                int priorBegin = 0;
                int priorEnd = 0;
                for (final Iterator<Integer> rangesIterator = rangesMap.keySet().iterator(); rangesIterator.hasNext();) {
                    final Integer rangeKey = rangesIterator.next();
                    final Range range = rangesMap.get(rangeKey);
                    final int begin = rangeKey.intValue();
                    final int end = new IPv4Address(range.getEnd()).getAddress();
    
                    if (priorRange != null) {
                        if (begin - priorEnd <= 1) {
                            priorRange.setBegin(IPv4Address.addressToString (Math.min(priorBegin, begin)));
                            priorRange.setEnd(IPv4Address.addressToString (Math.max(priorEnd, end)));
    
                            rangesIterator.remove();
                            continue;
                        }
                    }
    
                    priorRange = range;
                    priorBegin = begin;
                    priorEnd = end;
                }
    
                // Update changes made to sorted maps
                definition.setSpecific(specificsMap.values().toArray(new String[0]));
                definition.setRange(rangesMap.values().toArray(new Range[0]));
            }
        } finally {
            getWriteLock().unlock();
        }
    }

