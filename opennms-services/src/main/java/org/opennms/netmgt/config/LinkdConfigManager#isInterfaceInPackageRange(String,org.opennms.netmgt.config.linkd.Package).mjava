    public boolean isInterfaceInPackageRange(final String iface, final org.opennms.netmgt.config.linkd.Package pkg) {
        if (pkg == null) return false;

        //
        // Ensure that the interface is in the specific list or
        // that it is in the include range and is not excluded
        //
        boolean has_specific = false;
        boolean has_range_include = false;
        boolean has_range_exclude = false;
 
        getReadLock().lock();
        try {
            byte[] addr = InetAddressUtils.toIpAddrBytes(iface);
    
            // if there are NO include ranges then treat act as if the user include
            // the range 0.0.0.0 - 255.255.255.255
            has_range_include = pkg.getIncludeRangeCount() == 0 && pkg.getSpecificCount() == 0;
    
            // Specific wins; if we find one, return immediately.
            for (final String spec : pkg.getSpecificCollection()) {
                final byte[] speca = InetAddressUtils.toIpAddrBytes(spec);
                if (new ByteArrayComparator().compare(addr, speca) == 0) {
                    has_specific = true;
                    break;
                }
            }
            if (has_specific) return true;
    
            for (final String url : pkg.getIncludeUrlCollection()) {
                has_specific = isInterfaceInUrl(iface, url);
                if (has_specific) break;
            }
            if (has_specific) return true;
    
            if (!has_range_include) {
                for (final IncludeRange rng : pkg.getIncludeRangeCollection()) {
                    if (InetAddressUtils.isInetAddressInRange(iface, rng.getBegin(), rng.getEnd())) {
                        has_range_include = true;
                        break;
                    }
                }
            }
    
            for (final ExcludeRange rng : pkg.getExcludeRangeCollection()) {
                if (InetAddressUtils.isInetAddressInRange(iface, rng.getBegin(), rng.getEnd())) {
                    has_range_exclude = true;
                    break;
                }
            }
    
            return has_range_include && !has_range_exclude;
        } finally {
            getReadLock().unlock();
        }
    }

