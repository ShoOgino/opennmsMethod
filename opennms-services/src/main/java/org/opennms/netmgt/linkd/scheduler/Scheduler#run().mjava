	/**
	 * The main method of the scheduler. This method is responsible for checking
	 * the runnable queues for ready objects and then enqueuing them into the
	 * thread pool for execution.
	 *  
	 */
	public void run() {
		Category log = ThreadCategory.getInstance(getClass());

		synchronized (this) {
			m_status = RUNNING;
		}

		if (log.isDebugEnabled())
			log.debug("run: scheduler running");

		// Loop until a fatal exception occurs or until
		// the thread is interrupted.
		//
		for (;;) {
			// block if there is nothing in the queue(s)
			// When something is added to the queue it
			// signals us to wakeup
			//
			synchronized (this) {
				if (m_status != RUNNING && m_status != PAUSED
						&& m_status != PAUSE_PENDING
						&& m_status != RESUME_PENDING) {
					if (log.isDebugEnabled())
						log.debug("run: status = " + m_status
								+ ", time to exit");
					break;
				}

				if (m_scheduled == 0) {
					try {
						if (log.isDebugEnabled())
							log
									.debug("run: no interfaces scheduled, waiting...");
						wait();
					} catch (InterruptedException ex) {
						break;
					}
				}
			}

			// cycle through the queues checking for
			// what's ready to run. The queues are keyed
			// by the interval, but the mapped elements
			// are peekable fifo queues.
			//
			int runned = 0;
			FifoQueue out = m_runner.getRunQueue();
			synchronized (m_queues) {
				// get an iterator so that we can cycle
				// through the queue elements.
				//
				Iterator iter = m_queues.keySet().iterator();
				while (iter.hasNext()) {
					// Peak for Runnable objects until
					// there are no more ready runnables
					//
					// Also, only go through each queue once!
					// if we didn't add a count then it would
					// be possible to starve other queues.
					//
					Long key = (Long) iter.next();
					PeekableFifoQueue in = m_queues.get(key);
					if (in.isEmpty()) {
						continue;
					}
					ReadyRunnable readyRun = null;
					int maxLoops = in.size();
					do {
						try {
							readyRun = (ReadyRunnable) in.peek();
							if (readyRun != null && readyRun.isReady()) {
								if (log.isDebugEnabled()) {
									log.debug("run: found ready runnable "
											+ readyRun.getInfo());
								}

								// Pop the interface/readyRunnable from the
								// queue for execution.
								//
								in.remove();

								// Add runnable to the execution queue
								out.add(readyRun);
								++runned;
							}
						} catch (InterruptedException ex) {
							return; // jump all the way out
						} catch (FifoQueueException qe) {
							throw new UndeclaredThrowableException(qe);
						}
					} while (readyRun != null && readyRun.isReady()
							&& --maxLoops > 0);

				}
				
			}

			// Wait for 1 second if there were no runnables
			// executed during this loop, otherwise just
			// start over.
			//
			synchronized (this) {
				m_scheduled -= runned;
				if (runned == 0) {
					try {
						wait(1000);
					} catch (InterruptedException ex) {
						break; // exit for loop
					}
				}
			}

		} // end for(;;)

		if (log.isDebugEnabled())
			log.debug("run: scheduler exiting, state = STOPPED");
		synchronized (this) {
			m_status = STOPPED;
		}

	} // end run

