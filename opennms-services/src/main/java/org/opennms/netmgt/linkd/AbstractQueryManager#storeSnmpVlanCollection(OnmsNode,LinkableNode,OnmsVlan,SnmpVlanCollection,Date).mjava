    protected void storeSnmpVlanCollection(final OnmsNode onmsNode, final LinkableNode node, final OnmsVlan vlan, final SnmpVlanCollection snmpVlanColl, final Date scanTime) {


        if (!snmpVlanColl.hasDot1dBase()) {
            LogUtils.debugf(this, "storeSnmpVlanCollection: No Bridge MIB informations found for Vlan: %s. Skipping...", vlan.getVlanName());
            return;
        }

        processDot1dBaseAndDot1dStp(onmsNode, node, vlan, snmpVlanColl,
				scanTime);
        
        if (snmpVlanColl.hasDot1dBasePortTable()) {
            processDot1dBasePortAndStpPortTables(onmsNode, node, vlan,
					snmpVlanColl, scanTime);
        }
        
        if (snmpVlanColl.hasDot1dTpFdbTable()) {
            processDot1DTpFdbTable(node, vlan, snmpVlanColl, scanTime);
        }

        if (snmpVlanColl.hasQBridgeDot1dTpFdbTable()) {
            processQBridgeDot1dTpFdbTable(node, vlan, snmpVlanColl);
        }

        for (final String physaddr : getPhysAddrs(node.getNodeId())) {
            LogUtils.debugf(this, "storeSnmpVlanCollection: Try to add Bridge Identifier \"%s\" for node %d", physaddr, node.getNodeId());                       
            if (physaddr == null || physaddr.equals("") || physaddr.equals("000000000000")) continue;
            LogUtils.infof(this, "storeSnmpVlanCollection: Adding Bridge Identifier %s for node %d", physaddr, node.getNodeId());                       
            node.addBridgeIdentifier(physaddr);
        }

    }

