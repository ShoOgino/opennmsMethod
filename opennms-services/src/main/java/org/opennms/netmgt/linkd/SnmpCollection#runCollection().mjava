    private void runCollection() {

        EventBuilder builder = new EventBuilder(
                                                "uei.opennms.org/internal/linkd/nodeLinkDiscoveryStarted",
                                                "Linkd");
        builder.setNodeid(m_nodeid);
        builder.setInterface(m_address);
        m_linkd.getEventForwarder().sendNow(builder.getEvent());

        final String hostAddress = str(m_address);

        m_ipNetToMedia = new IpNetToMediaTable(m_address);

        m_CdpCache = new CdpCacheTable(m_address);

        m_lldpLocalGroup = new LldpLocalGroup(m_address);

        m_lldpRemTable = new LldpRemTable(m_address);

        m_lldpLocTable = new LldpLocTable(m_address);

        LogUtils.debugf(this, "run: collecting : %s", m_agentConfig);

        SnmpWalker walker = null;

        boolean collectIpRouteTable = m_collectIpRouteTable;
        if (collectIpRouteTable) {
            Class<SnmpTable<SnmpStore>> ipRouteGetter = null;
            try {
                ipRouteGetter = (Class<SnmpTable<SnmpStore>>) Class.forName(m_ipRouteClass);
            } catch (ClassNotFoundException e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " class not found ");
                collectIpRouteTable = false;
            }

            Class<?>[] classes = { InetAddress.class };
            Constructor<SnmpTable<SnmpStore>> constr = null;
            try {
                constr = ipRouteGetter.getConstructor(classes);
            } catch (Throwable e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " unable to get constructor.");
                collectIpRouteTable = false;
            }
            Object[] argum = { m_address };
            try {
                m_ipRoute = (SnmpTable<SnmpStore>) constr.newInstance(argum);
            } catch (Throwable e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " unable to invoke class.");
                collectIpRouteTable = false;
            }
        }

        boolean collectVlanTable = m_collectVlanTable;
        if (collectVlanTable) {
            Class<SnmpTable<SnmpStore>> vlanGetter = null;
            try {
                vlanGetter = (Class<SnmpTable<SnmpStore>>) Class.forName(m_vlanClass);
            } catch (ClassNotFoundException e) {
                LogUtils.warnf(this, e, "run: %s class not found",
                               m_vlanClass);
                collectVlanTable = false;
            }
            Class<?>[] classes = { InetAddress.class };
            Constructor<SnmpTable<SnmpStore>> constr = null;
            try {
                constr = vlanGetter.getConstructor(classes);
            } catch (NoSuchMethodException e) {
                LogUtils.warnf(this, e, "run: %s class has no such method",
                               m_vlanClass);
                collectVlanTable = false;
            } catch (SecurityException s) {
                LogUtils.warnf(this, s, "run: %s class security violation",
                               m_vlanClass);
                collectVlanTable = false;
            }
            Object[] argum = { m_address };
            try {
                m_vlanTable = (SnmpTable<SnmpStore>) constr.newInstance(argum);
            } catch (Throwable e) {
                LogUtils.warnf(this, e,
                               "run: unable to instantiate class %s",
                               m_vlanClass);
                collectVlanTable = false;
            }
        }

        String name = null;
        CollectionTracker[] tracker = new CollectionTracker[0];

        if (m_collectLldpTable && collectVlanTable && collectIpRouteTable
                && m_collectCdpTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_ipRoute, m_CdpCache, m_vlanTable };
        } else if (m_collectLldpTable && m_collectCdpTable
                && collectIpRouteTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/ipRouteTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_ipRoute, m_CdpCache };
        } else if (m_collectLldpTable && collectVlanTable
                && collectIpRouteTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/ipRouteTable/vlanTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_ipRoute, m_vlanTable };
        } else if (m_collectLldpTable && collectVlanTable
                && m_collectCdpTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/vlanTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_vlanTable, m_CdpCache };
        } else if (collectVlanTable && collectIpRouteTable
                && m_collectCdpTable) {
            name = "ipRouteTable/cdpCacheTable/vlanTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute,
                    m_CdpCache, m_vlanTable };
        } else if (m_collectLldpTable && collectIpRouteTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/ipRouteTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia, m_ipRoute };
        } else if (m_collectLldpTable && collectVlanTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/vlanTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_vlanTable };
        } else if (m_collectLldpTable && m_collectCdpTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia,
                    m_CdpCache };
        } else if (m_collectCdpTable && collectIpRouteTable) {
            name = "ipNetToMediaTable/ipRouteTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute,
                    m_CdpCache };
        } else if (collectVlanTable && collectIpRouteTable) {
            name = "ipNetToMediaTable/ipRouteTable/vlanTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute,
                    m_vlanTable };
        } else if (collectVlanTable && m_collectCdpTable) {
            name = "ipNetToMediaTable/vlanTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable,
                    m_CdpCache };
        } else if (m_collectLldpTable) {
            name = "lldpLocalGroup/lldpLocTable/lldpRemTable/ipNetToMediaTable";
            tracker = new CollectionTracker[] { m_lldpLocalGroup,
                    m_lldpLocTable, m_lldpRemTable, m_ipNetToMedia };
        } else if (collectIpRouteTable) {
            name = "ipNetToMediaTable/ipRouteTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute };
        } else if (collectVlanTable) {
            name = "ipNetToMediaTable/vlanTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable };
        } else if (m_collectCdpTable) {
            name = "ipNetToMediaTable/cdpCacheTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia, m_CdpCache };
        } else {
            name = "ipNetToMediaTable";
            tracker = new CollectionTracker[] { m_ipNetToMedia };
        }

        // if (name == null) {
        // LogUtils.infof(this,
        // "run: Unable to determine data to collect from %s",
        // str(m_agentConfig.getEffectiveAddress()));
        // return;
        // } else {
        LogUtils.infof(this, "run: Collecting %s from %s", name,
                       str(m_agentConfig.getEffectiveAddress()));
        // }
        walker = SnmpUtils.createWalker(m_agentConfig, name, tracker);

        walker.start();

        try {
            walker.waitFor();
        } catch (final InterruptedException e) {
            LogUtils.errorf(this, e, "run: collection interrupted, exiting");
            return;
        }

        // Log any failures
        //
        if (m_collectLldpTable && !this.hasLldpLocalGroup())
            LogUtils.infof(this,
                           "run: failed to collect lldpLocalGroup for %s",
                           hostAddress);
        if (m_collectLldpTable && !this.hasLldpLocTable())
            LogUtils.infof(this,
                           "run: failed to collect lldpLocTable for %s",
                           hostAddress);
        if (m_collectLldpTable && !this.hasLldpRemTable())
            LogUtils.infof(this,
                           "run: failed to collect lldpRemTable for %s",
                           hostAddress);
        if (!this.hasIpNetToMediaTable())
            LogUtils.infof(this,
                           "run: failed to collect ipNetToMediaTable for %s",
                           hostAddress);
        if (collectIpRouteTable && !this.hasRouteTable())
            LogUtils.infof(this,
                           "run: failed to collect ipRouteTable for %s",
                           hostAddress);
        if (m_collectCdpTable && !this.hasCdpCacheTable())
            LogUtils.infof(this,
                           "run: failed to collect dpCacheTable for %s",
                           hostAddress);
        if (collectVlanTable && !this.hasVlanTable())
            LogUtils.infof(this, "run: failed to collect VLAN for %s",
                           hostAddress);
        // Schedule SNMP VLAN collection only on VLAN.
        // If it has not VLAN collection no data download is done.

        // OnmsVlan vlan = null;

        if (this.hasVlanTable()) {
            if (!m_vlanClass.equals(CiscoVlanTable.class.getName())
                    && !m_vlanClass.equals(IntelVlanTable.class.getName())) {
                runAndSaveSnmpVlanCollection(new OnmsVlan(
                                                          TRUNK_VLAN_INDEX,
                                                          TRUNK_VLAN_NAME,
                                                          VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
            } else {
                LogUtils.debugf(this,
                                "run: start collection for %d VLAN entries",
                                getVlanTable().size());
                for (final SnmpStore ent : m_vlanTable) {
                    int vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
                    if (vlanindex == -1) {
                        LogUtils.debugf(this,
                                        "run: found null value for VLAN.");
                        continue;
                    }
                    String vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
                    if (vlanname == null)
                        vlanname = DEFAULT_VLAN_NAME;
                    Integer status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);

                    if (status == null
                            || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {
                        LogUtils.infof(this,
                                       "run: skipping VLAN %s: NOT ACTIVE or null",
                                       vlanindex);
                        continue;
                    }

                    String community = m_agentConfig.getReadCommunity();
                    LogUtils.debugf(this,
                                    "run: peer community: %s with VLAN %s",
                                    community, vlanindex);

                    Integer type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
                    if (type == null
                            || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
                        LogUtils.infof(this,
                                       "run: skipping VLAN %s NOT ETHERNET TYPE",
                                       vlanindex);
                        continue;
                    }
                    if (vlanindex != 1)
                        m_agentConfig.setReadCommunity(community + "@"
                                + vlanindex);

                    runAndSaveSnmpVlanCollection(new OnmsVlan(vlanindex,
                                                              vlanname,
                                                              status));
                    m_agentConfig.setReadCommunity(community);
                }
            }
        } else {
            runAndSaveSnmpVlanCollection(new OnmsVlan(
                                                      DEFAULT_VLAN_INDEX,
                                                      DEFAULT_VLAN_NAME,
                                                      VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
        }
        // update info in linkd used correctly by {@link DiscoveryLink}
        LogUtils.debugf(this, "run: saving collection into database for %s",
                        str(m_agentConfig.getEffectiveAddress()));

        m_linkd.updateNodeSnmpCollection(this);
        // clean memory
        // first make everything clean
        m_ipNetToMedia = null;
        m_ipRoute = null;
        m_CdpCache = null;
        m_vlanTable = null;
        m_lldpLocalGroup = null;
        m_lldpLocTable = null;
        m_lldpRemTable = null;
        m_snmpVlanCollection.clear();

        builder = new EventBuilder(
                                   "uei.opennms.org/internal/linkd/nodeLinkDiscoveryCompleted",
                                   "Linkd");
        builder.setNodeid(m_nodeid);
        builder.setInterface(m_address);
        m_linkd.getEventForwarder().sendNow(builder.getEvent());

        // reschedule itself
        reschedule();
        runned = true;
    }

