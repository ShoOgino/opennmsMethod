    private void runCollection() {

        EventBuilder builder = new EventBuilder(
                                                "uei.opennms.org/internal/linkd/nodeLinkDiscoveryStarted",
                                                "Linkd");
        builder.setNodeid(m_nodeid);
        builder.setInterface(m_address);
        m_linkd.getEventForwarder().sendNow(builder.getEvent());

        final String hostAddress = str(m_address);

        m_ipNetToMedia = new IpNetToMediaTable(m_address);

        m_CdpCache = new CdpCacheTable(m_address);

        m_lldpLocalGroup = new LldpLocalGroup(m_address);

        m_lldpRemTable = new LldpRemTable(m_address);

        m_lldpLocTable = new LldpLocTable(m_address);
        
        m_ospfGeneralGroup = new OspfGeneralGroup(m_address);
        
        m_ospfIfTable = new OspfIfTable(m_address);
        
        m_osNbrTable = new OspfNbrTable(m_address);

        LogUtils.debugf(this, "run: collecting : %s", m_agentConfig);
        LogUtils.debugf(this, "run: collectVlan/collectIpRoute/collectStp/m_collectBridge/m_collectCdp/m_collectLldp/m_collectOspf: %b/%b/%b/%b/%b/%b/%b",
                        m_collectVlan, m_collectIpRoute,
                        m_collectStp, m_collectBridge,
                        m_collectCdp,m_collectLldp,m_collectOspf);

        LogUtils.debugf(this, "run: m_saveStpNodeTable/m_saveIpRouteTable/m_saveStpInterfaceTable: %b/%b/%b",
                        m_saveStpNodeTable, m_saveIpRouteTable,
                        m_saveStpInterfaceTable);


        SnmpWalker walker = null;

        boolean collectIpRouteTable = m_collectIpRoute;
        if (collectIpRouteTable) {
            Class<SnmpTable<SnmpStore>> ipRouteGetter = null;
            try {
                ipRouteGetter = (Class<SnmpTable<SnmpStore>>) Class.forName(m_ipRouteClass);
            } catch (ClassNotFoundException e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " class not found ");
                collectIpRouteTable = false;
            }

            Class<?>[] classes = { InetAddress.class };
            Constructor<SnmpTable<SnmpStore>> constr = null;
            try {
                constr = ipRouteGetter.getConstructor(classes);
            } catch (Throwable e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " unable to get constructor.");
                collectIpRouteTable = false;
            }
            Object[] argum = { m_address };
            try {
                m_ipRoute = (SnmpTable<SnmpStore>) constr.newInstance(argum);
            } catch (Throwable e) {
                LogUtils.errorf(this, e, "run: " + m_ipRouteClass
                        + " unable to invoke class.");
                collectIpRouteTable = false;
            }
        }

        boolean collectVlanTable = m_collectVlan;
        if (collectVlanTable) {
            Class<SnmpTable<SnmpStore>> vlanGetter = null;
            try {
                vlanGetter = (Class<SnmpTable<SnmpStore>>) Class.forName(m_vlanClass);
            } catch (ClassNotFoundException e) {
                LogUtils.warnf(this, e, "run: %s class not found",
                               m_vlanClass);
                collectVlanTable = false;
            }
            Class<?>[] classes = { InetAddress.class };
            Constructor<SnmpTable<SnmpStore>> constr = null;
            try {
                constr = vlanGetter.getConstructor(classes);
            } catch (NoSuchMethodException e) {
                LogUtils.warnf(this, e, "run: %s class has no such method",
                               m_vlanClass);
                collectVlanTable = false;
            } catch (SecurityException s) {
                LogUtils.warnf(this, s, "run: %s class security violation",
                               m_vlanClass);
                collectVlanTable = false;
            }
            Object[] argum = { m_address };
            try {
                m_vlanTable = (SnmpTable<SnmpStore>) constr.newInstance(argum);
            } catch (Throwable e) {
                LogUtils.warnf(this, e,
                               "run: unable to instantiate class %s",
                               m_vlanClass);
                collectVlanTable = false;
            }
        }

        CollectionTracker[] tracker;
        int i=0;

        if (m_collectBridge) {
            i++;
        }
        if (m_collectOspf) {
            i=i+3;
        }
        if (m_collectLldp) {
            i=i+3;
        }
        if (collectIpRouteTable) {
            i++;
        }
        if (m_collectCdp) {
            i++;
        }
        if (collectVlanTable) {
            i++;
        }

        tracker = new CollectionTracker[i];
        
        i=0;
        String name = "";
        if (m_collectBridge) {
            name += "ipNetToMediaTable";
            tracker[i++] = m_ipNetToMedia;            
        }
        if (m_collectOspf) {
            if ( i > 0)
                name+="/";
            name += "ospfGeneralGroup/ospfIfTable/OspfNbrTable";
            tracker[i++] = m_ospfGeneralGroup;
            tracker[i++] = m_ospfIfTable;
            tracker[i++] = m_osNbrTable;            
        }
        if (m_collectLldp) {
            if ( i > 0)
                name+="/";
            name += "lldpLocalGroup/lldpLocTable/lldpRemTable";
            tracker[i++] = m_lldpLocalGroup;
            tracker[i++] = m_lldpLocTable;
            tracker[i++] = m_lldpRemTable;
        }
        if (collectIpRouteTable) {
            if ( i > 0)
                name+="/";
                name += "ipRouteTable";
            tracker[i++] = m_ipRoute;
        }
        if (m_collectCdp) {
            if ( i > 0)
                name+="/";
            name += "cdpCacheTable";
            tracker[i++] = m_CdpCache;
        }
        if (collectVlanTable) {
            if ( i > 0)
                name+="/";
            name += "vlanTable";
            tracker[i++] = m_vlanTable;
        }
        
        LogUtils.infof(this, "run: Collecting %s from %s", name,
                       str(m_agentConfig.getEffectiveAddress()));

        if (i > 0) {
            walker = SnmpUtils.createWalker(m_agentConfig, name, tracker);

            walker.start();

            try {
                walker.waitFor();
            } catch (final InterruptedException e) {
                LogUtils.errorf(this, e, "run: collection interrupted, exiting");
                return;
            }
        }
        // Log any failures
        //
        if (m_collectOspf && !this.hasOspfGeneralGroup())
            LogUtils.infof(this,
                           "run: failed to collect ospfGeneralGroup for %s",
                           hostAddress);
        if (m_collectOspf && !this.hasOspfIfTable())
            LogUtils.infof(this,
                           "run: failed to collect ospfIfTable for %s",
                           hostAddress);
        if (m_collectOspf && !this.hasOspfNbrTable())
            LogUtils.infof(this,
                           "run: failed to collect ospfNbrTable for %s",
                           hostAddress);
        if (m_collectLldp && !this.hasLldpLocalGroup())
            LogUtils.infof(this,
                           "run: failed to collect lldpLocalGroup for %s",
                           hostAddress);
        if (m_collectLldp && !this.hasLldpLocTable())
            LogUtils.infof(this,
                           "run: failed to collect lldpLocTable for %s",
                           hostAddress);
        if (m_collectLldp && !this.hasLldpRemTable())
            LogUtils.infof(this,
                           "run: failed to collect lldpRemTable for %s",
                           hostAddress);
        if (m_collectBridge && !this.hasIpNetToMediaTable())
            LogUtils.infof(this,
                           "run: failed to collect ipNetToMediaTable for %s",
                           hostAddress);
        if (collectIpRouteTable && !this.hasRouteTable())
            LogUtils.infof(this,
                           "run: failed to collect ipRouteTable for %s",
                           hostAddress);
        if (m_collectCdp && !this.hasCdpCacheTable())
            LogUtils.infof(this,
                           "run: failed to collect dpCacheTable for %s",
                           hostAddress);
        if (collectVlanTable && !this.hasVlanTable())
            LogUtils.infof(this, "run: failed to collect VLAN for %s",
                           hostAddress);
        // Schedule SNMP VLAN collection only on VLAN.
        // If it has not VLAN collection no data download is done.

        // OnmsVlan vlan = null;

        if (this.hasVlanTable()) {
            if (!m_vlanClass.equals(CiscoVlanTable.class.getName())
                    && !m_vlanClass.equals(IntelVlanTable.class.getName())) {
                runAndSaveSnmpVlanCollection(new OnmsVlan(
                                                          TRUNK_VLAN_INDEX,
                                                          TRUNK_VLAN_NAME,
                                                          VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
            } else {
                LogUtils.debugf(this,
                                "run: start collection for %d VLAN entries",
                                getVlanTable().size());
                for (final SnmpStore ent : m_vlanTable) {
                    int vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
                    if (vlanindex == -1) {
                        LogUtils.debugf(this,
                                        "run: found null value for VLAN.");
                        continue;
                    }
                    String vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
                    if (vlanname == null)
                        vlanname = DEFAULT_VLAN_NAME;
                    Integer status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);

                    if (status == null
                            || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {
                        LogUtils.infof(this,
                                       "run: skipping VLAN %s: NOT ACTIVE or null",
                                       vlanindex);
                        continue;
                    }

                    String community = m_agentConfig.getReadCommunity();
                    LogUtils.debugf(this,
                                    "run: peer community: %s with VLAN %s",
                                    community, vlanindex);

                    Integer type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
                    if (type == null
                            || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
                        LogUtils.infof(this,
                                       "run: skipping VLAN %s NOT ETHERNET TYPE",
                                       vlanindex);
                        continue;
                    }
                    if (vlanindex != 1)
                        m_agentConfig.setReadCommunity(community + "@"
                                + vlanindex);

                    runAndSaveSnmpVlanCollection(new OnmsVlan(vlanindex,
                                                              vlanname,
                                                              status));
                    m_agentConfig.setReadCommunity(community);
                }
            }
        } else {
            runAndSaveSnmpVlanCollection(new OnmsVlan(
                                                      DEFAULT_VLAN_INDEX,
                                                      DEFAULT_VLAN_NAME,
                                                      VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
        }
        // update info in linkd used correctly by {@link DiscoveryLink}
        LogUtils.debugf(this, "run: saving collection into database for %s",
                        str(m_agentConfig.getEffectiveAddress()));

        m_linkd.updateNodeSnmpCollection(this);
        // clean memory
        // first make everything clean
        m_ipNetToMedia = null;
        m_ipRoute = null;
        m_CdpCache = null;
        m_vlanTable = null;
        m_lldpLocalGroup = null;
        m_lldpLocTable = null;
        m_lldpRemTable = null;
        m_ospfGeneralGroup = null;
        m_ospfIfTable = null;
        m_osNbrTable = null;

        m_snmpVlanCollection.clear();

        builder = new EventBuilder(
                                   "uei.opennms.org/internal/linkd/nodeLinkDiscoveryCompleted",
                                   "Linkd");
        builder.setNodeid(m_nodeid);
        builder.setInterface(m_address);
        m_linkd.getEventForwarder().sendNow(builder.getEvent());

        // reschedule itself
        reschedule();
        runned = true;
    }

