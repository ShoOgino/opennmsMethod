    private void getLinksFromBridges() {
        if (m_bridgeNodes.size() > 0) {
            LogUtils.infof(this,
                           "run: trying to find links using MAC Address Forwarding Table");
        }

        for (final LinkableNode curNode : m_bridgeNodes.values()) {
            final int curNodeId = curNode.getNodeId();
            LogUtils.infof(this, "run: parsing bridge node with ID %d",
                           curNodeId);

            for (final Integer curBridgePort : curNode.getPortMacs().keySet()) {
                LogUtils.debugf(this,
                                "run: parsing bridge port %d with MAC address %s",
                                curBridgePort,
                                curNode.getMacAddressesOnBridgePort(curBridgePort).toString());

                if (curNode.isBackBoneBridgePort(curBridgePort)) {
                    LogUtils.debugf(this,
                                    "run: Port %d is a backbone bridge port. Skipping.",
                                    curBridgePort);
                    continue;
                }

                final int curIfIndex = curNode.getIfindex(curBridgePort);
                if (curIfIndex == -1) {
                    LogUtils.warnf(this,
                                   "run: got invalid ifIndex on bridge port %d",
                                   curBridgePort);
                    continue;
                }
                // First get the MAC addresses on bridge port

                final Set<String> macs = curNode.getMacAddressesOnBridgePort(curBridgePort);

                // Then find the bridges whose MAC addresses are learned on
                // bridge port
                final List<LinkableNode> bridgesOnPort = getBridgesFromMacs(macs);

                if (bridgesOnPort.isEmpty()) {
                    LogUtils.debugf(this,
                                    "run: no bridge info found on port %d. Saving MACs.",
                                    curBridgePort);
                    addLinks(macs, curNodeId, curIfIndex);
                } else {
                    // a bridge MAC address was found on port so you should
                    // analyze what happens
                    LogUtils.debugf(this,
                                    "run: bridge info found on port %d. Finding nearest.",
                                    curBridgePort);

                    // one among these bridges should be the node more close
                    // to the curnode, curport
                    for (final LinkableNode endNode : bridgesOnPort) {
                        final int endNodeid = endNode.getNodeId();

                        final int endBridgePort = getBridgePortOnEndBridge(curNode,
                                                                           endNode);
                        // The bridge port should be valid! This control is
                        // not properly done
                        if (endBridgePort == -1) {
                            LogUtils.warnf(this,
                                           "run: no valid port found on bridge nodeid %d for node bridge identifiers nodeid %d. Skipping.",
                                           endNodeid, curNodeId);
                            continue;
                        }

                        // Try to found a new
                        final boolean isTargetNode = isNearestBridgeLink(curNode,
                                                                         curBridgePort,
                                                                         endNode,
                                                                         endBridgePort);
                        if (!isTargetNode)
                            continue;

                        final int endIfindex = endNode.getIfindex(endBridgePort);
                        if (endIfindex == -1) {
                            LogUtils.warnf(this,
                                           "run: got invalid ifindex on designated bridge port %d",
                                           endBridgePort);
                            continue;
                        }

                        LogUtils.debugf(this,
                                        "run: backbone port found for node %d. Adding backbone port %d to bridge",
                                        curNodeId, curBridgePort);

                        curNode.addBackBoneBridgePorts(curBridgePort);
                        m_bridgeNodes.put(curNodeId, curNode);

                        LogUtils.debugf(this,
                                        "run: backbone port found for node %d. Adding to helper class backbone port bridge port %d",
                                        endNodeid, endBridgePort);

                        endNode.addBackBoneBridgePorts(endBridgePort);
                        m_bridgeNodes.put(endNodeid, endNode);

                        // finding links between two backbone ports
                        addLinks(getMacsOnBridgeLink(curNode, curBridgePort,
                                                     endNode, endBridgePort),
                                 curNodeId, curIfIndex);

                        final NodeToNodeLink lk = new NodeToNodeLink(
                                                                     curNodeId,
                                                                     curIfIndex);
                        lk.setNodeparentid(endNodeid);
                        lk.setParentifindex(endIfindex);
                        LogUtils.infof(this,
                                       "run: saving bridge link: "
                                               + lk.toString());
                        addNodetoNodeLink(lk);
                    }
                }
            }
            LogUtils.infof(this, "run: done parsing bridge node with ID %d",
                           curNodeId);
        }

        if (m_bridgeNodes.size() > 0) {
            LogUtils.infof(this,
                           "run: done finding links using MAC Address Forwarding Table");
        }

    }

