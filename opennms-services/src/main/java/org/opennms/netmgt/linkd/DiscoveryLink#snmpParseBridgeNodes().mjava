	private void snmpParseBridgeNodes() {
	    LogUtils.debugf(this, "parseBridgeNodes: searching bridge port for bridge identifier not yet already found. Iterating on bridge nodes.");
		
		List<LinkableNode> bridgenodeschanged = new ArrayList<LinkableNode>();
		Iterator<LinkableNode> ite = bridgeNodes.values().iterator();
		while (ite.hasNext()) {
			LinkableNode curNode = ite.next();
			LogUtils.debugf(this, "parseBridgeNodes: parsing bridge: %d/%s", curNode.getNodeId(), curNode.getSnmpPrimaryIpAddr());

			// get macs
			
			final List<String> macs = getNotAlreadyFoundMacsOnNode(curNode);

			if (macs.isEmpty()) continue;

			SnmpAgentConfig agentConfig = null;

			String className = null;
			
			final LinkdConfig linkdConfig = m_linkd.getLinkdConfig();
			linkdConfig.getReadLock().lock();

			try {
                boolean useVlan = linkdConfig.isVlanDiscoveryEnabled();
    			if (linkdConfig.getPackage(getPackageName()).hasEnableVlanDiscovery()) 
    				useVlan = linkdConfig.getPackage(getPackageName()).getEnableVlanDiscovery();
    			
    			if (useVlan && linkdConfig.hasClassName(curNode.getSysoid())) {
    				className = linkdConfig.getVlanClassName(curNode.getSysoid());
    			}
    
    			try {
    				agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(curNode.getSnmpPrimaryIpAddr()));
    			} catch (final UnknownHostException e) {
    			    LogUtils.errorf(this, e, "parseBridgeNodes: Failed to load snmp parameter from snmp configuration file.");
    				return;
    			}
    			
    			String community = agentConfig.getReadCommunity();
    			
    			Iterator<String> mac_ite = macs.iterator();
    			
    			while (mac_ite.hasNext()) {
    				String mac = mac_ite.next();
    				LogUtils.debugf(this, "parseBridgeNodes: parsing mac: %s", mac);
    
    				if (className != null && (className.equals("org.opennms.netmgt.linkd.snmp.CiscoVlanTable") 
    						|| className.equals("org.opennms.netmgt.linkd.snmp.IntelVlanTable"))){
    					Iterator<Vlan> vlan_ite = curNode.getVlans().iterator();
    					while (vlan_ite.hasNext()) {
    						Vlan vlan = vlan_ite.next();
    						if (vlan.getVlanStatus() != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL || vlan.getVlanType() != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
    						    LogUtils.debugf(this, "parseBridgeNodes: skipping vlan: %s", vlan.getVlanName());
    							continue;
    						}
    						agentConfig.setReadCommunity(community+"@"+vlan.getVlanIndex());
    						curNode = collectMacAddress(agentConfig, curNode, mac, vlan.getVlanIndex());
    						agentConfig.setReadCommunity(community);
    					}
    				} else {
    					int vlan = SnmpCollection.DEFAULT_VLAN_INDEX;
    					if (useVlan) vlan = SnmpCollection.TRUNK_VLAN_INDEX;
    					curNode = collectMacAddress(agentConfig, curNode, mac, vlan);
    				}
    			}
    			bridgenodeschanged.add(curNode);
			} finally {
			    linkdConfig.getReadLock().unlock();
			}
		}
		
		ite = bridgenodeschanged.iterator();
		while (ite.hasNext()) {
			LinkableNode node = ite.next();
			bridgeNodes.put(node.getNodeId(), node);
		}

	}

