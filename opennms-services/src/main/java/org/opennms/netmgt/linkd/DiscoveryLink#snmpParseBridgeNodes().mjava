	private void snmpParseBridgeNodes() {
	    LogUtils.debugf(this, "parseBridgeNodes: searching bridge port for bridge identifier not yet already found. Iterating on bridge nodes.");
		
		List<LinkableNode> bridgenodeschanged = new ArrayList<LinkableNode>();
		Iterator<LinkableNode> ite = m_bridgeNodes.values().iterator();
		while (ite.hasNext()) {
			LinkableNode curNode = ite.next();
			LogUtils.debugf(this, "parseBridgeNodes: parsing bridge: %d/%s", curNode.getNodeId(), curNode.getSnmpPrimaryIpAddr());

			// get macs
			
			final List<String> macs = getNotAlreadyFoundMacsOnNode(curNode);

			if (macs.isEmpty()) continue;

			SnmpAgentConfig agentConfig = null;

			String className = null;
			
			final LinkdConfig linkdConfig = m_linkd.getLinkdConfig();
			linkdConfig.getReadLock().lock();

			try {
                boolean useVlan = linkdConfig.isVlanDiscoveryEnabled();
    			if (linkdConfig.getPackage(getPackageName()).hasEnableVlanDiscovery()) {
    				useVlan = linkdConfig.getPackage(getPackageName()).getEnableVlanDiscovery();
    			}
    			
    			if (useVlan && linkdConfig.hasClassName(curNode.getSysoid())) {
    				className = linkdConfig.getVlanClassName(curNode.getSysoid());
    			}
    
				final InetAddress addr = InetAddressUtils.addr(curNode.getSnmpPrimaryIpAddr());
				if (addr == null) {
    			    LogUtils.errorf(this, "parseBridgeNodes: Failed to load SNMP parameter from SNMP configuration file.");
    				return;
				}
				agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(addr);
    			
    			String community = agentConfig.getReadCommunity();
    			
    			for (final String mac : macs) {
    				LogUtils.debugf(this, "parseBridgeNodes: parsing mac: %s", mac);
    
    				if (className != null && (className.equals("org.opennms.netmgt.linkd.snmp.CiscoVlanTable") 
    						|| className.equals("org.opennms.netmgt.linkd.snmp.IntelVlanTable"))){
    					Iterator<OnmsVlan> vlan_ite = curNode.getVlans().iterator();
    					while (vlan_ite.hasNext()) {
    						OnmsVlan vlan = vlan_ite.next();
    						if (vlan.getVlanStatus() != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL || vlan.getVlanType() != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
    						    LogUtils.debugf(this, "parseBridgeNodes: skipping vlan: %s", vlan.getVlanName());
    							continue;
    						}
    						agentConfig.setReadCommunity(community+"@"+vlan.getVlanId());
    						curNode = collectMacAddress(agentConfig, curNode, mac, vlan.getVlanId());
    						agentConfig.setReadCommunity(community);
    					}
    				} else {
    					int vlan = SnmpCollection.DEFAULT_VLAN_INDEX;
    					if (useVlan) vlan = SnmpCollection.TRUNK_VLAN_INDEX;
    					curNode = collectMacAddress(agentConfig, curNode, mac, vlan);
    				}
    			}
    			bridgenodeschanged.add(curNode);
			} finally {
			    linkdConfig.getReadLock().unlock();
			}
		}
		
		ite = bridgenodeschanged.iterator();
		while (ite.hasNext()) {
			LinkableNode node = ite.next();
			m_bridgeNodes.put(node.getNodeId(), node);
		}

	}

