	void deleteNode(int nid) {

		Category log = ThreadCategory.getInstance();

		SnmpCollection collection = null;
		if (log.isDebugEnabled())
			log.debug("deleteNode: deleting LinkableNode for node "
					+ nid);
		
		if (nodeid2snmpcollection.containsKey(new Integer(nid))) {
			collection = (SnmpCollection) nodeid2snmpcollection.get(new Integer(nid));
		} else log.warn("deleteNode: no snmp collection found for node " + nid);
			
		String nodekey = getLinkableNodeKey(nid);

		//test if collectionkey is the same
		if (nodekey != null) {
			if (log.isInfoEnabled())
				log.info("deleteNode: removing linkable node for nodeid " + nid + " key " + nodekey);
			synchronized (snmpprimaryip2nodes) {
				snmpprimaryip2nodes.remove(nodekey);
			}
		} else {
			if (log.isInfoEnabled())
				log.info("deleteNode: no linkable node found for nodeid " + nid);
		}

		if (collection != null) {
			// a nodeid with the same collection exists so
			// verify that rr exists if not add
			// else do nothing
			ReadyRunnable rr = m_scheduler.getReadyRunnable(collection);
			if (rr == null) {
				log.warn("deleteNode: Failed to get " + collection.getInfo() 
										+ " with nodeid "
										+ nid);
			} else {
				rr.unschedule();
			}
		}

		DbEventWriter dbwriter = new DbEventWriter(nid, DbEventWriter.ACTION_DELETE);
		dbwriter.run();

	}

