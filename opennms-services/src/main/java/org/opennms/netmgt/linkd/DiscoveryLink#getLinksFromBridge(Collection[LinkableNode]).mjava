    private void getLinksFromBridge(Collection<LinkableNode> linkableNodes) {
        Map<Integer, LinkableNode> bridgeNodes = new HashMap<Integer, LinkableNode>();
        List<String> macParsed = new ArrayList<String>();
        for (final LinkableNode linkableNode : linkableNodes) {
            LOG.debug("getLinksFromBridge: Iterating on LinkableNode's found node with nodeid/sysoid/ipaddress {}/{}/{}", linkableNode.getNodeId(),linkableNode.getSysoid(),str(linkableNode.getSnmpPrimaryIpAddr()));
            if (linkableNode.isBridgeNode()) {
                LOG.debug("getLinksFromBridge: adding to bridge node list: node with nodeid/bridgeidentifier {}/{}", linkableNode.getNodeId(),linkableNode.getBridgeIdentifiers().get(0));
                bridgeNodes.put(Integer.valueOf(linkableNode.getNodeId()),
                                  linkableNode);
            }
        }

        LOG.info("getLinksFromBridge: trying to find backbone ethernet links among {} bridges nodes using Spanning Tree Protocol", bridgeNodes.size());

        for (final LinkableNode curNode : bridgeNodes.values()) {
            final int curNodeId = curNode.getNodeId();
            final InetAddress cupIpAddr = curNode.getSnmpPrimaryIpAddr();

            LOG.info("getLinksFromBridge: parsing bridge nodeid {} IP address {} with {} VLANs", curNodeId, str(cupIpAddr), curNode.getStpInterfaces().size());

            for (final Map.Entry<Integer, List<OnmsStpInterface>> me : curNode.getStpInterfaces().entrySet()) {
                final Integer vlan = me.getKey();
                final String curBaseBridgeAddress = curNode.getBridgeIdentifier(vlan);

                LOG.debug("getLinksFromBridge: found bridge identifier {}", curBaseBridgeAddress);

                String designatedRoot = null;

                if (curNode.hasStpRoot(vlan)) {
                    designatedRoot = curNode.getStpRoot(vlan);
                } else {
                    LOG.debug("getLinksFromBridge: stp designated root bridge identifier not found. Skipping {}", curBaseBridgeAddress);
                    continue;
                }

                if (designatedRoot == null
                        || designatedRoot.equals("0000000000000000")) {
                    LOG.warn("getLinksFromBridge: stp designated root is invalid, skipping: {}", designatedRoot);
                    continue;
                }
                // check if designated
                // bridge is itself
                // if bridge is STP root bridge itself exiting
                // searching on linkablesnmpnodes

                if (curNode.isBridgeIdentifier(designatedRoot.substring(4))) {
                    LOG.debug("getLinksFromBridge: stp designated root is the bridge itself. Skipping.");
                    continue;
                }

                // Now parse STP bridge port info to get designated bridge
                LOG.debug("getLinksFromBridge: stp designated root is another bridge. {} Parsing stp interfaces", designatedRoot);

                for (final OnmsStpInterface stpIface : me.getValue()) {
                    // the bridge port number
                    final int stpbridgeport = stpIface.getBridgePort();
                    // if port is a backbone port continue
                    if (curNode.isBackBoneBridgePort(stpbridgeport)) {
                        LOG.debug("getLinksFromBridge: bridge port {} already found. Skipping.", stpbridgeport);
                        continue;
                    }

                    final String stpPortDesignatedPort = stpIface.getStpPortDesignatedPort();
                    final String stpPortDesignatedBridge = stpIface.getStpPortDesignatedBridge();

                    LOG.debug("getLinksFromBridge: parsing bridge port {} with stp designated bridge {} and stp designated port {}", stpbridgeport, stpPortDesignatedBridge, stpPortDesignatedPort);

                    if (stpPortDesignatedBridge == null
                            || stpPortDesignatedBridge.equals("0000000000000000")
                            || stpPortDesignatedBridge.equals("")) {
                        LOG.warn("getLinksFromBridge: designated bridge is invalid, skipping: {}", stpPortDesignatedBridge);
                        continue;
                    }

                    if (curNode.isBridgeIdentifier(stpPortDesignatedBridge.substring(4))) {
                        LOG.debug("getLinksFromBridge: designated bridge for port {} is bridge itself, skipping", stpbridgeport);
                        continue;
                    }

                    if (stpPortDesignatedPort == null
                            || stpPortDesignatedPort.equals("0000")) {
                        LOG.warn("getLinksFromBridge: designated port is invalid: {}. skipping", stpPortDesignatedPort);
                        continue;
                    }

                    // A Port Identifier shall be encoded as two octets,
                    // taken to represent an unsigned binary number. If
                    // two Port Identifiers are numerically compared, the
                    // lesser number denotes the Port of better priority.
                    // The more significant octet of a Port Identifier is
                    // a settable priority component that permits the
                    // relative priority of Ports on the same Bridge to be
                    // managed (17.13.7 and Clause 14). The less
                    // significant twelve bits is the Port Number
                    // expressed as an unsigned binary number. The value 0
                    // is not used as a Port Number. NOTE -- The number of
                    // bits that are considered to be part of the Port
                    // Number (12 bits) differs from the 1998 and prior
                    // versions of this standard (formerly, the priority
                    // component was 8 bits and the Port Number component
                    // also 8 bits). This change acknowledged that modern
                    // switched LAN infrastructures call for increasingly
                    // large numbers of Ports to be supported in a single
                    // Bridge. To maintain management compatibility with
                    // older implementations, the priority component is
                    // still considered, for management purposes, to be an
                    // 8-bit value, but the values that it can be set to
                    // are restricted to those where the least significant
                    // 4 bits are zero (i.e., only the most significant 4
                    // bits are settable).
                    int designatedbridgeport = 8191 & Integer.parseInt(stpPortDesignatedPort,
                                                                16);

                    // try to see if designated bridge is linkable SNMP node

                    final LinkableNode designatedNode = getNodeFromMacIdentifierOfBridgeNode(bridgeNodes.values(),stpPortDesignatedBridge.substring(4));

                    if (designatedNode == null) {
                        LOG.debug("getLinksFromBridge: no nodeid found for stp bridge address {}. Nothing to save.", stpPortDesignatedBridge);
                        continue; // no saving info if no nodeid
                    }

                    final int designatednodeid = designatedNode.getNodeId();

                    LOG.debug("getLinksFromBridge: found designated nodeid {}", designatednodeid);

                    if (!isNearestBridgeLink(bridgeNodes.values(),curNode, stpbridgeport,
                                             designatedNode,
                                             designatedbridgeport)) {
                        continue; // no saving info if no nodeid
                    }

                    // this is a backbone port so try adding to Bridge class
                    // get the ifindex on node

                    final int curIfIndex = curNode.getIfindex(stpbridgeport);

                    if (curIfIndex == -1) {
                        LOG.warn("getLinksFromBridge: got invalid ifindex on node: {}", curNode.toString());
                        continue;
                    }

                    final int designatedifindex = designatedNode.getIfindex(designatedbridgeport);

                    if (designatedifindex == -1) {
                        LOG.warn("getLinksFromBridge: got invalid ifindex on designated node: {}", designatedNode.toString());
                        continue;
                    }

                    LOG.debug("getLinksFromBridge: backbone bridge port {} found for node {}", stpbridgeport, curNodeId);

                    curNode.addBackBoneBridgePorts(stpbridgeport);
                    bridgeNodes.put(Integer.valueOf(curNodeId), curNode);

                    LOG.debug("getLinksFromBridge: backbone bridge port {} found for node {}", designatedbridgeport, designatednodeid);

                    designatedNode.addBackBoneBridgePorts(designatedbridgeport);
                    bridgeNodes.put(Integer.valueOf(designatednodeid),
                                      designatedNode);

                    LOG.debug("getLinksFromBridge: adding links on backbone found link");

                    macParsed = addLinks(macParsed, getMacsOnBridgeLink(curNode, stpbridgeport,
                                                 designatedNode,
                                                 designatedbridgeport),
                                                 curNodeId, curIfIndex,DiscoveryProtocol.bridge);

                    final NodeToNodeLink lk = new NodeToNodeLink(curNodeId,
                                                                 curIfIndex,DiscoveryProtocol.bridge);
                    lk.setNodeparentid(designatednodeid);
                    lk.setParentifindex(designatedifindex);
                    LOG.info("getLinksFromBridge: saving stp bridge link: {}", lk.toString());
                    addNodetoNodeLink(lk);
                }
            }
            LOG.info("getBackBoneLinksFromBridges: done parsing bridge with nodeid {} and ip address {} with {} VLANs", curNodeId, str(cupIpAddr), curNode.getStpInterfaces().size());
        }

        LOG.info("getLinksFromBridge: done finding backbone ethernet links among bridge nodes using Spanning Tree Protocol");

        LOG.info("getLinksFromBridge: trying to find links using MAC Address Forwarding Table");

        for (final LinkableNode curNode : bridgeNodes.values()) {
            final int curNodeId = curNode.getNodeId();
            LOG.info("getLinksFromBridge: parsing bridge node with ID {}", curNodeId);

            for (final Integer curBridgePort : curNode.getPortMacs().keySet()) {
                LOG.debug("getLinksFromBridge: parsing bridge port {} with MAC address {}", curBridgePort, curNode.getMacAddressesOnBridgePort(curBridgePort).toString());

                if (curNode.isBackBoneBridgePort(curBridgePort)) {
                    LOG.debug("getLinksFromBridge: Port {} is a backbone bridge port. Skipping.", curBridgePort);
                    continue;
                }

                final int curIfIndex = curNode.getIfindex(curBridgePort);
                
                // TT2295 save also ifindex -1 links
                if (curIfIndex == -1) {
                    LOG.warn("getLinksFromBridge: got invalid ifIndex on bridge port {}", curBridgePort);
                //    continue;
                }
                // First get the MAC addresses on bridge port

                final Set<String> macs = curNode.getMacAddressesOnBridgePort(curBridgePort);

                // Then find the bridges whose MAC addresses are learned on
                // bridge port
                final List<LinkableNode> bridgesOnPort = getBridgesFromMacs(bridgeNodes.values(),macs);

                if (bridgesOnPort.isEmpty()) {
                    LOG.debug("getLinksFromBridge: no bridges macs found on port {}. Saving MACs.", curBridgePort);
                    macParsed = addLinks(macParsed,macs, curNodeId, curIfIndex,DiscoveryProtocol.bridge);
                    continue;
                } 
                // a bridge MAC address was found on port so you should
                // analyze what happens
                LOG.debug("getLinksFromBridge: bridges macs found on port {}. Searching nearest.", curBridgePort);

                // one among these bridges should be the node more close
                // to the curnode, curport
                for (final LinkableNode endNode : bridgesOnPort) {
                    final int endNodeid = endNode.getNodeId();
                    if (curNodeId == endNodeid) {
                        LOG.debug("getLinksFromBridge: curnode and target node are the same. Skipping.");
                        continue;
                    }
                    final int endBridgePort = getBridgePortOnEndBridge(curNode,
                                                                       endNode);
                    // The bridge port should be valid! This control is
                    // not properly done
                    if (endBridgePort == -1) {
                        LOG.warn("getLinksFromBridge: no valid port found on bridge nodeid {} for node bridge identifiers nodeid {}. Skipping.", endNodeid, curNodeId);
                        continue;
                    }

                    // Try to found a new
                    final boolean isTargetNode = isNearestBridgeLink(bridgeNodes.values(),curNode,
                                                                     curBridgePort,
                                                                     endNode,
                                                                     endBridgePort);
                    if (!isTargetNode)
                        continue;

                    final int endIfindex = endNode.getIfindex(endBridgePort);
                    if (endIfindex == -1) {
                        LOG.warn("getLinksFromBridge: got invalid ifindex on designated bridge port {}", endBridgePort);
                        continue;
                    }

                    LOG.debug("getLinksFromBridge: backbone port found for node {}. Adding backbone bridge port {}", curNodeId, curBridgePort);

                    curNode.addBackBoneBridgePorts(curBridgePort);
                    bridgeNodes.put(curNodeId, curNode);

                    LOG.debug("getLinksFromBridge: backbone port found for node {}. Adding to backbone bridge port {}", endNodeid, endBridgePort);

                    endNode.addBackBoneBridgePorts(endBridgePort);
                    bridgeNodes.put(endNodeid, endNode);

                    // finding links between two backbone ports
                    // FIXME no criteria....check the rules
                    macParsed = addLinks(macParsed,getMacsOnBridgeLink(curNode, curBridgePort,
                                                 endNode, endBridgePort),
                                                 curNodeId, curIfIndex,DiscoveryProtocol.bridge);

                    final NodeToNodeLink lk = new NodeToNodeLink(
                                                                 curNodeId,
                                                                 curIfIndex, DiscoveryProtocol.bridge);
                    lk.setNodeparentid(endNodeid);
                    lk.setParentifindex(endIfindex);
                    LOG.info("getLinksFromBridge: saving bridge link: {}", lk.toString());
                    addNodetoNodeLink(lk);
                }
            }
            LOG.info("getLinksFromBridge: done parsing bridge node with ID {}", curNodeId);
        }

        LOG.info("getLinksFromBridges: done finding links using MAC Address Forwarding Table");

    }

