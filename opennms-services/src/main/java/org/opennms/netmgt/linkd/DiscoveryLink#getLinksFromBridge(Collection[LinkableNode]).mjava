    private void getLinksFromBridge(Collection<LinkableNode> linkableNodes) {
        LOG.info("getLinksFromBridge: finding links using Bridge Discovery");
        BridgeTopology topology = new BridgeTopology();
        List<LinkableNode> bridgeNodes = new ArrayList<LinkableNode>();
        for (final LinkableNode curNode : linkableNodes) {
            if (curNode.isBridgeNode()) {
                LOG.debug("getLinksFromBridge: found LinkableNode nodeid/sysoid/ipaddress {}/{}/{}",
                          curNode.getNodeId(), curNode.getSysoid(),
                          str(curNode.getSnmpPrimaryIpAddr()));
                bridgeNodes.add(curNode);
                for (Entry<Integer, String> entry: curNode.getMacIdentifiers().entrySet()) {
                	if (entry.getValue() == null || entry.getValue().equals(""))
                		continue;
                    topology.addBridgeAssociatedMac(curNode.getNodeId(), entry.getKey(),
                                                    entry.getValue());
                }
            }
        }

        for (final LinkableNode curNode : bridgeNodes) {
            final InetAddress curIpAddr = curNode.getSnmpPrimaryIpAddr();
            final Integer curNodeId = curNode.getNodeId();
            if (curNode.getStpInterfaces().size() == 0)
                LOG.info("getLinksFromBridge: no spanning tree info found on bridge with nodeid {} and ip address {}",
                         curNodeId, str(curIpAddr));
            for (final Map.Entry<Integer, List<OnmsStpInterface>> me : curNode.getStpInterfaces().entrySet()) {
                final Integer vlan = me.getKey();
                final String curBaseBridgeAddress = curNode.getBridgeIdentifier(vlan);
                LOG.info("getLinksFromBridge: parsing Spanning Tree Protocol Data:  nodeid {}, bridge identifier {}, VLAN {} with {} stp ports",
                         curNodeId, curBaseBridgeAddress, vlan,
                         curNode.getStpInterfaces().get(vlan).size());
                String designatedRoot = null;
                if (curNode.hasStpRoot(vlan)) {
                    designatedRoot = curNode.getStpRoot(vlan);
                } else {
                    LOG.info("getLinksFromBridge: bridge identifier {}, VLAN {}: stp designated root bridge identifier not found. Skipping.",
                             curBaseBridgeAddress, vlan);
                    continue;
                }
                if (designatedRoot == null
                        || designatedRoot.equals("0000000000000000")) {
                    LOG.warn("getLinksFromBridge: bridge identifier {}, VLAN {}: stp designated root {} is invalid. Skipping: {}",
                             curBaseBridgeAddress, vlan, designatedRoot);
                    continue;
                }
                if (curNode.isBridgeIdentifier(designatedRoot.substring(4))) {
                    LOG.info("getLinksFromBridge: bridge identifier {}, VLAN {}: stp designated root {} is the bridge itself. Skipping.",
                             curBaseBridgeAddress, vlan, designatedRoot);
                    continue;
                }
                LOG.info("getLinksFromBridge: bridge identifier {}, VLAN {}: stp designated root {} is another bridge. {} Parsing stp interfaces.",
                         curBaseBridgeAddress, vlan, designatedRoot);
                for (final OnmsStpInterface stpIface : me.getValue()) {
                    final int stpbridgeport = stpIface.getBridgePort();
                    final String stpPortDesignatedPort = stpIface.getStpPortDesignatedPort();
                    final String stpPortDesignatedBridge = stpIface.getStpPortDesignatedBridge();
                    LOG.info("getLinksFromBridge: bridge identifier {}, VLAN {}: parsing bridge port {} with stp designated bridge {} and stp designated port {}",
                             curBaseBridgeAddress, vlan, stpbridgeport,
                             stpPortDesignatedBridge, stpPortDesignatedPort);
                    if (stpPortDesignatedBridge == null
                            || stpPortDesignatedBridge.equals("0000000000000000")
                            || stpPortDesignatedBridge.equals("")) {
                        LOG.warn("getLinksFromBridge: bridge identifier {}, VLAN {}: designated bridge is invalid, skipping: {}",
                                 curBaseBridgeAddress, vlan,
                                 stpPortDesignatedBridge);
                        continue;
                    }
                    if (curNode.isBridgeIdentifier(stpPortDesignatedBridge.substring(4))) {
                        LOG.info("getLinksFromBridge: bridge identifier {}, VLAN {}: designated bridge for port {} is bridge itself, skipping",
                                 curBaseBridgeAddress, vlan, stpbridgeport);
                        continue;
                    }
                    if (stpPortDesignatedPort == null
                            || stpPortDesignatedPort.equals("0000")) {
                        LOG.warn("getLinksFromBridge: bridge identifier {}, VLAN {}: designated port is invalid: {}. skipping",
                                 curBaseBridgeAddress, vlan,
                                 stpPortDesignatedPort);
                        continue;
                    }
                    int designatedbridgeport = 8191 & Integer.parseInt(stpPortDesignatedPort,
                                                                       16);
                    final LinkableNode designatedNode = getNodeFromMacIdentifierOfBridgeNode(linkableNodes,
                                                                                             stpPortDesignatedBridge.substring(4));
                    if (designatedNode == null) {
                        LOG.debug("getLinksFromBridge: bridge identifier {}, VLAN {}: no nodeid found for stp designated bridge address {}. Nothing to save.",
                                  curBaseBridgeAddress, vlan,
                                  stpPortDesignatedBridge);
                        continue; // no saving info if no nodeid
                    }
                    topology.parseSTPEntry(curNodeId,
                                           stpbridgeport,
                                           curNode.getBridgeForwadingTableOnBridgePort(stpbridgeport),
                                           designatedNode.getNodeId(),
                                           designatedbridgeport,
                                           designatedNode.getBridgeForwadingTableOnBridgePort(designatedbridgeport));
                }
            }

        }

        for (final LinkableNode bridgeNode : bridgeNodes) {
        	topology.addNodeToTopology(bridgeNode);
        }

        List<String> macParsed = new ArrayList<String>();
        for (BridgeTopologyLink link : topology.getTopology()) {
            Integer curNodeId = link.getBridgeTopologyPort().getNodeid();
            Integer curIfIndex = getIfIndexFromNodeidBridgePort(linkableNodes,
                                                                curNodeId,
                                                                link.getBridgeTopologyPort().getBridgePort());
            if (link.getLinkedSwitchPort() != null ) {
            	final NodeToNodeLink lk = new NodeToNodeLink(
                        curNodeId,
                        curIfIndex,
                        DiscoveryProtocol.bridge);
            	lk.setNodeparentid(link.getLinkedSwitchPort().getNodeid());
            	lk.setParentifindex(link.getLinkedSwitchPort().getIfindex());
            	addNodetoNodeLink(lk);
            	LOG.info("getLinksFromBridge: saving bridge link: {}",
                        lk.toString());
            } else {
            	macParsed = addLinks(macParsed, link.getMacs(), curNodeId,
                                 curIfIndex, DiscoveryProtocol.bridge);
	            if (link.getDesignatebridgePort() != null) {
	                Integer endNodeId = link.getDesignatebridgePort().getNodeid();
	                Integer endIfIndex = getIfIndexFromNodeidBridgePort(linkableNodes,
	                                                                    endNodeId,
	                                                                    link.getDesignatebridgePort().getBridgePort());
	                final NodeToNodeLink lk = new NodeToNodeLink(
	                                                             curNodeId,
	                                                             curIfIndex,
	                                                             DiscoveryProtocol.bridge);
	                lk.setNodeparentid(endNodeId);
	                lk.setParentifindex(endIfIndex);
	                addNodetoNodeLink(lk);
	                LOG.info("getLinksFromBridge: saving bridge link: {}",
	                         lk.toString());
	            }
            }
        }
        LOG.info("getLinksFromBridge: done finding links using Bridge Discovery");

    }

