	/**
	 * This method is useful to get forwarding table
	 * for switch who failed.
	 */
	private void parseBridgeNodes() {
	    LogUtils.debugf(this, "parseBridgeNodes: searching bridge port for bridge identifier not yet already found. Iterating on bridge nodes.");
		
		List<LinkableNode> bridgenodeschanged = new ArrayList<LinkableNode>();
		for (LinkableNode curNode : m_bridgeNodes.values()) {
			LogUtils.debugf(this, "parseBridgeNodes: parsing bridge: %d/%s", curNode.getNodeId(), curNode.getSnmpPrimaryIpAddr());

			// get macs
			
			final List<String> macs = getNotAlreadyFoundMacsOnNode(curNode);

			if (macs.isEmpty()) continue;

			SnmpAgentConfig agentConfig = null;

			String className = null;
			
			final LinkdConfig linkdConfig = m_linkd.getLinkdConfig();
			linkdConfig.getReadLock().lock();

			try {
                        boolean useVlan = linkdConfig.isVlanDiscoveryEnabled();
    			if (linkdConfig.getPackage(getPackageName()).hasEnableVlanDiscovery()) {
    				useVlan = linkdConfig.getPackage(getPackageName()).getEnableVlanDiscovery();
    			}
    			
    			if (useVlan && linkdConfig.hasClassName(curNode.getSysoid())) {
    				className = linkdConfig.getVlanClassName(curNode.getSysoid());
    			}
    
				final InetAddress addr = curNode.getSnmpPrimaryIpAddr();
				if (addr == null) {
    			    LogUtils.errorf(this, "parseBridgeNodes: Failed to load SNMP parameter from SNMP configuration file.");
    				return;
				}
				agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(addr);
    			
    			String community = agentConfig.getReadCommunity();
    			
    			for (final String mac : macs) {
    				LogUtils.debugf(this, "parseBridgeNodes: parsing MAC: %s", mac);
    
    				if (className != null && (className.equals(CiscoVlanTable.class.getName()) 
    						|| className.equals(IntelVlanTable.class.getName()))){
    					for (OnmsVlan vlan : curNode.getVlans()) {
    						if (vlan.getVlanStatus() != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL || vlan.getVlanType() != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
    						    LogUtils.debugf(this, "parseBridgeNodes: skipping VLAN: %s", vlan.getVlanName());
    							continue;
    						}
    						agentConfig.setReadCommunity(community+"@"+vlan.getVlanId());
    						curNode = collectMacAddress(this, agentConfig, curNode, mac, vlan.getVlanId());
    						agentConfig.setReadCommunity(community);
    					}
    				} else {
    					int vlan = SnmpCollection.DEFAULT_VLAN_INDEX;
    					if (useVlan) vlan = SnmpCollection.TRUNK_VLAN_INDEX;
    					curNode = collectMacAddress(this, agentConfig, curNode, mac, vlan);
    				}
    			}
    			bridgenodeschanged.add(curNode);
			} finally {
			    linkdConfig.getReadLock().unlock();
			}
		}
		
		for (LinkableNode node : bridgenodeschanged) {
			m_bridgeNodes.put(node.getNodeId(), node);
		}
	}

