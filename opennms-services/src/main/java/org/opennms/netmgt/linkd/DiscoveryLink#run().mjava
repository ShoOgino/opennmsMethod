	/**
	 * <p>
	 * Performs link discovery for the Nodes and save info in
	 * DatalinkInterface table on DataBase
	 * <p>
	 * No synchronization is performed, so if this is used in a separate thread
	 * context synchronization must be added.
	 * </p>
	 *  
	 */

	public void run() {

		if (suspendCollection) {
			log().warn("DiscoveryLink.run: Suspended!");
		} else {
			Collection<LinkableNode> all_snmplinknodes = Linkd.getInstance()
					.getLinkableNodesOnPackage(getPackageName());

			if (log().isDebugEnabled()) {
				log().debug("run: LinkableNodes/package found: " + all_snmplinknodes.size() +"/" + getPackageName());
				log().debug("run: discoveryUsingBridge/discoveryUsingCdp/discoveryUsingRoutes: " + discoveryUsingBridge+"/" + discoveryUsingCdp +"/" + discoveryUsingRoutes);
				log().debug("run: enableDownloadDiscovery: " +enableDownloadDiscovery);
			}
			Iterator<LinkableNode> ite = all_snmplinknodes.iterator();

			while (ite.hasNext()) {
				LinkableNode curNode = ite.next();
				if (log().isDebugEnabled())
					log().debug("run: Iterating on LinkableNode's found node: " + curNode.getNodeId());

				if (curNode == null) {
						log().error("run: null linkable node found for iterator " + ite);
					continue;
				}

				if (curNode.isBridgeNode && discoveryUsingBridge) {
					bridgeNodes.put(new Integer(curNode.getNodeId()), curNode);
					
				}
				if (curNode.hasCdpInterfaces() && discoveryUsingCdp) {
					cdpNodes.add(curNode);
				}
				if (curNode.hasRouteInterfaces() && discoveryUsingRoutes) {
					routerNodes.add(curNode);
				}

				if (curNode.hasAtInterfaces()) {
					atNodes.add(curNode);
				}
			}

			

			if (log().isDebugEnabled())
				log().debug("run: using atNodes to populate macToAtinterface");

			ite = atNodes.iterator();
			while (ite.hasNext()) {
				Iterator<AtInterface> at_ite = ite.next().getAtInterfaces().iterator();
				while (at_ite.hasNext()) {
					AtInterface at = at_ite.next();
					int nodeid = at.getNodeId();
					String ipaddr = at.getIpAddress();
					String macAddress = at.getMacAddress();
					if (log().isDebugEnabled()) {
						log().debug("Parsing at Interface nodeid/ipaddr/macaddr: " + nodeid + "/" + ipaddr +"/" + macAddress);
					}
					if (!Linkd.getInstance().isInterfaceInPackage(at.getIpAddress(), getPackageName())) {
						if (log().isInfoEnabled()) 
							log()
							.info("run: at interface: " + ipaddr+ " does not belong to package: " + getPackageName()+ "! Not adding to discoverable atinterface.");
						macsExcluded.add(macAddress);
						continue;
					}
					if (isMacIdentifierOfBridgeNode(macAddress)) {
						if (log().isInfoEnabled()) 
						log()
						.info("run: at interface "
								+ macAddress
								+ " belongs to bridge node! Not adding to discoverable atinterface.");
						macsExcluded.add(macAddress);
						continue;
					}
					List<AtInterface> ats = macToAtinterface.get(macAddress);
					if (ats == null) ats = new ArrayList<AtInterface>();
					if (log().isInfoEnabled()) 
						log()
						.info("parseAtNodes: Adding to discoverable atinterface.");
					ats.add(at);
					macToAtinterface.put(macAddress, ats);
					if (log().isDebugEnabled())
						log().debug("parseAtNodes: mac:" + macAddress + " has now atinterface reference: " + ats.size());
				}		
			}

			if (log().isDebugEnabled())
				log().debug("run: end populate macToAtinterface");

			//now perform operation to complete
			if (enableDownloadDiscovery) {
				if (log().isInfoEnabled())
					log().info("run: get further unknown mac address snmp bridge table info");
				snmpParseBridgeNodes();
			} else {
				if (log().isInfoEnabled())
					log().info("run: skipping get further unknown mac address snmp bridge table info");
			}

			// First of all use quick methods to get backbone ports for speeding
			// up the link discovery

			if (log().isDebugEnabled())
				log()
						.debug("run: finding links among nodes using Cisco Discovery Protocol");

			// Try Cisco Discovery Protocol to found link among all nodes
			// Add CDP info for backbones ports

			ite = cdpNodes.iterator();
			while (ite.hasNext()) {
				LinkableNode curNode = ite.next();
				int curCdpNodeId = curNode.getNodeId();
				String curCdpIpAddr = curNode.getSnmpPrimaryIpAddr();

				if (log().isDebugEnabled())
					log().debug("run: parsing nodeid " + curCdpNodeId
							+ " ip address " + curCdpIpAddr + " with "
							+ curNode.getCdpInterfaces().size()
							+ " Cdp Interfaces. ");

				Iterator<CdpInterface> sub_ite = curNode.getCdpInterfaces().iterator();
				while (sub_ite.hasNext()) {
					CdpInterface cdpIface = sub_ite.next();

					int cdpIfIndex = cdpIface.getCdpIfIndex();
					
					if (cdpIfIndex < 0) {
						log().warn("run: found not valid CDP IfIndex "
								+ cdpIfIndex + " . Skipping");
						continue;
					}

					if (log().isDebugEnabled()) log().debug("run: found CDP ifindex " + cdpIfIndex);

					InetAddress targetIpAddr = cdpIface.getCdpTargetIpAddr();
					
					if (!Linkd.getInstance().isInterfaceInPackage(targetIpAddr.getHostAddress(), getPackageName())) 
					{
						log().warn("run: ip address "
								+ targetIpAddr.getHostAddress()
								+ " Not in package: " +getPackageName()+". Skipping");
					continue;
				}

					int targetCdpNodeId = cdpIface.getCdpTargetNodeId();

					if (targetCdpNodeId == -1) {
							log().warn("run: no node id found for ip address "
									+ targetIpAddr.getHostAddress()
									+ ". Skipping");
						continue;
					}

					if (log().isDebugEnabled()) log().debug("run: found nodeid/CDP target ipaddress: " + targetCdpNodeId+ ":"+ targetIpAddr);

					if (targetCdpNodeId == curCdpNodeId) {
						if (log().isDebugEnabled())
							log().debug("run: node id found for ip address "
									+ targetIpAddr.getHostAddress()
									+ " is itself. Skipping");
						continue;
					}

					int cdpDestIfindex = cdpIface.getCdpTargetIfIndex();
					
					if (cdpDestIfindex < 0) {
						log()
								.warn("run: found not valid CDP destination IfIndex "
										+ cdpDestIfindex + " . Skipping");
						continue;
					}
					
					if (log().isDebugEnabled()) log().debug("run: found CDP target ifindex " + cdpDestIfindex);

					if (log().isDebugEnabled())
						log().debug("run: parsing CDP link: nodeid=" + curCdpNodeId
								+ " ifindex=" + cdpIfIndex + " nodeparentid="
								+ targetCdpNodeId + " parentifindex="
								+ cdpDestIfindex);

					boolean add = false;
					if (curNode.isBridgeNode() && isBridgeNode(targetCdpNodeId)) {
						LinkableNode targetNode = bridgeNodes.get(new Integer(targetCdpNodeId));
						add = parseCdpLinkOn(curNode, cdpIfIndex,targetNode, cdpDestIfindex);
						if (log().isDebugEnabled())
							log().debug("run: both node are bridge nodes! Adding: " + add);
					} else if (curNode.isBridgeNode) {
						if (log().isDebugEnabled())
							log().debug("run: source node is bridge node, target node is not bridge node! Adding: " + add);
						add = parseCdpLinkOn(curNode,cdpIfIndex,targetCdpNodeId);
					} else if (isBridgeNode(targetCdpNodeId)) {
						if (log().isDebugEnabled())
							log().debug("run: source node is not bridge node, target node is bridge node! Adding: " + add);
						LinkableNode targetNode = bridgeNodes.get(new Integer(targetCdpNodeId));
						add = parseCdpLinkOn(targetNode,cdpDestIfindex,curCdpNodeId);
					} else {
						if (log().isDebugEnabled())
							log().debug("run: no node is bridge node! Adding CDP link");
							add = true;
					}

					// now add the cdp link
					if (add) {
						NodeToNodeLink lk = new NodeToNodeLink(targetCdpNodeId,
								cdpDestIfindex);
						lk.setNodeparentid(curCdpNodeId);
						lk.setParentifindex(cdpIfIndex);
						addNodetoNodeLink(lk);
						if (log().isDebugEnabled())
							log().debug("run: CDP link added: " + lk.toString());
					}
				}
			}

			// try get backbone links between switches using STP info
			// and store information in Bridge class
			if (log().isDebugEnabled())
				log()
						.debug("run: try to found backbone ethernet links among bridge nodes using Spanning Tree Protocol");

			ite = bridgeNodes.values().iterator();

			while (ite.hasNext()) {
				LinkableNode curNode = ite.next();

				int curNodeId = curNode.getNodeId();
				String cupIpAddr = curNode.getSnmpPrimaryIpAddr();

				if (log().isDebugEnabled())
					log().debug("run: parsing bridge nodeid " + curNodeId
							+ " ip address " + cupIpAddr);

				Iterator<Map.Entry<String, List<BridgeStpInterface>>> sub_ite = curNode.getStpInterfaces().entrySet()
						.iterator();

				if (log().isDebugEnabled())
					log().debug("run: parsing "
							+ curNode.getStpInterfaces().size() + " Vlan. ");

				while (sub_ite.hasNext()) {
					Map.Entry<String, List<BridgeStpInterface>> me = sub_ite.next();
					String vlan = (String) me.getKey();
					String curBaseBridgeAddress = curNode
							.getBridgeIdentifier(vlan);

					if (log().isDebugEnabled())
						log().debug("run: found bridge identifier "
								+ curBaseBridgeAddress);

					String designatedRoot = null;
					
					if (curNode.hasStpRoot(vlan)) {
						designatedRoot = curNode.getStpRoot(vlan);
					} else {
						if (log().isDebugEnabled())
							log()
									.debug("run: desigated root bridge identifier not found. Skipping"
											+ curBaseBridgeAddress);
						continue;
					}

					if (designatedRoot.equals("0000000000000000")) {
						log().warn("run: designated root is invalid. Skipping");
						continue;
					}
					// check if designated
					// bridge is it self
					// if bridge is STP root bridge itself exiting
					// searching on linkablesnmpnodes

					if (curNode.isBridgeIdentifier(designatedRoot.substring(4))) {
						if (log().isDebugEnabled())
							log()
									.debug("run: STP designated root is the bridge itself. Skipping");
						continue;
					}

					// Now parse STP bridge port info to get designated bridge
					if (log().isDebugEnabled())
						log()
								.debug("run: STP designated root is another bridge. " + designatedRoot + " Parsing Stp Interface");

					Iterator<BridgeStpInterface> stp_ite = me.getValue().iterator();
					while (stp_ite.hasNext()) {
						BridgeStpInterface stpIface = stp_ite
								.next();

						// the bridge port number
						int stpbridgeport = stpIface.getBridgeport();
						// if port is a backbone port continue
						if (curNode.isBackBoneBridgePort(stpbridgeport)) {
							if (log().isDebugEnabled())
								log().debug("run: bridge port " + stpbridgeport
										+ " already found .... Skipping");
							continue;
						}

						String stpPortDesignatedPort = stpIface
								.getStpPortDesignatedPort();
						String stpPortDesignatedBridge = stpIface
								.getStpPortDesignatedBridge();

						if (log().isDebugEnabled())
							log().debug("run: parsing bridge port "
									+ stpbridgeport
									+ " with stp designated bridge "
									+ stpPortDesignatedBridge
									+ " and with stp designated port "
									+ stpPortDesignatedPort);

						if (stpPortDesignatedBridge.equals("0000000000000000")) {
							log().warn("run: designated bridge is invalid "
									+ stpPortDesignatedBridge);
							continue;
						}

						if (curNode.isBridgeIdentifier(stpPortDesignatedBridge
								.substring(4))) {
							if (log().isDebugEnabled())
								log().debug("run: designated bridge for port "
										+ stpbridgeport + " is bridge itself ");
							continue;
						}

						if (stpPortDesignatedPort.equals("0000")) {
							log().warn("run: designated port is invalid "
									+ stpPortDesignatedPort);
							continue;
						}

						//A Port Identifier shall be encoded as two octets,
						// taken to represent an unsigned binary number. If two
						// Port
						//Identifiers are numerically compared, the lesser
						// number denotes the Port of better priority. The more
						//significant octet of a Port Identifier is a settable
						// priority component that permits the relative priority
						// of Ports
						//on the same Bridge to be managed (17.13.7 and Clause
						// 14). The less significant twelve bits is the Port
						//Number expressed as an unsigned binary number. The
						// value 0 is not used as a Port Number.
						//NOTE -- The number of bits that are considered to be
						// part of the Port Number (12 bits) differs from the
						// 1998 and prior
						//versions of this standard (formerly, the priority
						// component was 8 bits and the Port Number component
						// also 8 bits). This
						//change acknowledged that modern switched LAN
						// infrastructures call for increasingly large numbers
						// of Ports to be
						//supported in a single Bridge. To maintain management
						// compatibility with older implementations, the
						// priority
						//component is still considered, for management
						// purposes, to be an 8-bit value, but the values that
						// it can be set to are
						//restricted to those where the least significant 4
						// bits are zero (i.e., only the most significant 4 bits
						// are settable).
						int designatedbridgeport = Integer.parseInt(
								stpPortDesignatedPort.substring(1), 16);

						// try to see if designated bridge is linkable
						// snmp node

						LinkableNode designatedNode = getNodeFromMacIdentifierOfBridgeNode(stpPortDesignatedBridge
								.substring(4));

						if (designatedNode == null) {
							log()
									.warn("run: no nodeid found for stp bridge address "
											+ stpPortDesignatedBridge
											+ " . Nothing to save to db");
							continue; // no saving info if no nodeid
						}
						
						int designatednodeid = designatedNode.getNodeId();

						if (log().isDebugEnabled())
							log().debug("run: found designated nodeid "
									+ designatednodeid);

						// test if there are other bridges between this link
						// USING MAC ADDRESS FORWARDING TABLE

						if (!isNearestBridgeLink(curNode, stpbridgeport,
								designatedNode, designatedbridgeport)) {
							if (log().isDebugEnabled())
								log()
										.debug("run: other bridge found between nodes. No links to save!");
							continue; // no saving info if no nodeid
						}

						// this is a backbone port so try adding to Bridge class
						// get the ifindex on node

						int curIfIndex = curNode.getIfindex(stpbridgeport);

						if (curIfIndex == -1) {
							log().warn("run: got invalid ifindex");
							continue;
						}

						int designatedifindex = designatedNode
						.getIfindex(designatedbridgeport);
						
						if (designatedifindex == -1) {
							log()
									.warn("run: got invalid ifindex on designated node");
							continue;
						}

						if (log().isDebugEnabled())
							log().debug("run: backbone port found for node "
									+ curNodeId + ". Adding to bridge"
									+ stpbridgeport);

						curNode.addBackBoneBridgePorts(stpbridgeport);
						bridgeNodes.put(new Integer(curNodeId), curNode);

						if (log().isDebugEnabled())
							log().debug("run: backbone port found for node "
									+ designatednodeid
									+ " .Adding to helper class bb port "
									+ " bridge port " + designatedbridgeport);

						designatedNode
								.addBackBoneBridgePorts(designatedbridgeport);
						bridgeNodes.put(new Integer(designatednodeid),
								designatedNode);
						
						if (log().isDebugEnabled())
							log().debug("run: adding links on bb bridge port " + designatedbridgeport);

						addLinks(getMacsOnBridgeLink(curNode,
								stpbridgeport, designatedNode,
								designatedbridgeport),curNodeId,curIfIndex);

						// writing to db using class
						// DbDAtaLinkInterfaceEntry
						NodeToNodeLink lk = new NodeToNodeLink(curNodeId,
								curIfIndex);
						lk.setNodeparentid(designatednodeid);
						lk.setParentifindex(designatedifindex);
						addNodetoNodeLink(lk);

					}
				}
			}

			// finding links using mac address on ports

			if (log().isDebugEnabled())
				log()
						.debug("run: try to found links using Mac Address Forwarding Table");

			ite = bridgeNodes.values().iterator();

			while (ite.hasNext()) {
				LinkableNode curNode = ite.next();
				int curNodeId = curNode.getNodeId();
				if (log().isDebugEnabled())
					log().debug("run: parsing node bridge " + curNodeId);

				Iterator<Integer> sub_ite = curNode.getPortMacs().keySet().iterator();

				while (sub_ite.hasNext()) {
					Integer intePort = sub_ite.next();
					int curBridgePort = intePort.intValue();

					if (log().isDebugEnabled())
						log().debug("run: parsing bridge port "
								+ curBridgePort
								+ " with mac addresses "
								+ curNode.getMacAddressesOnBridgePort(
										curBridgePort).toString());

					if (curNode.isBackBoneBridgePort(curBridgePort)) {
						if (log().isDebugEnabled())
							log().debug("run: parsing backbone bridge port "
									+ curBridgePort + " .... Skipping");
						continue;
					}
					
					int curIfIndex = curNode.getIfindex(curBridgePort);
					if (curIfIndex == -1) {
						log().warn("run: got invalid ifindex on bridge port "
											+ curBridgePort);
						continue;
					}
					// First get the mac addresses on bridge port

					Set<String> macs = curNode.getMacAddressesOnBridgePort(curBridgePort);

					// Then find the bridges whose mac addresses are learned on bridge port
					List<LinkableNode> bridgesOnPort = getBridgesFromMacs(macs);
					
					if (bridgesOnPort.isEmpty()) {
						if (log().isDebugEnabled())
							log().debug("run: no bridge info found on port "
									+ curBridgePort + " .... Saving Macs");
						addLinks(macs, curNodeId, curIfIndex);
					} else {
						// a bridge mac address was found on port so you should analyze what happens
						if (log().isDebugEnabled())
							log().debug("run: bridge info found on port "
									+ curBridgePort + " .... Finding nearest.");
						Iterator<LinkableNode> bridge_ite = bridgesOnPort.iterator();
						// one among these bridges should be the node more close to the curnode, curport
						while (bridge_ite.hasNext()) {
							LinkableNode endNode = bridge_ite
									.next();
							
							int endNodeid = endNode.getNodeId();
							
							int endBridgePort = getBridgePortOnEndBridge(
									curNode, endNode);
// The bridge port should be valid! This control is not properly done
							if (endBridgePort == -1) {
									log()
											.error("run: no valid port found on bridge nodeid "
													+ endNodeid
													+ " for node bridge identifiers nodeid "
													+ curNodeId
													+ " . .....Skipping");
								continue;
							}
							
							// Try to found a new 
							boolean isTargetNode = isNearestBridgeLink(
									curNode, curBridgePort, endNode,
									endBridgePort);
							if (!isTargetNode)
									continue;

							int endIfindex = endNode.getIfindex(endBridgePort);
							if (endIfindex == -1) {
								log()
										.warn("run: got invalid ifindex o designated bridge port "
												+ endBridgePort);
								break;
							}

							if (log().isDebugEnabled())
								log().debug("run: backbone port found for node "
										+ curNodeId + ". Adding backbone port "
										+ curBridgePort + " to bridge");

							curNode.addBackBoneBridgePorts(curBridgePort);
							bridgeNodes.put(new Integer(curNodeId), curNode);

							if (log().isDebugEnabled())
								log().debug("run: backbone port found for node "
										+ endNodeid
										+ " .Adding to helper class bb port "
										+ " bridge port " + endBridgePort);

							endNode.addBackBoneBridgePorts(endBridgePort);
							bridgeNodes.put(new Integer(endNodeid), endNode);

							// finding links between two backbone ports
							addLinks(getMacsOnBridgeLink(curNode,
									curBridgePort, endNode, endBridgePort),curNodeId,curIfIndex);

							NodeToNodeLink lk = new NodeToNodeLink(curNodeId,
									curIfIndex);
							lk.setNodeparentid(endNodeid);
							lk.setParentifindex(endIfindex);
							addNodetoNodeLink(lk);
							break;
						}
					}
				}
			}

			// fourth find inter router links,
			// this part could have several special function to get inter router
			// links, but at the moment we worked much on switches.
			// In future we can try to extend this part.
			if (log().isDebugEnabled())
				log()
						.debug("run: try to found  not ethernet links on Router nodes");

			ite = routerNodes.iterator();
			while (ite.hasNext()) {
				LinkableNode curNode = ite.next();
				int curNodeId = curNode.getNodeId();
				String curIpAddr = curNode.getSnmpPrimaryIpAddr();
				if (log().isDebugEnabled())
					log().debug("run: parsing router nodeid " + curNodeId
							+ " ip address " + curIpAddr);

				Iterator<RouterInterface> sub_ite = curNode.getRouteInterfaces().iterator();
				if (log().isDebugEnabled())
					log().debug("run: parsing "
							+ curNode.getRouteInterfaces().size()
							+ " Route Interface. ");

				while (sub_ite.hasNext()) {
					RouterInterface routeIface = sub_ite
							.next();

					if (log().isDebugEnabled()) {
						log().debug("run: parsing RouterInterface: " + routeIface.toString());
					}

					if (routeIface.getMetric() == -1) {
						if (log().isInfoEnabled())
							log()
									.info("run: Router interface has invalid metric "
											+ routeIface.getMetric()
											+ ". Skipping");
						continue;
					}

					if (forceIpRouteDiscoveryOnEtherNet) {
						if (log().isInfoEnabled())
							log().info("run: force ip route discovery not getting SnmpIfType");
							
					} else {
						int snmpiftype = routeIface.getSnmpiftype();
						if (log().isInfoEnabled())
							log().info("run: force ip route discovery getting SnmpIfType: " + snmpiftype);
						
						if (snmpiftype == SNMP_IF_TYPE_ETHERNET) {
							if (log().isInfoEnabled())
								log()
										.info("run: Ethernet interface for nodeid. Skipping ");
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_PROP_VIRTUAL) {
							if (log().isInfoEnabled())
								log()
										.info("run: PropVirtual interface for nodeid. Skipping ");
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_L2_VLAN) {
							if (log().isInfoEnabled())
								log()
										.info("run: Layer2 Vlan interface for nodeid. Skipping ");
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_L3_VLAN) {
							if (log().isInfoEnabled())
								log()
										.info("run: Layer3 Vlan interface for nodeid. Skipping ");
							continue;
						} else if (snmpiftype == -1) {
							if (log().isInfoEnabled())
								log().info("store: interface has unknown snmpiftype "
										+ snmpiftype + " . Skipping ");
							continue;
						} 
					}
					
					InetAddress nexthop = routeIface.getNextHop();

					if (nexthop.getHostAddress().equals("0.0.0.0")) {
						if (log().isInfoEnabled())
							log()
									.info("run: nexthop address is broadcast address "
											+ nexthop.getHostAddress()
											+ " . Skipping ");
						// FIXME this should be further analized 
						// working on routeDestNet you can find hosts that
						// are directly connected with the dest network
						// This happens when static routing is made like this:
						// route 10.3.2.0 255.255.255.0 Serial0
						// so the router broadcasts on Serial0
						continue;
					}

					if (nexthop.isLoopbackAddress()) {
						if (log().isInfoEnabled())
							log()
									.info("run: nexthop address is localhost address "
											+ nexthop.getHostAddress()
											+ " . Skipping ");
						continue;
					}

					if (!Linkd.getInstance().isInterfaceInPackage(nexthop.getHostAddress(), getPackageName())) {
						if (log().isInfoEnabled())
							log()
									.info("run: nexthop address is not in package "
											+ nexthop.getHostAddress() + "/"+getPackageName() 
											+ " . Skipping ");
						continue;
					}

					
					int nextHopNodeid = routeIface.getNextHopNodeid();

					if (nextHopNodeid == -1) {
						if (log().isInfoEnabled())
							log()
									.info("run: no node id found for ip next hop address "
											+ nexthop.getHostAddress()
											+ " , skipping ");
						continue;
					}

					if (nextHopNodeid == curNodeId) {
						if (log().isDebugEnabled())
							log()
									.debug("run: node id found for ip next hop address "
											+ nexthop.getHostAddress()
											+ " is itself, skipping ");
						continue;
					}

					int ifindex = routeIface.getIfindex();
					
					if (ifindex == 0) {
						if (log().isInfoEnabled())
							log()
									.info("run: route interface has ifindex "
											+ ifindex + " . trying to get ifindex from nextHopNet: " 
											+ routeIface.getNextHopNet());
						ifindex = getIfIndexFromRouter(curNode, routeIface.getNextHopNet());
						if (ifindex == -1 ) {
							if (log().isDebugEnabled())
								log()
										.debug("run: found not correct ifindex "
												+ ifindex + " skipping.");
							continue;
						} else {
							if (log().isDebugEnabled())
								log()
										.debug("run: found correct ifindex "
												+ ifindex + " .");
						}
						
					}
					if (log().isDebugEnabled())
						log()
								.debug("run: saving route link");
					
					// Saving link also when ifindex = -1 (not found)
					NodeToNodeLink lk = new NodeToNodeLink(nextHopNodeid,
							routeIface.getNextHopIfindex());
					lk.setNodeparentid(curNodeId);
					lk.setParentifindex(ifindex);
					addNodetoNodeLink(lk);
				}
			}

			bridgeNodes.clear();
			routerNodes.clear();
			cdpNodes.clear();
			macsParsed.clear();
			macsExcluded.clear();
			macToAtinterface.clear();
			atNodes.clear();

			Linkd.getInstance().updateDiscoveryLinkCollection(this);

			links.clear();
			maclinks.clear();
		}
		// rescheduling activities
		isRunned = true;
		reschedule();
	}

