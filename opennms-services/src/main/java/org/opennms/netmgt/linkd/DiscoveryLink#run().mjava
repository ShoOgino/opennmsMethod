	/**
	 * <p>
	 * Performs link discovery for the Nodes and save info in
	 * DatalinkInterface table on DataBase
	 * <p>
	 * No synchronization is performed, so if this is used in a separate thread
	 * context synchronization must be added.
	 * </p>
	 */
	public void run() {

		if (suspendCollection) {
		    LogUtils.warnf(this, "run: Suspended!");
		} else {
			Collection<LinkableNode> linkableNodes = m_linkd.getLinkableNodesOnPackage(getPackageName());

			LogUtils.debugf(this, "run: LinkableNodes/package found: %d/%s", linkableNodes.size(), getPackageName());
			LogUtils.debugf(this, "run: discoveryUsingBridge/discoveryUsingCdp/discoveryUsingRoutes: %b/%b/%b", discoveryUsingBridge, discoveryUsingCdp, discoveryUsingRoutes);
			LogUtils.debugf(this, "run: enableDownloadDiscovery: %b", enableDownloadDiscovery);

			for (final LinkableNode linkableNode : linkableNodes) {
				LogUtils.debugf(this, "run: Iterating on LinkableNode's found node: %d", linkableNode.getNodeId());

				if (linkableNode.isBridgeNode() && discoveryUsingBridge) {
					m_bridgeNodes.put(new Integer(linkableNode.getNodeId()), linkableNode);
				}
				if (linkableNode.hasCdpInterfaces() && discoveryUsingCdp) {
					m_cdpNodes.add(linkableNode);
				}
				if (linkableNode.hasRouteInterfaces() && discoveryUsingRoutes) {
					m_routerNodes.add(linkableNode);
				}

				if (linkableNode.hasAtInterfaces()) {
					m_atNodes.add(linkableNode);
				}
			}

			populateMacToAtInterface();

			//now perform operation to complete
			if (enableDownloadDiscovery) {
			    LogUtils.infof(this, "run: get further unknown MAC address SNMP bridge table info");
			    parseBridgeNodes();
			} else {
			    LogUtils.infof(this, "run: skipping get further unknown MAC address SNMP bridge table info");
			}

			// First of all use quick methods to get backbone ports for speeding up the link discovery
			LogUtils.debugf(this, "run: finding links among nodes using Cisco Discovery Protocol");

			// Try Cisco Discovery Protocol to found link among all nodes
			// Add CDP info for backbones ports

			for (final LinkableNode curNode : m_cdpNodes) {
				int curCdpNodeId = curNode.getNodeId();
				final InetAddress curCdpIpAddr = curNode.getSnmpPrimaryIpAddr();

				LogUtils.debugf(this, "run: parsing nodeid %d IP address %s with %d CDP interfaces.", curCdpNodeId, curCdpIpAddr, curNode.getCdpInterfaces().size());

				for (final CdpInterface cdpIface : curNode.getCdpInterfaces()) {
				    final int cdpIfIndex = cdpIface.getCdpIfIndex();
					
					if (cdpIfIndex < 0) {
					    LogUtils.warnf(this, "run: found not valid CDP IfIndex %d.  Skipping.", cdpIfIndex);
						continue;
					}

					LogUtils.debugf(this, "run: found CDP ifindex %d", cdpIfIndex);

					final InetAddress targetIpAddr = cdpIface.getCdpTargetIpAddr();
					final String hostAddress = str(targetIpAddr);

					if (!m_linkd.isInterfaceInPackage(targetIpAddr, getPackageName())) 
					{
					    LogUtils.warnf(this, "run: IP address %s Not in package: %s.  Skipping.", hostAddress, getPackageName());
					    continue;
					}

					final int targetCdpNodeId = cdpIface.getCdpTargetNodeId();

					if (targetCdpNodeId == -1) {
					    LogUtils.warnf(this, "run: no node id found for IP address %s.  Skipping.", hostAddress);
						continue;
					}

					LogUtils.debugf(this, "run: found nodeid/CDP target ipaddress: %d:%s", targetCdpNodeId, str(targetIpAddr));

					if (targetCdpNodeId == curCdpNodeId) {
					    LogUtils.debugf(this, "run: node id found for IP address %s is itself.  Skipping.", hostAddress);
						continue;
					}

					final int cdpDestIfindex = cdpIface.getCdpTargetIfIndex();
					
					if (cdpDestIfindex < 0) {
					    LogUtils.warnf(this, "run: found not valid CDP destination IfIndex %d.  Skipping.", cdpDestIfindex);
						continue;
					}

					LogUtils.debugf(this, "run: found CDP target ifindex %d", cdpDestIfindex);

					LogUtils.debugf(this, "run: parsing CDP link: nodeid=%d ifindex=%d nodeparentid=%d parentifindex=%d", curCdpNodeId, cdpIfIndex, targetCdpNodeId, cdpDestIfindex);

					boolean add = false;
					if (curNode.isBridgeNode() && isBridgeNode(targetCdpNodeId)) {
						LinkableNode targetNode = m_bridgeNodes.get(new Integer(targetCdpNodeId));
						add = parseCdpLinkOn(curNode, cdpIfIndex,targetNode, cdpDestIfindex);
						LogUtils.debugf(this, "run: both node are bridge nodes! Adding: %b", add);
					} else if (curNode.isBridgeNode()) {
					    LogUtils.debugf(this, "run: source node is bridge node, target node is not bridge node! Adding: %b", add);
						add = parseCdpLinkOn(curNode,cdpIfIndex,targetCdpNodeId);
					} else if (isBridgeNode(targetCdpNodeId)) {
					    LogUtils.debugf(this, "run: source node is not bridge node, target node is bridge node! Adding: %b", add);
						LinkableNode targetNode = m_bridgeNodes.get(new Integer(targetCdpNodeId));
						add = parseCdpLinkOn(targetNode,cdpDestIfindex,curCdpNodeId);
					} else {
					    LogUtils.debugf(this, "run: no node is bridge node! Adding CDP link");
					    add = true;
					}

					// now add the cdp link
					if (add) {
					    final NodeToNodeLink lk = new NodeToNodeLink(targetCdpNodeId, cdpDestIfindex);
						lk.setNodeparentid(curCdpNodeId);
						lk.setParentifindex(cdpIfIndex);
						addNodetoNodeLink(lk);
						LogUtils.debugf(this, "run: CDP link added: %s", lk.toString());
					}
				}
			}

			// try get backbone links between switches using STP info
			// and store information in Bridge class
			LogUtils.debugf(this, "run: try to found backbone ethernet links among bridge nodes using Spanning Tree Protocol");

			for (final LinkableNode curNode : m_bridgeNodes.values()) {
			    final int curNodeId = curNode.getNodeId();
			    final InetAddress cupIpAddr = curNode.getSnmpPrimaryIpAddr();

				LogUtils.debugf(this, "run: parsing bridge nodeid %d IP address %s", curNodeId, str(cupIpAddr));

				LogUtils.debugf(this, "run: parsing %d VLANs", curNode.getStpInterfaces().size());

				for (final Map.Entry<String,List<OnmsStpInterface>> me : curNode.getStpInterfaces().entrySet()) {
				    final String vlan = me.getKey();
				    final String curBaseBridgeAddress = curNode.getBridgeIdentifier(vlan);

					LogUtils.debugf(this, "run: found bridge identifier %s", curBaseBridgeAddress);

					String designatedRoot = null;
					
					if (curNode.hasStpRoot(vlan)) {
						designatedRoot = curNode.getStpRoot(vlan);
					} else {
					    LogUtils.debugf(this, "run: designated root bridge identifier not found. Skipping %s", curBaseBridgeAddress);
						continue;
					}

					if (designatedRoot == null || designatedRoot.equals("0000000000000000")) {
					    LogUtils.warnf(this, "run: designated root is invalid. Skipping.");
						continue;
					}
					// check if designated
					// bridge is it self
					// if bridge is STP root bridge itself exiting
					// searching on linkablesnmpnodes

					if (curNode.isBridgeIdentifier(designatedRoot.substring(4))) {
					    LogUtils.debugf(this, "run: STP designated root is the bridge itself. Skipping.");
						continue;
					}

					// Now parse STP bridge port info to get designated bridge
					LogUtils.debugf(this, "run: STP designated root is another bridge. %s Parsing STP Interface", designatedRoot);

					for (final OnmsStpInterface stpIface : me.getValue()) {
						// the bridge port number
					    final int stpbridgeport = stpIface.getBridgePort();
						// if port is a backbone port continue
						if (curNode.isBackBoneBridgePort(stpbridgeport)) {
						    LogUtils.debugf(this, "run: bridge port %d already found. Skipping.", stpbridgeport);
							continue;
						}

						final String stpPortDesignatedPort = stpIface.getStpPortDesignatedPort();
						final String stpPortDesignatedBridge = stpIface.getStpPortDesignatedBridge();

						LogUtils.debugf(this, "run: parsing bridge port %d with STP designated bridge %s and STP designated port %s", stpbridgeport, stpPortDesignatedBridge, stpPortDesignatedPort);

						if (stpPortDesignatedBridge == null || stpPortDesignatedBridge.equals("0000000000000000") || stpPortDesignatedBridge.equals("")) {
						    LogUtils.warnf(this, "run: designated bridge is invalid: %s", stpPortDesignatedBridge);
							continue;
						}

						if (curNode.isBridgeIdentifier(stpPortDesignatedBridge.substring(4))) {
						    LogUtils.debugf(this, "run: designated bridge for port %d is bridge itself", stpbridgeport);
							continue;
						}

						if (stpPortDesignatedPort == null || stpPortDesignatedPort.equals("0000")) {
						    LogUtils.warnf(this, "run: designated port is invalid: %s", stpPortDesignatedPort);
							continue;
						}

                        // A Port Identifier shall be encoded as two octets,
                        // taken to represent an unsigned binary number. If
                        // two Port Identifiers are numerically compared, the
                        // lesser number denotes the Port of better priority.
                        // The more significant octet of a Port Identifier is
                        // a settable priority component that permits the
                        // relative priority of Ports on the same Bridge to be
                        // managed (17.13.7 and Clause 14). The less
                        // significant twelve bits is the Port Number
                        // expressed as an unsigned binary number. The value 0
                        // is not used as a Port Number. NOTE -- The number of
                        // bits that are considered to be part of the Port
                        // Number (12 bits) differs from the 1998 and prior
                        // versions of this standard (formerly, the priority
                        // component was 8 bits and the Port Number component
                        // also 8 bits). This change acknowledged that modern
                        // switched LAN infrastructures call for increasingly
                        // large numbers of Ports to be supported in a single
                        // Bridge. To maintain management compatibility with
                        // older implementations, the priority component is
                        // still considered, for management purposes, to be an
                        // 8-bit value, but the values that it can be set to
                        // are restricted to those where the least significant
                        // 4 bits are zero (i.e., only the most significant 4
                        // bits are settable).
                        int designatedbridgeport = Integer.parseInt(stpPortDesignatedPort.substring(1), 16);

						// try to see if designated bridge is linkable SNMP node

                        final LinkableNode designatedNode = getNodeFromMacIdentifierOfBridgeNode(stpPortDesignatedBridge.substring(4));

						if (designatedNode == null) {
						    LogUtils.warnf(this, "run: no nodeid found for STP bridge address %s. Nothing to save.", stpPortDesignatedBridge);
							continue; // no saving info if no nodeid
						}
						
						final int designatednodeid = designatedNode.getNodeId();

						LogUtils.debugf(this, "run: found designated nodeid %d", designatednodeid);

						// test if there are other bridges between this link
						// USING MAC ADDRESS FORWARDING TABLE

						if (!isNearestBridgeLink(curNode, stpbridgeport, designatedNode, designatedbridgeport)) {
						    LogUtils.debugf(this, "run: other bridge found between nodes. No links to save!");
							continue; // no saving info if no nodeid
						}

						// this is a backbone port so try adding to Bridge class
						// get the ifindex on node

						final int curIfIndex = curNode.getIfindex(stpbridgeport);

						if (curIfIndex == -1) {
						    LogUtils.warnf(this, "run: got invalid ifindex");
							continue;
						}

						final int designatedifindex = designatedNode.getIfindex(designatedbridgeport);
						
						if (designatedifindex == -1) {
						    LogUtils.warnf(this, "run: got invalid ifindex on designated node");
							continue;
						}

						LogUtils.debugf(this, "run: backbone port found for node %d. Adding to bridge %d.", curNodeId, stpbridgeport);

						curNode.addBackBoneBridgePorts(stpbridgeport);
						m_bridgeNodes.put(new Integer(curNodeId), curNode);

						LogUtils.debugf(this, "run: backbone port found for node %d. Adding to helper class BB port bridge port %d.", designatednodeid, designatedbridgeport);

						designatedNode.addBackBoneBridgePorts(designatedbridgeport);
						m_bridgeNodes.put(new Integer(designatednodeid), designatedNode);

						LogUtils.debugf(this, "run: adding links on BB bridge port %d", designatedbridgeport);

						addLinks(getMacsOnBridgeLink(curNode, stpbridgeport, designatedNode, designatedbridgeport),curNodeId,curIfIndex);

						// writing to db using class
						// DbDAtaLinkInterfaceEntry
						final NodeToNodeLink lk = new NodeToNodeLink(curNodeId, curIfIndex);
						lk.setNodeparentid(designatednodeid);
						lk.setParentifindex(designatedifindex);
						addNodetoNodeLink(lk);

					}
				}
			}

			// finding links using MAC address on ports
			LogUtils.debugf(this, "run: try to found links using MAC Address Forwarding Table");

			for (final LinkableNode curNode : m_bridgeNodes.values()) {
			    final int curNodeId = curNode.getNodeId();
				LogUtils.debugf(this, "run: parsing node bridge %d", curNodeId);

				for (final Integer curBridgePort : curNode.getPortMacs().keySet()) {
					LogUtils.debugf(this, "run: parsing bridge port %d with MAC address %s", curBridgePort, curNode.getMacAddressesOnBridgePort(curBridgePort).toString());

					if (curNode.isBackBoneBridgePort(curBridgePort)) {
					    LogUtils.debugf(this, "run: Port %d is a backbone bridge port. Skipping.", curBridgePort);
						continue;
					}
					
					final int curIfIndex = curNode.getIfindex(curBridgePort);
					if (curIfIndex == -1) {
					    LogUtils.warnf(this, "run: got invalid ifIndex on bridge port %d", curBridgePort);
						continue;
					}
					// First get the MAC addresses on bridge port

					final Set<String> macs = curNode.getMacAddressesOnBridgePort(curBridgePort);

					// Then find the bridges whose MAC addresses are learned on bridge port
					final List<LinkableNode> bridgesOnPort = getBridgesFromMacs(macs);
					
					if (bridgesOnPort.isEmpty()) {
					    LogUtils.debugf(this, "run: no bridge info found on port %d. Saving MACs.", curBridgePort);
						addLinks(macs, curNodeId, curIfIndex);
					} else {
						// a bridge MAC address was found on port so you should analyze what happens
					    LogUtils.debugf(this, "run: bridge info found on port %d. Finding nearest.", curBridgePort);
					    
                        // one among these bridges should be the node more close to the curnode, curport
					    for (final LinkableNode endNode : bridgesOnPort) {
					        final int endNodeid = endNode.getNodeId();
							
					        final int endBridgePort = getBridgePortOnEndBridge(curNode, endNode);
							// The bridge port should be valid! This control is not properly done
							if (endBridgePort == -1) {
							    LogUtils.errorf(this, "run: no valid port found on bridge nodeid %d for node bridge identifiers nodeid %d.  Skipping.", endNodeid, curNodeId);
								continue;
							}
							
							// Try to found a new 
							final boolean isTargetNode = isNearestBridgeLink(curNode, curBridgePort, endNode, endBridgePort);
							if (!isTargetNode) continue;

							final int endIfindex = endNode.getIfindex(endBridgePort);
							if (endIfindex == -1) {
							    LogUtils.warnf(this, "run: got invalid ifindex on designated bridge port %d", endBridgePort);
								break;
							}

							LogUtils.debugf(this, "run: backbone port found for node %d. Adding backbone port %d to bridge", curNodeId, curBridgePort);

							curNode.addBackBoneBridgePorts(curBridgePort);
							m_bridgeNodes.put(curNodeId, curNode);

							LogUtils.debugf(this, "run: backbone port found for node %d. Adding to helper class bb port bridge port %d", endNodeid, endBridgePort);

							endNode.addBackBoneBridgePorts(endBridgePort);
							m_bridgeNodes.put(endNodeid, endNode);

							// finding links between two backbone ports
							addLinks(getMacsOnBridgeLink(curNode, curBridgePort, endNode, endBridgePort),curNodeId,curIfIndex);

							final NodeToNodeLink lk = new NodeToNodeLink(curNodeId, curIfIndex);
							lk.setNodeparentid(endNodeid);
							lk.setParentifindex(endIfindex);
							addNodetoNodeLink(lk);
							break;
						}
					}
				}
			}

			// fourth find inter-router links,
			// this part could have several special function to get inter-router
			// links, but at the moment we worked much on switches.
			// In future we can try to extend this part.
			LogUtils.debugf(this, "run: try to found not ethernet links on Router nodes");

			for (final LinkableNode curNode : m_routerNodes) {
			    final int curNodeId = curNode.getNodeId();
				InetAddress curIpAddr = curNode.getSnmpPrimaryIpAddr();
				LogUtils.debugf(this, "run: parsing router nodeid %d IP address %s", curNodeId, str(curIpAddr));

				final List<RouterInterface> routeInterfaces = curNode.getRouteInterfaces();
                LogUtils.debugf(this, "run: parsing %d route interfaces.", routeInterfaces.size());
                
                for (final RouterInterface routeIface : routeInterfaces) {
					LogUtils.debugf(this, "run: parsing RouterInterface: " + routeIface.toString());

					if (routeIface.getMetric() == -1) {
					    LogUtils.infof(this, "run: Router interface has invalid metric %d. Skipping.", routeIface.getMetric());
						continue;
					}

					if (forceIpRouteDiscoveryOnEtherNet) {
					    LogUtils.infof(this, "run: force IP route discovery not getting SnmpIfType");
					} else {
					    final int snmpiftype = routeIface.getSnmpiftype();
						LogUtils.infof(this, "run: force IP route discovery getting SnmpIfType: " + snmpiftype);

						if (snmpiftype == SNMP_IF_TYPE_ETHERNET) {
						    LogUtils.infof(this, "run: Ethernet interface for nodeid %d. Skipping.", curNodeId);
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_PROP_VIRTUAL) {
						    LogUtils.infof(this, "run: PropVirtual interface for nodeid %d. Skipping.", curNodeId);
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_L2_VLAN) {
						    LogUtils.infof(this, "run: Layer2 VLAN interface for nodeid %d. Skipping.", curNodeId);
							continue;
						} else if (snmpiftype == SNMP_IF_TYPE_L3_VLAN) {
						    LogUtils.infof(this, "run: Layer3 VLAN interface for nodeid %d. Skipping.", curNodeId);
							continue;
						} else if (snmpiftype == -1) {
						    LogUtils.infof(this, "run: interface on node %d has unknown snmpiftype %d. Skipping.", curNodeId, snmpiftype);
							continue;
						} 
					}
					
					final InetAddress nexthop = routeIface.getNextHop();
					final String hostAddress = str(nexthop);

					if (hostAddress.equals("0.0.0.0")) {
					    LogUtils.infof(this, "run: nexthop address is broadcast address %s. Skipping.", hostAddress);
						// FIXME this should be further analyzed 
						// working on routeDestNet you can find hosts that
						// are directly connected with the destination network
						// This happens when static routing is made like this:
						// route 10.3.2.0 255.255.255.0 Serial0
						// so the router broadcasts on Serial0
						continue;
					}

					if (nexthop.isLoopbackAddress()) {
					    LogUtils.infof(this, "run: nexthop address is localhost address %s. Skipping.", hostAddress);
						continue;
					}

					if (!m_linkd.isInterfaceInPackage(nexthop, getPackageName())) {
					    LogUtils.infof(this, "run: nexthop address is not in package %s/%s. Skipping.", hostAddress, getPackageName());
						continue;
					}

					
					final int nextHopNodeid = routeIface.getNextHopNodeid();

					if (nextHopNodeid == -1) {
					    LogUtils.infof(this, "run: no node id found for IP next hop address %s. Skipping.", hostAddress);
						continue;
					}

					if (nextHopNodeid == curNodeId) {
					    LogUtils.debugf(this, "run: node id found for IP next hop address %s is itself. Skipping.", hostAddress);
						continue;
					}

					int ifindex = routeIface.getIfindex();
					
					if (ifindex == 0) {
                        LogUtils.infof(this, "run: route interface has ifindex %d -- trying to get ifIndex from nextHopNet: %s", ifindex, routeIface.getNextHopNet());
                        ifindex = getIfIndexFromRouter(curNode, routeIface.getNextHopNet());
						if (ifindex == -1 ) {
						    LogUtils.debugf(this, "run: found not correct ifindex %d. Skipping.", ifindex);
							continue;
						} else {
						    LogUtils.debugf(this, "run: found correct ifindex %d.", ifindex);
						}
						
					}
					LogUtils.debugf(this, "run: saving route link");
					
					// Saving link also when ifindex = -1 (not found)
					final NodeToNodeLink lk = new NodeToNodeLink(nextHopNodeid, routeIface.getNextHopIfindex());
					lk.setNodeparentid(curNodeId);
					lk.setParentifindex(ifindex);
					addNodetoNodeLink(lk);
				}
			}

			m_bridgeNodes.clear();
			m_routerNodes.clear();
			m_cdpNodes.clear();
			m_macsParsed.clear();
			macsExcluded.clear();
			m_macToAtinterface.clear();
			m_atNodes.clear();

			m_linkd.updateDiscoveryLinkCollection(this);

			m_links.clear();
			m_maclinks.clear();
		}
		// rescheduling activities
		isRunned = true;
		reschedule();
	}

