	/**
	 * <p>
	 * Performs the collection for the targeted IP address. The success or
	 * failure of the collection should be tested via the <code>failed</code>
	 * method.
	 * </p>
	 *
	 * <p>
	 * No synchronization is performed, so if this is used in a separate thread
	 * context synchronization must be added.
	 * </p>
	 */
	@SuppressWarnings("unchecked")
	public void run() {

		final String hostAddress = InetAddressUtils.str(m_address);
		if (suspendCollection) {
		    LogUtils.debugf(this, "SnmpCollection.run: address: %s Suspended!", hostAddress);
		} else {

			m_ipNetToMedia = new IpNetToMediaTable(m_address);

			m_CdpCache = new CdpCacheTable(m_address);

			LogUtils.debugf(this, "run: collecting : %s", m_agentConfig);

			SnmpWalker walker = null;

            boolean collectIpRouteTable = m_collectIpRouteTable;
            if (collectIpRouteTable) {
                Class<SnmpTable<SnmpStore>> ipRouteGetter = null;
                try {
                        ipRouteGetter = (Class<SnmpTable<SnmpStore>>)Class.forName(m_ipRouteClass);
                } catch (ClassNotFoundException e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " class not found ");
                        collectIpRouteTable = false;
                }

                Class<?>[] classes = { InetAddress.class };
                Constructor<SnmpTable<SnmpStore>> constr = null;
                try {
                        constr = ipRouteGetter.getConstructor(classes);
                } catch (Throwable e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " unable to get constructor.");
                        collectIpRouteTable = false;
                }
                Object[] argum = { m_address };
                try {
                        m_ipRoute = (SnmpTable<SnmpStore>) constr.newInstance(argum);
                } catch (Throwable e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " unable to invoke class.");
                        collectIpRouteTable = false;
                }
            }
			    			
			boolean collectVlanTable = m_collectVlanTable;
            if (collectVlanTable) {
				Class<SnmpTable<SnmpStore>> vlanGetter = null;
				try {
					vlanGetter = (Class<SnmpTable<SnmpStore>>)Class.forName(m_vlanClass);
				} catch (ClassNotFoundException e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: %s class not found", m_vlanClass);
				    collectVlanTable = false;
				}

				Class<?>[] classes = { InetAddress.class };
				Constructor<SnmpTable<SnmpStore>> constr = null;
				try {
					constr = vlanGetter.getConstructor(classes);
				} catch (NoSuchMethodException e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: %s class has no such method", m_vlanClass);
                    collectVlanTable = false;
				} catch (SecurityException s) {
                    LogUtils.warnf(this, s, "SnmpCollection.run: %s class security violation", m_vlanClass);
                    collectVlanTable = false;
				}
				Object[] argum = { m_address };
				try {
					m_vlanTable = (SnmpTable<SnmpStore>) constr.newInstance(argum);
				} catch (Throwable e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: unable to instantiate class %s", m_vlanClass);
                    collectVlanTable = false;
				}
			}
			
            String name = null;
            CollectionTracker[] tracker = new CollectionTracker[0];

            if (collectVlanTable && collectIpRouteTable && m_collectCdpTable) {
                name = "ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache, m_vlanTable };
            } else if (m_collectCdpTable && collectIpRouteTable) {
                name = "ipNetToMediaTable/ipRouteTable/cdpCacheTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache };
            } else if (collectVlanTable && collectIpRouteTable) {
                name = "ipNetToMediaTable/ipRouteTable/vlanTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_vlanTable };
            } else if (collectVlanTable && m_collectCdpTable) {
                name = "ipNetToMediaTable/vlanTable/cdpCacheTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable, m_CdpCache };
            } else if (collectIpRouteTable) {
                name = "ipNetToMediaTable/ipRouteTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_ipRoute };
            } else if (collectVlanTable) {
                name = "ipNetToMediaTable/vlanTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_vlanTable };
            } else if (m_collectCdpTable && m_ipNetToMedia != null && m_CdpCache != null) {
                name = "ipNetToMediaTable/cdpCacheTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia, m_CdpCache };
            } else if (m_ipNetToMedia != null) {
                name = "ipNetToMediaTable";
                tracker = new CollectionTracker[] { m_ipNetToMedia };
            }
            if (name == null) {
                LogUtils.infof(this, "Unable to determine data to collect.");
                return;
            }
            walker = SnmpUtils.createWalker(m_agentConfig, name, tracker);

			walker.start();

			try {
				walker.waitFor();
			} catch (final InterruptedException e) {
				m_ipNetToMedia = null;
				m_ipRoute = null;
				m_CdpCache = null;
				m_vlanTable = null;

				LogUtils.errorf(this, e, "SnmpCollection.run: collection interrupted, exiting");
				return;
			}

			// Log any failures
			//
			if (!this.hasIpNetToMediaTable())
			    LogUtils.infof(this, "SnmpCollection.run: failed to collect ipNetToMediaTable for %s", hostAddress);
			if (!this.hasRouteTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect ipRouteTable for %s", hostAddress);
			if (!this.hasCdpCacheTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect dpCacheTable for %s", hostAddress);
			if (collectVlanTable && !this.hasVlanTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect Vlan for %s", hostAddress);
			// Schedule SNMP VLAN collection only on VLAN.
			// If it has not VLAN collection no data download is done.
			
			OnmsVlan vlan = null;

			if (this.hasVlanTable()) {
				if (!m_vlanClass.equals("org.opennms.netmgt.linkd.snmp.CiscoVlanTable")
						&& !m_vlanClass.equals("org.opennms.netmgt.linkd.snmp.IntelVlanTable")) {

					runAndSaveSnmpVlanCollection(new OnmsVlan(TRUNK_VLAN_INDEX,TRUNK_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
				} else {
				    LogUtils.debugf(this, "SnmpCollection.run: start collection for %d VLAN entries", getVlanTable().getEntries().size());

					for (final SnmpStore ent : m_vlanTable.getEntries()) {
		 				int vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
						if (vlanindex == -1) {
						    LogUtils.debugf(this, "SnmpCollection.run: found null value for vlan.");
							continue;
						}
						String vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
						if (vlanname == null) vlanname = DEFAULT_VLAN_NAME; 
						Integer status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);

						if (status == null || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {
						    LogUtils.infof(this, "SnmpCollection.run: skipping VLAN %s: NOT ACTIVE or null", vlan);
							continue;
						}

						String community = m_agentConfig.getReadCommunity();
						LogUtils.debugf(this, "SnmpCollection.run: peer community: %s with VLAN %s", community, vlan);

						Integer type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
						if (type == null || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
						    LogUtils.infof(this, "SnmpCollection.run: skipping VLAN %s NOT ETHERNET TYPE", vlan);
							continue;
						}
						m_agentConfig.setReadCommunity(community + "@" + vlanindex);

						runAndSaveSnmpVlanCollection(new OnmsVlan(vlanindex,vlanname,status));
						m_agentConfig.setReadCommunity(community);
					}  
				}

			} else {
				runAndSaveSnmpVlanCollection(new OnmsVlan(DEFAULT_VLAN_INDEX,DEFAULT_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
			}
			// update info in linkd used correctly by discoveryLink
			LogUtils.debugf(this, "SnmpCollection.run: saving collection into database");

			m_linkd.updateNodeSnmpCollection(this);
			// clean memory
			// first make every think clean
			m_ipNetToMedia = null;
			m_ipRoute = null;
			m_CdpCache = null;
			m_vlanTable = null;
			m_snmpVlanCollection.clear();
		}

		// schedule it self
		reschedule();
		runned = true;
	}

