	/**
	 * <p>
	 * Performs the collection for the targeted internet address. The success or
	 * failure of the collection should be tested via the <code>failed</code>
	 * method.
	 * </p>
	 * 
	 * <p>
	 * No synchronization is performed, so if this is used in a separate thread
	 * context synchornization must be added.
	 * </p>
	 * 
	 */

	public void run() {
		

		if (suspendCollection) {
			log().debug("SnmpCollection.run: address: "
					+ m_address.getHostAddress() + " Suspended!");
		} else {

			m_ipNetToMedia = new IpNetToMediaTable(m_address);

			m_ipRoute = new IpRouteTable(m_address);

			m_CdpCache = new CdpCacheTable(m_address);

			if (log().isDebugEnabled())
				log().debug("run: collecting : " + m_agentConfig);

			SnmpWalker walker = null;

			if (m_collectVlanTable) {
				Class vlanGetter = null;
				try {
					vlanGetter = Class.forName(m_vlanClass);
				} catch (ClassNotFoundException e) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class not found " + e);
				}

				Class[] classes = { InetAddress.class };
				Constructor constr = null;
				try {
					constr = vlanGetter.getConstructor(classes);
				} catch (NoSuchMethodException e) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class has not such method " + e);
				} catch (SecurityException s) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class security violation " + s);
				}
				Object[] argum = { m_address };
				try {
					m_vlanTable = (SnmpTable) constr.newInstance(argum);
				} catch (InvocationTargetException t) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class Invocation Exception " + t);
				} catch (InstantiationException i) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class Instantiation Exception " + i);
				} catch (IllegalAccessException s) {
					log().error("SnmpCollection.run: " + m_vlanClass
							+ " class Illegal Access Exception " + s);
				}
			}
			
			if (m_collectVlanTable && m_collectIpRouteTable && m_collectCdpTable) {
				walker = SnmpUtils
						.createWalker(
								m_agentConfig,
								"ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable",
								new CollectionTracker[] { m_ipNetToMedia,
										m_ipRoute, m_CdpCache, m_vlanTable });

			} else if (m_collectCdpTable && m_collectIpRouteTable){
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable/cdpCacheTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute,
								m_CdpCache });

			} else if (m_collectVlanTable && m_collectIpRouteTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable/vlanTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute,
								m_vlanTable });
			} else if (m_collectVlanTable && m_collectCdpTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
					"ipNetToMediaTable/vlanTable/cdpCacheTable",
					new CollectionTracker[] { m_ipNetToMedia, m_vlanTable,
							m_CdpCache });
			} else if (m_collectIpRouteTable){
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute});
			} else if (m_collectVlanTable ) {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/vlanTable",
						new CollectionTracker[] { m_ipNetToMedia, m_vlanTable });
			} else if (m_collectCdpTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
					"ipNetToMediaTable/cdpCacheTable",
					new CollectionTracker[] { m_ipNetToMedia, m_CdpCache });

			}else {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable",
						new CollectionTracker[] { m_ipNetToMedia});
			}

			walker.start();

			try {
				walker.waitFor();
			} catch (InterruptedException e) {
				m_ipNetToMedia = null;
				m_ipRoute = null;
				m_CdpCache = null;
				m_vlanTable = null;

				log().error("SnmpCollection.run: collection interrupted, exiting",
						e);
				return;
			}

			// Log any failures
			//
			if (!this.hasIpNetToMediaTable())
				log()
						.info("SnmpCollection.run: failed to collect ipNetToMediaTable for "
								+ m_address.getHostAddress());
			if (!this.hasRouteTable())
				log()
						.info("SnmpCollection.run: failed to collect ipRouteTable for "
								+ m_address.getHostAddress());
			if (!this.hasCdpCacheTable())
				log()
						.info("SnmpCollection.run: failed to collect dpCacheTable for "
								+ m_address.getHostAddress());
			if (m_collectVlanTable && !this.hasVlanTable())
				log().info("SnmpCollection.run: failed to collect Vlan for "
						+ m_address.getHostAddress());
			// Schedule snmp vlan collection
			// only on VLAN.
			// If it has not vlan collection no data download is done.
			
			Vlan vlan = null;

			if (this.hasVlanTable()) {
				if (!m_vlanClass
						.equals("org.opennms.netmgt.linkd.snmp.CiscoVlanTable")
						&& !m_vlanClass
								.equals("org.opennms.netmgt.linkd.snmp.IntelVlanTable")) {

					runAndSaveSnmpVlanCollection(new Vlan(TRUNK_VLAN_INDEX,TRUNK_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
				} else {
					if (log().isDebugEnabled())
						log().debug("SnmpCollection.run: start collection for "
								+ getVlanTable().getEntries().size() + " VLAN entries ");

					java.util.Iterator itr = m_vlanTable.getEntries().iterator();
					while (itr.hasNext()) {
						SnmpTableEntry ent = (SnmpTableEntry) itr.next();
		 				int vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
						if (vlanindex == -1) {
							if (log().isDebugEnabled())
								log()
										.debug("SnmpCollection.run: found null value for vlan.");
							continue;
						}
						String vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
						if (vlanname == null) vlanname = DEFAULT_VLAN_NAME; 
						Integer status = ent
						.getInt32(VlanCollectorEntry.VLAN_STATUS);

						if (status == null
								|| status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {
							if (log().isInfoEnabled())
								log().info("SnmpCollection.run: skipping VLAN "
										+ vlan + " NOT ACTIVE or null ");
							continue;
						}

						String community = m_agentConfig.getReadCommunity();
						if (log().isDebugEnabled())
							log().debug("SnmpCollection.run: peer community: "
									+ community + " with VLAN " + vlan);


						Integer type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
						if (type == null
								|| type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
							if (log().isInfoEnabled())
								log().info("SnmpCollection.run: skipping VLAN "
										+ vlan + " NOT ETHERNET TYPE");
							continue;
						}
						m_agentConfig.setReadCommunity(community + "@" + vlanindex);

						runAndSaveSnmpVlanCollection(new Vlan(vlanindex,vlanname,status));
						m_agentConfig.setReadCommunity(community);
					}  
				}

			} else {
				runAndSaveSnmpVlanCollection(new Vlan(DEFAULT_VLAN_INDEX,DEFAULT_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
			}
			// update info in linkd used correctly by discoveryLink
			if (log().isDebugEnabled())
				log()
						.debug("SnmpCollection.run: saving collection into database ");

			Linkd.getInstance().updateNodeSnmpCollection(this);
			// clean memory
			// first make every think clean
			m_ipNetToMedia = null;
			m_ipRoute = null;
			m_CdpCache = null;
			m_vlanTable = null;
			m_snmpVlanCollection.clear();
		}

		// schedule it self
		reschedule();
		runned = true;
	}

