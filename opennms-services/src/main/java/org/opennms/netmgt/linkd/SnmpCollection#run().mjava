	/**
	 * <p>
	 * Performs the collection for the targeted internet address. The success or
	 * failure of the collection should be tested via the <code>failed</code>
	 * method.
	 * </p>
	 *
	 * <p>
	 * No synchronization is performed, so if this is used in a separate thread
	 * context synchornization must be added.
	 * </p>
	 */
	@SuppressWarnings("unchecked")
    public void run() {
		

		if (suspendCollection) {
		    LogUtils.debugf(this, "SnmpCollection.run: address: %s Suspended!", m_address.getHostAddress());
		} else {

			m_ipNetToMedia = new IpNetToMediaTable(m_address);

			m_CdpCache = new CdpCacheTable(m_address);

			LogUtils.debugf(this, "run: collecting : %s", m_agentConfig);

			SnmpWalker walker = null;

            if (m_collectIpRouteTable) {
                Class<?> ipRouteGetter = null;
                try {
                        ipRouteGetter = Class.forName(m_ipRouteClass);
                } catch (ClassNotFoundException e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " class not found ");
                }

                Class<?>[] classes = { InetAddress.class };
                Constructor<?> constr = null;
                try {
                        constr = ipRouteGetter.getConstructor(classes);
                } catch (Exception e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " unable to get constructor.");
                }
                Object[] argum = { m_address };
                try {
                        m_ipRoute = (SnmpTable) constr.newInstance(argum);
                } catch (Exception e) {
                        LogUtils.errorf(this, e, "SnmpCollection.run: " + m_ipRouteClass + " unable to invoke class.");
                }
            }
			    			
			if (m_collectVlanTable) {
				Class<?> vlanGetter = null;
				try {
					vlanGetter = Class.forName(m_vlanClass);
				} catch (ClassNotFoundException e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: %s class not found", m_vlanClass);
				}

				Class<?>[] classes = { InetAddress.class };
				Constructor<?> constr = null;
				try {
					constr = vlanGetter.getConstructor(classes);
				} catch (NoSuchMethodException e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: %s class has no such method", m_vlanClass);
				} catch (SecurityException s) {
                    LogUtils.warnf(this, s, "SnmpCollection.run: %s class security violation", m_vlanClass);
				}
				Object[] argum = { m_address };
				try {
					m_vlanTable = (SnmpTable) constr.newInstance(argum);
				} catch (Exception e) {
				    LogUtils.warnf(this, e, "SnmpCollection.run: unable to instantiate class %s", m_vlanClass);
				}
			}
			
			if (m_collectVlanTable && m_collectIpRouteTable && m_collectCdpTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
								"ipNetToMediaTable/ipRouteTable/cdpCacheTable/vlanTable",
								new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache, m_vlanTable });
			} else if (m_collectCdpTable && m_collectIpRouteTable){
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable/cdpCacheTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_CdpCache });
			} else if (m_collectVlanTable && m_collectIpRouteTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable/vlanTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute, m_vlanTable });
			} else if (m_collectVlanTable && m_collectCdpTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
					"ipNetToMediaTable/vlanTable/cdpCacheTable",
					new CollectionTracker[] { m_ipNetToMedia, m_vlanTable, m_CdpCache });
			} else if (m_collectIpRouteTable){
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/ipRouteTable",
						new CollectionTracker[] { m_ipNetToMedia, m_ipRoute});
			} else if (m_collectVlanTable ) {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable/vlanTable",
						new CollectionTracker[] { m_ipNetToMedia, m_vlanTable });
			} else if (m_collectCdpTable) {
				walker = SnmpUtils.createWalker(m_agentConfig,
					"ipNetToMediaTable/cdpCacheTable",
					new CollectionTracker[] { m_ipNetToMedia, m_CdpCache });
			}else {
				walker = SnmpUtils.createWalker(m_agentConfig,
						"ipNetToMediaTable",
						new CollectionTracker[] { m_ipNetToMedia});
			}

			walker.start();

			try {
				walker.waitFor();
			} catch (InterruptedException e) {
				m_ipNetToMedia = null;
				m_ipRoute = null;
				m_CdpCache = null;
				m_vlanTable = null;

				LogUtils.errorf(this, e, "SnmpCollection.run: collection interrupted, exiting");
				return;
			}

			// Log any failures
			//
			if (!this.hasIpNetToMediaTable())
			    LogUtils.infof(this, "SnmpCollection.run: failed to collect ipNetToMediaTable for %s", m_address.getHostAddress());
			if (!this.hasRouteTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect ipRouteTable for %s", m_address.getHostAddress());
			if (!this.hasCdpCacheTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect dpCacheTable for %s", m_address.getHostAddress());
			if (m_collectVlanTable && !this.hasVlanTable())
                LogUtils.infof(this, "SnmpCollection.run: failed to collect Vlan for %s", m_address.getHostAddress());
			// Schedule snmp vlan collection only on VLAN.
			// If it has not vlan collection no data download is done.
			
			Vlan vlan = null;

			if (this.hasVlanTable()) {
				if (!m_vlanClass.equals("org.opennms.netmgt.linkd.snmp.CiscoVlanTable")
						&& !m_vlanClass.equals("org.opennms.netmgt.linkd.snmp.IntelVlanTable")) {

					runAndSaveSnmpVlanCollection(new Vlan(TRUNK_VLAN_INDEX,TRUNK_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
				} else {
				    LogUtils.debugf(this, "SnmpCollection.run: start collection for %d VLAN entries", getVlanTable().getEntries().size());

					for (final SnmpTableEntry ent : m_vlanTable.getEntries()) {
		 				int vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
						if (vlanindex == -1) {
						    LogUtils.debugf(this, "SnmpCollection.run: found null value for vlan.");
							continue;
						}
						String vlanname = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
						if (vlanname == null) vlanname = DEFAULT_VLAN_NAME; 
						Integer status = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);

						if (status == null || status != VlanCollectorEntry.VLAN_STATUS_OPERATIONAL) {
						    LogUtils.infof(this, "SnmpCollection.run: skipping VLAN %s: NOT ACTIVE or null", vlan);
							continue;
						}

						String community = m_agentConfig.getReadCommunity();
						LogUtils.debugf(this, "SnmpCollection.run: peer community: %s with VLAN %s", community, vlan);

						Integer type = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
						if (type == null || type != VlanCollectorEntry.VLAN_TYPE_ETHERNET) {
						    LogUtils.infof(this, "SnmpCollection.run: skipping VLAN %s NOT ETHERNET TYPE", vlan);
							continue;
						}
						m_agentConfig.setReadCommunity(community + "@" + vlanindex);

						runAndSaveSnmpVlanCollection(new Vlan(vlanindex,vlanname,status));
						m_agentConfig.setReadCommunity(community);
					}  
				}

			} else {
				runAndSaveSnmpVlanCollection(new Vlan(DEFAULT_VLAN_INDEX,DEFAULT_VLAN_NAME,VlanCollectorEntry.VLAN_STATUS_OPERATIONAL));
			}
			// update info in linkd used correctly by discoveryLink
			LogUtils.debugf(this, "SnmpCollection.run: saving collection into database");

			Linkd.getInstance().updateNodeSnmpCollection(this);
			// clean memory
			// first make every think clean
			m_ipNetToMedia = null;
			m_ipRoute = null;
			m_CdpCache = null;
			m_vlanTable = null;
			m_snmpVlanCollection.clear();
		}

		// schedule it self
		reschedule();
		runned = true;
	}

