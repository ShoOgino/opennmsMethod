	void scheduleNodeCollection(int nid) {

		Category log = ThreadCategory.getInstance();
		java.sql.Connection dbConn = null;
		SnmpCollection coll = null;
		boolean scheduleSnmpCollection = true;
		
		// First of all get SnmpCollection
		try {
			dbConn = DataSourceFactory.getInstance().getConnection();
			if (log.isDebugEnabled()) {
				log.debug("scheduleNodeCollection: Loading node " + nid
						+ " from database");
			}
			try {
				coll = LinkdConfigFactory.getInstance().getSnmpCollection(
						dbConn, nid);
				if (coll == null) {
					log.warn("scheduleNodeCollection: Failed to get Linkable node from LinkdConfigFactory. Exiting");
					return;
				}
			} catch (UnknownHostException h) {
					log.warn("scheduleNodeCollection: Failed to get Linkable node from LinkdConfigFactory"
									+ h);
			}
		} catch (SQLException sqlE) {
			log
					.fatal(
							"scheduleNodeCollection: SQL Exception while syncing node object with database information.",
							sqlE);
			throw new UndeclaredThrowableException(sqlE);
		} catch (Throwable t) {
			log
					.fatal(
							"scheduleNodeCollection: Unknown error while syncing node object with database information.",
							t);
			throw new UndeclaredThrowableException(t);
		} finally {
			try {
				if (dbConn != null) {
					dbConn.close();
				}
			} catch (SQLException e) {
				log
						.error(
								"scheduleNodeCollection: SQL Exception while syncing node object with database information.",
								e);
			}
		}

		// you have to test if an old collection for this node exists 
		if (nodeid2snmpcollection.containsKey(new Integer(nid))) {
			SnmpCollection oldColl = (SnmpCollection) nodeid2snmpcollection.get(new Integer(nid));
			if (oldColl.equals(coll)) {
				scheduleSnmpCollection = false;
				coll = oldColl;
			} else {
				// the new collection is change
				// first of all unschedule
				// second remove from hash
				oldColl.unschedule();
				synchronized (snmpprimaryip2nodes) {
					snmpprimaryip2nodes.remove(getLinkableNodeKey(nid));
				}
			}
		}
			
		// this means that same snmpcollection exists
		if (scheduleSnmpCollection && snmpprimaryip2nodes.containsKey(coll.getTarget().getHostAddress())) {
			// this means that collection is the same but nodes should be different
			scheduleSnmpCollection = false;
			
			LinkableNode oldNode = (LinkableNode) snmpprimaryip2nodes
					.get(coll.getTarget().getHostAddress());

			// first of all set status to D on linkd tables for old node if
			// different from new
			if (nid != oldNode.getNodeId()) {
				DbEventWriter dbwriter = new DbEventWriter(oldNode.getNodeId(),
						DbEventWriter.ACTION_DELETE);
				dbwriter.run();
				nodeid2snmpcollection.remove(new Integer(oldNode.getNodeId()));
			} else {
				coll = (SnmpCollection) nodeid2snmpcollection.get(new Integer(nid));
			}
		}
		
		LinkableNode node = new LinkableNode(nid,coll.getTarget().getHostAddress());
		
		synchronized (nodeid2snmpcollection) {
			snmpprimaryip2nodes.put(coll.getTarget().getHostAddress(), node);
		}
		
		synchronized (snmpprimaryip2nodes) {
			nodeid2snmpcollection.put(new Integer(nid), coll);
		}

		
		// schedule collection if
		if (scheduleSnmpCollection) {
			synchronized (coll) {
				if (coll.getScheduler() == null) {
					coll.setScheduler(m_scheduler);
				}
				coll.setPollInterval(m_snmp_poll_interval);
				coll.setInitialSleepTime(0);
				coll.schedule();
			}
			
			if (!scheduledDiscoveryLink) {
				DiscoveryLink discoveryLink = new DiscoveryLink();
	
				if (log.isDebugEnabled())
					log
							.debug("scheduleNodeCollection: scheduling Discovery Link");
				synchronized (discoveryLink) {
					if (discoveryLink.getScheduler() == null) {
						discoveryLink.setScheduler(m_scheduler);
					}
					discoveryLink.setSnmpPollInterval(m_snmp_poll_interval);
					discoveryLink.setDiscoveryInterval(m_discovery_link_interval);
					discoveryLink.setInitialSleepTime(0);
				}
				discoveryLink.schedule();
				scheduledDiscoveryLink = true;
			}
		}

	}

