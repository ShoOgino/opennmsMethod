	/**
	 * This method is used to schedule a ready runnable in the system. The
	 * interval is used as the key for determining which queue to add the
	 * runnable.
	 * 
	 * @param interval
	 *            The queue to add the runnable to.
	 * @param runnable
	 *            The element to run when interval expires.
	 * 
	 * @throws java.lang.RuntimeException
	 *             Thrown if an error occurs adding the element to the queue.
	 */
	public synchronized void schedule(long interval,
			final ReadyRunnable runnable) {

		final long timeToRun = getCurrentTime() + interval;
		ReadyRunnable timeKeeper = new ReadyRunnable() {
			public boolean isReady() {
				return getCurrentTime() >= timeToRun && runnable.isReady();
			}

			public boolean isSnmpCollection() {
				return runnable.isSnmpCollection();
			}

			public boolean isDiscoveryLink() {
				return runnable.isDiscoveryLink();
			}

			public InetAddress getTarget() throws UnknownHostException {
				return runnable.getTarget();
			}

			public void run() {
				runnable.run();
			}

			public void suspend() {
				runnable.suspend();
			}

			public void wakeUp() {
				runnable.wakeUp();
			}

			public boolean isSuspended() {
				return runnable.isSuspended();
			}
			
			public void unschedule() throws UnknownHostException, Throwable {
				runnable.unschedule();
			}

			public String toString() {
				return runnable.toString() + " (ready in "
						+ Math.max(0, timeToRun - getCurrentTime()) + "ms)";
			}
		};
		schedule(timeKeeper, interval);
	}

