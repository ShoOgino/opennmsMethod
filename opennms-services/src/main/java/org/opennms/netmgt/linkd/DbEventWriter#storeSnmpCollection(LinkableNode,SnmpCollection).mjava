    /** {@inheritDoc} */
    public LinkableNode storeSnmpCollection(LinkableNode node, SnmpCollection snmpcoll) throws SQLException {

        final DBUtils d = new DBUtils(getClass());
        try {
            Connection dbConn = getConnection();
            d.watch(dbConn);
            Timestamp now = new Timestamp(System.currentTimeMillis());
    
            if (snmpcoll.hasIpNetToMediaTable()) {
                Iterator<IpNetToMediaTableEntry> ite1 = snmpcoll.getIpNetToMediaTable().getEntries().iterator();
                LogUtils.debugf(this, "store: saving IpNetToMediaTable to atinterface table in DB");
                // the AtInterfaces used by LinkableNode where to save info
                java.util.List<AtInterface> atInterfaces = new java.util.ArrayList<AtInterface>();
                while (ite1.hasNext()) {
    
                    IpNetToMediaTableEntry ent = ite1.next();
    
                    int ifindex = ent.getIpNetToMediaIfIndex();
    
                    if (ifindex < 0) {
                        LogUtils.warnf(this, "store: invalid ifindex " + ifindex);
                        continue;
                    }
    
                    InetAddress ipaddress = ent.getIpNetToMediaNetAddress();
    
                    if (ipaddress == null || ipaddress.isLoopbackAddress() || ipaddress.getHostAddress().equals("0.0.0.0")) {
                        LogUtils.warnf(this, "store: ipNetToMedia invalid ip " + ipaddress.getHostAddress());
                        continue;
                    }
    
                    String physAddr = ent.getIpNetToMediaPhysAddress();
    
                    if (physAddr == null || physAddr.equals("000000000000") || physAddr.equalsIgnoreCase("ffffffffffff")) {
                        LogUtils.warnf(this, "store: ipNetToMedia invalid mac address " + physAddr + " for ip " + ipaddress.getHostAddress());
                        continue;
                    }
                    
                    LogUtils.debugf(this, "store: trying save ipNetToMedia info: ipaddr " + ipaddress.getHostName() + " mac address " + physAddr + " ifindex " + ifindex);
    
                    // get an At interface but without setting mac address
                    AtInterface at = getNodeidIfindexFromIp(dbConn, ipaddress);
                    if (at == null) {
                        LogUtils.warnf(this, "getNodeidIfindexFromIp: no nodeid found for ipaddress " + ipaddress + ".");
                        sendNewSuspectEvent(ipaddress, snmpcoll.getTarget(), snmpcoll.getPackageName());
                        continue;
                    }
                    // set the mac address
                    at.setMacAddress(physAddr);
                    // add At Inteface to list of valid interfaces
                    atInterfaces.add(at);
    
                    // Save in DB
                    DbAtInterfaceEntry atInterfaceEntry = DbAtInterfaceEntry.get(dbConn, at.getNodeId(), ipaddress.getHostAddress());
    
                    if (atInterfaceEntry == null) {
                        atInterfaceEntry = DbAtInterfaceEntry.create(at.getNodeId(), ipaddress.getHostAddress());
                    }
    
                    // update object
                    atInterfaceEntry.updateAtPhysAddr(physAddr);
                    atInterfaceEntry.updateSourceNodeId(node.getNodeId());
                    atInterfaceEntry.updateIfIndex(ifindex);
                    atInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);
                    atInterfaceEntry.set_lastpolltime(now);
    
                    // store object in database
                    atInterfaceEntry.store(dbConn);
                }
                // set AtInterfaces in LinkableNode
                node.setAtInterfaces(atInterfaces);
            }
    
            if (snmpcoll.hasCdpCacheTable()) {
                LogUtils.debugf(this, "store: saving CdpCacheTable into SnmpLinkableNode");
                java.util.List<CdpInterface> cdpInterfaces = new java.util.ArrayList<CdpInterface>();
                Iterator<CdpCacheTableEntry> ite2 = snmpcoll.getCdpCacheTable().getEntries().iterator();
                while (ite2.hasNext()) {
                    CdpCacheTableEntry cdpEntry = ite2.next();
                    int cdpAddrType = cdpEntry.getCdpCacheAddressType();
    
                    if (cdpAddrType != CDP_ADDRESS_TYPE_IP_ADDRESS) {
                        LogUtils.warnf(this, "cdp Address Type not valid " + cdpAddrType);
                        continue;
                    }
    
                    InetAddress cdpTargetIpAddr = cdpEntry.getCdpCacheAddress();
    
                    if (cdpTargetIpAddr == null || cdpTargetIpAddr.isLoopbackAddress() || cdpTargetIpAddr.getHostAddress().equals("0.0.0.0")) {
                        LogUtils.warnf(this, "cdp Ip Address is not valid " + cdpTargetIpAddr);
                        continue;
                    }
    
                    LogUtils.debugf(this, "cdp ip address found " + cdpTargetIpAddr.getHostAddress());
    
                    int cdpIfIndex = cdpEntry.getCdpCacheIfIndex();
    
                    if (cdpIfIndex < 0) {
                        LogUtils.warnf(this, "cdpIfIndex not valid " + cdpIfIndex);
                        continue;
                    }
    
                    LogUtils.debugf(this, "cdp ifindex found " + cdpIfIndex);
    
                    String cdpTargetDevicePort = cdpEntry.getCdpCacheDevicePort();
    
                    if (cdpTargetDevicePort == null) {
                        LogUtils.warnf(this, "cdpTargetDevicePort null. Skipping. ");
                        continue;
                    }
    
                    LogUtils.debugf(this, "cdp Target device port name found " + cdpTargetDevicePort);
    
                    int targetCdpNodeId = getNodeidFromIp(dbConn, cdpTargetIpAddr);
    
                    if (targetCdpNodeId == -1) {
                        LogUtils.warnf(this, "No nodeid found: cdp interface not added to Linkable Snmp Node. Skipping");
                        sendNewSuspectEvent(cdpTargetIpAddr, snmpcoll.getTarget(), snmpcoll.getPackageName());
                        continue;
                    }
    
                    int cdpTargetIfindex = getIfIndexByName(dbConn, targetCdpNodeId, cdpTargetDevicePort);
    
                    if (cdpTargetIfindex == -1) {
                        LogUtils.warnf(this, "No valid if target index found: cdp interface not added to Linkable Snmp Node. Skipping");
                        continue;
                    }
    
                    CdpInterface cdpIface = new CdpInterface(cdpIfIndex);
                    cdpIface.setCdpTargetNodeId(targetCdpNodeId);
                    cdpIface.setCdpTargetIpAddr(cdpTargetIpAddr);
                    cdpIface.setCdpTargetIfIndex(cdpTargetIfindex);
    
                    LogUtils.debugf(this, "Adding cdp interface to Linkable Snmp Node." + cdpIface.toString());
    
                    cdpInterfaces.add(cdpIface);
                }
                node.setCdpInterfaces(cdpInterfaces);
            }
    
            if (snmpcoll.hasRouteTable()) {
                java.util.List<RouterInterface> routeInterfaces = new java.util.ArrayList<RouterInterface>();
    
                Iterator<SnmpTableEntry> ite3 = snmpcoll.getIpRouteTable().getEntries().iterator();
                LogUtils.debugf(this, "store: saving ipRouteTable to iprouteinterface table in DB");
                while (ite3.hasNext()) {
                    SnmpTableEntry ent = ite3.next();
    
                    Integer ifindex = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_IFINDEX);
    
                    if (ifindex == null || ifindex < 0) {
                        LogUtils.warnf(this, "store: Not valid ifindex " + ifindex + ", skipping...");
                        continue;
                    }
    
                    InetAddress nexthop = ent.getIPAddress(IpRouteCollectorEntry.IP_ROUTE_NXTHOP);
    
                    if (nexthop == null) {
                        LogUtils.warnf(this, "storeSnmpCollection: next hop null found skipping.");
                        continue;
                    }
    
                    InetAddress routedest =  ent.getIPAddress(IpRouteCollectorEntry.IP_ROUTE_DEST);
                    if (routedest == null) {
                        LogUtils.warnf(this, "storeSnmpCollection: route dest null found skipping.");
                        continue;
                    }
                    InetAddress routemask = ent.getIPAddress(IpRouteCollectorEntry.IP_ROUTE_MASK);
    
                    if (routemask == null) {
                        LogUtils.warnf(this, "storeSnmpCollection: route dest null found skipping.");
                        continue;
                    }
    
                    LogUtils.debugf(this, "storeSnmpCollection: parsing routedest/routemask/nexthop: " + routedest + "/" + routemask + "/" + nexthop + " ifindex "
                                    + (ifindex < 1 ? "less than 1" : ifindex));
    
                    Integer routemetric1 =  ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_METRIC1);
    
                    /**
                     * FIXME: send routedest 0.0.0.0 to discoverylink remember that
                     * now nexthop 0.0.0.0 is not parsed, anyway we should analyze
                     * this case in link discovery so here is the place where you
                     * can have this info saved for now is discarded. See
                     * DiscoveryLink for more details......
                     */
    
                    // the routerinterface constructor set nodeid, ifindex,
                    // netmask
                    // for nexthop address
                    // try to find on snmpinterface table
                    RouterInterface routeIface = getNodeidMaskFromIp(dbConn, nexthop);
    
                    // if target node is not snmp node always try to find info
                    // on ipinterface table
                    if (routeIface == null) {
                        routeIface = getNodeFromIp(dbConn, nexthop);
                    }
    
                    if (routeIface == null) {
                        LogUtils.warnf(this, "store: No nodeid found for next hop ip" + nexthop + " Skipping ip route interface add to Linkable Snmp Node");
                        // try to find it in ipinterface
                        sendNewSuspectEvent(nexthop, snmpcoll.getTarget(), snmpcoll.getPackageName());
                    } else {
                        int snmpiftype = -2;
    
                        if (ifindex > 0) snmpiftype = getSnmpIfType(dbConn, node.getNodeId(), ifindex);
    
                        if (snmpiftype == -1) {
                            LogUtils.warnf(this, "store: interface has wrong or null snmpiftype " + snmpiftype + " . Skipping saving to discoverylink. ");
                        } else if (nexthop.isLoopbackAddress()) {
                            LogUtils.infof(this, "storeSnmpCollection: next hop loopbackaddress found. Skipping saving 	to discoverylink.");
                        } else if (nexthop.getHostAddress().equals("0.0.0.0")) {
                            LogUtils.infof(this, "storeSnmpCollection: next hop broadcast address found. Skipping saving to discoverylink.");
                        } else if (nexthop.isMulticastAddress()) {
                            LogUtils.infof(this, "storeSnmpCollection: next hop multicast address found. Skipping saving to discoverylink.");
                        } else if (routemetric1 == null || routemetric1 < 0) {
                            LogUtils.infof(this, "storeSnmpCollection: route metric is invalid. Skipping saving to discoverylink.");
                        } else {
                            LogUtils.debugf(this, "store: interface has snmpiftype " + snmpiftype + " . Adding to DiscoverLink ");
    
                            routeIface.setRouteDest(routedest);
                            routeIface.setRoutemask(routemask);
                            routeIface.setSnmpiftype(snmpiftype);
                            routeIface.setIfindex(ifindex);
                            routeIface.setMetric(routemetric1);
                            routeIface.setNextHop(nexthop);
                            routeInterfaces.add(routeIface);
    
                        }
                    }
    
                    // always save info to DB
                    if (snmpcoll.getSaveIpRouteTable()) {
                        Integer routemetric2 = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_METRIC2);
                        Integer routemetric3 = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_METRIC3);
                        Integer routemetric4 = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_METRIC4);
                        Integer routemetric5 = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_METRIC5);
                        Integer routetype = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_TYPE);
                        Integer routeproto = ent.getInt32(IpRouteCollectorEntry.IP_ROUTE_PROTO);

                        DbIpRouteInterfaceEntry iprouteInterfaceEntry = DbIpRouteInterfaceEntry.get(dbConn, node.getNodeId(), routedest.getHostAddress());
                        if (iprouteInterfaceEntry == null) {
                            // Create a new entry
                            iprouteInterfaceEntry = DbIpRouteInterfaceEntry.create(node.getNodeId(), routedest.getHostAddress());
                        }
                        // update object
                        iprouteInterfaceEntry.updateRouteMask(routemask.getHostAddress());
                        iprouteInterfaceEntry.updateRouteNextHop(nexthop.getHostAddress());
                        iprouteInterfaceEntry.updateIfIndex(ifindex);
    
                        // okay to autobox these since we're checking for null
                        if (routemetric1 != null) iprouteInterfaceEntry.updateRouteMetric1(routemetric1);
                        if (routemetric2 != null) iprouteInterfaceEntry.updateRouteMetric2(routemetric2);
                        if (routemetric3 != null) iprouteInterfaceEntry.updateRouteMetric3(routemetric3);
                        if (routemetric4 != null) iprouteInterfaceEntry.updateRouteMetric4(routemetric4);
                        if (routemetric5 != null) iprouteInterfaceEntry.updateRouteMetric5(routemetric5);
                        if (routetype != null) iprouteInterfaceEntry.updateRouteType(routetype);
                        if (routeproto != null) iprouteInterfaceEntry.updateRouteProto(routeproto);
                        iprouteInterfaceEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);
                        iprouteInterfaceEntry.set_lastpolltime(now);
    
                        // store object in database
                        iprouteInterfaceEntry.store(dbConn);
                    }
                }
                node.setRouteInterfaces(routeInterfaces);
            }
    
            LogUtils.debugf(this, "store: saving VlanTable in DB");
    
            if (snmpcoll.hasVlanTable()) {
    
                List<Vlan> vlans = new ArrayList<Vlan>();
                Iterator<SnmpTableEntry> ite3 = snmpcoll.getVlanTable().getEntries().iterator();
                LogUtils.debugf(this, "store: saving Snmp Vlan Table to vlan table in DB");
                while (ite3.hasNext()) {
                    SnmpTableEntry ent = ite3.next();
    
                    Integer vlanindex = ent.getInt32(VlanCollectorEntry.VLAN_INDEX);
    
                    if (vlanindex == null || vlanindex < 0) {
                        LogUtils.warnf(this, "store: Not valid vlan ifindex" + vlanindex + " Skipping...");
                        continue;
                    }
    
                    String vlanName = ent.getDisplayString(VlanCollectorEntry.VLAN_NAME);
                    if (vlanName == null) {
                        LogUtils.warnf(this, "store: Null vlan name. forcing to default...");
                        vlanName = "default-" + vlanindex;
                    }
    
                    Integer vlantype = ent.getInt32(VlanCollectorEntry.VLAN_TYPE);
                    Integer vlanstatus = ent.getInt32(VlanCollectorEntry.VLAN_STATUS);
    
                    // always save info to DB
                    DbVlanEntry vlanEntry = DbVlanEntry.get(dbConn, node.getNodeId(), vlanindex);
                    if (vlanEntry == null) {
                        // Create a new entry
                        vlanEntry = DbVlanEntry.create(node.getNodeId(), vlanindex);
                    }
    
                    vlanEntry.updateVlanName(vlanName);
                    // okay to autobox these since we're checking for null
                    if (vlantype != null) {
                        vlanEntry.updateVlanType(vlantype);
                    } else {
                        vlantype = -1;
                    }
                    if (vlanstatus != null) {
                        vlanEntry.updateVlanStatus(vlanstatus);
                    } else {
                        vlanstatus = -1;
                    }
                    vlanEntry.updateStatus(DbAtInterfaceEntry.STATUS_ACTIVE);
                    vlanEntry.set_lastpolltime(now);
    
                    LogUtils.debugf(this, "vlanEntry = %s", vlanEntry);

                    // store object in database
                    vlanEntry.store(dbConn);
                    Vlan vlan = new Vlan(vlanindex, vlanName, vlanstatus, vlantype);
    
                    vlans.add(vlan);
                }
                node.setVlans(vlans);
            }
    
            LogUtils.debugf(this, "store: saving SnmpVlanCollection's in DB");
    
            Iterator<Entry<Vlan, SnmpVlanCollection>> ite4 = snmpcoll.getSnmpVlanCollections().entrySet().iterator();
    
            SnmpVlanCollection snmpVlanColl = null;
            Vlan vlan = null;
            while (ite4.hasNext()) {
    
                Entry<Vlan, SnmpVlanCollection> entry = ite4.next();
    
                vlan = entry.getKey();
    
                int vlanid = vlan.getVlanIndex();
                String vlanname = vlan.getVlanName();
                String vlanindex = Integer.toString(vlanid);
                LogUtils.debugf(this, "store: parsing VLAN " + vlanindex + " VLAN_NAME " + vlanname);
    
                snmpVlanColl = entry.getValue();
    
                if (snmpVlanColl.hasDot1dBase()) {
                    LogUtils.debugf(this, "store: saving Dot1dBaseGroup in stpnode table");
    
                    Dot1dBaseGroup dod1db = snmpVlanColl.getDot1dBase();
    
                    DbStpNodeEntry dbStpNodeEntry = null;
    
                    String baseBridgeAddress = dod1db.getBridgeAddress();
                    if (baseBridgeAddress == null || baseBridgeAddress == "000000000000") {
                        LogUtils.warnf(this, "store: invalid base bridge address: %s", baseBridgeAddress);
                    } else {
                        node.addBridgeIdentifier(baseBridgeAddress, vlanindex);
                        int basenumports = dod1db.getNumberOfPorts();
    
                        int bridgetype = dod1db.getBridgeType();
    
                        if (snmpcoll.getSaveStpNodeTable()) {
                            dbStpNodeEntry = DbStpNodeEntry.get(dbConn, node.getNodeId(), vlanid);
                            if (dbStpNodeEntry == null) {
                                // Create a new entry
                                dbStpNodeEntry = DbStpNodeEntry.create(node.getNodeId(), vlanid);
                            }
                            // update object
    
                            dbStpNodeEntry.updateBaseBridgeAddress(baseBridgeAddress);
                            dbStpNodeEntry.updateBaseNumPorts(basenumports);
                            dbStpNodeEntry.updateBaseType(bridgetype);
                            dbStpNodeEntry.updateBaseVlanName(vlanname);
                        }
                        if (snmpVlanColl.hasDot1dStp()) {
                            LogUtils.debugf(this, "store: adding Dot1dStpGroup in stpnode table");
    
                            Dot1dStpGroup dod1stp = snmpVlanColl.getDot1dStp();
                            int protospec = dod1stp.getStpProtocolSpecification();
                            int stppriority = dod1stp.getStpPriority();
                            int stprootcost = dod1stp.getStpRootCost();
                            int stprootport = dod1stp.getStpRootPort();
                            String stpDesignatedRoot = dod1stp.getStpDesignatedRoot();
    
                            if (stpDesignatedRoot == null || stpDesignatedRoot == "0000000000000000") {
                                LogUtils.debugf(this, "store: Dot1dStpGroup found stpDesignatedRoot " + stpDesignatedRoot + " not adding to Linkable node");
                                stpDesignatedRoot = "0000000000000000";
                            } else {
                                node.setVlanStpRoot(vlanindex, stpDesignatedRoot);
                            }
    
                            if (snmpcoll.getSaveStpNodeTable()) {
                                dbStpNodeEntry.updateStpProtocolSpecification(protospec);
                                dbStpNodeEntry.updateStpPriority(stppriority);
                                dbStpNodeEntry.updateStpDesignatedRoot(stpDesignatedRoot);
                                dbStpNodeEntry.updateStpRootCost(stprootcost);
                                dbStpNodeEntry.updateStpRootPort(stprootport);
                            }
                        }
                        // store object in database
                        if (snmpcoll.getSaveStpNodeTable()) {
                            dbStpNodeEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);
                            dbStpNodeEntry.set_lastpolltime(now);
                            dbStpNodeEntry.store(dbConn);
                        }
    
                        if (snmpVlanColl.hasDot1dBasePortTable()) {
                            Iterator<Dot1dBasePortTableEntry> sub_ite = snmpVlanColl.getDot1dBasePortTable().getEntries().iterator();
                            LogUtils.debugf(this, "store: saving Dot1dBasePortTable in stpinterface table");
                            while (sub_ite.hasNext()) {
                                Dot1dBasePortTableEntry dot1dbaseptentry = sub_ite.next();
    
                                int baseport = dot1dbaseptentry.getBaseBridgePort();
                                int ifindex = dot1dbaseptentry.getBaseBridgePortIfindex();
    
                                if (baseport == -1 || ifindex == -1) {
                                    LogUtils.warnf(this, "store: Dot1dBasePortTable invalid baseport or ifindex " + baseport + " / " + ifindex);
                                    continue;
                                }
    
                                node.setIfIndexBridgePort(ifindex, baseport);
    
                                if (snmpcoll.getSaveStpInterfaceTable()) {
    
                                    DbStpInterfaceEntry dbStpIntEntry = DbStpInterfaceEntry.get(dbConn, node.getNodeId(), baseport, vlanid);
                                    if (dbStpIntEntry == null) {
                                        // Create a new entry
                                        dbStpIntEntry = DbStpInterfaceEntry.create(node.getNodeId(), baseport, vlanid);
                                    }
    
                                    dbStpIntEntry.updateIfIndex(ifindex);
                                    dbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);
                                    dbStpIntEntry.set_lastpolltime(now);
                                    dbStpIntEntry.store(dbConn);
                                }
                            }
                        }
    
                        if (snmpVlanColl.hasDot1dStpPortTable()) {
                            LogUtils.debugf(this, "store: adding Dot1dStpPortTable in stpinterface table");
                            Iterator<Dot1dStpPortTableEntry> sub_ite = snmpVlanColl.getDot1dStpPortTable().getEntries().iterator();
                            while (sub_ite.hasNext()) {
                                Dot1dStpPortTableEntry dot1dstpptentry = sub_ite.next();
    
                                DbStpInterfaceEntry dbStpIntEntry = null;
    
                                int stpport = dot1dstpptentry.getDot1dStpPort();
    
                                if (stpport == -1) {
                                    LogUtils.warnf(this, "store: Dot1dStpPortTable found invalid stp port. Skipping");
                                    continue;
                                }
    
                                if (snmpcoll.getSaveStpInterfaceTable()) {
    
                                    dbStpIntEntry = DbStpInterfaceEntry.get(dbConn, node.getNodeId(), stpport, vlanid);
                                    if (dbStpIntEntry == null) {
                                        // Cannot create the object becouse must
                                        // exists
                                        // the dot1dbase
                                        // object!!!!!
                                        LogUtils.warnf(this, "store: StpInterface not found in database when storing STP info" + " for bridge node with nodeid " + node.getNodeId()
                                                    + " bridgeport number " + stpport + " and vlan index " + vlanindex + " skipping.");
                                    }
                                }
    
                                String stpPortDesignatedBridge = dot1dstpptentry.getDot1dStpPortDesignatedBridge();
                                String stpPortDesignatedPort = dot1dstpptentry.getDot1dStpPortDesignatedPort();
    
                                if (stpPortDesignatedBridge == null || stpPortDesignatedBridge.equals("0000000000000000")) {
                                    LogUtils.warnf(this, "store: " + stpPortDesignatedBridge + " designated bridge is invalid not adding to discoveryLink");
                                    stpPortDesignatedBridge = "0000000000000000";
                                } else if (stpPortDesignatedPort == null || stpPortDesignatedPort.equals("0000")) {
                                    LogUtils.warnf(this, "store: " + stpPortDesignatedPort + " designated port is invalid not adding to discoveryLink");
                                    stpPortDesignatedPort = "0000";
                                } else {
                                    BridgeStpInterface stpIface = new BridgeStpInterface(stpport, vlanindex);
                                    stpIface.setStpPortDesignatedBridge(stpPortDesignatedBridge);
                                    stpIface.setStpPortDesignatedPort(stpPortDesignatedPort);
                                    node.addStpInterface(stpIface);
                                }
    
                                if (snmpcoll.getSaveStpInterfaceTable()) {
                                    dbStpIntEntry.updateStpPortState(dot1dstpptentry.getDot1dStpPortState());
                                    dbStpIntEntry.updateStpPortPathCost(dot1dstpptentry.getDot1dStpPortPathCost());
                                    dbStpIntEntry.updateStpportDesignatedBridge(stpPortDesignatedBridge);
                                    dbStpIntEntry.updateStpportDesignatedRoot(dot1dstpptentry.getDot1dStpPortDesignatedRoot());
                                    dbStpIntEntry.updateStpPortDesignatedCost(dot1dstpptentry.getDot1dStpPortDesignatedCost());
                                    dbStpIntEntry.updateStpportDesignatedPort(stpPortDesignatedPort);
                                    dbStpIntEntry.updateStatus(DbStpNodeEntry.STATUS_ACTIVE);
                                    dbStpIntEntry.set_lastpolltime(now);
    
                                    dbStpIntEntry.store(dbConn);
    
                                }
                            }
                        }
    
                        if (snmpVlanColl.hasDot1dTpFdbTable()) {
                            LogUtils.debugf(this, "store: parsing Dot1dTpFdbTable");
    
                            Iterator<Dot1dTpFdbTableEntry> subite = snmpVlanColl.getDot1dFdbTable().getEntries().iterator();
                            while (subite.hasNext()) {
                                Dot1dTpFdbTableEntry dot1dfdbentry = subite.next();
                                String curMacAddress = dot1dfdbentry.getDot1dTpFdbAddress();
    
                                if (curMacAddress == null || curMacAddress.equals("000000000000")) {
                                    LogUtils.warnf(this, "store: Dot1dTpFdbTable invalid macaddress " + curMacAddress + " Skipping.");
                                    continue;
                                }
    
                                LogUtils.debugf(this, "store: Dot1dTpFdbTable found macaddress " + curMacAddress);
    
                                int fdbport = dot1dfdbentry.getDot1dTpFdbPort();
    
                                if (fdbport == 0 || fdbport == -1) {
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable mac learned on invalid port " + fdbport + " . Skipping");
                                    continue;
                                }
    
                                LogUtils.debugf(this, "store: Dot1dTpFdbTable mac address found " + " on bridge port " + fdbport);
    
                                int curfdbstatus = dot1dfdbentry.getDot1dTpFdbStatus();
    
                                if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {
                                    node.addMacAddress(fdbport, curMacAddress, vlanindex);
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable found learned status" + " on bridge port ");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {
                                    node.addBridgeIdentifier(curMacAddress);
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable mac is bridge identifier");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable found INVALID status. Skipping");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable found MGMT status. Skipping");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {
                                    LogUtils.debugf(this, "store: Dot1dTpFdbTable found OTHER status. Skipping");
                                } else if (curfdbstatus == -1) {
                                    LogUtils.warnf(this, "store: Dot1dTpFdbTable null status found. Skipping");
                                }
                            }
                        }
    
                        if (snmpVlanColl.hasQBridgeDot1dTpFdbTable()) {
                            LogUtils.debugf(this, "store: parsing QBridgeDot1dTpFdbTable");
    
                            Iterator<QBridgeDot1dTpFdbTableEntry> subite = snmpVlanColl.getQBridgeDot1dFdbTable().getEntries().iterator();
                            while (subite.hasNext()) {
                                QBridgeDot1dTpFdbTableEntry dot1dfdbentry = subite.next();
    
                                String curMacAddress = dot1dfdbentry.getQBridgeDot1dTpFdbAddress();
    
                                if (curMacAddress == null || curMacAddress.equals("000000000000")) {
                                    LogUtils.warnf(this, "store: QBridgeDot1dTpFdbTable invalid macaddress " + curMacAddress + " Skipping.");
                                    continue;
                                }
    
                                LogUtils.debugf(this, "store: Dot1dTpFdbTable found macaddress " + curMacAddress);
    
                                int fdbport = dot1dfdbentry.getQBridgeDot1dTpFdbPort();
    
                                if (fdbport == 0 || fdbport == -1) {
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable mac learned on invalid port " + fdbport + " . Skipping");
                                    continue;
                                }
    
                                LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable mac address found " + " on bridge port " + fdbport);
    
                                int curfdbstatus = dot1dfdbentry.getQBridgeDot1dTpFdbStatus();
    
                                if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_LEARNED) {
                                    node.addMacAddress(fdbport, curMacAddress, vlanindex);
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable found learned status" + " on bridge port ");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_SELF) {
                                    node.addBridgeIdentifier(curMacAddress);
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable mac is bridge identifier");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_INVALID) {
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable found INVALID status. Skipping");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_MGMT) {
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable found MGMT status. Skipping");
                                } else if (curfdbstatus == SNMP_DOT1D_FDB_STATUS_OTHER) {
                                    LogUtils.debugf(this, "store: QBridgeDot1dTpFdbTable found OTHER status. Skipping");
                                } else if (curfdbstatus == -1) {
                                    LogUtils.warnf(this, "store: QBridgeDot1dTpFdbTable null status found. Skipping");
                                }
                            }
                        }
    
                        // now adding bridge identifier mac addresses of switch
                        // from
                        // snmpinterface
                        PreparedStatement stmt = null;
                        stmt = dbConn.prepareStatement(SQL_GET_SNMPPHYSADDR_SNMPINTERFACE);
                        d.watch(stmt);
                        stmt.setInt(1, node.getNodeId());
    
                        ResultSet rs = stmt.executeQuery();
                        d.watch(rs);
    
                        while (rs.next()) {
                            String macaddr = rs.getString("snmpphysaddr");
                            if (macaddr == null) continue;
                            node.addBridgeIdentifier(macaddr);
                            LogUtils.debugf(this, "setBridgeIdentifierFromSnmpInterface: found bridge identifier " + macaddr + " from snmpinterface db table");
                        }
    
                    }
                }
            }
            update(dbConn, now, node.getNodeId());
    
            return node;
        } catch (Throwable e) {
            LogUtils.errorf(this, e, "Unexpected exception while storing SNMP collections: %s", e.getMessage());
            return null;
        } finally {
            d.cleanUp();
        }

    }

