    /** {@inheritDoc} */
    @Override
    public LinkableNode storeSnmpCollection(LinkableNode node, SnmpCollection snmpcoll) throws SQLException {

        final DBUtils d = new DBUtils(getClass());
        try {
            Connection dbConn = getConnection();
            d.watch(dbConn);
            Timestamp scanTime = new Timestamp(System.currentTimeMillis());
    
            if (snmpcoll.hasIpNetToMediaTable()) {
                processIpNetToMediaTable(node, snmpcoll, dbConn, scanTime);
            }
    
            if (snmpcoll.hasCdpCacheTable()) {
                processCdpCacheTable(node, snmpcoll, dbConn, scanTime);
            }
    
            if (snmpcoll.hasRouteTable()) {
                processRouteTable(node, snmpcoll, dbConn, scanTime);
            }
    
            if (snmpcoll.hasVlanTable()) {
                processVlanTable(node, snmpcoll, dbConn, scanTime);
            }
    
            LogUtils.debugf(this, "store: saving SnmpVlanCollection's in DB");

            for (final OnmsVlan vlan : snmpcoll.getSnmpVlanCollections().keySet()) {
    
            	LogUtils.debugf(this, "store: parsing VLAN %s/%s", vlan.getVlanId(), vlan.getVlanName());

                final SnmpVlanCollection snmpVlanColl = snmpcoll.getSnmpVlanCollections().get(vlan);
    
                if (snmpVlanColl.hasDot1dBase()) {
                	processDot1DBase(node, snmpcoll, d, dbConn, scanTime, vlan, snmpVlanColl);
                }
            }

            markOldDataInactive(dbConn, scanTime, node.getNodeId());
    
            return node;
        } catch (Throwable e) {
            LogUtils.errorf(this, e, "Unexpected exception while storing SNMP collections: %s", e.getMessage());
            return null;
        } finally {
            d.cleanUp();
        }

    }

