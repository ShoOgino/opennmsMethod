	private void processDot1dBaseAndDot1dStp(final OnmsNode onmsNode,
			final LinkableNode node, final OnmsVlan vlan,
			final SnmpVlanCollection snmpVlanColl, final Date scanTime) {
        LogUtils.debugf(this, "processDot1dBaseAndDot1dStp: Starting Bridge MIB processing for Vlan: %s.", vlan.getVlanName());

        final String baseBridgeAddress = snmpVlanColl.getDot1dBase().getBridgeAddress();
        if (baseBridgeAddress == null) {
            LogUtils.infof(this, "processDot1dBaseAndDot1dStp: Invalid base bridge address (%s) on node %d", baseBridgeAddress, node.getNodeId());
            return;
        }

        LogUtils.debugf(this, "processDot1dBaseAndDot1dStp: Found Bridge Identifier %s for Vlan %d.", baseBridgeAddress, vlan.getVlanId());
        node.addBridgeIdentifier(baseBridgeAddress, Integer.toString(vlan.getVlanId()));
        
        if (snmpVlanColl.hasDot1dStp()) {
            LogUtils.debugf(this, "processDot1dBaseAndDot1dStp: processing Dot1dStpGroup in stpnode");

            final String stpDesignatedRoot = snmpVlanColl.getDot1dStp().getStpDesignatedRoot();

            if (stpDesignatedRoot != null ) {
                LogUtils.debugf(this, "processDot1dBaseAndDot1dStp: Dot1dStpGroup found valid stpDesignatedRoot %s, adding to Linkable node", stpDesignatedRoot);
            }
        }

        if (getLinkd().saveStpNodeTable(snmpVlanColl.getPackageName())) {
        	saveStpNode(getOnmsStpNode(onmsNode,node,scanTime, vlan, snmpVlanColl));
        }
	}

