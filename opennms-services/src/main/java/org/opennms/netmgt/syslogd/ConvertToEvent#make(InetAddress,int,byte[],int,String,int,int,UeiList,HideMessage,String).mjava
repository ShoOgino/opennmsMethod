    /**
     * Constructs a new event encapsulation instance based upon the
     * information passed to the method. The passed byte array is decoded into
     * a string using the <tt>US-ASCII</tt> character encoding.
     *
     * @param addr The remote agent's address.
     * @param port The remote agent's port
     * @param data The XML data in US-ASCII encoding.
     * @param len  The length of the XML data in the buffer.
     * @throws java.io.UnsupportedEncodingException
     *          Thrown if the data buffer cannot be decoded using the
     *          US-ASCII encoding.
     * @throws MessageDiscardedException 
     */
    static ConvertToEvent make(final InetAddress addr, final int port, final byte[] data,
                               final int len, final String matchPattern, final int hostGroup, final int messageGroup,
                               final UeiList ueiList, final HideMessage hideMessage, final String discardUei)
            throws UnsupportedEncodingException, MessageDiscardedException {
        if (m_parserClass == null) {
            final String parser = SyslogdConfigFactory.getInstance().getParser();
            try {
                m_parserClass = Class.forName(parser).asSubclass(SyslogParser.class);
            } catch (final Exception ex) {
                LogUtils.debugf(ConvertToEvent.class, ex, "Unable to instantiate Syslog parser class specified in config: %s", parser);
                m_parserClass = CustomSyslogParser.class;
            }
        }

        final ConvertToEvent e = new ConvertToEvent();

        String deZeroedData = new String(data, 0, len, "US-ASCII");
        if (deZeroedData.endsWith("\0")) {
            deZeroedData = deZeroedData.substring(0, deZeroedData.length() - 1);
        }
        
        e.m_sender = addr;
        e.m_port = port;
        e.m_eventXML = deZeroedData;
        e.m_ackEvents = new ArrayList<Event>(16);
        e.m_log = null;

        LogUtils.debugf(ConvertToEvent.class, "Converting to event: %s", e);

        final SyslogParser parser;
        try {
            Method m = m_parserClass.getDeclaredMethod("getParser", String.class);
            Object[] args = new Object[] { e.m_eventXML };
            parser = (SyslogParser)m.invoke(ConvertToEvent.class, args);
        } catch (final Exception ex) {
            LogUtils.debugf(ConvertToEvent.class, ex, "Unable to get parser for class '%s'", m_parserClass.getName());
            throw new MessageDiscardedException(ex);
        }

        if (!parser.find()) {
            throw new MessageDiscardedException("message does not match");
        }
        SyslogMessage message;
        try {
            message = parser.parse();
        } catch (final SyslogParserException ex) {
            LogUtils.debugf(ConvertToEvent.class, ex, "Unable to parse '%s'", e.m_eventXML);
            throw new MessageDiscardedException(ex);
        }

        LogUtils.debugf(ConvertToEvent.class, "got syslog message %s", message);
        if (message == null) {
            throw new MessageDiscardedException(String.format("Unable to parse '%s'", e.m_eventXML));
        }
        // Build a basic event out of the syslog message

        final Event event = new Event();
        event.setSource("syslogd");

        // Set event host
        try {
            event.setHost(InetAddress.getLocalHost().getHostName());
        } catch (UnknownHostException uhE) {
            event.setHost("unresolved.host");
            LogUtils.warnf(ConvertToEvent.class, uhE, "Failed to resolve local hostname.");
        }

        final String hostAddress = message.getHostAddress();
        if (hostAddress != null && hostAddress.length() > 0) {
            // Set nodeId
            long nodeId = SyslogdIPMgr.getNodeId(hostAddress);
            if (nodeId != -1) {
                event.setNodeid(nodeId);
            }

            event.setInterface(hostAddress);
        }

        event.setCreationTime(EventConstants.formatToString(message.getDate()));
        event.setTime(EventConstants.formatToString(new Date()));
        final Logmsg logmsg = new Logmsg();
        logmsg.setDest("logndisplay");

        final String priorityTxt = SyslogDefs.getPriorityName(message.getSeverity());
        final String facilityTxt = SyslogDefs.getFacilityName(message.getFacility());

        //Check for UEI matching or allow a simple standard one.

        event.setUei("uei.opennms.org/syslogd/" + facilityTxt + "/" + priorityTxt);

        // We will also here find out if, the host needs to
        // be replaced, the message matched to a UEI, and
        // last if we need to actually hide the message.
        // this being potentially helpful in avoiding showing
        // operator a password or other data that should be
        // confidential.

        /*
        * We matched on a regexp for host/message pair.
        * This can be a forwarded message as in BSD Style
        * or syslog-ng.
        * We assume that the host is given to us
        * as an IP/Hostname and that the resolver
        * on the ONMS host actually can resolve the
        * node to match against nodeId.
         */

        // We will need these shortly
        final Parms eventParms = new Parms();
        Parm eventParm = null;
        Value parmValue = null;
        
        Pattern msgPat = null;
        Matcher msgMat = null;

        // Time to verify UEI matching.

        final String fullText = message.getFullText();
        
        final List<UeiMatch> ueiMatch = ueiList.getUeiMatchCollection();
        if (ueiMatch == null) {
            LogUtils.warnf(ConvertToEvent.class, "No ueiList configured.");
        } else {
            for (final UeiMatch uei : ueiMatch) {
                if (uei.getMatch().getType().equals("substr")) {
                    if (matchSubstring(discardUei, event, fullText, uei)) {
                	    break;
                	}
                } else if (uei.getMatch().getType().equals("regex")) {
                    if (matchRegex(message, uei, event, eventParms, discardUei)) {
                        break;
                    }
                }
            }
        }

        // Time to verify if we need to hide the message
        boolean doHide = false;
        final List<HideMatch> hideMatch = hideMessage.getHideMatchCollection();
        if (hideMatch == null) {
            LogUtils.warnf(ConvertToEvent.class, "No hideMessage configured.");
        } else {
            for (final HideMatch hide : hideMatch) {
                if (hide.getMatch().getType().equals("substr")) {
                    if (fullText.contains(hide.getMatch().getExpression())) {
                        // We should hide the message based on this match
                    	doHide = true;
                    }            	
                } else if (hide.getMatch().getType().equals("regex")) {
                	try {
                    	msgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);
                    	msgMat = msgPat.matcher(fullText);            		
                	} catch (PatternSyntaxException pse) {
                	    LogUtils.warnf(ConvertToEvent.class, pse, "Failed to compile regex pattern '%s'", hide.getMatch().getExpression());
                		msgMat = null;
                	}
                	if ((msgMat != null) && (msgMat.find())) {
                        // We should hide the message based on this match
                		doHide = true;
                	}
                }
                if (doHide) {
                    LogUtils.debugf(ConvertToEvent.class, "Hiding syslog message from Event - May contain sensitive data");
                    message.setMessage(HIDDEN_MESSAGE);
    	            // We want to stop here, no point in checking further hideMatches
    	            break;
                }
            }
        }

        // Using parms provides configurability.
        logmsg.setContent(message.getMessage());
        event.setLogmsg(logmsg);

        // Add appropriate parms
        eventParm = new Parm();
        eventParm.setParmName("syslogmessage");
        parmValue = new Value();
        parmValue.setContent(message.getMessage());
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("severity");
        parmValue = new Value();
        parmValue.setContent("" + priorityTxt);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("timestamp");
        parmValue = new Value();
        parmValue.setContent(message.getSyslogFormattedDate());
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        if (message.getProcessName() != null) {
            eventParm = new Parm();
            eventParm.setParmName("process");
            parmValue = new Value();
            parmValue.setContent(message.getProcessName());
            eventParm.setValue(parmValue);
            eventParms.addParm(eventParm);
        }

        eventParm = new Parm();
        eventParm.setParmName("service");
        parmValue = new Value();
        parmValue.setContent("" + facilityTxt);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        if (message.getProcessId() != null) {
            eventParm = new Parm();
            eventParm.setParmName("processid");
            parmValue = new Value();
            parmValue.setContent(message.getProcessId().toString());
            eventParm.setValue(parmValue);
            eventParms.addParm(eventParm);
        }

        // Good thing(TM)
        event.setParms(eventParms);

        e.m_event = event;
        return e;
    }

