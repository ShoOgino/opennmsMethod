    /**
     * Constructs a new event encapsulation instance based upon the
     * information passed to the method. The passed byte array is decoded into
     * a string using the <tt>US-ASCII</tt> character encoding.
     *
     * @param addr The remote agent's address.
     * @param port The remote agent's port
     * @param data The XML data in US-ASCII encoding.
     * @param len  The length of the XML data in the buffer.
     * @throws java.io.UnsupportedEncodingException
     *          Thrown if the data buffer cannot be decoded using the
     *          US-ASCII encoding.
     */
    static ConvertToEvent make(InetAddress addr, int port, byte[] data,
                               int len, String matchPattern, int hostGroup, int messageGroup,
                               UeiList ueiList, HideMessage hideMessage)
            throws UnsupportedEncodingException {

        ConvertToEvent e = new ConvertToEvent();

        // Get host address /

        e.m_sender = addr;
        e.m_port = port;
        e.m_eventXML = new String(data, 0, len, "US-ASCII");
        e.m_ackEvents = new ArrayList(16);
        e.m_log = null;

        String m_logPrefix = Syslogd.LOG4J_CATEGORY;
        ThreadCategory.setPrefix(m_logPrefix);
        ThreadCategory.setPrefix(LOG4J_CATEGORY);
        Category log = ThreadCategory.getInstance();

        log.debug("In the make part of UdpReceivedSyslog " + e.toString());

        // Build a basic event out of the syslog message

        Event event = new Event();
        event.setSource("syslogd");

        // Set nodeId

        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll("/",
                ""));
        // log.debug("Nodeid via SyslogdIPMgr " +
        // SyslogdIPMgr.getNodeId(addr.toString().replaceAll("/","")));

        if (nodeId != -1)
            event.setNodeid(nodeId);

        // Set event host
        //
        try {
            event.setHost(InetAddress.getLocalHost().getHostName());
        } catch (UnknownHostException uhE) {
            event.setHost("unresolved.host");
            log.warn("Failed to resolve local hostname", uhE);
        }

        event.setInterface(addr.toString().replaceAll("/", ""));

        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));
        Logmsg logmsg = new Logmsg();
        logmsg.setDest("logndisplay");

        String message = new String(data, 0, len, "US-ASCII");

        // log.debug("The parsed message... " + message );

        int lbIdx = message.indexOf('<');
        int rbIdx = message.indexOf('>');

        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {
            log.warn("Syslogd received an unparsable message!");
        }

        int priCode = 0;
        String priStr = message.substring(lbIdx + 1, rbIdx);

        try {
            priCode = Integer.parseInt(priStr);
        } catch (NumberFormatException ex) {
            log.debug("ERROR Bad priority code '" + priStr + "'");

        }

        int facility = SyslogDefs.extractFacility(priCode);
        int priority = SyslogDefs.extractPriority(priCode);

        String priorityTxt = SyslogDefs.getPriorityName(priority);
        // event.setSeverity(priorityTxt);
        // We leave the priority alone, this might need to be set.

        String facilityTxt = SyslogDefs.getFacilityName(facility);

        //Check for UEI matching or allow a simple standard one.

        event.setUei("uei.opennms.org/syslogd/" + facilityTxt + "/"
                + priorityTxt);

        // message = message.substring(rbIdx + 1, (message.length() - 1));

        message = message.substring(rbIdx + 1, (message.length()));

        //
        // Check to see if msg looks non-standard.
        // In this case, it means that there is not a standard
        // date in the front of the message text.
        //
        boolean stdMsg = true;

        if (message.length() < 16) {
            stdMsg = false;
        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '
                || message.charAt(9) != ':' || message.charAt(12) != ':'
                || message.charAt(15) != ' ') {
            stdMsg = false;
        }

        String timestamp;

        if (!stdMsg) {
            try {
                timestamp = SyslogTimeStamp.getInstance().format(new Date());
            } catch (IllegalArgumentException ex) {
                log.debug("ERROR INTERNAL DATE ERROR!");
                timestamp = "";
            }
        } else {
            timestamp = message.substring(0, 15);
            message = message.substring(16);
        }

        // These 2 debugs will aid in analyzing the regexpes as syslog seems
        // to differ alot
        // depending on implementation or message structure.

        log.debug("Message : " + message);
        log.debug("Pattern : " + matchPattern);
        log.debug("Host group: " + hostGroup);
        log.debug("Message group: " + messageGroup);

        // We will also here find out if, the host needs to
        // be replaced, the message matched to a UEI, and
        // last if we need to actually hide the message.
        // this being potentially helpful in avoiding showing
        // operator a password or other data that should be
        // confindential.

        Pattern pattern = Pattern.compile(matchPattern);
        Matcher m = pattern.matcher(message);

        /*
        * We matched on a regexp for host/message pair.
        * This can be a forwarded message as in BSD Style
        * or syslog-ng.
        * We assume that the host is given to us
        * as an IP/Hostname and that the resolver
        * on the ONMS host actually can resolve the
        * node to match against nodeId.
         */

        if ((m = pattern.matcher(message)).matches()) {

            log.debug("Regexp matched message: " + message);
            log.debug("Host: " + m.group(hostGroup));
            log.debug("Message: " + m.group(messageGroup));

            // We will try and extract an IP address from
            // a hostname.....

            String myHost = "";

            try {
                InetAddress address = InetAddress.getByName(m.group(hostGroup));
                byte[] ipAddr = address.getAddress();

                // Convert to dot representation
                for (int i = 0; i < ipAddr.length; i++) {
                    if (i > 0) {
                        myHost += ".";
                    }
                    myHost += ipAddr[i] & 0xFF;
                }
            } catch (UnknownHostException e1) {
                log.info("Could not parse the host: " + e1);

            }

            if (!"".equals(myHost)) {
                nodeId = SyslogdIPMgr.getNodeId(myHost.replaceAll(
                        "/",
                        ""));

                if (nodeId != -1)
                  event.setNodeid(nodeId);
                  // Clean up for further processing....
                  event.setInterface(myHost.replaceAll("/", ""));
                message = m.group(messageGroup);
                log.debug("Regexp used to find node: " + event.getNodeid());
            }
        }

        // We will need these shortly
        Parms eventParms = new Parms();
        Parm eventParm = null;
        Value parmValue = null;
        
        Pattern msgPat;
        Matcher msgMat;

        // Time to verify UEI matching.

        Iterator match = ueiList.getUeiMatchCollection().iterator();
        UeiMatch uei;
        while (match.hasNext()) {

            uei = (UeiMatch) match.next();
            if (uei.getMatch().getType().equals("substr")) {
                log.debug("Attempting substring match for text of a Syslogd event to :" + uei.getMatch().getExpression());
            	if (message.contains(uei.getMatch().getExpression())) {
                    //We can pass a new UEI on this
                    log.debug("Changed the UEI of a Syslogd event, based on substring match, to :" + uei.getUei());
                    event.setUei(uei.getUei());
                    // I think we want to stop processing here so the first
                    // ueiMatch wins, right?
                    break;
                }
            } else if (uei.getMatch().getType().equals("regex")) {
                log.debug("Attempting regex match for text of a Syslogd event to :" + uei.getMatch().getExpression());
                try {
            		msgPat = Pattern.compile(uei.getMatch().getExpression(), Pattern.MULTILINE);
            		msgMat = msgPat.matcher(message);
                } catch(PatternSyntaxException pse) {
            		log.error("Failed to compile regex pattern '"+uei.getMatch().getExpression()+"'", pse);
            		msgMat = null;
            	}
            	if ((msgMat != null) && (msgMat.matches())) {
            		// We matched a UEI
            		log.debug("Changed the UEI of a Syslogd event, based on regex match, to :" + uei.getUei());
            		event.setUei(uei.getUei());
            		if (msgMat.groupCount() > 0) {
            			for (int groupNum = 1; groupNum <= msgMat.groupCount(); groupNum++) {
            				log.debug("Added parm 'group"+groupNum+"' with value '"+msgMat.group(groupNum)+"' to Syslogd event based on regex match group");
            				eventParm = new Parm();
            				eventParm.setParmName("group"+groupNum);
            				parmValue = new Value();
            				parmValue.setContent(msgMat.group(groupNum));
            				eventParm.setValue(parmValue);
            				eventParms.addParm(eventParm);
            			}
            		}
                    // I think we want to stop processing here so the first
                    // ueiMatch wins, right?
            		break;
            	}
            }
        }

        // Time to verify if we need to hide the message

        match = hideMessage.getHideMatchCollection().iterator();

        HideMatch hide;
    	boolean doHide = false;
        while (match.hasNext()) {
            hide = (HideMatch) match.next();
            if (hide.getMatch().getType().equals("substr")) {
                if (message.contains(hide.getMatch().getExpression())) {
                    // We should hide the message based on this match
                	doHide = true;
                }            	
            } else if (hide.getMatch().getType().equals("regex")) {
            	try {
                	msgPat = Pattern.compile(hide.getMatch().getExpression(), Pattern.MULTILINE);
                	msgMat = msgPat.matcher(message);            		
            	} catch (PatternSyntaxException pse) {
            		log.error("Failed to compile regex pattern '"+hide.getMatch().getExpression()+"'", pse);
            		msgMat = null;
            	}
            	if ((msgMat != null) && (msgMat.matches())) {
                    // We should hide the message based on this match
            		doHide = true;
            	}
            }
            if (doHide) {
	            log.debug("Hiding syslog message from Event - May contain sensitive data");
	            message = HIDDEN_MESSAGE;
	            // We want to stop here, no point in checking further hideMatches
	            break;
            }
        }

        lbIdx = message.indexOf('[');
        rbIdx = message.indexOf(']');
        int colonIdx = message.indexOf(':');
        int spaceIdx = message.indexOf(' ');

        int processId = 0;
        String processName = "";
        String processIdStr = "";

        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1)
                && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, lbIdx);
            processIdStr = message.substring(lbIdx + 1, rbIdx);
            message = message.substring(colonIdx + 2);

            try {
                processId = Integer.parseInt(processIdStr);
            } catch (NumberFormatException ex) {
                log.debug("ERROR Bad process id '" + processIdStr + "'");
                processId = 0;
            }
        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0
                && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, colonIdx);
            message = message.substring(colonIdx + 2);
        }

        // log.debug(processName +"," + processId + " " + timestamp + " " +
        // message);

        // Using parms provides configurability.
        logmsg.setContent(message);
        event.setLogmsg(logmsg);

        // Add appropriate parms
        eventParm = new Parm();
        eventParm.setParmName("syslogmessage");
        parmValue = new Value();
        parmValue.setContent((message));
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("severity");
        parmValue = new Value();
        parmValue.setContent("" + priorityTxt);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("timestamp");
        parmValue = new Value();
        parmValue.setContent(timestamp);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("process");
        parmValue = new Value();
        parmValue.setContent(processName);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("service");
        parmValue = new Value();
        parmValue.setContent("" + facilityTxt);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        eventParm = new Parm();
        eventParm.setParmName("processid");
        parmValue = new Value();
        parmValue.setContent("" + processId);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);

        // Good thing(tm)
        event.setParms(eventParms);

        // log.debug("Returning from SyslogToEvent " + event.toString());
        e.m_event = event;
        return e;
    }

