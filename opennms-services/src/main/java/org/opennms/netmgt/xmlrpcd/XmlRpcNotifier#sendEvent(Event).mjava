    /**
     * <p>
     * Notify the external event xmlrpc server of the occurrence of a generic
     * event -- ie. an event that's been configured for XMLRPC forwarding, but
     * which does not correspond to one of the specific event methods of this
     * class
     *
     * @param event a {@link org.opennms.netmgt.xml.event.Event} object.
     * @return a boolean.
     */
    public boolean sendEvent(final Event event) {
        Assert.notNull(event, "event object must not be null");
        
        // FIXME: This is unused and is intended for Spring xmlrpc integration
        //Object o = m_recipient.sendNodeUpEvent(getLabelForEventNode3event), getEventHost(event), event.getTime());
        
        // Create the request parameters list
        final Vector<Object> params = new Vector<Object>();
        final Hashtable<String, String> table = new Hashtable<String, String>();
        params.addElement(table);

        final String source = event.getSource();
		if (source != null) {
            table.put("source", source);
        }
        
        final String label = getLabelForEventNode(event);
        if (label != null) {
            table.put("nodeLabel", label);
        }
        
        final String host = getEventHost(event);
        if (host != null) {
            table.put("host", host);
        }
        
        table.put("time", String.valueOf(event.getTime()));
        table.put("uei", String.valueOf(event.getUei()));
        table.put("nodeId", Long.toString(event.getNodeid()));

        final String intf = event.getInterface();
        if (intf != null) {
            table.put("interface", intf);
        }

        final String service = event.getService();
        if (service != null) {
            table.put("service", service);
        }

        final String descr = event.getDescr();
        if (descr != null) {
            table.put("description", descr);
        }
        
        final String severity = event.getSeverity();
        if (severity != null) {
            table.put("severity", event.getSeverity());
        }

        // process event parameters (if any)
        final List<Parm> eventParams = event.getParmCollection();
        if (eventParams != null)
        {
        	final int numParams = eventParams.size();
            for (int i = 0; i < numParams; i++) {
            	final Parm p = eventParams.get(i);
            	final Value v = p.getValue();

                table.put("param" + i + " name", p.getParmName());
                table.put("param" + i + " type", v.getType());
                table.put("param" + i + " value", v.getContent());
            }
        }

        if (event.getSnmp() == null) {
            return sendXmlrpcRequest(XMLRPC_GENERIC_COMMAND, params);
        } else {
            // get trap-specific fields
        	final Snmp trapInfo = event.getSnmp();

            table.put("communityString", String.valueOf(trapInfo.getCommunity()));
            table.put("genericTrapNumber", Integer.toString(trapInfo.getGeneric()));
            table.put("enterpriseId", String.valueOf(trapInfo.getId()));

            if (trapInfo.getIdtext() != null) {
                table.put("enterpriseIdText", trapInfo.getIdtext());
            }

            table.put("specificTrapNumber", Integer.toString(trapInfo.getSpecific()));
            table.put("timeStamp", Long.toString(trapInfo.getTimeStamp()));
            table.put("version", String.valueOf(trapInfo.getVersion()));

            return sendXmlrpcRequest(XMLRPC_SNMP_TRAP_COMMAND, params);
        }
    }

