    /**
     * The main worker of the fiber. This method is executed by the encapsulated
     * thread to read events from the execution queue and to execute any
     * configured scripts, allowing these scripts to react to the received
     * event. If the thread is interrupted or the status changes to
     * <code>STOP_PENDING</code> then the method will return as quickly as
     * possible.
     */
    @Override
    public void run() {

        synchronized (this) {
            m_status = RUNNING;
        }

        for (;;) {
            synchronized (this) {
                // if stopped or stop pending then break out

                if (m_status == STOP_PENDING || m_status == STOPPED) {
                    break;
                }

                // if paused or pause pending then block

                while (m_status == PAUSE_PENDING || m_status == PAUSED) {
                    m_status = PAUSED;
                    try {
                        wait();
                    } catch (InterruptedException ex) {
                        // exit
                        break;
                    }
                }

                // if resume pending then change to running

                if (m_status == RESUME_PENDING) {
                    m_status = RUNNING;
                }
            }

            // Extract the next event

            Event event = null;
            try {
                event = m_execQ.poll(1000, TimeUnit.MILLISECONDS);
                if (event == null) // status check time
                {
                    continue; // goto top of loop
                }
            } catch (InterruptedException ex) {
                break;
            }

            // check for reload event
            if (isReloadConfigEvent(event)) {
                try {
                    ScriptdConfigFactory.reload();
                    m_config = ScriptdConfigFactory.getInstance();
                    loadConfig();

                    ReloadScript[] reloadScripts = m_config.getReloadScripts();

                    for (int i = 0; i < reloadScripts.length; i++) {
                        try {
                            m_mgr.exec(reloadScripts[i].getLanguage(), "", 0, 0, reloadScripts[i].getContent());
                        }

                        catch (BSFException ex) {
                            LOG.error("Reload script[{}] failed.", i, ex);
                        }
                    }

                    LOG.debug("Script configuration reloaded");
                }

                catch (Throwable ex) {
                    LOG.error("Unable to reload ScriptD configuration: ", ex);
                }
            }

            Script[] attachedScripts = event.getScript();

            List<EventScript> mapScripts = null;

            try {
                mapScripts = m_eventScriptMap.get(event.getUei());
            }

            catch (Throwable ex) {
            }

            if (attachedScripts.length > 0 || mapScripts != null || m_eventScripts.size() > 0) {
                LOG.debug("Executing scripts for: {}", event.getUei());

                m_mgr.registerBean("event", event);

                // And the events node
                OnmsNode node = null;

                if (event.hasNodeid()) {
                    Long nodeLong = event.getNodeid();
                    Integer nodeInt = Integer.valueOf(nodeLong.intValue());
                    // NMS-8294: Initialize the entire node hierarchy so that
                    // BSF scripts can execute outside of a transaction
                    node = m_nodeDao.getHierarchy(nodeInt);
                    m_mgr.registerBean("node", node);
                }

                // execute the scripts attached to the event

                LOG.debug("Executing attached scripts");
                if (attachedScripts.length > 0) {
                    for (int i = 0; i < attachedScripts.length; i++) {
                        try {
                            Script script = attachedScripts[i];
                            m_mgr.exec(script.getLanguage(), "", 0, 0, script.getContent());
                        }

                        catch (BSFException ex) {
                            LOG.error("Attached script [{}] execution failed", i, ex);
                        }
                    }
                }

                // execute the scripts mapped to the UEI

                LOG.debug("Executing mapped scripts");
                if (mapScripts != null) {
                    for (int i = 0; i < mapScripts.size(); i++) {
                        try {
                            EventScript script = (EventScript) mapScripts.get(i);
                            m_mgr.exec(script.getLanguage(), "", 0, 0, script.getContent());
                        }

                        catch (BSFException ex) {
                            LOG.error("UEI-specific event handler script execution failed: {}", event.getUei(), ex);
                        }
                    }
                }

                // execute the scripts that are not mapped to any UEI

                LOG.debug("Executing global scripts");
                for (int i = 0; i < m_eventScripts.size(); i++) {
                    try {
                        EventScript script = (EventScript) m_eventScripts.get(i);
                        m_mgr.exec(script.getLanguage(), "", 0, 0, script.getContent());
                    }

                    catch (BSFException ex) {
                        LOG.error("Non-UEI-specific event handler script [{}] execution failed", i, ex);
                    }
                }

		if (node != null)
		    m_mgr.unregisterBean("node");
		
                m_mgr.unregisterBean("event");

                LOG.debug("Finished executing scripts for: {}", event.getUei());

            }
        } // end infinite loop

        synchronized (this) {
            m_status = STOPPED;
        }

    } // end run

