    public PollStatus pollTimeUdp(MonitoredService svc, Map<String, Object> parameters, PollStatus serviceStatus, TimeoutTracker tracker, InetAddress ipv4Addr, int port, int allowedSkew, boolean persistSkew) {
        int localTime = 0;
        int remoteTime = 0;
        boolean gotTime = false;
        for (tracker.reset(); tracker.shouldRetry() && !gotTime; tracker.nextAttempt()) {
            DatagramSocket socket = null;
            try {
    
                tracker.startAttempt();
    
                socket = new DatagramSocket();
                socket.setSoTimeout(tracker.getSoTimeout());
                log().debug("Requesting time from host: " + ipv4Addr + " on UDP port: " + port);
    
                //
                // Send an empty datagram per RFC868
                //
                socket.send(new DatagramPacket(new byte[]{}, 0, ipv4Addr, port));
                
                //
                // Try to receive a response from the remote socket
                //
                byte[] timeBytes = new byte[4];
                ByteBuffer timeByteBuffer = ByteBuffer.wrap(timeBytes);
                DatagramPacket timePacket = new DatagramPacket(timeBytes, timeBytes.length, ipv4Addr, port);
                socket.receive(timePacket);
                int bytesRead = timePacket.getLength();
    
                if (bytesRead != 4)
                    continue;
                if (log().isDebugEnabled()) {
                    log().debug("pollTimeUdp: bytes read = " + bytesRead);
                }
                
                try {
                    remoteTime = timeByteBuffer.getInt();
                } catch (BufferUnderflowException bue) {
                    log().error("Encountered buffer underflow while reading time from remote socket.");
                    remoteTime = 0;
                    serviceStatus = PollStatus.unavailable("Failed to read a valid time from remote host.");
                    continue; // to next iteration of for() loop
                }
                
                localTime  = (int)(System.currentTimeMillis() / 1000) - EPOCH_ADJ_FACTOR;
                gotTime = true;
                serviceStatus = qualifyTime(remoteTime, localTime, allowedSkew, serviceStatus, tracker.elapsedTimeInMillis(), persistSkew);
            } catch (PortUnreachableException e) {
                serviceStatus = logDown(Level.DEBUG, "Port unreachable exception for address " + ipv4Addr.getHostAddress(), e);
            } catch (NoRouteToHostException e) {
                serviceStatus = logDown(Level.WARN, "No route to host exception for address " + ipv4Addr.getHostAddress(), e);
            } catch (InterruptedIOException e) {
                serviceStatus = logDown(Level.DEBUG, "did not connect to host with " + tracker);
            } catch (IOException e) {
                serviceStatus = logDown(Level.DEBUG, "IOException while polling address: " + ipv4Addr, e);
            } finally {
                if (socket != null)
                    socket.close();
            }
        }
        return serviceStatus;
    }

