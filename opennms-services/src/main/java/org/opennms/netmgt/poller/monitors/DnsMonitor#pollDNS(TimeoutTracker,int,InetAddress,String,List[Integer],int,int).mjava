    private PollStatus pollDNS(final TimeoutTracker timeoutTracker, final int port, final InetAddress address, final String lookup, final List<Integer> fatalCodes, int minAnswers, int maxAnswers) {
    	final String addr = InetAddressUtils.str(address);
        for (timeoutTracker.reset(); timeoutTracker.shouldRetry(); timeoutTracker.nextAttempt()) {
            try {
                final Name name = Name.fromString(lookup, Name.root);
                final SimpleResolver resolver = new SimpleResolver();
                resolver.setAddress(new InetSocketAddress(addr, port));
                resolver.setLocalAddress((InetSocketAddress)null);
                double timeout = timeoutTracker.getSoTimeout()/1000;
                resolver.setTimeout((timeout < 1 ? 1 : (int) timeout));
                final Record question = Record.newRecord(name, Type.A, DClass.IN);
                final Message query = Message.newQuery(question);
                PollStatus status;

                timeoutTracker.startAttempt();
                final Message response = resolver.send(query);
                double responseTime = timeoutTracker.elapsedTimeInMillis();

                final Integer rcode = response.getHeader().getRcode();
                LOG.debug("received response code: {}", rcode);

                if (fatalCodes.contains(rcode)) {
                    status = PollStatus.unavailable("Received an invalid DNS response for address: " + addr);
                    LOG.debug(status.getReason());
                    return status;
                } else if (minAnswers != DEFAULT_MIN_ANSWERS || maxAnswers != DEFAULT_MAX_ANSWERS) {
                    int numAnswers = response.getSectionArray(Section.ANSWER).length;
                    boolean tooFewAnswers = numAnswers < minAnswers;
                    boolean tooManyAnswers = numAnswers > maxAnswers;
                    if (tooFewAnswers) {
                        status = PollStatus.unavailable("Response contained only " + numAnswers + " answer(s), but at least " + minAnswers + " answers(s) are needed.");
                        LOG.warn(status.getReason());
                        return status;
                    }
                    if (tooManyAnswers) {
                        status = PollStatus.unavailable("Response contained " + numAnswers + " answer(s), but " + maxAnswers + " or fewer answers(s) are needed.");
                        LOG.warn(status.getReason());
                        return status;
                    }
                    status = PollStatus.up(responseTime);
                    LOG.debug("valid DNS response received with {} answer(s), responseTime = {}ms", numAnswers, responseTime);
                    return status;
                } else {
                    status = PollStatus.up(responseTime);
                    LOG.debug("valid DNS response received, responseTime = {}ms", responseTime);
                    return status;
                }

            } catch (final InterruptedIOException e) {
                // No response received, retry without marking the poll failed. If we get this condition over and over until 
                // the retries are exhausted, it will leave serviceStatus null and we'll get the log message at the bottom 
            } catch (final NoRouteToHostException e) {
                String reason1 = "No route to host exception for address: " + addr;
                LOG.debug(reason1, e);
                return PollStatus.unavailable(reason1);
            } catch (final ConnectException e) {
                String reason1 = "Connection exception for address: " + addr;
                LOG.debug(reason1, e);
                return PollStatus.unavailable(reason1);
            } catch (final IOException e) {
                String reason1 = "IOException while polling address: " + addr + " " + e.getMessage();
                LOG.debug(reason1, e);
                return PollStatus.unavailable(reason1);
            }
        }
        String reason = "Never received valid DNS response for address: " + addr;
       
        LOG.debug(reason);
        return PollStatus.unavailable(reason);
    }

