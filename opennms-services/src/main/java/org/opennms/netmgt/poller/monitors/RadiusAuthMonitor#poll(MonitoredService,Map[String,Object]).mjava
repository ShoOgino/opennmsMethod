    /**
     * {@inheritDoc}
     *
     * Radius Authentication Poller
     *
     * Note that the poller will return SERVICE_AVAILABLE only if the
     * authentication Request actually succeeds. A failed authentication
     * request will result in SERVICE_UNAVILABLE, although the radius
     * server may actually be up.
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_AVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNAVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNRESPONSIVE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_AVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNAVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNRESPONSIVE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_AVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNAVAILABLE
     * @see org.opennms.netmgt.poller.ServiceMonitor#SERVICE_UNRESPONSIVE
     */
    public PollStatus poll(MonitoredService svc, Map<String, Object> parameters) {
    	final NetworkInterface<InetAddress> iface = svc.getNetInterface();

    	// Assume that the service is down
        PollStatus status = PollStatus.unavailable();

        if (parameters == null) {
            throw new NullPointerException();
        }
        
        final TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);

        int authport = ParameterMap.getKeyedInteger(parameters, "authport", DEFAULT_AUTH_PORT);
        int acctport = ParameterMap.getKeyedInteger(parameters, "acctport", DEFAULT_ACCT_PORT);
        String user = ParameterMap.getKeyedString(parameters, "user", DEFAULT_USER);
        String password = ParameterMap.getKeyedString(parameters, "password", DEFAULT_PASSWORD);
        String secret = ParameterMap.getKeyedString(parameters, "secret", DEFAULT_SECRET);
        String authType = ParameterMap.getKeyedString(parameters, "authtype", DEFAULT_AUTH_TYPE);
        String nasid = ParameterMap.getKeyedString(parameters, "nasid", DEFAULT_NASID);
        InetAddress addr = iface.getAddress();

        AttributeFactory.loadAttributeDictionary("net.jradius.dictionary.AttributeDictionaryImpl");
        final RadiusClient rc = new RadiusClient(addr, secret, authport, acctport, ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT));

        for (tracker.reset(); tracker.shouldRetry(); tracker.nextAttempt()) {
	    	final AttributeList attributes = new AttributeList();
	    	attributes.add(new Attr_UserName(user));
	    	attributes.add(new Attr_NASIdentifier(nasid));
	    	attributes.add(new Attr_UserPassword(password));
	
	    	final AccessRequest accessRequest = new AccessRequest(rc, attributes);
	    	final RadiusAuthenticator auth;
	    	if (authType.equalsIgnoreCase("chap")) {
	    		auth = new CHAPAuthenticator();
	    	} else if (authType.equalsIgnoreCase("pap")) {
	    		auth = new PAPAuthenticator();
	    	} else if (authType.equalsIgnoreCase("mschapv1")) {
	    		auth = new MSCHAPv1Authenticator();
	    	} else if (authType.equalsIgnoreCase("mschapv2")) {
	    		auth = new MSCHAPv2Authenticator();
	    	} else if (authType.equalsIgnoreCase("eapmd5") || authType.equalsIgnoreCase("eap-md5")) {
	    		auth = new EAPMD5Authenticator();
	    	} else if (authType.equalsIgnoreCase("eapmschapv2") || authType.equalsIgnoreCase("eap-mschapv2")) {
	    		auth = new EAPMSCHAPv2Authenticator();
	    	} else {
	    		return logDown(Level.ERROR, "Unknown authenticator type '" + authType + "'");
	    	}
	
        	tracker.startAttempt();

	    	RadiusPacket reply;
			try {
				reply = rc.authenticate(accessRequest, auth, ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY));
				if (reply instanceof AccessAccept) {
                    double responseTime = tracker.elapsedTimeInMillis();
                    status = PollStatus.available(responseTime);
                    LogUtils.debugf(this, "Radius service is AVAILABLE on: %s", addr.getCanonicalHostName());
                    LogUtils.debugf(this, "poll: responseTime= %fms", responseTime);
                    break;
				} else if (reply != null) {
					LogUtils.debugf(this, "response returned, but request was not accepted: %s", reply);
				}
				status = logDown(Level.ERROR, "Invalid RADIUS reply: " + reply);
			} catch (final Exception e) {
				status = logDown(Level.ERROR, "Error while attempting to connect to the RADIUS service on " + addr.getCanonicalHostName(), e);
			}
	
        }
        return status;
    }

