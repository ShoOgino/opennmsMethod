    /**
     * This method performs a check of the client version on the remote
     * service. From the <code>NsclientCheckParams</code> object passed to
     * this method only the 'parameter' string is used, this contains the four
     * digit version number which should be formatted like: 2.0.1.0 If the
     * parameter does not contain for period delimited digits, the check will
     * return the packet with with
     * <code>NsclientPacket.RES_STATE_UNKNOWN</code> for a result code.
     * 
     * @param param
     *            The param string member of this value contains the minimum
     *            client version.
     * @return the processed <code>NsclientPacket</code>.
     * @throws NsclientException
     *             this method rethrows the exception thrown by
     *             <code>sendCheckRequest</code>
     */
    private NsclientPacket checkClientVersion(NsclientCheckParams param)
            throws NsclientException {
        NsclientPacket pack = null;

        // get the client version response.
        try {
            pack = sendCheckRequest(m_Password + "&" + CHECK_CLIENTVERSION);
        } catch (NsclientException e) {
            throw e;
        }

        // Check for "ERROR" string.
        if (pack.getResponse().matches(".*ERROR.*")) {
            pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);
            return pack;
        }

        // if we're not checking the clientversion, just return OK.
        if (param.getParamString() == null
                || param.getParamString().equals("")) {
            pack.setResultCode(NsclientPacket.RES_STATE_OK);
            return pack;
        } else {
            // otherwise, if we are checking, split it up into four octets and
            // compare.
            pack.setResultCode(NsclientPacket.RES_STATE_CRIT);
            String[] minimum = param.getParamString().split("\\.");
            String[] remote = pack.getResponse().split("\\.");

            // make sure they both contain the same number of version digits.
            if (remote.length != 4 || minimum.length != 4) {
                pack.setResultCode(NsclientPacket.RES_STATE_UNKNOWN);
                return pack;
            }

            // then convert them to arrays.
            Integer[] remVer = { new Integer(Integer.parseInt(remote[0])),
                    new Integer(Integer.parseInt(remote[1])),
                    new Integer(Integer.parseInt(remote[2])),
                    new Integer(Integer.parseInt(remote[3])) };
            Integer[] minVer = { new Integer(Integer.parseInt(minimum[0])),
                    new Integer(Integer.parseInt(minimum[1])),
                    new Integer(Integer.parseInt(minimum[2])),
                    new Integer(Integer.parseInt(minimum[3])) };

            if (remVer[0].compareTo(minVer[0]) > 0) {
                pack.setResultCode(NsclientPacket.RES_STATE_OK);
            } else if (remVer[0].compareTo(minVer[0]) == 0) {
                if (remVer[1].compareTo(minVer[1]) > 0) {
                    pack.setResultCode(NsclientPacket.RES_STATE_OK);
                } else if (remVer[1].compareTo(minVer[1]) == 0) {
                    if (remVer[2].compareTo(minVer[2]) > 0) {
                        pack.setResultCode(NsclientPacket.RES_STATE_OK);
                    } else if (remVer[2].compareTo(minVer[2]) == 0) {
                        if (remVer[3].compareTo(minVer[3]) > 0) {
                            pack.setResultCode(NsclientPacket.RES_STATE_OK);
                        } else if (remVer[3].compareTo(minVer[3]) == 0) {
                            pack.setResultCode(NsclientPacket.RES_STATE_OK);
                        }
                    }
                }
            }

            return pack;
        }
    }

