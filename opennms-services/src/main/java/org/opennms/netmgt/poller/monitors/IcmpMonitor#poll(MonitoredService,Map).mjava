    /**
     * <P>
     * Poll the specified address for ICMP service availability.
     * </P>
     * 
     * <P>
     * The ICMP service monitor relies on Discovery for the actual generation of
     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is
     * utilized for passing poll requests and receiving poll replies from
     * discovery. All exchanges are SOAP/XML compliant.
     * </P>
     * @param parameters
     *            The package parameters (timeout, retry, etc...) to be used for
     *            this poll.
     * @param iface
     *            The network interface to test the service on.
     * @return The availibility of the interface and if a transition event
     *         should be supressed.
     * 
     */
    public PollStatus poll(MonitoredService svc, Map parameters) {
        NetworkInterface iface = svc.getNetInterface();

        // Get interface address from NetworkInterface
        //
        if (iface.getType() != NetworkInterface.TYPE_IPV4)
            throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_IPV4 currently supported");

        Category log = ThreadCategory.getInstance(this.getClass());

        // get parameters
        //
        int retry = ParameterMap.getKeyedInteger(parameters, "retry", DEFAULT_RETRY);
        int timeout = ParameterMap.getKeyedInteger(parameters, "timeout", DEFAULT_TIMEOUT);

        // Find an appropritate thread id
        //
        Long tidKey = null;
        long tid = (long) Thread.currentThread().hashCode();
       InetAddress ipv4Addr = (InetAddress) iface.getAddress();
       Ping reply = new Ping(ipv4Addr);

       synchronized (m_waiting)
       {
            while (m_waiting.containsKey(tidKey = new Long(tid)))
                ++tid;
          m_waiting.put(tidKey, reply);
        }
        DatagramPacket pkt = getDatagram(ipv4Addr, tid);

        PollStatus serviceStatus = PollStatus.unavailable();
        for (int attempts = 0; attempts <= retry && !reply.isSignaled(); ++attempts) {
            // Send the datagram and wait
            //
            synchronized (reply) {
                try {
                    m_icmpSock.send(pkt);
                } catch (IOException ioE) {
                    log.info("Failed to send to address " + ipv4Addr, ioE);
                    break;
                } catch (Throwable t) {
                    log.info("Undeclared throwable exception caught sending to " + ipv4Addr, t);
                    break;
                }

                try {
                    reply.wait(timeout);
                } catch (InterruptedException ex) {
                    // interrupted so return, reset interrupt.
                    //
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }

        synchronized (m_waiting)
        {
           m_waiting.remove(tidKey);
        }


        if (reply.isSignaled()) {
            serviceStatus = PollStatus.available();

            // Determine round-trip-time for the ping packet
            ICMPEchoPacket replyPkt = reply.getPacket();
            if (replyPkt != null) {
                long rtt = replyPkt.getPingRTT();
                serviceStatus.setResponseTime(rtt);
                log.debug("Ping round trip time for " + ipv4Addr + ": " + rtt + "us");
            }
        }

        return serviceStatus;
    }

