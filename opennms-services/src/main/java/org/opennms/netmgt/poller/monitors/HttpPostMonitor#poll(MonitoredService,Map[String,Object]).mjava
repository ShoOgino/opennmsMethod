    /**
     * {@inheritDoc}
     *
     * Poll the specified address for service availability.
     *
     * During the poll an attempt is made to execute the named method (with optional input) connect on the specified port. If
     * the exec on request is successful, the banner line generated by the
     * interface is parsed and if the banner text indicates that we are talking
     * to Provided that the interface's response is valid we set the service
     * status to SERVICE_AVAILABLE and return.
     */
    public PollStatus poll(MonitoredService svc, Map<String, Object> parameters) {
        NetworkInterface<InetAddress> iface = svc.getNetInterface();

        // Process parameters

        // Get interface address from NetworkInterface
        if (iface.getType() != NetworkInterface.TYPE_INET)
          throw new NetworkInterfaceNotSupportedException("Unsupported interface type, only TYPE_INET currently supported");

        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);

        // Port
        int port = ParameterMap.getKeyedInteger(parameters, PARAMETER_PORT, DEFAULT_PORT);

        //URI
        String strURI = ParameterMap.getKeyedString(parameters, PARAMETER_URI, DEFAULT_URI);

        //Username
        String strUser = ParameterMap.getKeyedString(parameters, PARAMETER_USERNAME, null);

        //Password
        String strPasswd = ParameterMap.getKeyedString(parameters, PARAMETER_PASSWORD, null);

        //BannerMatch
        String strBannerMatch = ParameterMap.getKeyedString(parameters, PARAMETER_BANNER, null);

        //Scheme
        String strScheme = ParameterMap.getKeyedString(parameters, PARAMETER_SCHEME, DEFAULT_SCHEME);

        //Payload
        String strPayload = ParameterMap.getKeyedString(parameters, PARAMETER_PAYLOAD, null);

        //Mimetype
        String strMimetype = ParameterMap.getKeyedString(parameters, PARAMETER_MIMETYPE, DEFAULT_MIMETYPE);

        //Charset
        String strCharset = ParameterMap.getKeyedString(parameters, PARAMETER_CHARSET, DEFAULT_CHARSET);

        InetAddress ipv4Addr = (InetAddress) iface.getAddress();

        final String hostAddress = InetAddressUtils.str(ipv4Addr);
        
        LOGGER.debug("poll: address = " + hostAddress + ", port = " + port + ", " + tracker);

        // Give it a whirl
        PollStatus serviceStatus = PollStatus.unavailable();

        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {
            try {
                tracker.startAttempt();

                HttpHost httpHost = new HttpHost(hostAddress, port);
                HttpParams clientParams = new BasicHttpParams();
                clientParams.setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, tracker.getSoTimeout());
                clientParams.setIntParameter(CoreConnectionPNames.SO_TIMEOUT, tracker.getSoTimeout());
                DefaultHttpClient client = new DefaultHttpClient(clientParams);
                client.setHttpRequestRetryHandler(new DefaultHttpRequestRetryHandler(DEFAULT_RETRY, false));
                HttpEntity postReq;

                if (strUser != null && strPasswd != null) {
                  Credentials defaultcreds = new UsernamePasswordCredentials(strUser, strPasswd);
                  client.getCredentialsProvider().setCredentials(AuthScope.ANY, defaultcreds);
                }

                try {
                  postReq = new StringEntity(strPayload, strMimetype, strCharset);
                } catch (UnsupportedEncodingException e) {
                  serviceStatus = PollStatus.unavailable("Unsupported encoding encountered while constructing POST body " + e);
                  break;
                }

                StringBuilder sb = new StringBuilder(strScheme);
                sb.append("://").append(hostAddress).append(":").append(port).append(strURI);

                LOGGER.debug("HttpPostMonitor: Constructed URL is " + sb);

                HttpPost post = new HttpPost(new URI(sb.toString()));
                post.setEntity(postReq);
                HttpResponse response = client.execute(httpHost, post);

                LOGGER.debug("HttpPostMonitor: Status Line is " + response.getStatusLine());

                if (response.getStatusLine().getStatusCode() > 399) {
                    LOGGER.info("HttpPostMonitor: Got response status code " + response.getStatusLine().getStatusCode());
                    LOGGER.debug("HttpPostMonitor: Received server response: " + response.getStatusLine());
                    LOGGER.debug("HttpPostMonitor: Failing on bad status code");
                    serviceStatus = PollStatus.unavailable("HTTP(S) Status code " + response.getStatusLine().getStatusCode());
                    break;
                }

                LOGGER.debug("HttpPostMonitor: Response code is valid");
                double responseTime = tracker.elapsedTimeInMillis();

                HttpEntity entity = response.getEntity();
                InputStream responseStream = entity.getContent();
                String Strresponse = IOUtils.toString(responseStream);

                if (Strresponse == null)
                    continue;

                LOGGER.debug("HttpPostMonitor: banner = " + Strresponse);
                LOGGER.debug("HttpPostMonitor: responseTime= " + responseTime + "ms");

                //Could it be a regex?
                if (strBannerMatch.charAt(0)=='~'){
                    if (!Strresponse.matches(strBannerMatch.substring(1))) {
                        serviceStatus = PollStatus.unavailable("Banner does not match Regex '"+strBannerMatch+"'");
                        break;
                    }
                    else {
                        serviceStatus = PollStatus.available(responseTime);
                    }
                }
                else {
                    if (Strresponse.indexOf(strBannerMatch) > -1) {
                        serviceStatus = PollStatus.available(responseTime);
                    }
                    else {
                        serviceStatus = PollStatus.unavailable("Did not find expected Text '"+strBannerMatch+"'");
                        break;
                    }
                }

            } catch (URISyntaxException e) {
                String reason = "URISyntaxException for URI: " + strURI + " " + e.getMessage();
                LOGGER.debug(reason, e);
                serviceStatus = PollStatus.unavailable(reason);
                break;
            } catch (Exception e) {
                String reason = "Exception: " + e.getMessage();
                LOGGER.debug(reason, e);
                serviceStatus = PollStatus.unavailable(reason);
                break;
            }
        }

        // return the status of the service
        return serviceStatus;
    }

