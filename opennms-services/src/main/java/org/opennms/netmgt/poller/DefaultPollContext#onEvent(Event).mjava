    /* (non-Javadoc)
     * @see org.opennms.netmgt.eventd.EventListener#onEvent(org.opennms.netmgt.xml.event.Event)
     */
    /** {@inheritDoc} */
    @Override
    public void onEvent(final Event event) {
        if (LOG.isDebugEnabled()) {
            // CAUTION: m_pendingPollEvents.size() is not a constant-time operation
            LOG.debug("onEvent: Received event: {} uei: {}, dbid: {}, pendingEventCount: {}", event, event.getUei(), event.getDbid(), m_pendingPollEvents.size());
        }

        for (final PendingPollEvent pollEvent : m_pendingPollEvents) {
            LOG.trace("onEvent: comparing event to pollEvent: {}", pollEvent);
            // TODO: This equals comparison is more like a '==' operation because
            // I think that both events would have to be identical instances to
            // have the same event ID. This will probably cause problems if we
            // cluster event processing and the event instances are ever not 
            // identical.
            if (event.equals(pollEvent.getEvent())) {
                LOG.trace("onEvent: found matching pollEvent, completing pollEvent: {}", pollEvent);
                // Thread-safe and idempotent
                pollEvent.complete(event);
                // TODO: Can we break here? I think there should only be one 
                // instance of any given event in m_pendingPollEvents
                // break;
            }
        }

        for (final Iterator<PendingPollEvent> it = m_pendingPollEvents.iterator(); it.hasNext();) {
            final PendingPollEvent pollEvent = it.next();
            LOG.trace("onEvent: determining if pollEvent is pending: {}", pollEvent);
            if (!pollEvent.isPending()) {
                try {
                    // Thread-safe and idempotent
                    processPending(pollEvent);
                } catch (Throwable e) {
                    LOG.error("Unexpected exception while processing pollEvent: " + pollEvent, e);
                }
                // TODO: Should we remove the task before processing it? This would
                // reduce the chances that two threads could process the same event
                // simultaneously, although since the call is now thread-safe and
                // idempotent, that's not really a problem.
                it.remove();
                continue;
            }

            // If the event was not completed and it is still pending, then don't do anything to it
        }
        LOG.debug("onEvent: Finished processing event: {} uei: {}, dbid: {}", event, event.getUei(), event.getDbid());
    }

