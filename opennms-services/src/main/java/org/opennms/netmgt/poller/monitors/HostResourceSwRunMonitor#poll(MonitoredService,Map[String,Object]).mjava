    /**
     * {@inheritDoc}
     *
     * <P>
     * The poll() method is responsible for polling the specified address for
     * SNMP service availability.
     * </P>
     * @exception RuntimeException
     *                Thrown for any uncrecoverable errors.
     */
    @Override
    public PollStatus poll(MonitoredService svc, Map<String, Object> parameters) {
        NetworkInterface<InetAddress> iface = svc.getNetInterface();

        InetAddress ipaddr = (InetAddress) iface.getAddress();

        // Retrieve this interface's SNMP peer object
        //
        SnmpAgentConfig agentConfig = SnmpPeerFactory.getInstance().getAgentConfig(ipaddr);
        if (agentConfig == null) throw new RuntimeException("SnmpAgentConfig object not available for interface " + ipaddr);
        final String hostAddress = InetAddressUtils.str(ipaddr);
		log().debug("poll: setting SNMP peer attribute for interface " + hostAddress);

        // Get configuration parameters
        //
        // This should never need to be overridden, but it can be in order to be used with similar tables.
        String serviceNameOid = ParameterMap.getKeyedString(parameters, "service-name-oid", HOSTRESOURCE_SW_NAME_OID);
        // This should never need to be overridden, but it can be in order to be used with similar tables.
        String serviceStatusOid = ParameterMap.getKeyedString(parameters, "service-status-oid", HOSTRESOURCE_SW_STATUS_OID);
        // This is the string that represents the service name to be monitored.
        String serviceName = ParameterMap.getKeyedString(parameters, "service-name", null);
        // The service name may appear in the table more than once. If this is set to true, all values must match the run level.
        String matchAll = ParameterMap.getKeyedString(parameters, "match-all", "false");
        // This is one of: 
        //                   running(1),
        //                   runnable(2),    -- waiting for resource
        //                                   -- (i.e., CPU, memory, IO)
        //                   notRunnable(3), -- loaded but waiting for event
        //                   invalid(4)      -- not loaded
        //
        // This represents the maximum run-level, i.e. 2 means either running(1) or runnable(2) pass.
        String runLevel = ParameterMap.getKeyedString(parameters, "run-level", "2");
        // If "match-all" is true, there can be an optional "min-services" and "max-services" parameters that can define a range. The service is up if:
        // a) services_count >= min-services and services_count <= max-services
        // b) either one is not defined, then only one has to pass.
        // c) neither are defined, the monitor acts just like it used to - checking all instances to see if they are all running.
        // It is assumed that all services would have to pass the minimum run state test, no matter what the count.
        int minServices = ParameterMap.getKeyedInteger(parameters, "min-services", -1);
        int maxServices = ParameterMap.getKeyedInteger(parameters, "max-services", -1);

        // set timeout and retries on SNMP peer object
        //
        agentConfig.setTimeout(ParameterMap.getKeyedInteger(parameters, "timeout", agentConfig.getTimeout()));
        agentConfig.setRetries(ParameterMap.getKeyedInteger(parameters, "retry", ParameterMap.getKeyedInteger(parameters, "retries", agentConfig.getRetries())));
        agentConfig.setPort(ParameterMap.getKeyedInteger(parameters, "port", agentConfig.getPort()));

        if (log().isDebugEnabled()) log().debug("poll: service= SNMP address= " + agentConfig);
        PollStatus status = PollStatus.unavailable("HostResourceSwRunMonitor service not found, addr=" + hostAddress + ", service-name=" + serviceName);

        // Establish SNMP session with interface
        //
        int matches = 0;
        try {
            if (log().isDebugEnabled()) {
                log().debug("HostResourceSwRunMonitor.poll: SnmpAgentConfig address: " +agentConfig);
            }

            if (serviceName == null) {
                status.setReason("HostResourceSwRunMonitor no service-name defined, addr=" + hostAddress);
                log().warn("HostResourceSwRunMonitor.poll: No Service Name Defined! ");
		return status;
            }

            if (minServices > 0 && maxServices > 0 && minServices >= maxServices) {
                String reason = "min-services(" + minServices + ") should be less than max-services(" + maxServices + ")";
                status.setReason("HostResourceSwRunMonitor " + reason + ", addr=" + hostAddress+ ", service-name=" + serviceName);
                log().warn("HostResourceSwRunMonitor.poll: " + reason + ".");
                return status;
            }

            // This updates two maps: one of instance and service name, and one of instance and status.
            final SnmpObjId serviceNameOidId = SnmpObjId.get(serviceNameOid);
            final SnmpObjId serviceStatusOidId = SnmpObjId.get(serviceStatusOid);
            final Map<SnmpInstId, SnmpValue> nameResults = new HashMap<SnmpInstId, SnmpValue>();
            final Map<SnmpInstId, SnmpValue> statusResults = new HashMap<SnmpInstId, SnmpValue>();
            RowCallback callback = new RowCallback() {
                @Override
                public void rowCompleted(SnmpRowResult result) {
                    nameResults.put(result.getInstance(), result.getValue(serviceNameOidId));
                    statusResults.put(result.getInstance(), result.getValue(serviceStatusOidId));
                }
            };
            TableTracker tracker = new TableTracker(callback, serviceNameOidId, serviceStatusOidId);
            SnmpWalker walker = SnmpUtils.createWalker(agentConfig, "HostResourceSwRunMonitor", tracker);
            walker.start();
            walker.waitFor();

            // Iterate over the list of running services
            for(SnmpInstId nameInstance : nameResults.keySet()) {

                // See if the service name is in the list of running services
                if (match(serviceName, stripExtraQuotes(nameResults.get(nameInstance).toString()))) {
                    matches++;
                    log().debug("poll: HostResourceSwRunMonitor poll succeeded, addr=" + hostAddress + ", service-name=" + serviceName + ", value=" + nameResults.get(nameInstance));
                    // Using the instance of the service, get its status and see if it meets the criteria
                    if (meetsCriteria(statusResults.get(nameInstance), "<=", runLevel)) {
                        status = PollStatus.available();
                        // If we get here, that means the service passed the criteria, if only one match is desired we exit.
                        if ("false".equals(matchAll)) {
                           return status;
                        }
                    // if we get here, that means the meetsCriteria test failed. 
                    } else {
                        status = logDown(Level.DEBUG, "HostResourceSwRunMonitor poll failed, addr=" + hostAddress + ", service-name=" + serviceName + ", status=" + statusResults.get(nameInstance));
                        return status;
                    }
                }
            }
            log().debug("poll: HostResourceSwRunMonitor the number of matches found for " + serviceName + " was " + matches);

        } catch (NumberFormatException e) {
            status = logDown(Level.ERROR, "Number operator used on a non-number " + e.getMessage());
        } catch (IllegalArgumentException e) {
            status = logDown(Level.ERROR, "Invalid SNMP Criteria: " + e.getMessage());
        } catch (Throwable t) {
            status = logDown(Level.WARN, "Unexpected exception during SNMP poll of interface " + hostAddress, t);
        }
        // This will be executed only if match-all=true
        boolean minOk = minServices > 0 ? matches >= minServices : true;
        boolean maxOk = maxServices > 0 ? matches <= maxServices : true;
        if (!minOk && maxServices < 0) { // failed min-services only
            status = logDown(Level.DEBUG, "HostResourceSwRunMonitor poll failed: service-count(" + matches + ") >= min-services(" + minServices + "), addr=" + hostAddress + ", service-name=" + serviceName);
        }
        if (!maxOk && minServices < 0) { // failed max-services only
            status = logDown(Level.DEBUG, "HostResourceSwRunMonitor poll failed: service-count(" + matches + ") <= max-services(" + maxServices + "), addr=" + hostAddress + ", service-name=" + serviceName);
        }
        if ((!minOk || !maxOk) && minServices > 0 && maxServices > 0) { // failed both (bad range)
            status = logDown(Level.DEBUG, "HostResourceSwRunMonitor poll failed: min-services(" + minServices + ") >= service-count(" + matches + ") <= max-services(" + maxServices + "), addr=" + hostAddress + ", service-name=" + serviceName);
        }

        // If matchAll is set to true, then the status is set to available above with a single match.
        // Otherwise, the service will be unavailable.

        return status;
    }

