    /**
     * Verifies that collection time is subtracted from the interval
     * when then "strict interval" property is enabled.
     */
    @Test
    public void collectUsingStrictInterval() throws CollectionInitializationException, CollectionException, IOException {
        System.setProperty(CollectableService.STRICT_INTERVAL_SYS_PROP, Boolean.TRUE.toString());
        createCollectableService();

        Long serviceIntervalInMs = 2000L;
        Long collectionDelayInMs = 500L;
        when(spec.getInterval()).thenReturn(serviceIntervalInMs);
        when(spec.collect(any())).then(new Answer<CollectionSet>() {
            @Override
            public CollectionSet answer(InvocationOnMock invocation) throws InterruptedException {
                Thread.sleep(collectionDelayInMs);
                return null;
            }
        });

        // Run the CollectableService and verify that the collection time is
        // subtracted from the interval when the "strict interval" property is enabled
        ArgumentCaptor<Long> intervalCaptor = ArgumentCaptor.forClass(Long.class);
        service.run();
        verify(scheduler, times(1)).schedule(intervalCaptor.capture(), any());

        Long upperBound = serviceIntervalInMs - collectionDelayInMs;
        assertTrue(String.format("Expected the interval to be less than %d, but was %d",
                upperBound, intervalCaptor.getValue()), intervalCaptor.getValue() <= upperBound);

        when(spec.collect(any())).then(new Answer<CollectionSet>() {
            @Override
            public CollectionSet answer(InvocationOnMock invocation) throws InterruptedException {
                Thread.sleep(2 * serviceIntervalInMs);
                return null;
            }
        });

        service.run();
        verify(scheduler, times(2)).schedule(intervalCaptor.capture(), any());
        assertEquals(Long.valueOf(0), intervalCaptor.getValue());
    }

