     /**
      * Per bug report NMS-4244, multiple calls to the getCounter functionality on CollectionResourceWrapper used to pay
      * no mind of the actual time when samples were collected, instead assuming that it was the collection interval ago.
      * When a collection cycle fails (entirely or partly) and thresholded values weren't available, the counter value
      * was incorrectly calculated on the next succeeding cycle (taking the difference from the last successful 
      * collection and dividing by just a single collection interval.
      */
	@Test
	public void testGetCounterValueWithGap() throws Exception {
	        m_ignoreWarnings = true; // we get a warning on the first getAttributeValue()

		CollectionAgent agent = createCollectionAgent();
		SnmpCollectionResource resource = createNodeResource(agent);

		// Add Counter Attribute
		String attributeName = "myCounter";
	        String attributeId = "node[1].resourceType[node].instance[null].metric[" + attributeName + "]";
		Map<String, CollectionAttribute> attributes = new HashMap<String, CollectionAttribute>();
		SnmpAttribute attribute = addAttributeToCollectionResource(resource,
				attributeName, "counter", "0", 1000);
		attributes.put(attribute.getName(), attribute);

		// We manipulate the Date objects passed to the
		// CollectionResourceWrapper to simulate various collection intervals
		Date baseDate = new Date();

		// Get counter value - first time
		CollectionResourceWrapper wrapper = createWrapper(resource, attributes,
				baseDate);

		Assert.assertFalse(CollectionResourceWrapper.s_cache
				.containsKey(attributeId));
		Assert.assertEquals(Double.valueOf(Double.NaN),
				wrapper.getAttributeValue(attributeName)); // Last value is null
		Assert.assertEquals(Double.valueOf(Double.NaN),
				wrapper.getAttributeValue(attributeName)); // Last value is null
		Assert.assertEquals(Double.valueOf(1000.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);

        // Increase counter
        attribute = addAttributeToCollectionResource(resource, attributeName, "counter", "0", 2500);
        attributes.put(attribute.getName(), attribute);
        //Next wrapper is told the data was collected 5 minutes in the future (300 seconds)
        wrapper = createWrapper(resource, attributes, new Date(baseDate.getTime()+300000));
       
        // Get counter value - second time
        // Last value is 1000.0, so 2500-1000/300 = 1500/300 =  5.
        Assert.assertEquals(Double.valueOf(1000.0), CollectionResourceWrapper.s_cache.get(attributeId).value);
        Assert.assertEquals(Double.valueOf(5.0), wrapper.getAttributeValue(attributeName));
        //Validate that the cached counter value has been updated
        Assert.assertEquals(Double.valueOf(2500.0), CollectionResourceWrapper.s_cache.get(attributeId).value);
        //but that calling getAttributeValue doesn't re-calculate the rate inappropriately or update the static cache
        Assert.assertEquals(Double.valueOf(5.0), wrapper.getAttributeValue(attributeName));
        Assert.assertEquals(Double.valueOf(2500.0), CollectionResourceWrapper.s_cache.get(attributeId).value);

		// Now create a collection that is missing the counter value; we're
		// expecting null result and no cache updates
		attributes = new HashMap<String, CollectionAttribute>();
		attribute = addAttributeToCollectionResource(resource, "notMyCounter",
				"counter", "0", 1000); // We want a value, just not one called "myCounter"
		attributes.put(attribute.getName(), attribute);
		// Next collection is 10 minutes (600 seconds) after the first.
		wrapper = createWrapper(resource, attributes,
				new Date(baseDate.getTime() + 600000));

		// No change, so we expect the cache to have (and continue to) remain
		// the same, and to get no attribute value out
		Assert.assertEquals(Double.valueOf(2500.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);
		Assert.assertNull(wrapper.getAttributeValue(attributeName)); 
		Assert.assertEquals(Double.valueOf(2500.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);

		// Now if we collect successfully again, we expect the counter to be the
		// change divided by two collection cycles
		attributes = new HashMap<String, CollectionAttribute>();
		attribute = addAttributeToCollectionResource(resource, attributeName,
				"counter", "0", 7300);
		attributes.put(attribute.getName(), attribute);
		
		// Next collection is 15 minutes (900 seconds) after the first.
		wrapper = createWrapper(resource, attributes,
				new Date(baseDate.getTime() + 900000));

		// Get counter value - fourth time
		// Last value is 5500, but we've had two collection cycles, so
		// 7300-2500/600 = 4800/600 = 8
		Assert.assertEquals(Double.valueOf(2500.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);
		Assert.assertEquals(Double.valueOf(8.0), wrapper.getAttributeValue(attributeName));
		Assert.assertEquals(Double.valueOf(7300.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);
		Assert.assertEquals(Double.valueOf(8.0), wrapper.getAttributeValue(attributeName));
		Assert.assertEquals(Double.valueOf(7300.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);
		Assert.assertEquals(Double.valueOf(8.0), wrapper.getAttributeValue(attributeName));
		Assert.assertEquals(Double.valueOf(7300.0),
				CollectionResourceWrapper.s_cache.get(attributeId).value);

		EasyMock.verify(agent);
	}

