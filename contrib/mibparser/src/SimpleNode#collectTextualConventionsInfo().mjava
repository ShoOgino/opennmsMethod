  /**
   * Walk the abstract syntax tree and collect information about
   * any TEXTUAL-CONVENTIONS. The reason for collecting these in
   * a symbol table is that this relates the underlying type to
   * the text name and it is the underlying type that would need
   * to be printed in the xml.
   */
  public void collectTextualConventionsInfo() {
    //if (printDebug) System.out.println("collectTextualConventionsInfo node=" + this.toString());

    if (this.getVisited() == true) {
      return;
    }

    // Look for a tree starting with "TextConvention" or "Assignment"
    // 0) the node TextConvention has some type name
    // 1) the first child is the base type, that is referred to by the type name above
    //    TextConvention VasStates visited=false children=1
    //     GetTypeIdentifier Integer32 visited=false children=0

    boolean textConventionFound = ParseMibTreeConstants.jjtNodeName[this.id].
        equals("TextConvention") ||
        ParseMibTreeConstants.jjtNodeName[this.id].equals("Assignment");
    // walk through and find the index of the table which is the first child

    String typeName = this.getName();
    String baseTypeName = null; // will be in the child

    if (children != null) {
      // walk through the children and collect information
      String indexName = null;
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode) children[i];

        if (textConventionFound) {
          if (printDebug) {
            System.out.println("adding OID " + n.getName() + "/" + typeName +
                               " to typeNametable");
            // put all the OID vars in a symbol table (hashtable) oidName/tableName
          }
          baseTypeName = n.getName();
          typeNameTable.put(typeName, baseTypeName);
        }

        if (n != null) {
          n.collectTextualConventionsInfo();
          n.setVisited(true);
        }
      } // end for

    }

  } // end collectTextualConventionInfo

