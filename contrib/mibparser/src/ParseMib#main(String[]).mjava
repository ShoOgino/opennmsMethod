  public static void main(String args[]) {

    try {
      if (args.length == 0) {
          System.out.println("usage: ParseMib [-debug] files");
          System.out.println("version: " + Version.versionString);
          System.exit(0);
      }

      boolean setDebug = false;
      Vector argsList = new Vector();
      String arg = null;

      for (int i = 0; i < args.length; i++) {
           arg = args[i];
           // System.out.println("arg=#" + args[i] + "#");
           if (arg.equalsIgnoreCase("-debug"))
               setDebug = true;
           else if (arg.equalsIgnoreCase("")) {
               // artifact from shell, ant or error, ignore
           }
           else
               argsList.addElement(arg);
      }

      SimpleNode.setDebug(setDebug);

      SimpleNode n = null;

      boolean firstFile = true;
      ParseMib parser = null;
      for (int i = 0; i < argsList.size(); i++) {
           arg = (String)argsList.elementAt(i);
           if (setDebug) System.out.println("JavaCC Parser:  Reading from file " + arg + " . . .");

           try {
            if (firstFile)
                parser = new ParseMib(new java.io.FileInputStream(arg));
            else
                parser.ReInit(new java.io.FileInputStream(arg));
           } catch (java.io.FileNotFoundException fnf) {
                System.err.println("ERROR: the file '" + arg +
                   "' was not found or is mis-spelled");
                System.exit(Errors.FILE_NOT_FOUND);
           }

           n = parser.Start();
           if (setDebug)
               n.dump("");
           firstFile = false;

           // must be called in this order because the ast is
           // decorated on each walk
           // 1) collectTableInfo
           // 2) collectTableIndexInfo
           // 3) collectSequenceInfo
           // 4) collectOids
           // 5) collectTextualConventionsInfo
           if (setDebug) System.out.println("collect table information");
           n.markNotVisited(); // mark the abstract syntax tree as not visited
           n.collectTableInfo();

           if (setDebug) System.out.println("collect table index information");
           n.markNotVisited(); // mark the abstract syntax tree as not visited
           n.collectTableIndexInfo();

           if (setDebug) System.out.println("collect sequence info information");
           n.markNotVisited(); // mark the abstract syntax tree as not visited
           n.collectSequenceInfo();

           if (setDebug) System.out.println("collect oids");
           n.markNotVisited(); // mark the abstract syntax tree as not visited
           n.collectOids();

           if (setDebug) System.out.println("collect type information");
           n.markNotVisited(); // mark the abstract syntax tree as not visited
           n.collectTextualConventionsInfo();

           // System.out.println("Dumping SymbolTables");
           // n.dumpSymbolTables();

           n.writeOids();
      }

      if (setDebug) System.out.println("Thank you.");
    } catch (Throwable e) {
      System.err.println("Oops.");
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(Errors.UNKNOWN_FATAL);
    }
  }

