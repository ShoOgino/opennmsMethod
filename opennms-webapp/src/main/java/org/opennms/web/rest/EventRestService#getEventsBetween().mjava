	/**
	 * Returns all the events which match the filter/query in the query parameters
	 *
	 * @return Collection of OnmsEvents (ready to be XML-ified)
	 * @throws java.text.ParseException if any.
	 */
	@GET
	@Produces( { MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
	@Path("between")
	@Transactional
	public OnmsEventCollection getEventsBetween() throws ParseException {
	    final CriteriaBuilder builder = new CriteriaBuilder(OnmsEvent.class);
	    final MultivaluedMap<String, String> params = m_uriInfo.getQueryParameters();
	    
	    final String column;
	    if (params.containsKey("column")) {
	    	column = params.getFirst("column");
	    	params.remove("column");
	    } else {
	    	column = "eventTime";
	    }
	    Date begin;
	    if (params.containsKey("begin")) {
	    	try {
		    	begin = ISO8601_FORMATTER.parseLocalDateTime(params.getFirst("begin")).toDate();
	    	} catch (final Throwable t) {
	    		begin = ISO8601_FORMATTER_MILLIS.parseDateTime(params.getFirst("begin")).toDate();
	    	}
	    	params.remove("begin");
	    } else {
	    	begin = new Date(0);
	    }
	    Date end;
	    if (params.containsKey("end")) {
	    	try {
		    	end = ISO8601_FORMATTER.parseLocalDateTime(params.getFirst("end")).toDate();
	    	} catch (final Throwable t) {
		    	end = ISO8601_FORMATTER_MILLIS.parseLocalDateTime(params.getFirst("end")).toDate();
	    	}
	    	params.remove("end");
	    } else {
	    	end = new Date();
	    }

		applyQueryFilters(params, builder);
	    builder.match("all");
		try {
			builder.between(column, begin, end);
		} catch (final Throwable t) {
			throw new IllegalArgumentException("Unable to parse " + begin + " and " + end + " as dates!");
		}

	    final OnmsEventCollection coll = new OnmsEventCollection(m_eventDao.findMatching(builder.toCriteria()));
		coll.setTotalCount(m_eventDao.countMatching(builder.clearOrder().toCriteria()));
		
		return coll;
	}

