    /**
     * Unloads the working graph into the working report list at the requested
     * graph number. If the graph was modified from an existing graph, then the
     * old one is replaced. A new blank working graph is then created
     *
     * @param requested_graphnum a int.
     */
    public void unloadWorkingGraph(int requested_graphnum) {
        int total_graphs = m_workingReport.getGraphs().size();
        int insert_location = requested_graphnum--;

        // Check range for existing graph and delete if it is in the valid range
        if ((m_workingGraphIndex >= 0) && (m_workingGraphIndex < total_graphs)) {
            // in range... delete existing graph.
            final int index = m_workingGraphIndex;
            m_workingReport.removeGraph(m_workingReport.getGraphs().get(index));
        }

        // Check range for insertion point
        if ((insert_location < 0) || (insert_location >= total_graphs)) {
            // out of range... assume the new graph needs to be appended to list
            m_workingReport.addGraph(m_workingGraph);
        } else {
            // Insert the graph in the configuration within the working report
            m_workingReport.addGraph(insert_location, m_workingGraph);
        }

        // Create a new and unique instance of a report for screwing around with
        // as the working report
        m_workingGraph = getNewGraph();
        m_workingGraphIndex = -1;
    }

