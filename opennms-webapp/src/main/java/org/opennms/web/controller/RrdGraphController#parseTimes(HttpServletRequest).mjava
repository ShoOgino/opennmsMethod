    public long[] parseTimes(HttpServletRequest request) {
    	String startTime = request.getParameter("start");
    	String endTime = request.getParameter("end");
    	
    	if(startTime == null || "".equals(startTime)) {
    		startTime = "now - 1day";
    	}
    	
    	if(endTime == null || "".equals(endTime)) {
    		endTime = "now";
    	}
    	boolean startIsInteger = false;
    	boolean endIsInteger = false;
    	long start = 0, end = 0;
    	try {
    		start = Long.valueOf(startTime);
    		startIsInteger = true;
    	} catch (NumberFormatException e) {
    	}
    	
    	try {
    		end = Long.valueOf(endTime);
    		endIsInteger = true;
    	} catch (NumberFormatException e) {
    	}
    	
    	if(endIsInteger && startIsInteger) {
    		return new long[] {start, end};	
    	}
    	
    	//One or both of start/end aren't integers, so we need to do full parsing using TimeParser
    	//But, if one of them *is* an integer, convert from incoming milliseconds to seconds that
    	// is expected for epoch times by TimeParser
    	if(startIsInteger) {
    		//Convert to seconds
    		startTime = ""+(start/1000);
    	}
    	if(endIsInteger) {
    		endTime = "" +(end/1000);
    	}
    	
    	TimeParser startParser = new TimeParser(startTime);
    	TimeParser endParser = new TimeParser(endTime);
        try {

        	TimeSpec specStart = startParser.parse();
        	TimeSpec specEnd = endParser.parse();
        	long results[] = TimeSpec.getTimestamps(specStart, specEnd);
        	//Multiply by 1000.  TimeSpec returns timestamps in Seconds, not Milliseconds.  Gah.  
        	results[0] = results[0]*1000;
        	results[1] = results[1]*1000;
        	return results;
		} catch (RrdException e) {
			throw new IllegalArgumentException("Could not parse start '"+ startTime+"' and end '"+endTime+"' as valid time specifications", e);
		}
    }

