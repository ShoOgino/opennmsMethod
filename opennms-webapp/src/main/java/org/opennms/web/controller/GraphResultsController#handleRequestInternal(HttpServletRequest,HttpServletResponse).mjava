    /** {@inheritDoc} */
    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String[] requestedParameters = new String[] {
                "resourceId",
                "generatedId",
                "reports",
                "nodeCriteria"
        };
        ResourceId[] resourceIds = new ResourceId[0];
        if (request.getParameterValues("resourceId") != null) {
            resourceIds = Arrays.stream(request.getParameterValues("resourceId")).map(ResourceId::fromString).toArray(ResourceId[]::new);
        }
        String[] reports = request.getParameterValues("reports");
        String nodeCriteria = request.getParameter("nodeCriteria");
        String generatedId = request.getParameter("generatedId");
        
        // see if the start and end time were explicitly set as params
        String start = request.getParameter("start");
        String end = request.getParameter("end");

        String relativeTime = request.getParameter("relativetime");
        
        final String startMonth = request.getParameter("startMonth");
        final String startDate = request.getParameter("startDate");
        final String startYear = request.getParameter("startYear");
        final String startHour = request.getParameter("startHour");

        final String endMonth = request.getParameter("endMonth");
        final String endDate = request.getParameter("endDate");
        final String endYear = request.getParameter("endYear");
        final String endHour = request.getParameter("endHour");
        
        long startLong = 0;
        long endLong = 0;

        if (start != null || end != null) {
            String[] ourRequiredParameters = new String[] {
                    "start",
                    "end"
            };
        
            if (start == null) {
                throw new MissingParameterException("start",
                                                    ourRequiredParameters);
            }
            
            if (end == null) {
                throw new MissingParameterException("end",
                                                    ourRequiredParameters);
            }
            //The following is very similar to RrdGraphController.parseTimes, but modified for the local context a bit
            // There's merging possibilities, but I don't know how (common parent class seems wrong; service bean for a single
            // method isn't much better.  Ideas?
            
    		//Try a simple 'long' parsing.  If either fails, do a full parse.  If one is a straight 'long' but the other isn't
    		// that's fine, the TimeParser code will handle it fine (as long as we convert milliseconds to seconds)
            // Indeed, we *have* to use TimeParse for both to ensure any relative references (using "start" or "end") work correctly. 
    		// NB: can't do a "safe" parsing using the WebSecurityUtils; if we did, it would filter out all the possible rrdfetch 
    		// format text and always work :)
    		
        	boolean startIsInteger = false;
        	boolean endIsInteger = false;
        	
        	//If either of start/end *is* a long, convert from the incoming milliseconds to seconds that
        	// is expected for epoch times by TimeParser
        	try {
        		startLong = Long.valueOf(start);
        		startIsInteger = true;
        		start = ""+(startLong/1000);
        	} catch (NumberFormatException e) {
        	}
        	
        	try {
        		endLong = Long.valueOf(end);
        		endIsInteger = true;
        		end = "" +(endLong/1000);
        	} catch (NumberFormatException e) {
        	}
        	
        	if(!endIsInteger || !startIsInteger) {        	
        		//One or both of start/end aren't integers, so we need to do full parsing using TimeParser
        		TimeParser startParser = new TimeParser(start);
        		TimeParser endParser = new TimeParser(end);
	            try {
	
	            	TimeSpec specStart = startParser.parse();
	            	TimeSpec specEnd = endParser.parse();
	            	long[] results = TimeSpec.getTimestamps(specStart, specEnd);
	            	//Multiply by 1000.  TimeSpec returns timestamps in Seconds, not Milliseconds.  
	            	startLong = results[0]*1000;
	            	endLong = results[1]*1000;
	            } catch (RrdException e1) {
	    			throw new IllegalArgumentException("Could not parse start '"+ start+"' and end '"+end+"' as valid time specifications", e1);
	    		}
        	}

        } else if (startMonth != null || startDate != null 
                   || startYear != null || startHour != null
                   || endMonth != null || endDate != null || endYear != null
                   || endHour != null) {
            
            String[] ourRequiredParameters = new String[] {
                    "startMonth",
                    "startDate",
                    "startYear",
                    "startHour",
                    "endMonth",
                    "endDate",
                    "endYear",
                    "endHour"
            };
            
            for (String requiredParameter : ourRequiredParameters) {
                if (request.getParameter(requiredParameter) == null) {
                    throw new MissingParameterException(requiredParameter,
                                                        ourRequiredParameters);
                }
            }

            Calendar startCal = Calendar.getInstance();
            startCal.set(Calendar.MONTH, WebSecurityUtils.safeParseInt(startMonth));
            startCal.set(Calendar.DATE, WebSecurityUtils.safeParseInt(startDate));
            startCal.set(Calendar.YEAR, WebSecurityUtils.safeParseInt(startYear));
            startCal.set(Calendar.HOUR_OF_DAY, WebSecurityUtils.safeParseInt(startHour));
            startCal.set(Calendar.MINUTE, 0);
            startCal.set(Calendar.SECOND, 0);
            startCal.set(Calendar.MILLISECOND, 0);

            Calendar endCal = Calendar.getInstance();
            endCal.set(Calendar.MONTH, WebSecurityUtils.safeParseInt(endMonth));
            endCal.set(Calendar.DATE, WebSecurityUtils.safeParseInt(endDate));
            endCal.set(Calendar.YEAR, WebSecurityUtils.safeParseInt(endYear));
            endCal.set(Calendar.HOUR_OF_DAY, WebSecurityUtils.safeParseInt(endHour));
            endCal.set(Calendar.MINUTE, 0);
            endCal.set(Calendar.SECOND, 0);
            endCal.set(Calendar.MILLISECOND, 0);

            startLong = startCal.getTime().getTime();
            endLong = endCal.getTime().getTime();
        } else {
            if (relativeTime == null) {
                relativeTime = RelativeTimePeriod.DEFAULT_RELATIVE_TIME_PERIOD.getId();
            }

            RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(s_periods, relativeTime, RelativeTimePeriod.DEFAULT_RELATIVE_TIME_PERIOD);

            long[] times = period.getStartAndEndTimes();
            startLong = times[0];
            endLong = times[1];
        }

        // The 'matching' parameter is going to work only for one resource.
        String matching = request.getParameter("matching");
        if (matching != null && resourceIds.length != 0) {
            reports = getSuggestedReports(resourceIds[0], matching);
        }

        ModelAndView modelAndView = null;
        try {
            GraphResults model = m_graphResultsService.findResults(resourceIds, reports, generatedId, nodeCriteria, startLong, endLong, relativeTime);
            modelAndView = new ModelAndView("/graph/results", "results", model);
        } catch (Exception e) {
            LOG.warn("Can't get graph results", e);
            modelAndView = new ModelAndView("/graph/results-error");
        }
        modelAndView.addObject("loggedIn", request.getRemoteUser() != null);

        return modelAndView;
    }

