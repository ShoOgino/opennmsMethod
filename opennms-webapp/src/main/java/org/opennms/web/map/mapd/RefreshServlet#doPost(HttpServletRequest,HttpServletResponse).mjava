	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		ThreadCategory.setPrefix(MapsConstants.LOG4J_CATEGORY);
		log = ThreadCategory.getInstance(this.getClass());
		//elems is the feedback of the last refresh operation posted from client (counterOK or counterNOK)
		String feedback = request.getParameter("elems");
		String action = request.getParameter("action");
		log.debug("Received action="+action+" elems="+feedback);
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(response
				.getOutputStream()));
		String strToSend = "";
		try {
			HttpSession session = request.getSession(false);
			Manager m = null;
			if(session!=null){
				m = (Manager) session.getAttribute("manager");
				log.debug("Got manager from session: "+m);
			}
			m.startSession();
			VMap map = null;
 
			if (session != null) {
				map = (VMap) session.getAttribute("sessionMap");
				if (map != null) {
					strToSend = action + "OK";
					boolean actionfound = false;
					if (action.equals(MapsConstants.REFRESH_ACTION)) {
						//TODO inviare al client anche gli elementi e i links da rimuovere
						//     e farsi dare un feedback (contenuto nella successiva richiesta) per essere sicuri 
						//	   che la mappa visualizzata dal client sia sincronizzata con quella di sessione
						actionfound = true;
						String sessionId = session.getId();
						Refresher refresher = Refresher.getInstance();
						if(refresher==null){
							log.error("Refresher is null. InitializerServletContext must create it.");
							throw new IllegalStateException("Refresher is null. InitializerServletContext must create it.");
						}
						long refreshCounter = refresher.getRefreshCounter(sessionId, map, m);
						log.debug("Current refresh counter is "+refreshCounter);
						
						List<VElement> changedElements = refresher.getChangedElements(session.getId(), map, m);
						List<VLink> changedLinks = refresher.getChangedLinks(session.getId(), map, m);
						List<VLink> removedLinks = refresher.getDeletedLinks(session.getId(), map, m);
						if(feedback.equals(refreshCounter+"OK")){
							log.debug("Synchronizing last refresh (on current sessionMap)");
							VElement[] lastChangedElems = refresher.getLastChangedElements(sessionId, map, m).toArray(new VElement[0]);
							refresher.resetLastChangedElements(sessionId, map, m);
							log.debug("Adding changed elems of last refresh: "+lastChangedElems.toString());
							for(int k=0; k<lastChangedElems.length;k++){
								VElement ve = lastChangedElems[k];
								map.removeElement(ve.getId(), ve.getType());
								map.addElement(ve);
							}
														
							List<VLink> lastChangedLinks = refresher.getLastChangedLinks(sessionId, map, m);
							refresher.resetLastChangedLinks(sessionId, map, m);
							log.debug("Adding changed links of last refresh: "+lastChangedLinks.toString());
							Iterator<VLink> it = lastChangedLinks.iterator();
							while(it.hasNext()){
								VLink  curr = it.next();
								map.removeLink(curr);
								map.addLink(curr);
							}
							
							List<VLink> lastRemovedLinks = refresher.getLastDeletedLinks(sessionId, map, m);
							refresher.resetLastDeletedLinks(sessionId, map, m);
							log.debug("Removing links of last refresh: "+lastRemovedLinks.toString());
							it = lastRemovedLinks.iterator();
							while(it.hasNext()){
								VLink  curr = it.next();
								map.removeLink(curr);		
							}
							
						}else{
							log.debug("Feedback negative. Reusing last data (elements and links).");
							List<VElement> lastChangedElems = refresher.getLastChangedElements(sessionId, map, m);
							log.debug("lastChagedElems="+lastChangedElems.toString());
							log.debug("changedElems="+changedElements.toString());
							log.debug("Adding lastChangedElems to changedElems ");
							changedElements.addAll(lastChangedElems);
							
							
							List<VLink> lastChangedLinks = refresher.getLastChangedLinks(sessionId, map, m);
							log.debug("lastChangedLinks="+lastChangedLinks.toString());
							log.debug("changedLinks="+changedLinks.toString());
							log.debug("Adding lastChangedLinks to changedLinks ");	
							changedLinks.addAll(lastChangedLinks);
							
							
							List<VLink> lastRemovedLinks = refresher.getLastChangedLinks(sessionId, map, m);
							log.debug("lastRemovedLinks="+lastRemovedLinks.toString());
							log.debug("removedLinks="+removedLinks.toString());
							log.debug("Adding lastRemovedLinks to removedLinks ");	
							removedLinks.addAll(lastRemovedLinks);
							
	
						}
						
						//1. send changed elements
						VElement[] velements=(VElement[])changedElements.toArray(new VElement[0]);
						if (velements != null) {
							for(int k=0; k<velements.length;k++){
								VElement ve = velements[k];
								strToSend += "&" + ve.getId() + ve.getType() + "+"
										+ ve.getIcon() + "+" + ve.getLabel();
								strToSend += "+" + ve.getRtc() + "+"
										+ ve.getStatus() + "+" + ve.getSeverity();
							}
						}

						//2. send removed links
						if (removedLinks != null) {
							Iterator ite = removedLinks.iterator();
							while (ite.hasNext()) {
								VLink vl = (VLink) ite.next();
									strToSend += "&" + vl.getFirst().getId()
									+ vl.getFirst().getType() + "+"
									+ vl.getSecond().getId()
									+ vl.getSecond().getType()+"+"+vl.getLinkTypeId()+"+"+vl.getLinkOperStatusString();
							}
						} 						

						//3. send changed links
						if (changedLinks != null) {
							Iterator ite = changedLinks.iterator();
							while (ite.hasNext()) {
								VLink vl = (VLink) ite.next();
									strToSend += "&" + vl.getFirst().getId()
									+ vl.getFirst().getType() + "+"
									+ vl.getSecond().getId()
									+ vl.getSecond().getType()+"+"+vl.getLinkTypeId()+"+"+vl.getLinkOperStatusString();
							}
						} 
						
						//increment counter 
						log.debug("Incrementing refresh counter...");
						refresher.incrementRefreshCounter(sessionId, map, m);
						
					} 
					//TODO gestire la reload (decidere se tenerla)
					if (action.equals(MapsConstants.RELOAD_ACTION)) {
						actionfound = true;
						// First refresh Element objects
						map = m.reloadMap(map);
						VElement[] velements=map.getAllElements();
						
						//checks for only changed velements 
						if (velements != null) {
							for(int k=0; k<velements.length;k++){
								VElement ve = velements[k];
								strToSend += "&" + ve.getId() + ve.getType() + "+"
										+ ve.getIcon() + "+" + ve.getLabel();
								strToSend += "+" + ve.getRtc() + "+"
										+ ve.getStatus() + "+" + ve.getSeverity()+ "+" + ve.getX()+ "+" + ve.getY();
							}
						}

						// Second Refresh Link Object on Map
						// Now is done using a very simple way
						// but really it's slow
						// the alternativ is anyway to analize all 
						// links, 1 against other.
						// So with this solution more traffic
						// less stress on server
						// more work on client
						
						// We are waiting to attempt to mapd
						map.removeAllLinks();

						// get all links on map
						//List links = null;
						List links = m.getLinks(velements);

						// add links to map
						map.addLinks((VLink[]) links.toArray(new VLink[0]));

						// write to client
						if (links != null) {
							Iterator ite = links.iterator();
							while (ite.hasNext()) {
								VLink vl = (VLink) ite.next();
									strToSend += "&" + vl.getFirst().getId()
									+ vl.getFirst().getType() + "+"
									+ vl.getSecond().getId()
									+ vl.getSecond().getType()+"+"+vl.getLinkTypeId()+"+"+vl.getLinkOperStatusString();
							}
						} 
						
					}
					

					if (actionfound) {
						session.setAttribute("sessionMap",map);
					} else {
						throw new Exception("action " + action + " not exists");
					}

				} else {
					throw new Exception("Attribute session sessionMap is null");
				}
			} else {
				throw new Exception("HttpSession not initialized");
			}
			m.endSession();
			
		} catch (Exception e) {
			strToSend = action + "Failed";
			log.error("Exception catch " + e);
			StackTraceElement[] ste = e.getStackTrace();
			for(int k=0; k<ste.length; k++){
				log.error(ste[k].toString());
			}
		} finally {
			bw.write(strToSend);
			bw.close();
			log.info("Sending response to the client '" + strToSend + "'");
		}
	}

