	private void synchronizeSnapshot(Snapshot ss, HashMap<Integer, NodeChange> changedNodes)throws MapsException{
	
		Iterator<NodeChange> elems = changedNodes.values().iterator();
		ArrayList<VElement> chNodes = new ArrayList<VElement>();
		ArrayList<VLink> addLinks = new ArrayList<VLink>();
		ArrayList<VLink> delLinks = new ArrayList<VLink>();
		log.info("Synchronizing snapshot (map/manager) "+ss.map.getId()+ "/"+ss.m_manager);
		while(elems.hasNext()){
			NodeChange n = elems.next();
			
			if(ss.containsElement(n.getId(),VElement.NODE_TYPE)){
				log.debug("Snapshot contains "+n.getId()+","+VElement.NODE_TYPE+" upgrading status and adding to changedNodes List");
				VElement node = ss.getElement(n.getId(), VElement.NODE_TYPE);
				node.setStatus(n.getStatus());
				//TODO manage availability and severity also.
				chNodes.add(node);
			}
			//TODO fix following: elements returned has not realtime values (status, avail, sev.)  updated, but their values are obsolete
			Set<VElement> parentsOfNode = ss.getElementsForNode(n.getId());
			chNodes.addAll(parentsOfNode);
			
			List<VLink> linksOnNode = new ArrayList<VLink>();
			if(n.getAddlinks() || n.getDeletelinks()){
				VElement nodeElement=ss.getElement(n.getId(), VElement.NODE_TYPE);
				VElement[] elemes = ss.getAllElements();
				linksOnNode = ss.getLinksOnElem(elemes, nodeElement);
			}
			if(n.getAddlinks()){
				log.info("adding links on node "+linksOnNode.toString());
				addLinks.addAll(linksOnNode);
			}
			if(n.getDeletelinks()){
				log.info("deleting links on node "+linksOnNode.toString());
				delLinks.addAll(linksOnNode);
			}
		}
		
		//add found changes to the snapshot
		if(chNodes.size()>0)
			ss.addChangedElements(chNodes);
		if(addLinks.size()>0)
			ss.addChangedLinks(addLinks);		
		if(delLinks.size()>0)
			ss.addDeletedLinks(delLinks);
	}
/*
	*//**
	 * The method finds (and returns) the links between elements (maps and nodes) in the map of passed snapshot. 
	 * @param link
	 * @param ss
	 * @return the links between elements (maps and nodes) in the map of passed snapshot.
	 *//*
	private List<VLink> getMatchingLinks(VLink link, Snapshot ss)throws MapsException{
		List<VLink> result = new ArrayList<VLink>();
		if(ss.containsElement(link.getFirst().getId(),link.getFirst().getType()) && ss.containsElement(link.getSecond().getId(),link.getSecond().getType())){
			result.add(link);
		}
		VElement[] elems = ss.getAllElements();
		if(elems!=null){
			boolean hasFirst=false, hasSecond=false;
			//find first elem of the link
			if(ss.containsElement(link.getFirst().getId(),link.getFirst().getType())){
				hasFirst=true;
			}
			//find second elem of the link
			if(ss.containsElement(link.getSecond().getId(),link.getSecond().getType())){
				hasSecond=true;
			}
			
			//add links node-submap (and submap-node)
			List<VElement> elemsContainingFirst = new ArrayList<VElement>();
			List<VElement> elemsContainingSecond = new ArrayList<VElement>();
			for(int i=0; i<elems.length;i++){
				if(ss.getNodeidsOnElement(elems[i]).contains(link.getFirst().getId()))
					elemsContainingFirst.add(elems[i]);
				if(ss.getNodeidsOnElement(elems[i]).contains(link.getSecond().getId()))
					elemsContainingSecond.add(elems[i]);
			}
			
			Iterator<VElement> iter = elemsContainingFirst.iterator();
			while(iter.hasNext()){
				VElement currEl = iter.next();
				if(hasSecond){
					VLink newLink = new VLink(currEl,link.getSecond());
					newLink.setLinkOperStatus(link.getLinkOperStatus());
					newLink.setLinkTypeId(link.getLinkTypeId());
					result.add(newLink);
				}
			}
			
			iter = elemsContainingSecond.iterator();
			while(iter.hasNext()){
				VElement currEl = iter.next();
				if(hasFirst){
					VLink newLink = new VLink(link.getFirst(),currEl);
					newLink.setLinkOperStatus(link.getLinkOperStatus());
					newLink.setLinkTypeId(link.getLinkTypeId());
					result.add(newLink);
				}
			}
			
			// add links submap-submap 
			iter = elemsContainingFirst.iterator();
			while(iter.hasNext()){
				VElement firstEl = iter.next();
				Iterator<VElement> ite2 = elemsContainingSecond.iterator();
				while(ite2.hasNext()){
					VElement secondEl = ite2.next();
					VLink newLink = new VLink(firstEl,secondEl);
					newLink.setLinkOperStatus(link.getLinkOperStatus());
					newLink.setLinkTypeId(link.getLinkTypeId());
					result.add(newLink);
				}
			}
			
		}
		return result;
	}*/

