    /**
     * Take all the maps in the tree of maps considering the with name in
     * input as the root of the tree. If there are more maps with
     * <i>mapName</i> (case insensitive) all trees with these maps as root are
     * considered and returned.
     *
     * @param mapName a {@link java.lang.String} object.
     * @return a List with the MapMenu objects.
     * @throws org.opennms.web.map.MapsException if any.
     * @throws org.opennms.web.map.MapNotFoundException if any.
     */
    public List<VMapInfo> getMapsMenuTreeByName(String mapName)
            throws MapNotFoundException, MapsException {
        List<VMapInfo> mapsInTreesList = new ArrayList<VMapInfo>();
        //
        VMapInfo[] mapsMenu = null;
        try {
            mapsMenu = getMapsMenuByName(mapName);
        } catch (MapNotFoundException mnf) {
            // do nothing...
        }
        if (mapsMenu != null) {
            // find all accessible maps for the user,
            // for all maps (and theirs tree of maps) with name like mapName.
            for (VMapInfo element : mapsMenu) {
                // build a map in wich each entry is [mapparentid,
                // listofchildsids]
                java.util.Map<Integer, Set<Integer>> parent_child = dbManager.getMapsStructure();
                List<Integer> childList = new ArrayList<Integer>();

                preorderVisit(Integer.valueOf(element.getId()), childList,
                              parent_child);

                for (int i = 0; i < childList.size(); i++) {
                    preorderVisit(childList.get(i), childList, parent_child);
                }

                // adds all sub-tree of maps to the visible map list
                for (int i = 0; i < childList.size(); i++) {
                    mapsInTreesList.add(getMapMenu(childList.get(i).intValue()));
                }
            }
        }
        return mapsInTreesList;
    }

