    private VElement refresh(VElement mapElement, Set<Integer> nodesBySource, Vector<Integer> deletedNodeids, java.util.Map<Integer,AlarmInfo> outagedNodes,java.util.Map<Integer,Double> avails) throws MapsException {
		VElement ve = mapElement.clone();
		if (log.isDebugEnabled()) {
            log.debug("refresh: parsing VElement ID " + ve.getId()
					+ ve.getType() + ", label:"+ve.getLabel()+" with node by sources: " +nodesBySource.toString() + " deletedNodeids: " + deletedNodeids.toString()
					+ " outagedNode: " +outagedNodes.keySet().toString());
        }

		double elementAvail = mapsPropertiesFactory.getDisabledAvail().getMin();
		int elementStatus = mapsPropertiesFactory.getDefaultStatus().getId();
		float elementSeverity = mapsPropertiesFactory.getDefaultSeverity().getId();
		String calculateSeverityAs = mapsPropertiesFactory.getSeverityMapAs();
		
		// get status, severity and availability: for each node, look for alternative data
		// sources; if no source is found or if the data is not retrieved, use opennms. 
		if (dbManager.isElementNotDeleted(ve.getId(), ve.getType())) {
            elementAvail = mapsPropertiesFactory.getUndefinedAvail().getMin();
            elementStatus=mapsPropertiesFactory.getUnknownStatus().getId();
            elementSeverity = mapsPropertiesFactory.getIndeterminateSeverity().getId();
            log.warn("The element type: " + ve.getType() +" with id=" + ve.getId() + " was deleted");
		} else if (ve.isNode()) {
			if(deletedNodeids.contains(new Integer(ve.getId()))){
	            elementAvail = mapsPropertiesFactory.getUndefinedAvail().getMin();
	            elementStatus=mapsPropertiesFactory.getUnknownStatus().getId();
	            elementSeverity = mapsPropertiesFactory.getIndeterminateSeverity().getId();
			} else{ //if the node isn't deleted
				if (nodesBySource.contains(new Integer(ve.getId()))) {
					Object id = new Integer(ve.getId());
					log.debug("getting status from alternative source " + dataSource.getClass().getName());
					int status = mapsPropertiesFactory.getStatus(dataSource.getStatus(id));
					if (status >= 0) {
						elementStatus = status;
						log.debug("got status from alternative source. Value is "+elementStatus);
					}
					
					int sev = mapsPropertiesFactory.getSeverity(dataSource.getSeverity(id));
					if (sev >= 0) {
						elementSeverity = sev;
						log.debug("got severity from alternative source. Value is "+sev);
					} 
					if (mapsPropertiesFactory.isAvailEnabled()) {
						double avail = dataSource.getAvailability(id);
						if (avail >= 0) {
							elementAvail = avail;
							log.debug("got availability from alternative source. Value is "+avail);
						} 
					}
				} else {
					AlarmInfo oi = outagedNodes.get(new Integer(ve.getId()));
					if (oi != null) {
						elementStatus = oi.getStatus();
						elementSeverity= oi.getSeverity();
					}
	  				if (mapsPropertiesFactory.isAvailEnabled() && (new Integer(ve.getId()) != null) && (avails.get(new Integer(ve.getId())) != null)) {
	   					elementAvail =avails.get(new Integer(ve.getId())).doubleValue();
	   				}				
					
				}
			} // end of nodes deleted				
    	} else { // the element is a Map
			log.debug("Calculating severity for submap Element " + ve.getId()
					+ " using '" + calculateSeverityAs + "' mode.");
			Set<Integer> nodesonve = getNodeidsOnElement(ve);
			if (nodesonve != null && nodesonve.size() > 0) {
				log.debug("found nodes on Map element :" + nodesonve.toString());
				elementAvail = mapsPropertiesFactory.getDisabledAvail().getMin();
				float sev = 0;
				if (calculateSeverityAs.equalsIgnoreCase("worst")
						|| calculateSeverityAs.equalsIgnoreCase("best")) {
					sev = mapsPropertiesFactory.getDefaultSeverity().getId();
				}
				Iterator<Integer> ite = nodesonve.iterator();
				while (ite.hasNext()) {
					Integer nextNodeId = ite.next();
					if(deletedNodeids.contains(nextNodeId)){
						elementAvail += mapsPropertiesFactory.getUndefinedAvail().getMin();
						elementStatus=mapsPropertiesFactory.getUnknownStatus().getId();
						elementSeverity = mapsPropertiesFactory.getIndeterminateSeverity().getId();
					}else{ //if the node isn't deleted
						if (nodesBySource.contains(nextNodeId)) {
							int st = mapsPropertiesFactory.getStatus(dataSource.getStatus(nextNodeId));
							if (st >= 0) {
								if (st < elementStatus) {
									elementStatus = st;
								}
								log.debug("got status from alternative source. Value is "+st);
							}

							int tempSeverity = mapsPropertiesFactory.getSeverity(dataSource.getSeverity(nextNodeId));
							if (tempSeverity >= 0) {
								log.debug("got severity from alternative source. Value is "+tempSeverity);
								if (calculateSeverityAs.equalsIgnoreCase("avg")) {
									sev += tempSeverity;
								} else if (calculateSeverityAs
										.equalsIgnoreCase("worst")) {
									if (sev > tempSeverity) {
										sev = tempSeverity;
									}
								} else if (calculateSeverityAs
										.equalsIgnoreCase("best")) {
									if (sev < tempSeverity) {
										sev = tempSeverity;
									}
								}
							} 	
							if (mapsPropertiesFactory.isAvailEnabled()) {
								double avail = dataSource.getAvailability(nextNodeId);
								if (avail >= 0) {
									elementAvail += avail;
									log.debug("got availability from alternative source. Value is "+avail);
								} 
							}	
						} else {
							AlarmInfo oi = outagedNodes.get(nextNodeId);
							if (oi != null) {
								elementStatus = oi.getStatus();
								float tempSeverity= oi.getSeverity();
								if (tempSeverity >= 0) {
									if (calculateSeverityAs.equalsIgnoreCase("avg")) {
										sev += tempSeverity;
									} else if (calculateSeverityAs
											.equalsIgnoreCase("worst")) {
										if (sev > tempSeverity) {
											sev = tempSeverity;
										}
									} else if (calculateSeverityAs
											.equalsIgnoreCase("best")) {
										if (sev < tempSeverity) {
											sev = tempSeverity;
										}
									}
								} 	
							}
			  				if (mapsPropertiesFactory.isAvailEnabled() && (nextNodeId != null) && (avails.get(nextNodeId) != null)) {
			   					elementAvail +=avails.get(nextNodeId).doubleValue();
			   				}	
							
						}
					}
				}
				if (calculateSeverityAs.equalsIgnoreCase("avg")) {
					elementSeverity = sev / nodesonve.size();
				} else {
					elementSeverity = sev;
				}
				//calculate availability as average of all nodes on element
				if(elementAvail>0) {
                    elementAvail=elementAvail / nodesonve.size();
                }
				
			} else {
				log.debug("no nodes on Map element found");
			}
		}
		
		if (log.isDebugEnabled()) {
            log.debug("refreshElement: element avail/status/severity "
					+ elementAvail + "/" + elementStatus + "/"
					+ elementSeverity);
        }

		ve.setRtc(elementAvail);
		ve.setStatus(elementStatus);
		ve.setSeverity(new BigDecimal(elementSeverity + 1 / 2).intValue());
		return ve;
	}

