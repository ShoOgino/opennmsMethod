	/**
	 * Parses the map.properties file into some mappings: 
	 *  -severitiesMap: severity label (String) to Severity
	 *	-statusesMap: status (String) uei to Status
	 * 	-availsMap: min (String) of avail to Avail
	 *	-iconsMap: icon (String) label to String (icon filename)
	 *	-iconsBySysoidMap: sysoid (String) to icon label (String)
	 *	-bgImagesMap: background (String) image label to String (background image filename)
	 *	-sourcesMap: source label (String) to DataSource 
	 *	-factoriesMap: factory label (String) to MapsFactory
	 */
	protected void parseMapProperties() throws FileNotFoundException,
			IOException {
		log.debug("Parsing map.properties...");
		severitiesMap = new HashMap<String,Severity>();
		statusesMap = new HashMap<String,Status>();
		availsMap = new HashMap<String,Avail>();
		iconsMap = new HashMap<String,String>();
		iconsBySysoidMap = new HashMap<String,String>();
		bgImagesMap = new HashMap<String,String>();
		linksMap = new HashMap<Integer,Link>();
		linksBySnmpTypeMap = new HashMap<Integer,Set<Link>>();
		linkStatusesMap = new HashMap<String,LinkStatus>();

		// read the file
		Properties props = new Properties();
		props.load(new FileInputStream(mapPropertiesFile));
		
		//load context menu flag
		String cntxtmenu = props.getProperty("enable.contextmenu");
		if(cntxtmenu!=null && cntxtmenu.equalsIgnoreCase("false"))
			contextMenuEnabled=false;
		if (log.isDebugEnabled())
			log.debug("enable.contextmenu=" + cntxtmenu);			
		// load context menu object only if context menu is enabled
		
		cmenu = new ContextMenu();
		if (contextMenuEnabled) {
			String commandList = props.getProperty("cmenu.commands");
			if(commandList!=null){
				String[] commands = BundleLists.parseBundleList(commandList);
				if(commands!=null){
					for (int j = 0; j < commands.length;j++) {
						String link = "-";
						String params = "-";
						if(!commands[j].equals("-")){
							//load the link to open for the command
							link = props.getProperty("cmenu."+commands[j]+".link");
							if (log.isDebugEnabled())
							log.debug("cmenu."+commands[j]+".link="+link);
							if(link==null){
								log.warn("link is null! skipping..");
								continue;
							}
							params = props.getProperty("cmenu."+commands[j]+".params");						
							if (log.isDebugEnabled())
								log.debug("cmenu."+commands[j]+".params="+params);
							if(params==null) params="";
						}
						cmenu.addEntry(commands[j], link, params);
					}
				}
			}else{
				log.warn("Context Menu enabled but No command found!");
			}

		}
		
		//load double click flag
		String doubleclick = props.getProperty("enable.doubleclick");
		if(doubleclick!=null && doubleclick.equalsIgnoreCase("false"))
			doubleClickEnabled=false;
		if (log.isDebugEnabled())
			log.debug("enable.doubleclick=" + doubleclick);			
		
		// load reload flag
		String reloadStr = props.getProperty("enable.reload");
		if(reloadStr!=null && reloadStr.equalsIgnoreCase("true"))
			reload=true;
		
		if (log.isDebugEnabled())
			log.debug("enable.reload=" + reloadStr);			
		
		// look up severities and their properties
		severityMapAs=props.getProperty("severity.map", "avg");

		// look up severities and their properties
		
		String[] severities = BundleLists.parseBundleList(props
				.getProperty("severities"));

		for (int i = 0; i < severities.length; i++) {
			String id = props.getProperty("severity." + severities[i] + ".id");
			String label = props.getProperty("severity." + severities[i]
					+ ".label");
			String color = props.getProperty("severity." + severities[i]
					+ ".color");
			String flash = props.getProperty("severity." + severities[i]
					+ ".flash");
			Severity sev = new Severity(WebSecurityUtils.safeParseInt(id), label, color);
			if (flash != null && flash.equalsIgnoreCase("true"))
				sev.setFlash(true);
			log.debug("found severity " + severities[i] + " with id=" + id
					+ ", label=" + label + ", color=" + color + ". Adding it.");
			severitiesMap.put(label, sev);
		}
		orderedSeverities = new Severity[severitiesMap.size()];
		Iterator<Severity> it_sev = severitiesMap.values().iterator();
		int k = 0;
		while (it_sev.hasNext()) {
			orderedSeverities[k++] = it_sev.next();
		}
		Arrays.sort(orderedSeverities);

		String defaultid = props.getProperty("severity.default");
		if (defaultid == null) {
			throw new IllegalStateException(
					"Required Default Severity not found.");
		}

		String sevid = props.getProperty("severity." + defaultid + ".id");
		String sevlabel = props.getProperty("severity." + defaultid + ".label");
		String sevcolor = props.getProperty("severity." + defaultid + ".color");
		defaultSeverity = new Severity(WebSecurityUtils.safeParseInt(sevid), sevlabel, sevcolor);
		
		
		String indeterminateId = props.getProperty("severity.indeterminate");
		if (indeterminateId == null) {
			throw new IllegalStateException(
					"Required Indeterminate Severity not found.");
		}

		String indsevid = props.getProperty("severity." + indeterminateId + ".id");
		String indsevlabel = props.getProperty("severity." + indeterminateId
				+ ".label");
		String indsevcolor = props.getProperty("severity." + indeterminateId
				+ ".color");
		indeterminateSeverity = new Severity(WebSecurityUtils.safeParseInt(indsevid), indsevlabel, indsevcolor);
		
		//Links
		String[] links = BundleLists.parseBundleList(props
				.getProperty("links"));
		
		String defaultLinkStr = props.getProperty("link.default");
		if(defaultLinkStr==null){
			log.error("Mandatory property 'link.default' not found!");
			throw new IllegalStateException("The property 'link.default' is mandatory");
		}
		defaultLink = WebSecurityUtils.safeParseInt(defaultLinkStr);

		for (int i = 0; i < links.length; i++) {
			String id = props.getProperty("link." + links[i] + ".id");
			String text = props.getProperty("link." + links[i]+ ".text");
			String speed = props.getProperty("link." + links[i]+ ".speed");
			String width = props.getProperty("link." + links[i]+ ".width");
			String dasharray = props.getProperty("link." + links[i]+ ".dash-array");			
			String snmptype = props.getProperty("link." + links[i]+ ".snmptype");			
			if(id==null){
				log.error("param id for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(text==null){
				log.error("param text for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(speed==null){
				log.error("param speed for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(width==null){
				log.error("param width for link cannot be null in map.properties: skipping link...");
				continue;
			}
				
			int dash_arr=-1;
			if(dasharray!=null)
				dash_arr=WebSecurityUtils.safeParseInt(dasharray);
			
			int snmp_type=-1;
			if(snmptype!=null)
				snmp_type=WebSecurityUtils.safeParseInt(snmptype);

			Link lnk = new Link(WebSecurityUtils.safeParseInt(id), speed,text,width,dash_arr,snmp_type);
			
			log.debug("found link " + links[i] + " with id=" + id
					+ ", text=" + text+ ", speed=" + speed+ ", width=" + width+ ", dash-array=" + dasharray+ "snmp-type=" + snmp_type+". Adding it.");
			linksMap.put(new Integer(id), lnk);
			Set<Link> linkbysnmptypeSet = linksBySnmpTypeMap.get(new Integer(snmp_type));
			if(linkbysnmptypeSet==null)
				linkbysnmptypeSet=new HashSet<Link>();
			linkbysnmptypeSet.add(lnk);
			linksBySnmpTypeMap.put(new Integer(snmp_type), linkbysnmptypeSet);
		}
		
		
		
		//Links Statuses
		String[] linkStatuses = BundleLists.parseBundleList(props
				.getProperty("linkstatuses"));
		for (int i = 0; i < linkStatuses.length; i++) {
			String color = props.getProperty("linkstatus." + linkStatuses[i] + ".color");
			String flash = props.getProperty("linkstatus." + linkStatuses[i]+ ".flash");
			if(color==null){
				log.error("param color for linkstatus cannot be null in map.properties: skipping linkstatus...");
				continue;
			}
			boolean flashBool = false;
			if(flash!=null && flash.equalsIgnoreCase("false"))
				flashBool=false;			
			log.debug("found linkstatus " + linkStatuses[i] + " with color=" + color
					+ ", flash=" + flashBool+ ". Adding it.");
			LinkStatus ls = new LinkStatus(linkStatuses[i],color,flashBool);
			linkStatusesMap.put(linkStatuses[i], ls);
		}		
		
		
		if(props.getProperty("multilink.status")!=null){
			multilinkStatus = props.getProperty("multilink.status"); 	
		}
		if(!multilinkStatus.equals("best") && !multilinkStatus.equals("worst")){
			log.error("multilink.status property must be 'best' or 'worst'... using default ('best')");
			multilinkStatus=MULTILINK_BEST_STATUS;
		}
		log.debug("found multilink.status:"+multilinkStatus);
				
			
		// look up statuses and their properties
		String[] statuses = BundleLists.parseBundleList(props
				.getProperty("statuses"));

		for (int i = 0; i < statuses.length; i++) {
			String id = props.getProperty("status." + statuses[i] + ".id");
			String uei = props.getProperty("status." + statuses[i] + ".uei");
			String color = props
					.getProperty("status." + statuses[i] + ".color");
			String text = props.getProperty("status." + statuses[i] + ".text");
			log.debug("found status " + statuses[i] + " with id=" + id
					+ ", uei=" + uei + ", color=" + color + ", text=" + text
					+ ". Adding it.");
			Status status = new Status(WebSecurityUtils.safeParseInt(id), uei, color, text);
			statusesMap.put(uei, status);
		}

		orderedStatuses = new Status[statusesMap.size()];
		Iterator<Status> it_status = statusesMap.values().iterator();
		k = 0;
		while (it_status.hasNext()) {
			orderedStatuses[k++] = it_status.next();
		}
		Arrays.sort(orderedStatuses);

		String unknownid = props.getProperty("status.unknown.uei");
		if (unknownid == null) {
			throw new IllegalStateException(
					"Required Unknown Uei Status not found.");
		}
		String stid = props.getProperty("status." + unknownid + ".id");
		String stuei = props.getProperty("status." + unknownid + ".uei");
		String stcolor = props.getProperty("status." + unknownid + ".color");
		String sttext = props.getProperty("status." + unknownid + ".text");
		unknownStatus = new Status(WebSecurityUtils.safeParseInt(stid), stuei, stcolor, sttext);
		
		String defaultstid = props.getProperty("status.default");
		if (defaultstid == null) {
			throw new IllegalStateException(
					"Required Default Status not found.");
		}
		String staid = props.getProperty("status." + defaultstid + ".id");
		String stauei = props.getProperty("status." + defaultstid + ".uei");
		String stacolor = props.getProperty("status." + defaultstid + ".color");
		String statext = props.getProperty("status." + defaultstid + ".text");
		defaultStatus = new Status(WebSecurityUtils.safeParseInt(staid), stauei, stacolor, statext);
		
		// look up statuses and their properties
		String[] availes = BundleLists.parseBundleList(props
				.getProperty("availabilities"));

		for (int i = 0; i < availes.length; i++) {
			String id = props.getProperty("avail." + availes[i] + ".id");
			String min = props.getProperty("avail." + availes[i] + ".min");
			String color = props.getProperty("avail." + availes[i] + ".color");
			String flash = props.getProperty("avail." + availes[i] + ".flash");
			log.debug("found avail " + availes[i] + " with id=" + id + ", min="
					+ min + ", color=" + color + ". Adding it.");
			Avail avail = new Avail(WebSecurityUtils.safeParseInt(id),
					WebSecurityUtils.safeParseInt(min), color);
			if (flash != null && flash.equalsIgnoreCase("true"))
				avail.setFlash(true);
			availsMap.put(min, avail);
		}

		orderedAvails = new Avail[availsMap.size()];
		Iterator<Avail> it_avail = availsMap.values().iterator();
		k = 0;
		while (it_avail.hasNext()) {
			orderedAvails[k++] = it_avail.next();
		}
		Arrays.sort(orderedAvails);
		
		String avid = props.getProperty("avail.undefined.id");
		String avmin = props.getProperty("avail.undefined.min");
		String avcolor = props.getProperty("avail.undefined.color");
		if (avid == null || avmin == null || avcolor == null) {
			throw new IllegalStateException(
					"Required avail.undefined properties not found.");
		}
		undefinedAvail = new Avail(WebSecurityUtils.safeParseInt(avid), WebSecurityUtils.safeParseInt(avmin), avcolor);

		
		String enableAvail = props.getProperty("avail.enable");
		if (enableAvail != null && enableAvail.equalsIgnoreCase("false"))
			availEnabled=false;
		else availEnabled = true;
		
		String disableAvailId = props.getProperty("avail.enable.false.id");
		if (disableAvailId == null) {
			throw new IllegalStateException(
					"Required Default Status not found.");
		}
		Iterator<Avail> ite = availsMap.values().iterator();
		while (ite.hasNext()) {
			Avail av = ite.next();
			if (av.getId() == WebSecurityUtils.safeParseInt(disableAvailId)){
				disabledAvail=av;
				break;
			}
		}

		// look up icons filenames
		String[] icons = BundleLists
				.parseBundleList(props.getProperty("icons"));

		for (int i = 0; i < icons.length; i++) {
			String filename = props.getProperty("icon." + icons[i]
					+ ".filename");
			log.debug("found icon " + icons[i] + " with filename=" + filename
					+ ". Adding it.");
			iconsMap.put(icons[i], filename);
		}
		
		// look up sysoid icons
		String[] sysoids = BundleLists.parseBundleList(props.getProperty("sysoids"));
		
		for (int i = 0; i < sysoids.length; i++) {
		    String iconName = props.getProperty("sysoid." + sysoids[i] + ".iconName");
		    log.debug("found sysoid " + sysoids[i] + " with iconName=" + iconName
	                    + ". Adding it.");
	        iconsBySysoidMap.put(sysoids[i], iconName);
		}
		
		defaultMapIcon = props.getProperty("icon.default.map");
		log.debug("default map icon: "+defaultMapIcon);
		if (defaultMapIcon == null) {
			throw new IllegalStateException(
					"Required Default Map Icon not found.");
		}
		defaultNodeIcon = props.getProperty("icon.default.node");
		if (defaultNodeIcon == null) {
			throw new IllegalStateException(
					"Required Default Icon Node not found.");
		}
		log.debug("default node icon: "+defaultNodeIcon);
		
		String defaultMapElementDimensionString = props.getProperty("icon.default.mapelementdimension");
        if (defaultMapElementDimensionString != null) {
            defaultMapElementDimension = WebSecurityUtils.safeParseInt(defaultMapElementDimensionString);
        }
        log.debug("default map element dimension: "+defaultMapElementDimension);

		// look up background filenames
		String[] bg = BundleLists
				.parseBundleList(props.getProperty("bgimages"));

		for (int i = 0; i < bg.length; i++) {
			String filename = props.getProperty("bgimage." + bg[i]
					+ ".filename");
			log.debug("found bgimage " + bg[i] + " with filename=" + filename
					+ ". Adding it.");
			bgImagesMap.put(bg[i], filename);
		}

//		propertiesMaps = new Map[] { severitiesMap, statusesMap, availsMap,
//				iconsMap, bgImagesMap};

//		return (propertiesMaps);
	}

