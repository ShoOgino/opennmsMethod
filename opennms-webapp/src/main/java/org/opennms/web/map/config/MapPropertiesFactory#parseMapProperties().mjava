	/**
	 * Parses the map.properties file into some mappings: 
	 *  -severitiesMap: severity label (String) to Severity
	 *	-statusesMap: status (String) uei to Status
	 * 	-availsMap: min (String) of avail to Avail
	 *	-iconsMap: icon (String) label to String (icon filename)
	 *	-bgImagesMap: background (String) image label to String (background image filename)
	 *	-sourcesMap: source label (String) to DataSource 
	 *	-factoriesMap: factory label (String) to MapsFactory
	 */
	protected static Map[] parseMapProperties() throws FileNotFoundException,
			IOException {
		log.debug("Parsing map.properties...");
		severitiesMap = new HashMap<String,Severity>();
		statusesMap = new HashMap<String,Status>();
		availsMap = new HashMap<String,Avail>();
		iconsMap = new HashMap<String,String>();
		bgImagesMap = new HashMap<String,String>();
		sourcesMap = new HashMap<String,DataSource>();
		factoriesMap = new HashMap<String,MapsFactory>();
		linksMap = new HashMap<Integer,Link>();
		linksBySnmpTypeMap = new HashMap<Integer,Set<Link>>();
		linkStatusesMap = new HashMap<String,LinkStatus>();

		// read the file
		Properties props = new Properties();
		props.load(new FileInputStream(MapPropertiesFactory.mapPropertiesFile));

		// looks up for sources and their properties
		if(props.containsKey("sources")){
			String[] sources = BundleLists.parseBundleList(props
					.getProperty("sources"));
			for (int i = 0; i < sources.length; i++) {
				log.debug("---found source " + sources[i] + "---");
				// load nodes' filters
				List filterList = new ArrayList();
				if(props.containsKey("source." + sources[i] + ".filters")){
					String[] filters = BundleLists.parseBundleList(props
							.getProperty("source." + sources[i] + ".filters"));
					for (int filterCounter = 0; filterCounter < filters.length; filterCounter++) {
						String table = props.getProperty("source." + sources[i]
								+ ".filter." + filters[filterCounter] + ".table");
						String condition = props.getProperty("source." + sources[i]
								+ ".filter." + filters[filterCounter] + ".condition");
						log.debug("source." + sources[i] + ".filter."
								+ filters[filterCounter] + ".table=" + table);
						log.debug("source." + sources[i] + ".filter."
								+ filters[filterCounter] + ".field=" + condition);
						Filter f = new Filter(table, condition);
						filterList.add(f);
					}
				}
	
				// load the datasource class to get data
				String implClass = props.getProperty("source." + sources[i]
						+ ".class");
				if(implClass==null){
					log.error("The property 'class' is mandatory for each source! skipping source "+sources[i]);
					continue;
				}
				log.debug("source." + sources[i] + ".class=" + implClass);
	
				// load datasource params
				HashMap paramsMap = new HashMap();
				if(props.containsKey("source." + sources[i] + ".params")){
					String[] params = BundleLists.parseBundleList(props
							.getProperty("source." + sources[i] + ".params"));
					for (int paramCounter = 0; paramCounter < params.length; paramCounter++) {
						String param = props.getProperty("source." + sources[i]
								+ ".param." + params[paramCounter]);
						paramsMap.put(params[paramCounter], param);
						log.debug("source." + sources[i] + ".param."
								+ params[paramCounter] + "=" + param);
					}
				}
				
				DataSource ds = new DataSource(sources[i], implClass, paramsMap,
						(Filter[]) filterList.toArray(new Filter[0]));
				sourcesMap.put(sources[i], ds);
				log.debug("---end of source " + sources[i] + "---");
			}
		}
		// look up factories and their properties
		defaultFactory = props.getProperty("default.factory");
		if(defaultFactory==null){
			log.fatal("The property 'default.factory' is mandatory");
			throw new IllegalStateException("The property 'default.factory' is mandatory");
		}
		
		String[] factories = BundleLists.parseBundleList(props
				.getProperty("factories"));
		for (int i = 0; i < factories.length; i++) {
			log.debug("---found map factory " + factories[i] + "---");
			
			// load the map manager class to delete/save maps and elements
			String managerClass = props.getProperty("factory." + factories[i]
					+ ".managerclass");
			if(managerClass==null){
				log.error("The property 'managerclass' is mandatory for each map factory! skipping factory "+factories[i]);
				continue;
			}
			log.debug("factory." + factories[i] + ".managerclass=" + managerClass);
			
			// load the map manager class to delete/save maps and elements
			String dataSource = props.getProperty("factory." + factories[i]
					+ ".source");
			
			log.debug("factory." + factories[i] + ".source=" + dataSource);
			// load map factory params
			HashMap paramsMap = new HashMap();
			if(props.containsKey("factory." + factories[i] + ".params")){
				String[] params = BundleLists.parseBundleList(props
						.getProperty("factory." + factories[i] + ".params"));
				for (int paramCounter = 0; paramCounter < params.length; paramCounter++) {
					String param = props.getProperty("factory." + factories[i]
							+ ".param." + params[paramCounter]);
					paramsMap.put(params[paramCounter], param);
					log.debug("factory." + factories[i] + ".param."
							+ params[paramCounter] + "=" + param);
				}
			}
			// load the modifymaps flag
			String adminmodify = props.getProperty("factory." + factories[i]
					+ ".adminmodify");
			boolean adminMod = true;
			if(adminmodify!=null && adminmodify.equalsIgnoreCase("false"))
				adminMod=false;
			log.debug("factory." + factories[i] + ".adminmodify=" + adminMod);
			
			//load the modifymaps flag
			String allmodify = props.getProperty("factory." + factories[i]
					+ ".allmodify");
			boolean allMod = false;
			if(allmodify!=null && allmodify.equalsIgnoreCase("true"))
				allMod=true;
			log.debug("factory." + factories[i] + ".allmodify=" + allMod);

			//load reload flag
			String reload = props.getProperty("factory." + factories[i]
					+ ".reload");
			boolean rel = false;
			if(reload!=null && reload.equalsIgnoreCase("true"))
				rel=true;
			log.debug("factory." + factories[i] + ".reload=" + rel);
			
			//load context menu flag
			String cntxtmenu = props.getProperty("factory." + factories[i]
					+ ".contextmenu");
			boolean cntxt = true;
			if(cntxtmenu!=null && cntxtmenu.equalsIgnoreCase("false"))
				cntxt=false;
			log.debug("factory." + factories[i] + ".contextmenu=" + cntxt);			

			//load double click flag
			String doubleclick = props.getProperty("factory." + factories[i]
					+ ".doubleclick");
			boolean dbclick = true;
			if(doubleclick!=null && doubleclick.equalsIgnoreCase("false"))
				dbclick=false;
			log.debug("factory." + factories[i] + ".doubleclick=" + dbclick);			
			
			ContextMenu contMenu = null;
			if(cntxt){
				String commandList = props.getProperty("factory."+factories[i]+".cmenu.commands");
				if(commandList!=null){
					String[] commands = BundleLists.parseBundleList(commandList);
					if(commands!=null){
						contMenu = new ContextMenu();
						for (int j = 0; j < commands.length;j++) {
							String link = "-";
							String params = "-";
							if(!commands[j].equals("-")){
								//load the link to open for the command
								link = props.getProperty("factory." + factories[i]+ ".cmenu."+commands[j]+".link");
								log.debug("factory." + factories[i]+ ".cmenu."+commands[j]+".link="+link);
								if(link==null){
									log.warn("link is null! skipping..");
									continue;
								}
								params = props.getProperty("factory." + factories[i]+ ".cmenu."+commands[j]+".params");						
								log.debug("factory." + factories[i]+ ".cmenu."+commands[j]+".params="+params);
								if(params==null) params="";
							}
							contMenu.addEntry(commands[j], link, params);
						}
					}
				}else{
					log.warn("Context Menu enabled and No command found for factory "+factories[i]);
				}
			}else{
				log.debug("contextMenu disabled for the factory "+factories[i] +": skipping...");
			}
			MapsFactory df = new MapsFactory( managerClass, adminMod, allMod, rel, cntxt, contMenu, dbclick , dataSource, paramsMap, factories[i]);
			factoriesMap.put(factories[i], df);
			log.debug("---end of map factory " + factories[i] + "---");
		}
		// look up severities and their properties
		severityMapAs=props.getProperty("severity.map", "avg");
		
		String[] severities = BundleLists.parseBundleList(props
				.getProperty("severities"));

		for (int i = 0; i < severities.length; i++) {
			String id = props.getProperty("severity." + severities[i] + ".id");
			String label = props.getProperty("severity." + severities[i]
					+ ".label");
			String color = props.getProperty("severity." + severities[i]
					+ ".color");
			String flash = props.getProperty("severity." + severities[i]
					+ ".flash");
			Severity sev = new Severity(Integer.parseInt(id), label, color);
			if (flash != null && flash.equalsIgnoreCase("true"))
				sev.setFlash(true);
			log.debug("found severity " + severities[i] + " with id=" + id
					+ ", label=" + label + ", color=" + color + ". Adding it.");
			severitiesMap.put(label, sev);
		}
		orderedSeverities = new Severity[severitiesMap.size()];
		Iterator it = severitiesMap.values().iterator();
		int k = 0;
		while (it.hasNext()) {
			orderedSeverities[k++] = (Severity) it.next();
		}
		Arrays.sort(orderedSeverities);

		//Links
		String[] links = BundleLists.parseBundleList(props
				.getProperty("links"));
		
		String defaultLinkStr = props.getProperty("link.default");
		if(defaultLinkStr==null){
			log.error("Mandatory property 'link.default' not found!");
			throw new IllegalStateException("The property 'link.default' is mandatory");
		}
		defaultLink = Integer.parseInt(defaultLinkStr);

		for (int i = 0; i < links.length; i++) {
			String id = props.getProperty("link." + links[i] + ".id");
			String text = props.getProperty("link." + links[i]+ ".text");
			String speed = props.getProperty("link." + links[i]+ ".speed");
			String width = props.getProperty("link." + links[i]+ ".width");
			String dasharray = props.getProperty("link." + links[i]+ ".dash-array");			
			String snmptype = props.getProperty("link." + links[i]+ ".snmptype");			
			if(id==null){
				log.error("param id for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(text==null){
				log.error("param text for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(speed==null){
				log.error("param speed for link cannot be null in map.properties: skipping link...");
				continue;
			}
			if(width==null){
				log.error("param width for link cannot be null in map.properties: skipping link...");
				continue;
			}
				
			int dash_arr=-1;
			if(dasharray!=null)
				dash_arr=Integer.parseInt(dasharray);
			
			int snmp_type=-1;
			if(snmptype!=null)
				snmp_type=Integer.parseInt(snmptype);

			Link lnk = new Link(Integer.parseInt(id), speed,text,width,dash_arr,snmp_type);
			
			log.debug("found link " + links[i] + " with id=" + id
					+ ", text=" + text+ ", speed=" + speed+ ", width=" + width+ ", dash-array=" + dasharray+ "snmp-type=" + snmp_type+". Adding it.");
			linksMap.put(new Integer(id), lnk);
			Set<Link> linkbysnmptypeSet = linksBySnmpTypeMap.get(new Integer(snmp_type));
			if(linkbysnmptypeSet==null)
				linkbysnmptypeSet=new HashSet<Link>();
			linkbysnmptypeSet.add(lnk);
			linksBySnmpTypeMap.put(new Integer(snmp_type), linkbysnmptypeSet);
		}
		
		
		
		//Links Statuses
		String[] linkStatuses = BundleLists.parseBundleList(props
				.getProperty("linkstatuses"));
		for (int i = 0; i < linkStatuses.length; i++) {
			String color = props.getProperty("linkstatus." + linkStatuses[i] + ".color");
			String flash = props.getProperty("linkstatus." + linkStatuses[i]+ ".flash");
			if(color==null){
				log.error("param color for linkstatus cannot be null in map.properties: skipping linkstatus...");
				continue;
			}
			boolean flashBool = false;
			if(flash!=null && flash.equalsIgnoreCase("false"))
				flashBool=false;			
			log.debug("found linkstatus " + linkStatuses[i] + " with color=" + color
					+ ", flash=" + flashBool+ ". Adding it.");
			LinkStatus ls = new LinkStatus(linkStatuses[i],color,flashBool);
			linkStatusesMap.put(linkStatuses[i], ls);
		}		
		
		
		if(props.getProperty("multilink.status")!=null){
			multilinkStatus = props.getProperty("multilink.status"); 	
		}
		if(!multilinkStatus.equals("best") && !multilinkStatus.equals("worst")){
			log.error("multilink.status property must be 'best' or 'worst'... using default ('best')");
			multilinkStatus=MULTILINK_BEST_STATUS;
		}
		log.debug("found multilink.status:"+multilinkStatus);
				
			
		// look up statuses and their properties
		String[] statuses = BundleLists.parseBundleList(props
				.getProperty("statuses"));

		for (int i = 0; i < statuses.length; i++) {
			String id = props.getProperty("status." + statuses[i] + ".id");
			String uei = props.getProperty("status." + statuses[i] + ".uei");
			String color = props
					.getProperty("status." + statuses[i] + ".color");
			String text = props.getProperty("status." + statuses[i] + ".text");
			log.debug("found status " + statuses[i] + " with id=" + id
					+ ", uei=" + uei + ", color=" + color + ", text=" + text
					+ ". Adding it.");
			Status status = new Status(Integer.parseInt(id), uei, color, text);
			statusesMap.put(uei, status);
		}

		orderedStatuses = new Status[statusesMap.size()];
		it = statusesMap.values().iterator();
		k = 0;
		while (it.hasNext()) {
			orderedStatuses[k++] = (Status) it.next();
		}
		Arrays.sort(orderedStatuses);

		// look up statuses and their properties
		String[] availes = BundleLists.parseBundleList(props
				.getProperty("availabilities"));

		for (int i = 0; i < availes.length; i++) {
			String id = props.getProperty("avail." + availes[i] + ".id");
			String min = props.getProperty("avail." + availes[i] + ".min");
			String color = props.getProperty("avail." + availes[i] + ".color");
			String flash = props.getProperty("avail." + availes[i] + ".flash");
			log.debug("found avail " + availes[i] + " with id=" + id + ", min="
					+ min + ", color=" + color + ". Adding it.");
			Avail avail = new Avail(Integer.parseInt(id),
					Integer.parseInt(min), color);
			if (flash != null && flash.equalsIgnoreCase("true"))
				avail.setFlash(true);
			availsMap.put(min, avail);
		}

		orderedAvails = new Avail[availsMap.size()];
		it = availsMap.values().iterator();
		k = 0;
		while (it.hasNext()) {
			orderedAvails[k++] = (Avail) it.next();
		}
		Arrays.sort(orderedAvails);

		// look up icons filenames
		String[] icons = BundleLists
				.parseBundleList(props.getProperty("icons"));

		for (int i = 0; i < icons.length; i++) {
			String filename = props.getProperty("icon." + icons[i]
					+ ".filename");
			log.debug("found icon " + icons[i] + " with filename=" + filename
					+ ". Adding it.");
			iconsMap.put(icons[i], filename);
		}

		// look up background filenames
		String[] bg = BundleLists
				.parseBundleList(props.getProperty("bgimages"));

		for (int i = 0; i < bg.length; i++) {
			String filename = props.getProperty("bgimage." + bg[i]
					+ ".filename");
			log.debug("found bgimage " + bg[i] + " with filename=" + filename
					+ ". Adding it.");
			bgImagesMap.put(bg[i], filename);
		}
		propertiesMaps = new Map[] { severitiesMap, statusesMap, availsMap,
				iconsMap, bgImagesMap, sourcesMap , factoriesMap};

		return (propertiesMaps);
	}

