    /**
     * create an SVG subtree, contained inside <g></g> elements, for a given
     * node
     * 
     * @param loadIcons
     *            tell me whether I should generate file:// references to load
     *            icons from the filesystem or generate URL references. "true"
     *            will generate file:// references for when we are sending the
     *            output to the Batik Transcoder, while "false" will generate
     *            http:// references for when we are downloading the SVG
     *            directly into an external viewer.
     */

    private Element createHostElement(MapNode n, boolean loadIcons) {
        // a "g" element is just a container for other elements
        // we're "containing" each host inside of "g" elements
        Element host = this.document.createElementNS(this.namespace, "g");
        host.setAttributeNS(null, "id", n.getHostname());

        int x = n.getX();
        int y = n.getY();

        // try to get an OpenNMS CategoryModel so we can figure out
        // colors for our text and stuff
        CategoryModel cModel = null;
        double normalThreshold = 0.0;
        double warningThreshold = 0.0;

        try {
            cModel = CategoryModel.getInstance();
            normalThreshold = cModel.getCategoryNormalThreshold(CategoryModel.OVERALL_AVAILABILITY_CATEGORY);
            warningThreshold = cModel.getCategoryWarningThreshold(CategoryModel.OVERALL_AVAILABILITY_CATEGORY);
        } catch (Exception e) {
            log("Exception in DocumentGenerator.createHostElement()");
            log("Exception in CategoryModel.getInstance()");
            log(e.toString());
        }

        // create an "a" link reference for the host icon
        Element link = this.document.createElementNS(this.namespace, "a");
        link.setAttributeNS(null, "xlink:href", this.urlBase + "element/node.jsp?node=" + n.getNodeID());

        // create the icon for the host
        Element icon = this.document.createElementNS(this.namespace, "image");
        icon.setAttributeNS(null, "x", n.getIconX());
        icon.setAttributeNS(null, "y", n.getIconY());
        icon.setAttributeNS(null, "width", "40px");
        icon.setAttributeNS(null, "height", "40px");
        // icon.setAttributeNS(null, "xlink:href", "#" + n.getIconName());

        if (loadIcons) {
            // we're using the Transcoder, so generate filesystem references
            String path = "file://" + ctx.getRealPath("map/images/svg/" + n.getIconName() + ".svg");
            icon.setAttributeNS(null, "xlink:href", path);
        } else {
            // we're sending out SVG so generate http:// references
            icon.setAttributeNS(null, "xlink:href", this.urlBase + "map/images/svg/" + n.getIconName() + ".svg");
        }

        // create the hostname text for the host
        Element hostname = this.document.createElementNS(this.namespace, "text");
        hostname.setAttributeNS(null, "x", n.getHostnameX());
        hostname.setAttributeNS(null, "y", n.getHostnameY());
        hostname.setAttributeNS(null, "font-family", "sans-serif");
        hostname.setAttributeNS(null, "font-size", "12");
        hostname.setAttributeNS(null, "fill", "black");
        hostname.setAttributeNS(null, "style", "text-anchor: middle");
        org.w3c.dom.Node textString = this.document.createTextNode(n.getHostname());
        hostname.appendChild(textString);

        // create the RTC Value text for the host
        Element rtc = this.document.createElementNS(this.namespace, "text");
        rtc.setAttributeNS(null, "x", n.getRTCX());
        rtc.setAttributeNS(null, "y", n.getRTCY());
        rtc.setAttributeNS(null, "font-family", "sans-serif");
        rtc.setAttributeNS(null, "font-size", "12");

        if (cModel != null) {
            try {
                rtc.setAttributeNS(null, "fill", CategoryUtil.getCategoryColor(normalThreshold, warningThreshold, n.getRTC()));
            } catch (IOException e) {
                log("IOException in CategoryUtil.getCategoryColor");
                log(e.toString());
            } catch (org.exolab.castor.xml.MarshalException e) {
                log("org.exolab.castor.xml.MarshalException in CategoryUtil.getCategoryColor");
                log(e.toString());
            } catch (org.exolab.castor.xml.ValidationException e) {
                log("org.exolab.castor.xml.ValidationException in CategoryUtil.getCategoryColor");
                log(e.toString());
            }

        } else {
            rtc.setAttributeNS(null, "fill", "black");
        }

        rtc.setAttributeNS(null, "style", "text-anchor: middle");
        textString = this.document.createTextNode(CategoryUtil.formatValue(n.getRTC()) + " %");
        rtc.appendChild(textString);

        // create the status text for the host
        Element status = this.document.createElementNS(this.namespace, "text");
        status.setAttributeNS(null, "x", n.getStatusX());
        status.setAttributeNS(null, "y", n.getStatusY());
        status.setAttributeNS(null, "font-family", "sans-serif");
        status.setAttributeNS(null, "font-size", "12");
        status.setAttributeNS(null, "style", "text-anchor: middle");
        textString = this.document.createTextNode(n.getStatus());

        if (n.getStatus().equals("Up")) {
            status.setAttributeNS(null, "fill", "green");
        } else {
            status.setAttributeNS(null, "fill", "red");
        }

        status.appendChild(textString);

        // put the icon inside of the link element
        link.appendChild(icon);

        // append all the host elements inside of the g element
        host.appendChild(link);
        host.appendChild(hostname);
        host.appendChild(rtc);
        host.appendChild(status);

        return host;
    }

