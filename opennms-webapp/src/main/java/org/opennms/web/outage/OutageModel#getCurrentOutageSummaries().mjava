    /**
     * Return a list of IP addresses, the number of services down on each IP
     * address, and the longest time a service has been down for each IP
     * address. The list will be sorted in ascending order from the service down
     * longest to the service down shortest.
     *
     * @return an array of {@link org.opennms.netmgt.model.outage.OutageSummary} objects.
     * @throws java.sql.SQLException if any.
     */
    public OutageSummary[] getCurrentOutageSummaries() throws SQLException {
        OutageSummary[] summaries = new OutageSummary[0];

        try {
            Connection conn = Vault.getDbConnection();
            d.watch(conn);
            
            Statement stmt = conn.createStatement();
            d.watch(stmt);
            //FIXME: This query is questionable at best but rewritten to follow relationships
            ResultSet rs = stmt.executeQuery("  "
            		+ "SELECT DISTINCT \n" + 
            		"         node.nodeid, max(outages.iflostservice) as timeDown, \n" + 
            		"         node.nodelabel, \n" + 
            		"         now() as timeNow \n" + 
            		"    FROM node \n" + 
            		"    JOIN ipinterface \n" + 
            		"      ON ipinterface.nodeid = node.nodeid \n" + 
            		"    JOIN ifservices \n" + 
            		"      ON ifservices.ipinterfaceid = ipinterface.id \n" + 
            		"    JOIN outages \n" + 
            		"      ON outages.ifserviceid = ifservices.id\n" + 
            		"   WHERE outages.ifregainedservice IS NULL \n" + 
            		"     AND node.nodeType != 'D' \n" + 
            		"     AND ipinterface.ismanaged != 'D' \n" + 
            		"     AND ifservices.status != 'D' \n" + 
            		"GROUP BY node.nodeid, node.nodelabel \n" + 
            		"ORDER BY timeDown DESC");
            d.watch(rs);

            List<OutageSummary> list = new ArrayList<OutageSummary>();

            while (rs.next()) {
                int nodeId = rs.getInt("nodeID");
                Timestamp timeDownTS = rs.getTimestamp("timeDown");
                long timeDown = timeDownTS.getTime();
                Date downDate = new Date(timeDown);
                String nodeLabel = rs.getString("nodelabel");
                Date now = new Date(rs.getTimestamp("timeNow").getTime());

                list.add(new OutageSummary(nodeId, nodeLabel, downDate, null, now));
            }

            summaries = list.toArray(new OutageSummary[list.size()]);
        } finally {
            d.cleanUp();
        }

        return summaries;
    }

