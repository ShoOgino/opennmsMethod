    /**
     * <p>createPrefabCommand</p>
     *
     * @param graph a {@link org.opennms.web.graph.Graph} object.
     * @param commandPrefix a {@link java.lang.String} object.
     * @param workDir a {@link java.io.File} object.
     * @param reportName a {@link java.lang.String} object.
     * @return a {@link java.lang.String} object.
     */

    protected String createPrefabCommand(Graph graph, String commandPrefix, File workDir, String reportName, Integer width, Integer height) {
        PrefabGraph prefabGraph = graph.getPrefabGraph();

        String[] rrds = getRrdNames(graph.getResource(), graph.getPrefabGraph().getColumns());

        StringBuffer buf = new StringBuffer();
        buf.append(commandPrefix);
        buf.append(" ");
        buf.append(prefabGraph.getCommand());
        String command = buf.toString();

        long startTime = graph.getStart().getTime();
        long endTime = graph.getEnd().getTime();
        long diffTime = endTime - startTime;

        /*
         * remember rrdtool wants the time in seconds, not milliseconds;
         * java.util.Date.getTime() returns milliseconds, so divide by 1000
         */
        String startTimeString = Long.toString(startTime / 1000);
        String endTimeString = Long.toString(endTime / 1000);
        String diffTimeString = Long.toString(diffTime / 1000);

        HashMap<String, String> translationMap = new HashMap<String, String>();

        for (int i = 0; i < rrds.length; i++) {
            String key = "{rrd" + (i + 1) + "}";
            translationMap.put(key, rrds[i]);
        }

        translationMap.put("{startTime}", startTimeString);
        translationMap.put("{endTime}", endTimeString);
        translationMap.put("{diffTime}", diffTimeString);

        SimpleDateFormat fmt = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        translationMap.put("{startTimeDate}", fmt.format(new Date(startTime)).replace(":", "\\:"));
        translationMap.put("{endTimeDate}", fmt.format(new Date(endTime)).replace(":", "\\:"));

        // Handle a start time with a format.
        Matcher stm = Pattern.compile("\\{startTime:(.+?)\\}").matcher(command);
        boolean matchFail = false;
        while(stm.find() && !matchFail) {
            String sdfPattern = stm.group(0);
            if (sdfPattern == null) {
                matchFail = true;
            } else {
                try {
                    fmt = new SimpleDateFormat(sdfPattern);
                    translationMap.put("{startTime:"+sdfPattern+"}", fmt.format(new Date(startTime)).replace(":", "\\:"));
                } catch (IllegalArgumentException e) {
                    LOG.error("Cannot parse date format '{}' for graph {}.", sdfPattern, reportName);
                }
            }
        }

        // Handle an end time with a format
        Matcher etm = Pattern.compile("\\{endTime:(.+?)\\}").matcher(command);
        matchFail = false;
        while (etm.find() && !matchFail) {
            String sdfPattern = etm.group(0);
            if (sdfPattern == null) {
              matchFail = true;
            } else {
                try {
                    fmt = new SimpleDateFormat(sdfPattern);
                    translationMap.put("{endTime:"+sdfPattern+"}", fmt.format(new Date(endTime)).replace(":", "\\:"));
                } catch (IllegalArgumentException e) {
                    LOG.error("Cannot parse date format '{}' for graph {}.", sdfPattern, reportName);
                }
            }
        }

        try {
            translationMap.putAll(getTranslationsForAttributes(graph.getResource().getExternalValueAttributes(), prefabGraph.getExternalValues(), "external value attribute"));
            translationMap.putAll(getTranslationsForAttributes(graph.getResource().getStringPropertyAttributes(), prefabGraph.getPropertiesValues(), "string property attribute"));
        } catch (RuntimeException e) {
            LOG.error("Invalid attributes were found on resource '{}'", graph.getResource().getId());
            throw e;
        }


        try {
            for (Map.Entry<String, String> translation : translationMap.entrySet()) {
                // replace s1 with s2
                final Matcher matcher = Pattern.compile(translation.getKey(), Pattern.LITERAL).matcher(command);
                command = matcher.replaceAll(Matcher.quoteReplacement(translation.getValue()));
            }
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Invalid regular expression syntax, check rrd-properties file", e);
        }


        if (width != null) {
            final Pattern re = Pattern.compile("(--width|-w)(\\w+|=)(\\d+)");

            final Matcher matcher = re.matcher(command);
            if (matcher.matches()) {
                matcher.replaceFirst("--width " + width);
            } else {
                command = command + " --width " + width;
            }
        }

        if (height != null) {
            final Pattern re = Pattern.compile("(--height|-h)(\\w+|=)(\\d+)");

            final Matcher matcher = re.matcher(command);
            if (matcher.matches()) {
                matcher.replaceFirst("--height " + height);
            } else {
                command = command + " --height " + height;
            }
        }

        return command;
    }

