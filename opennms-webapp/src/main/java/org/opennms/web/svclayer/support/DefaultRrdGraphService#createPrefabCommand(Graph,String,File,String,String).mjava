    protected String createPrefabCommand(Graph graph,
            String commandPrefix,
            File workDir, String reportName,
            String relativePropertiesPath) {
        PrefabGraph prefabGraph = graph.getPrefabGraph();

        String[] rrds = getRRDNames(graph);
        
        StringBuffer buf = new StringBuffer();
        buf.append(commandPrefix);
        buf.append(" ");
        buf.append(prefabGraph.getCommand());
        String command = buf.toString();
        
        long startTime = graph.getStart().getTime();
        long endTime = graph.getEnd().getTime();
        long diffTime = endTime - startTime;
        
        /*
         * remember rrdtool wants the time in seconds, not milliseconds;
         * java.util.Date.getTime() returns milliseconds, so divide by 1000
         */
        String startTimeString = Long.toString(startTime / 1000);
        String endTimeString = Long.toString(endTime / 1000);
        String diffTimeString = Long.toString(diffTime / 1000);
        
        HashMap<String, String> translationMap = new HashMap<String, String>();
        
        for (int i = 0; i < rrds.length; i++) {
            String key = "{rrd" + (i + 1) + "}";
            translationMap.put(RE.simplePatternToFullRegularExpression(key),
                    rrds[i]);
        }
        
        translationMap.put(RE.simplePatternToFullRegularExpression("{startTime}"), startTimeString);
        translationMap.put(RE.simplePatternToFullRegularExpression("{endTime}"), endTimeString);
        translationMap.put(RE.simplePatternToFullRegularExpression("{diffTime}"), diffTimeString);

        for (String externalValue : prefabGraph.getExternalValues()) { 
            if ("ifSpeed".equals(externalValue)) {
                if (!"node".equals(graph.getResource().getParent().getResourceType().getName())) {
                    throw new IllegalStateException("Report requires an "
                                                    + "external value of "
                                                    + externalValue
                                                    + ", but this requires "
                                                    + "the parent resource "
                                                    + "to be a node, but "
                                                    + "parent of this "
                                                    + "resource is not a "
                                                    + "node");
                }
                
                // XXX error checking
                int nodeId = Integer.parseInt(graph.getResource().getParent().getName());
                String speed = getIfSpeed(nodeId, graph.getResource().getName());
                if (speed == null) {
                    throw new IllegalStateException("Report requires an "
                                                    + "external value of "
                                                    + externalValue
                                                    + ", but it is not "
                                                    + "available for this "
                                                    + "resource");
                }
                
                translationMap.put(RE.simplePatternToFullRegularExpression("{" + externalValue + "}"), speed);
            } else {
                throw new IllegalStateException("Unsupported external value name: " + externalValue);
            }                
        }
        
        String[] propertiesValues = prefabGraph.getPropertiesValues();
        if (propertiesValues != null && propertiesValues.length > 0) {
            Properties properties;
            try {
                properties = loadProperties(workDir,
                                            relativePropertiesPath);
            } catch (DataAccessException e) {
                String message = "Could not load properties file but prefab graph has propertiesValues, so the properties file is required.  Chained exception: " + e;
                log().warn(message, e);
                throw new IllegalArgumentException(message, e);
            }

            for (Map.Entry<Object, Object> entry : properties.entrySet()) {
                String value=entry.getValue().toString();
                //Replace any single backslashes in the value with escaped backslashes so other parsing won't barf
                value=value.replace("\\","\\\\");
                translationMap.put(RE.simplePatternToFullRegularExpression("{" + entry.getKey() + "}"),
                                   value);
            }
        }
        
        try {
            for (Map.Entry<String, String> translation : translationMap.entrySet()) {
                // replace s1 with s2
                RE re = new RE(translation.getKey());
                command = re.subst(command, translation.getValue());
            }
        } catch (RESyntaxException e) {
            throw new IllegalArgumentException("Invalid regular expression "
                                               + "syntax, check "
                                               + "rrd-properties file", e);
        }
        
        return command;
    }

