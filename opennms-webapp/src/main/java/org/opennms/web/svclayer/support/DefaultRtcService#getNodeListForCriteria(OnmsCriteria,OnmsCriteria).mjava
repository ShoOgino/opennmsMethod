    /** {@inheritDoc} */
    public RtcNodeModel getNodeListForCriteria(OnmsCriteria serviceCriteria, OnmsCriteria outageCriteria) {
        serviceCriteria.addOrder(Order.asc("node.label"));
        serviceCriteria.addOrder(Order.asc("node.id"));
        serviceCriteria.addOrder(Order.asc("ipInterface.inetAddress"));
        serviceCriteria.addOrder(Order.asc("serviceType.name"));

        Date periodEnd = new Date(System.currentTimeMillis());
        Date periodStart = new Date(periodEnd.getTime() - (24 * 60 * 60 * 1000));
        
        Disjunction disjunction = Restrictions.disjunction();
        disjunction.add(Restrictions.isNull("ifRegainedService"));
        disjunction.add(Restrictions.ge("ifLostService", periodStart));
        disjunction.add(Restrictions.ge("ifRegainedService", periodStart));
        outageCriteria.add(disjunction);
        
        outageCriteria.addOrder(Order.asc("monitoredService"));
        outageCriteria.addOrder(Order.asc("ifLostService"));
        
        List<OnmsMonitoredService> services = m_monitoredServiceDao.findMatching(serviceCriteria);
        List<OnmsOutage> outages = m_outageDao.findMatching(outageCriteria);
        
        Map<OnmsMonitoredService, Long> serviceDownTime = calculateServiceDownTime(periodEnd, periodStart, outages);
        
        RtcNodeModel model = new RtcNodeModel();
        
        OnmsNode lastNode = null;
        int serviceCount = 0;
        int serviceDownCount = 0;
        long downMillisCount = 0;
        for (OnmsMonitoredService service : services) {
            if (!service.getIpInterface().getNode().equals(lastNode) && lastNode != null) {
                Double availability = calculateAvailability(serviceCount, downMillisCount);
                
                model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));
                
                serviceCount = 0;
                serviceDownCount = 0;
                downMillisCount = 0;
            }
            
            serviceCount++;
            if (service.isDown()) {
                serviceDownCount++;
            }
            
            Long downMillis = serviceDownTime.get(service);
            if  (downMillis != null) {
                downMillisCount += downMillis;
            }
            
            lastNode = service.getIpInterface().getNode();
        }
        if (lastNode != null) {
            Double availability = calculateAvailability(serviceCount, downMillisCount);
            
            model.addNode(new RtcNodeModel.RtcNode(lastNode, serviceCount, serviceDownCount, availability));
        }
        
        return model;
    }

