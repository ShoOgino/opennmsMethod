    /**
     * This method executes the command using a Process. The method will decide
     * if an input stream needs to be used.
     *
     * @return the return code of the command
     */
    public int execute() {
        int returnCode = 0;

        List<String> args = new ArrayList<String>();

        args.add(m_commandName);

        // put the non streamed arguments into the argument array
        for (Argument curArg : m_arguments) {
            // only non streamed arguments go into this list
            if (!curArg.isStreamed()) {
                if (!curArg.getSubstitution().equals("")) {
                    args.add(curArg.getSubstitution());
                }
                if (curArg.getValue() != null && !curArg.getValue().equals("")) {
                    args.add(curArg.getValue());
                }
            }
        }

        try {
            // set up the process
            String[] arguments = args.toArray(new String[args.size()]);

            Process command = Runtime.getRuntime().exec(arguments);

            // see if we need to build a streamed argument buffer
            if (m_useStream) {
                // make sure the output we are writing is buffered
                BufferedWriter processInput = new BufferedWriter(new OutputStreamWriter(command.getOutputStream(), "UTF-8"));

                StringBuffer buffer = new StringBuffer();

                // now write each streamed argument to the processes input
                // buffer
                for (Argument curArg : m_arguments) {
                    if (curArg.isStreamed()) {
                        if (!curArg.getSubstitution().equals("")) {
                            buffer.append(curArg.getSubstitution());
                        }
                        if (!curArg.getValue().equals("")) {
                            buffer.append(curArg.getValue());
                        }
                    }
                }

                // put the streamed argumetns into the stream
                processInput.write(buffer.toString());

                processInput.flush();
                processInput.close();
            }

            returnCode = command.waitFor();
        } catch (IOException e) {
            log().error("Command failed with IOExceptoin: " + e, e);
        } catch (InterruptedException e) {
            log().error("Command failed with InterruptedExceptoin: " + e, e);
        }

        log().debug("command complete with return code " + returnCode);

        return returnCode;
    }

