    @Override
    public CompletableFuture<PingSweepResponseDTO> execute(PingSweepRequestDTO request) {

        final PingSweepResultTracker tracker = new PingSweepResultTracker();
        final ExecutorService executor = Executors.newFixedThreadPool(1);
        // IPAddrRange range = new IPAddrRange(request.getBegin(),
        // request.getEnd());
        String foreignSource = request.getForeignSource();
        String location = request.getLocation();
        long timeout = request.getTimeout();
        int packetSize = request.getPacketSize();
        List<IPPollRange> ranges = new ArrayList<>();
        for (IPRangeDTO dto : request.getIpRanges()) {
            IPPollRange pollRange = new IPPollRange(foreignSource, location, dto.getBegin(), dto.getEnd(), timeout, 1);
            ranges.add(pollRange);
        }
        // Use a RateLimiter to limit the ping packets per second that we send
        RateLimiter limiter = RateLimiter.create(request.getPacketSize());

        List<IPPollAddress> addresses = StreamSupport.stream(getAddresses(ranges).spliterator(), false)
                .filter(j -> j.getAddress() != null).collect(Collectors.toList());

        return CompletableFuture.supplyAsync(() -> {

            addresses.stream().forEach(pollAddress -> {
                try {
                    tracker.expectCallbackFor(pollAddress.getAddress());
                    limiter.acquire();
                    pingerFactory.getInstance().ping(pollAddress.getAddress(), timeout, request.getRetries(), packetSize, 1, tracker);
                } catch (Exception e) {
                    tracker.handleError(pollAddress.getAddress(), null, e);
                    tracker.completeExceptionally(e);
                }
            });

            try {
                tracker.getLatch().await();
            } catch (InterruptedException e) {
                throw Throwables.propagate(e);
            }
            tracker.complete();
            return tracker.getResponse();
        } , executor);

    }

