    @Override
    public CompletableFuture<PingSweepResponseDTO> execute(PingSweepRequestDTO request) {
        final Pinger pinger = pingerFactory.getInstance();
        final PingSweepResultTracker tracker = new PingSweepResultTracker();

        String location = request.getLocation();
        int packetSize = request.getPacketSize();
        List<IPPollRange> ranges = new ArrayList<>();
        for (IPRangeDTO dto : request.getIpRanges()) {
            IPPollRange pollRange = new IPPollRange(null, location, dto.getBegin(), dto.getEnd(), dto.getTimeout(), dto.getRetries());
            ranges.add(pollRange);
        }

        // Use a RateLimiter to limit the ping packets per second that we send
        RateLimiter limiter = RateLimiter.create(request.getPacketsPerSecond());

        List<IPPollAddress> addresses = StreamSupport.stream(getAddresses(ranges).spliterator(), false)
                .filter(j -> j.getAddress() != null).collect(Collectors.toList());

        return CompletableFuture.supplyAsync(() -> {
            addresses.stream().forEach(pollAddress -> {
                try {
                    tracker.expectCallbackFor(pollAddress.getAddress());
                    limiter.acquire();
                    pinger.ping(pollAddress.getAddress(), pollAddress.getTimeout(), pollAddress.getRetries(), packetSize, 1, tracker);
                } catch (Exception e) {
                    tracker.handleError(pollAddress.getAddress(), null, e);
                    tracker.completeExceptionally(e);
                }
            });

            try {
                tracker.getLatch().await();
            } catch (InterruptedException e) {
                throw Throwables.propagate(e);
            }
            tracker.complete();
            return tracker.getResponse();
        } , executor);

    }

