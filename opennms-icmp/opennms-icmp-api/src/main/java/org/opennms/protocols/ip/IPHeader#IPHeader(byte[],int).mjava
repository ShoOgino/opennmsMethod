    /**
     * Constructs a new IPHeader object from the passed data buffer. The data is
     * gathered from the buffer starting at the location marked by offset. If
     * there is not sufficent data in the buffer then an exception is thrown.
     * 
     * @param header
     *            The buffer containing the header
     * @param offset
     *            The offset into the buffer where the IP header is located.
     * 
     * @exception java.lang.IndexOutOfBoundsException
     *                This exception is thrown if the minimum number of bytes
     *                are not present to represent an IPHeader object.
     * @exception UnknownIPVersionException
     *                Thrown if the format of the version is unknown.
     * 
     */
    public IPHeader(byte[] header, int offset) {
        int length = header.length;

        if ((length - offset) < 20)
            throw new IndexOutOfBoundsException("Minimum IP header size is 20 bytes");

        //
        // now start to build the header information
        //
        int ndx = 0;

        //
        // Get the header version and header length. The
        // header version lives in the first 4 bits of the
        // header. The header length lives in the next 4 bits.
        // NOTE: The header length is the number of 32-bit
        // words in the header, so the true length is m_hdrlen * 4.
        //
        m_version = (byte) (header[offset + ndx] >>> 4);
        m_hdrlen = (byte) (header[offset + ndx] & 0xf);
        ++ndx;

        //
        // check the version number
        //
        if (m_version != 4)
            throw new UnknownIPVersionException("Unknown IP Version, version = " + m_version);

        //
        // check to make sure there is enough data now that
        // we know the total length of the header
        //
        if ((length - offset) < (m_hdrlen * 4))
            throw new IndexOutOfBoundsException("Insufficient data: buffer size = " + (length - offset) + " and header length = " + (m_hdrlen * 4));

        //
        // Now get the Type Of Service flags (8-bits)
        //
        m_tos = header[offset + ndx];
        ++ndx;

        //
        // Convert the 16-bit total length of the packet
        // in bytes.
        //
        m_length = (short) (byteToShort(header[offset + ndx]) << 8 | byteToShort(header[offset + ndx + 1]));
        ndx += 2;

        //
        // Next get the 16-bit identification field
        //
        m_identity = (short) (byteToShort(header[offset + ndx]) << 8 | byteToShort(header[offset + ndx + 1]));
        ndx += 2;

        //
        // Get the next 16-bits of information. The upper 3-bits
        // are the header flags. The lower 13-bits is the
        // fragment offset!
        //
        m_fragOffset = (short) (byteToShort(header[offset + ndx]) << 8 | byteToShort(header[offset + ndx + 1]));
        m_flags = (byte) (m_fragOffset >>> 13); // get the upper 3-bits
        m_fragOffset = (short) (m_fragOffset & 0x1fff); // mask off the upper
                                                        // 3-bits
        ndx += 2;

        //
        // The 8-bit Time To Live (TTL) is next
        //
        m_ttl = header[offset + ndx];
        ++ndx;

        //
        // The 8-bit protocol is next. This is used by the
        // OS to determine if the packet is TCP, UDP, etc al.
        //
        m_protocol = header[offset + ndx];
        ++ndx;

        //
        // Now get the 16-bit one's compliment checksum
        //
        m_checksum = (short) (byteToShort(header[offset + ndx]) << 8 | byteToShort(header[offset + ndx + 1]));
        ndx += 2;

        //
        // The 32-bit IPv4 source address is next. This is the
        // address of the sender of the packet.
        //
        m_srcAddr = byteToInt(header[offset + ndx]) << 24 | byteToInt(header[offset + ndx + 1]) << 16 | byteToInt(header[offset + ndx + 2]) << 8 | byteToInt(header[offset + ndx + 3]);
        ndx += 4;

        //
        // The 32-bit IPv4 destination address. This is the address
        // of the interface that should receive the packet.
        //
        m_dstAddr = byteToInt(header[offset + ndx]) << 24 | byteToInt(header[offset + ndx + 1]) << 16 | byteToInt(header[offset + ndx + 2]) << 8 | byteToInt(header[offset + ndx + 3]);
        ndx += 4;

        //
        // get the option data now
        //
        int hl = byteToInt(m_hdrlen) << 2; // m_hdrlen * 4 ! :)
        if (hl > ndx) {
            m_options = new byte[hl - ndx];
            int x = 0;
            while (ndx < hl) {
                m_options[x++] = header[offset + ndx++];
            }
        } else {
            m_options = new byte[0];
        }

    } // end IPHeader(byte[], int)

