    /**
     * <P>
     * Decodes a character array into the corresponding byte array. The buffer
     * must be an intergral number of 4 character. I.E. size mod 4 is equal to
     * zero or an exception will be thrown. Likewise, if there is an invalid
     * character in the input array then an exception will be thrown.
     * </P>
     * 
     * 
     * @param data
     *            The data stream to be filtered.
     * 
     * @return The coverted array of bytes.
     * 
     * @exception java.lang.IllegalArgumentException
     *                Thrown if an invalid buffer that cannot be decoded is
     *                passed.
     * 
     */
    public static byte[] decodeBase64(char[] data) {
        //. If the data is zero length just return a zero length byte array
        if (data.length == 0) {
            return new byte[0];
        }
        //
        // check the length, it must be an integral number of 4 characters.
        //
        if ((data.length % 4) != 0)
            throw new IllegalArgumentException("Invalid base64 encoding, improper length");

        //
        // get the raw length and check for
        // the appended padding characters
        // if any.
        //
        int rawlen = (data.length / 4) * 3;
        for (int i = 1; i <= 2; i++) {
            if (data[data.length - i] == BASE64_PAD)
                --rawlen;
        }

        //
        // allocate the new buffer
        //
        byte[] rawdata = new byte[rawlen];
        int rawndx = 0;

        //
        // convert the character array into
        // a byte array.
        //
        int quantum = 0;
        for (int i = 0; i < data.length; i++) {
            if ((i % 4) == 0 && i > 0) {
                int c = ((quantum >> 16) & 0xff);
                rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);

                c = ((quantum >> 8) & 0xff);
                rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);

                c = quantum & 0xff;
                rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);

                quantum = 0;
            }
            quantum <<= 6;

            char c = data[i];
            if ((int) c >= BASE64_VALUES.length || BASE64_VALUES[(int) c] == -1)
                throw new IllegalArgumentException("Invalid character in decode stream");

            quantum |= BASE64_VALUES[(int) c];
        }

        //
        // hand the last byte(s) of data
        //
        int c = ((quantum >> 16) & 0xff);
        rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);

        if (rawndx < rawlen) {
            c = ((quantum >> 8) & 0xff);
            rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);
        }
        if (rawndx < rawlen) {
            c = quantum & 0xff;
            rawdata[rawndx++] = (byte) (c > 127 ? c - 256 : c);
        }

        //
        // return the raw data
        //
        return rawdata;
    }

