    /**
     * Indirectly verifies the cosmicClear, unclear and GC automations.
     */
    @Test
    public void canFlapAlarm() {
        // Alarms may not immediately clear/unclear due to the way to rules are structured
        // so we add some delay between the steps to make sure that they do
        long step = TimeUnit.MINUTES.toMillis(2);
        Scenario scenario = Scenario.builder()
                .withLegacyAlarmBehavior()
                .withTickLength(1, TimeUnit.MINUTES)
                .withNodeDownEvent(step, 1)
                .withNodeUpEvent(2*step, 1)
                .withNodeDownEvent(3*step, 1)
                .withNodeUpEvent(4*step, 1)
                .withNodeDownEvent(5*step, 1)
                .build();
        ScenarioResults results = scenario.play();

        // Verify the set of alarms at various points in time

        // t=0, no alarms
        assertThat(results.getAlarms(0), hasSize(0));
        // t=1, a single problem alarm
        assertThat(results.getAlarms(step), hasSize(1));
        assertThat(results.getProblemAlarm(step), hasSeverity(OnmsSeverity.MAJOR));
        assertThat(results.getProblemAlarm(step).getCounter(), equalTo(1));
        // t=2, a (cleared) problem and a resolution
        assertThat(results.getAlarms(2*step), hasSize(2));
        assertThat(results.getProblemAlarm(2*step), hasSeverity(OnmsSeverity.CLEARED));
        assertThat(results.getProblemAlarm(2*step).getCounter(), equalTo(1));
        assertThat(results.getResolutionAlarm(2*step), hasSeverity(OnmsSeverity.NORMAL));
        assertThat(results.getResolutionAlarm(2*step).getCounter(), equalTo(1));
        // t=3, a (re-armed) problem and a resolution
        assertThat(results.getAlarms(3*step), hasSize(2));
        assertThat(results.getProblemAlarm(3*step), hasSeverity(OnmsSeverity.MAJOR));
        assertThat(results.getProblemAlarm(3*step).getCounter(), equalTo(2));
        assertThat(results.getResolutionAlarm(3*step), hasSeverity(OnmsSeverity.NORMAL));
        assertThat(results.getResolutionAlarm(3*step).getCounter(), equalTo(1));
        // t=4, a (cleared) problem and a resolution
        assertThat(results.getAlarms(4*step), hasSize(2));
        assertThat(results.getProblemAlarm(4*step), hasSeverity(OnmsSeverity.CLEARED));
        assertThat(results.getProblemAlarm(4*step).getCounter(), equalTo(2));
        assertThat(results.getResolutionAlarm(4*step), hasSeverity(OnmsSeverity.NORMAL));
        // Allow the resolution to have a counter of 1 or 2 - the alarm may have been deleted
        assertThat(results.getResolutionAlarm(4*step).getCounter(), anyOf(equalTo(1), equalTo(2)));
        // t=5, a (re-armed) problem and a resolution
        assertThat(results.getAlarms(5*step), hasSize(2));
        assertThat(results.getProblemAlarm(5*step), hasSeverity(OnmsSeverity.MAJOR));
        assertThat(results.getProblemAlarm(5*step).getCounter(), equalTo(3));
        assertThat(results.getResolutionAlarm(5*step), hasSeverity(OnmsSeverity.NORMAL));
        // Allow the resolution to have a counter of 1 or 2 - the alarm may have been deleted
        assertThat(results.getResolutionAlarm(5*step).getCounter(), anyOf(equalTo(1), equalTo(2)));
        // t=âˆž
        assertThat(results.getAlarmsAtLastKnownTime(), hasSize(0));
    }

