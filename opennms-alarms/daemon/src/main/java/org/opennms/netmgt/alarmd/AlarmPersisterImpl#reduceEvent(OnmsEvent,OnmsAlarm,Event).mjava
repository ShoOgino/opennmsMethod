    private void reduceEvent(OnmsEvent persistedEvent, OnmsAlarm alarm, Event event) {
        // Always set these
        alarm.setLastEvent(persistedEvent);
        alarm.setLastEventTime(persistedEvent.getEventTime());
        
        if (!isResolutionEvent(event)) {
            incrementCounter(alarm);
            
            if (isResolvedAlarm(alarm)) {
                resetAlarmSeverity(persistedEvent, alarm);
            }
        } else {
            
            if (isResolvedAlarm(alarm)) {
                incrementCounter(alarm);
            } else {
                alarm.setSeverity(OnmsSeverity.CLEARED);
            }
        }
        alarm.setAlarmType(event.getAlarmData().getAlarmType());

        if (!event.getAlarmData().hasUpdateFields()) {

            //We always set these even if there are not update fields specified
            alarm.setLogMsg(persistedEvent.getEventLogMsg());
        } else {
            for (UpdateField field : event.getAlarmData().getUpdateFieldList()) {
                String fieldName = field.getFieldName();

                //Always set these, unless specified not to, in order to maintain current behavior
                if (fieldName.equalsIgnoreCase("LogMsg") && !field.isUpdateOnReduction()) {
                    continue;
                } else {
                    alarm.setLogMsg(persistedEvent.getEventLogMsg());
                }

                //Set these others
                if (field.isUpdateOnReduction()) {

                    if (fieldName.toLowerCase().startsWith("distpoller")) {
                        alarm.setDistPoller(persistedEvent.getDistPoller());
                    } else if (fieldName.toLowerCase().startsWith("ipaddr")) {
                        alarm.setIpAddr(persistedEvent.getIpAddr());
                    } else if (fieldName.toLowerCase().startsWith("mouseover")) {
                        alarm.setMouseOverText(persistedEvent.getEventMouseOverText());
                    } else if (fieldName.toLowerCase().startsWith("operinstruct")) {
                        alarm.setOperInstruct(persistedEvent.getEventOperInstruct());
                    } else if (fieldName.equalsIgnoreCase("severity")) {
                        resetAlarmSeverity(persistedEvent, alarm);
                    } else if (fieldName.toLowerCase().contains("descr")) {
                        alarm.setDescription(persistedEvent.getEventDescr());
                    } else if (fieldName.toLowerCase().startsWith("acktime")) {
                        final String expandedAckTime = m_eventUtil.expandParms(field.getValueExpression(), event);
                        if ("null".equalsIgnoreCase(expandedAckTime) && alarm.isAcknowledged()) {
                            alarm.unacknowledge("admin");
                        } else if ("".equals(expandedAckTime) || expandedAckTime.toLowerCase().startsWith("now")) { 
                            alarm.setAlarmAckTime(Calendar.getInstance().getTime());
                        } else if (expandedAckTime.matches("^\\d+$")) {
                            final long ackTimeLong;
                            try {
                                ackTimeLong = Long.valueOf(expandedAckTime);
                                // Heuristic: values < 2**31 * 1000 (10 Jan 2004) are probably whole seconds, otherwise milliseconds
                                if (ackTimeLong < 1073741824000L) {
                                    alarm.setAlarmAckTime(new java.util.Date(ackTimeLong * 1000));
                                } else {
                                    alarm.setAlarmAckTime(new java.util.Date(ackTimeLong));
                                }
                            } catch (NumberFormatException nfe) {
                                LOG.warn("Could not parse update-field 'acktime' value '{}' as a Long. Using current time instead.", expandedAckTime);
                                alarm.setAlarmAckTime(Calendar.getInstance().getTime());
                            }
                        } else if (expandedAckTime.toLowerCase().matches("^0x[0-9a-f]{22}$") || expandedAckTime.toLowerCase().matches("^0x[0-9a-f]{16}$")) {
                            alarm.setAlarmAckTime(m_eventUtil.decodeSnmpV2TcDateAndTime(new BigInteger(expandedAckTime.substring(2), 16)));
                        } else {
                            LOG.warn("Not sure what to do with update-field 'acktime' value '{}'. Using current time instead.", expandedAckTime);
                            alarm.setAlarmAckTime(Calendar.getInstance().getTime());
                        }
                    } else if (fieldName.toLowerCase().startsWith("ackuser")) {
                        final String expandedAckUser = m_eventUtil.expandParms(field.getValueExpression(), event);
                        if ("null".equalsIgnoreCase(expandedAckUser) || "".equals(expandedAckUser)) {
                            alarm.unacknowledge("admin");
                        } else {
                            alarm.setAlarmAckUser(expandedAckUser);
                        }
                    }
                } else {
                    LOG.warn("reduceEvent: The specified field: {}, is not supported.", fieldName);
                }
            }
        }

        Set<OnmsAlarm> relatedAlarms = getRelatedAlarms(event.getParmCollection());
        if (relatedAlarms != null && !relatedAlarms.isEmpty()) {
            // alarm.relatedAlarms becomes the union of any existing alarms and any in the event.
            for (OnmsAlarm related : relatedAlarms) {
                alarm.addRelatedAlarm(related);
            }
        }

        persistedEvent.setAlarm(alarm);
    }

