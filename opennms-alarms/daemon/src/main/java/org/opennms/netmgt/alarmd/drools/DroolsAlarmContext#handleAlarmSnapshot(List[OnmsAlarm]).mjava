    @Override
    public void handleAlarmSnapshot(List<OnmsAlarm> alarms) {
        if (!isStarted()) {
            LOG.debug("Ignoring alarm snapshot. Drools session is stopped.");
            return;
        }

        LOG.debug("Handling snapshot for {} alarms.", alarms.size());
        final Map<Integer, OnmsAlarm> alarmsInDbById = alarms.stream()
                .filter(a -> a.getId() != null)
                .collect(Collectors.toMap(OnmsAlarm::getId, a -> a));

        // Eagerly initialize the alarms
        for (OnmsAlarm alarm : alarms) {
            eagerlyInitializeAlarm(alarm);
        }

        // Retrieve the acks from the database for the set of the alarms we've been given
        final Map<Integer, OnmsAcknowledgment> acksByRefId = fetchAcks(alarms);

        // Track some stats
        final long numSituations = alarms.stream().filter(OnmsAlarm::isSituation).count();
        numAlarmsFromLastSnapshot.set(alarms.size() - numSituations);
        numSituationsFromLastSnapshot.set(numSituations);

        submitOrRun(kieSession -> {
            final Set<Integer> alarmIdsInDb = alarmsInDbById.keySet();
            final Set<Integer> alarmIdsInWorkingMem = alarmsById.keySet();

            final Set<Integer> alarmIdsToAdd = Sets.difference(alarmIdsInDb, alarmIdsInWorkingMem).stream()
                    // The snapshot contains an alarm which we don't have in working memory.
                    // It is possible that the alarm was in fact deleted some time after the
                    // snapshot was processed. We should only add it, if we did not explicitly
                    // delete the alarm after the snapshot was taken.
                    .filter(alarmId -> !stateTracker.wasAlarmWithIdDeleted(alarmId))
                    .collect(Collectors.toSet());
            final Set<Integer> alarmIdsToRemove = Sets.difference(alarmIdsInWorkingMem, alarmIdsInDb).stream()
                    // We have an alarm in working memory that is not contained in the snapshot.
                    // Only remove it from memory if the fact we have dates before the snapshot.
                    .filter(alarmId -> !stateTracker.wasAlarmWithIdUpdated(alarmId))
                    .collect(Collectors.toSet());
            final Set<Integer> alarmIdsToUpdate = Sets.intersection(alarmIdsInWorkingMem, alarmIdsInDb).stream()
                    // This stream contains the set of all alarms which are both in the snapshot
                    // and in working memory
                    .filter(alarmId -> {
                        final AlarmAndFact alarmAndFact = alarmsById.get(alarmId);
                        // Don't bother updating the alarm in memory if the fact we have is more recent than the snapshot
                        if (stateTracker.wasAlarmWithIdUpdated(alarmId)) {
                            return false;
                        }
                        final OnmsAlarm alarmInMem = alarmAndFact.getAlarm();
                        final OnmsAlarm alarmInDb = alarmsInDbById.get(alarmId);
                        // Only update the alarms if they are different
                        return shouldUpdateAlarmForSnapshot(alarmInMem, alarmInDb);
                    })
                    .collect(Collectors.toSet());

            // Log details that help explain what actions are being performed, if any
            if (LOG.isDebugEnabled()) {
                if (!alarmIdsToAdd.isEmpty() || !alarmIdsToRemove.isEmpty() || !alarmIdsToUpdate.isEmpty()) {
                    LOG.debug("Adding {} alarms, removing {} alarms and updating {} alarms for snapshot.",
                            alarmIdsToAdd.size(), alarmIdsToRemove.size(), alarmIdsToUpdate.size());
                } else {
                    LOG.debug("No actions to perform for alarm snapshot.");
                }
                // When TRACE is enabled, include diagnostic information to help explain why
                // the alarms are being updated
                if (LOG.isTraceEnabled()) {
                    for (Integer alarmIdToUpdate : alarmIdsToUpdate) {
                        LOG.trace("Updating alarm with id={}. Alarm from DB: {} vs Alarm from memory: {}",
                                alarmIdToUpdate,
                                alarmsInDbById.get(alarmIdToUpdate),
                                alarmsById.get(alarmIdToUpdate));
                    }
                }
            }

            for (Integer alarmIdToRemove : alarmIdsToRemove) {
                handleDeletedAlarmForAtomic(kieSession, alarmIdToRemove, alarmsById.get(alarmIdToRemove).getAlarm().getReductionKey());
            }

            final Set<OnmsAlarm> alarmsToUpdate = Sets.union(alarmIdsToAdd, alarmIdsToUpdate).stream()
                    .map(alarmsInDbById::get)
                    .collect(Collectors.toSet());
            for (OnmsAlarm alarm : alarmsToUpdate) {
                handleNewOrUpdatedAlarmForAtomic(kieSession, alarm, acksByRefId.get(alarm.getId()));
            }

            stateTracker.resetStateAndStopTrackingAlarms();
            LOG.debug("Done handling snapshot.");
        });
    }

