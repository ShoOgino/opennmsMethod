    private void startWithModuleAndFacts(ReleaseId releaseId, List<Object> factObjects) {
        final KieServices ks = KieServices.Factory.get();
        kieContainer = ks.newKieContainer(releaseId);
        kieSession = kieContainer.newKieSession(kSessionName);
        // When usePseudoClock is set, the clock is expected to be driven manually and we start at 0
        // instead of the actual current time
        final long now =  usePseudoClock ? 0L : System.currentTimeMillis();
        // Create and add our clock to the session
        this.clock = new SessionClock(kieSession, now);

        // Optionally restore any facts
        factObjects.forEach(factObject -> kieSession.insert(factObject));

        if (onNewKiewSessionCallback != null) {
            onNewKiewSessionCallback.accept(kieSession);
        }

        // Save the releaseId
        releaseIdForContainerUsedByKieSession = releaseId;

        // We're started!
        started.set(true);

        // Schedule the clock updates
        clockUpdateTimer = new java.util.Timer();
        clockUpdateTimer.schedule(new TimerTask() {
           @Override
           public void run() {
               try {
                   if (clock != null) {
                       clock.advanceTimeToNow();
                   }
               } catch (Exception e) {
                   // Should never happen, but just in case...
                   LOG.error("Exception occurred while advancing session clock.", e);
               }
           }
       }, CLOCK_UPDATE_INTERVAL_MS, CLOCK_UPDATE_INTERVAL_MS);

        // Schedule the liveness check
        livenessTimer = new java.util.Timer();
        livenessTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                try {
                    if (kieSession != null) {
                        final Timer.Context ctx = livenessTimerMetric.time();
                        final CountDownLatch latch = new CountDownLatch(1);
                        kieSession.submit(kieSession -> {
                            latch.countDown();
                            ctx.close();
                        });
                        latch.await();
                    }
                } catch (Exception e) {
                    LOG.error("Exception occurred while performing liveness check.", e);
                }
            }
        }, LIVENESS_CHECK_INTERVAL_MS, LIVENESS_CHECK_INTERVAL_MS);

        // Allow the base classes to seed the context before we start ticking
        onStart();

        if (!useManualTick) {
            thread = new Thread(() -> {
                fireThreadId.set(Thread.currentThread().getId());
                while (started.get()) {
                    try {
                        LOG.debug("Firing until halt.");
                        kieSession.fireUntilHalt();
                    } catch (Exception e) {
                        // If we're supposed to be stopped, ignore the exception
                        if (!started.get()) {
                            LOG.error("Error occurred while firing rules. Waiting 30 seconds before starting to fire again.", e);
                            try {
                                Thread.sleep(TimeUnit.SECONDS.toMillis(30));
                            } catch (InterruptedException ex) {
                                LOG.warn("Interrupted while waiting to start firing rules again. Exiting thread.");
                                return;
                            }
                        } else {
                            LOG.info("Encountered exception while firing rules, but the engine is stopped. Exiting thread.");
                            return;
                        }
                    }
                }
            });
            thread.setName("DroolsSession-" + kSessionName);
            thread.start();
        }
    }

