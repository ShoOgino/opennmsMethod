    @Override
    public void handleAlarmSnapshot(List<OnmsAlarm> alarms, long systemMillisBeforeSnapshot) {
        if (!isStarted()) {
            LOG.debug("Ignoring alarm snapshot. Drools session is stopped.");
            return;
        }

        // Lock while handling the snapshot and unlock in the callback to {@link #postHandleAlarmSnapshot}
        // This prevents the rules from firing immediately after the snapshot was processed, but
        // before the session & transaction were closed, which can cause Hibernate related exceptions.
        getLock().lock();
        LOG.debug("Handling snapshot for {} alarms.", alarms.size());
        final Map<Integer, OnmsAlarm> alarmsInDbById = alarms.stream()
                .filter(a -> a.getId() != null)
                .collect(Collectors.toMap(OnmsAlarm::getId, a -> a));

        final Set<Integer> alarmIdsInDb = alarmsInDbById.keySet();
        final Set<Integer> alarmIdsInWorkingMem = alarmsById.keySet();

        // Remove deleted alarm entries that happened before the snapshot
        stateTracker.expireEntriesBefore(systemMillisBeforeSnapshot);

        final Set<Integer> alarmIdsToAdd = Sets.difference(alarmIdsInDb, alarmIdsInWorkingMem).stream()
                // The snapshot contains an alarm which we don't have in working memory.
                // It is possible that the alarm was in fact deleted some time after the
                // snapshot was processed. We should only add it, if we did not explicitly
                // delete the alarm after the snapshot was taken.
                .filter(alarmId -> !stateTracker.wasAlarmWithIdDeletedOnOrAfter(alarmId, systemMillisBeforeSnapshot))
                .collect(Collectors.toSet());
        final Set<Integer> alarmIdsToRemove = Sets.difference(alarmIdsInWorkingMem, alarmIdsInDb).stream()
                // We have an alarm in working memory that is not contained in the snapshot.
                // Only remove it from memory if the fact we have dates before the snapshot.
                .filter(alarmId -> !stateTracker.wasAlarmWithIdUpdatedOnOrAfter(alarmId, systemMillisBeforeSnapshot))
                .collect(Collectors.toSet());
        final Set<Integer> alarmIdsToUpdate = Sets.intersection(alarmIdsInWorkingMem, alarmIdsInDb).stream()
                // This stream contains the set of all alarms which are both in the snapshot
                // and in working memory
                .filter(alarmId -> {
                    final AlarmAndFact alarmAndFact = alarmsById.get(alarmId);
                    // Don't bother updating the alarm in memory if the fact we have is more recent than the snapshot
                    if (stateTracker.wasAlarmWithIdUpdatedOnOrAfter(alarmId, systemMillisBeforeSnapshot)) {
                        return false;
                    }
                    final OnmsAlarm alarmInMem = alarmAndFact.getAlarm();
                    final OnmsAlarm alarmInDb = alarmsInDbById.get(alarmId);
                    // Only update the alarms if they are different
                    return shouldUpdateAlarmForSnapshot(alarmInMem, alarmInDb);
                })
                .collect(Collectors.toSet());

        // Log details that help explain what actions are being performed, if any
        if (LOG.isDebugEnabled()) {
            if (!alarmIdsToAdd.isEmpty() || !alarmIdsToRemove.isEmpty() || !alarmIdsToUpdate.isEmpty()) {
                LOG.debug("Adding {} alarms, removing {} alarms and updating {} alarms for snapshot.",
                        alarmIdsToAdd.size(), alarmIdsToRemove.size(), alarmIdsToUpdate.size());
            } else {
                LOG.debug("No actions to perform for alarm snapshot.");
            }
            // When TRACE is enabled, include diagnostic information to help explain why
            // the alarms are being updated
            if (LOG.isTraceEnabled()) {
                for (Integer alarmIdToUpdate : alarmIdsToUpdate) {
                    LOG.trace("Updating alarm with id={}. Alarm from DB: {} vs Alarm from memory: {}",
                            alarmIdToUpdate,
                            alarmsInDbById.get(alarmIdToUpdate),
                            alarmsById.get(alarmIdToUpdate));
                }
            }
        }

        for (Integer alarmIdToRemove : alarmIdsToRemove) {
            handleDeletedAlarmNoLock(alarmIdToRemove, alarmsById.get(alarmIdToRemove).getAlarm().getReductionKey());
        }
        for (Integer alarmIdToAdd : alarmIdsToAdd) {
            handleNewOrUpdatedAlarmNoLock(alarmsInDbById.get(alarmIdToAdd));
        }
        for (Integer alarmIdToUpdate : alarmIdsToUpdate) {
            handleNewOrUpdatedAlarmNoLock(alarmsInDbById.get(alarmIdToUpdate));
        }

        LOG.debug("Done handling snapshot.");
    }

