    private OnmsAlarm addOrReduceEventAsAlarm(Event event) throws IllegalStateException {
        
        final OnmsEvent persistedEvent = m_eventDao.get(event.getDbid());
        if (persistedEvent == null) {
            throw new IllegalStateException("Event with id " + event.getDbid() + " was deleted before we could retrieve it and create an alarm.");
        }

        final String reductionKey = event.getAlarmData().getReductionKey();
        LOG.debug("addOrReduceEventAsAlarm: looking for existing reduction key: {}", reductionKey);
        
        String key = reductionKey;
        String clearKey = event.getAlarmData().getClearKey();
        
        boolean didSwapReductionKeyWithClearKey = false;
        if (!m_legacyAlarmState && clearKey != null && isResolutionEvent(event)) {
            key = clearKey;
            didSwapReductionKeyWithClearKey = true;
        }

        OnmsAlarm alarm = m_alarmDao.findByReductionKey(key);

        if (alarm == null && didSwapReductionKeyWithClearKey) {
            // if the clearKey returns null, still need to check the reductionKey
            alarm = m_alarmDao.findByReductionKey(reductionKey);
        }

        if (alarm == null || (m_createNewAlarmIfClearedAlarmExists && OnmsSeverity.CLEARED.equals(alarm.getSeverity()))) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("addOrReduceEventAsAlarm: reductionKey:{} not found, instantiating new alarm", reductionKey);
            }

            if (alarm != null) {
                LOG.debug("addOrReduceEventAsAlarm: \"archiving\" cleared Alarm for problem: {}; " +
                        "A new alarm will be instantiated to manage the problem.", reductionKey);
                alarm.archive();
                m_alarmDao.save(alarm);
                m_alarmDao.flush();

                m_alarmEntityNotifier.didArchiveAlarm(alarm, reductionKey);
            }

            alarm = createNewAlarm(persistedEvent, event);

            // Trigger extensions, allowing them to mangle the alarm
            try {
                final OnmsAlarm alarmCreated = alarm;
                extensions.forEach(ext -> ext.afterAlarmCreated(alarmCreated, event, persistedEvent));
            } catch (Exception ex) {
                LOG.error("An error occurred while invoking the extension callbacks.", ex);
            }

            m_alarmDao.save(alarm);
            m_eventDao.saveOrUpdate(persistedEvent);

            m_alarmEntityNotifier.didCreateAlarm(alarm);
        } else {
            LOG.debug("addOrReduceEventAsAlarm: reductionKey:{} found, reducing event to existing alarm: {}", reductionKey, alarm.getId());
            reduceEvent(persistedEvent, alarm, event);

            // Trigger extensions, allowing them to mangle the alarm
            try {
                final OnmsAlarm alarmUpdated = alarm;
                extensions.forEach(ext -> ext.afterAlarmUpdated(alarmUpdated, event, persistedEvent));
            } catch (Exception ex) {
                LOG.error("An error occurred while invoking the extension callbacks.", ex);
            }

            m_alarmDao.update(alarm);
            m_eventDao.update(persistedEvent);

            if (event.getAlarmData().isAutoClean()) {
                m_eventDao.deletePreviousEventsForAlarm(alarm.getId(), persistedEvent);
            }

            m_alarmEntityNotifier.didUpdateAlarmWithReducedEvent(alarm);
        }
        return alarm;
    }

