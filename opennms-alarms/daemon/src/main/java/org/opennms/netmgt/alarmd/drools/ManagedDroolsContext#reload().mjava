    public synchronized void reload() {
        if (!started.get()) {
            LOG.warn("The context for session {} is not yet started. Treating reload as a start request", kSessionName);
            start();
            return;
        }

        // Attempt to build and deploy the ruleset
        // If this fails, we'll throw an exception and abort the reload
        final ReleaseId releaseId = buildKieModule();

        // The rules we're successfully built and deployed

        // Let's halt the current engine
        started.set(false);
        if (!useManualTick) {
            kieSession.halt();
            try {
                thread.join(TimeUnit.MINUTES.toMillis(2));
            } catch (InterruptedException e) {
                LOG.warn("Interrupted while waiting for session to halt. Aborting reload request.");
                return;
            }

            // The thread should be stopped, but we don't know for sure
            // Let's me a best effort to stop it before we proceed and start another one
            if (thread.isAlive()) {
                LOG.warn("Thread is still alive! Interrupting.");
                thread.interrupt();
            }
        }

        // Grab the facts
        final List<Object> factObjects = kieSession.getFactHandles().stream()
                .map(kieSession::getObject)
                .filter(o -> !(o instanceof SessionClock)) // Exclude the fact for our SessionClock
                .collect(Collectors.toList());

        // Dispose the session
        kieSession.dispose();

        // Remove the previous module
        if (releaseIdForContainerUsedByKieSession != null) {
            if (KieServices.Factory.get().getRepository().removeKieModule(releaseIdForContainerUsedByKieSession) != null) {
                LOG.info("Successfully removed previous KIE module with ID: {}.", releaseIdForContainerUsedByKieSession);
            } else {
                LOG.info("Previous KIE module was with ID: {} was already removed.", releaseIdForContainerUsedByKieSession);
            }
            releaseIdForContainerUsedByKieSession = null;
        }

        // Restart the engine
        startWithModuleAndFacts(releaseId, factObjects);
    }

