    protected void doSnapshot() {
        if (listeners.size() < 1) {
            return;
        }

        final AtomicLong numAlarms = new AtomicLong(-1);
        final long systemMillisBeforeSnasphot = System.currentTimeMillis();
        final AtomicLong systemMillisAfterLoad = new AtomicLong(-1);
        try {
            forEachListener(AlarmLifecycleListener::preHandleAlarmSnapshot);
            template.execute(new TransactionCallbackWithoutResult() {
                @Override
                protected void doInTransactionWithoutResult(TransactionStatus status) {
                    final List<OnmsAlarm> allAlarms = alarmDao.findAll();
                    numAlarms.set(allAlarms.size());
                    // Save the timestamp after the load, so we can differentiate between how long it took
                    // to load the alarms and how long it took to invoke the callbacks
                    systemMillisAfterLoad.set(System.currentTimeMillis());
                    forEachListener(l -> {
                        LOG.debug("Calling handleAlarmSnapshot on listener: {}", l);
                        l.handleAlarmSnapshot(allAlarms);
                        LOG.debug("Done calling listener.");
                    });
                }
            });
        } finally {
            if (LOG.isDebugEnabled()) {
                final long now = System.currentTimeMillis();
                LOG.debug("Alarm snapshot for {} alarms completed. Spent {}ms loading the alarms. " +
                                "Snapshot processing took a total of of {}ms.",
                        numAlarms.get(),
                        systemMillisAfterLoad.get() - systemMillisBeforeSnasphot,
                        now - systemMillisBeforeSnasphot);
            }
            forEachListener(AlarmLifecycleListener::postHandleAlarmSnapshot);
        }
    }

