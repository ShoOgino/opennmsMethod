    private void tryWithLock(int alarmId, String reductionKey, BiConsumer<Integer, String> callback, String action) {
        try {
            // It is possible that the session is currently locked while waiting for the
            // transaction that this thread is holding to be committed, so we limit the time
            // we spend waiting for the lock in order to avoid deadlocks.
            // If we were not able to successfully acquire the lock, then log a warning.
            // The alarm snapshot handling will ensure that the state of the context is eventually consistent.
            if (getLock().tryLock(LOCK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                try {
                    callback.accept(alarmId, reductionKey);
                } finally {
                    getLock().unlock();
                }
            } else {
                LOG.warn("Failed to acquire Drools session lock within {}ms. " +
                                "{} for alarm with id={} and reduction-key={} will not be immediately reflected in the context.",
                        LOCK_TIMEOUT_MS, action, alarmId, reductionKey);
            }
        } catch (InterruptedException e) {
            LOG.warn("Interrupted while waiting for Drools session lock. " +
                            "{} for alarm with id={} and reduction-key={} will not be immediately reflected in the context.",
                   action, alarmId, reductionKey);
            // Propagate the interrupt
            Thread.currentThread().interrupt();
        }
    }

