    /** {@inheritDoc} 
     * @return */
    @Override
    public OnmsAlarm persist(Event event) {
        if (!checkEventSanityAndDoWeProcess(event)) {
            return null;
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("process: {}; nodeid: {}; ipaddr: {}; serviceid: {}", event.getUei(), event.getNodeid(), event.getInterface(), event.getService());
        }

        // Lock both the reduction and clear keys (if set) using a fair striped lock
        // We do this to ensure that clears and triggers are processed in the same order
        // as the calls are made
        final Iterable<Lock> locks = lockStripes.bulkGet(getLockKeys(event));
        final OnmsAlarmAndLifecycleEvent alarmAndEvent;
        try {
            locks.forEach(Lock::lock);
            // Process the alarm inside a transaction
            alarmAndEvent = m_transactionOperations.execute((action) -> addOrReduceEventAsAlarm(event));
        } finally {
            locks.forEach(Lock::unlock);
        }

        // Send the event outside of the database transaction
        m_eventForwarder.sendNow(alarmAndEvent.getEvent());

        return alarmAndEvent.getAlarm();
    }

