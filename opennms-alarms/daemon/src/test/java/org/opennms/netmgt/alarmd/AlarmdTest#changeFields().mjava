    @Test
    @JUnitTemporaryDatabase(tempDbClass=MockDatabase.class)
    public void changeFields() throws InterruptedException, SQLException {
        assertEquals(0, m_jdbcTemplate.queryForInt("select count(*) from alarms"));
        
        String reductionKey = "testUpdateField";
        
        int alarmCount = m_jdbcTemplate.queryForInt("select count(*) from alarms");
        
        assertEquals(0, alarmCount);
        
        MockNode node1 = m_mockNetwork.getNode(1);
        
        //Verify we have the default alarm
        sendNodeDownEvent(reductionKey, node1);
        int severity = m_jdbcTemplate.queryForInt("select severity from alarms a where a.reductionKey = ?", reductionKey);
        assertEquals(OnmsSeverity.MAJOR, OnmsSeverity.get(severity));
        
        //Store the original logmsg from the original alarm (we are about to test changing it with subsequent alarm reduction)
        String defaultLogMsg = m_jdbcTemplate.query("select logmsg from alarms", new ResultSetExtractor<String>() {

            @Override
            public String extractData(ResultSet results) throws SQLException, DataAccessException {
                results.next();
                int row = results.getRow();
                boolean isLast = results.isLast();
                boolean isFirst = results.isFirst();
                
                if (row != 1 && !isLast && !isFirst) {
                    throw new SQLException("Row count is not = 1.  There should only be one row returned from the query: \n"+ results.getStatement());
                }
                
                return results.getString(1);
            }
            
        });
        
        assertTrue("The logmsg column should not be null", defaultLogMsg != null);

        //Duplicate the alarm but change the severity and verify the change
        sendNodeDownEventWithUpdateFieldSeverity(reductionKey, node1, OnmsSeverity.CRITICAL);
        severity = m_jdbcTemplate.queryForInt("select severity from alarms");
        assertEquals("Severity should now be Critical", OnmsSeverity.CRITICAL, OnmsSeverity.get(severity));
        
        //Duplicate the alarm but don't force the change of severity
        sendNodeDownEvent(reductionKey, node1);
        severity = m_jdbcTemplate.queryForInt("select severity from alarms");
        assertEquals("Severity should still be Critical", OnmsSeverity.CRITICAL, OnmsSeverity.get(severity));

        //Duplicate the alarm and change the logmsg
        sendNodeDownEventChangeLogMsg(reductionKey, node1, "new logMsg");
        String newLogMsg = m_jdbcTemplate.query("select logmsg from alarms", new ResultSetExtractor<String>() {
            @Override
            public String extractData(ResultSet results) throws SQLException, DataAccessException {
                results.next();
                return results.getString(1);
            }
        });
        assertEquals("new logMsg", newLogMsg);
        assertTrue(!newLogMsg.equals(defaultLogMsg));
        
        //Duplicate the alarm but force logmsg to not change (lggmsg field is updated by default)
        sendNodeDownEventDontChangeLogMsg(reductionKey, node1, "newer logMsg");
        newLogMsg = m_jdbcTemplate.query("select logmsg from alarms", new ResultSetExtractor<String>() {
            @Override
            public String extractData(ResultSet results) throws SQLException, DataAccessException {
                results.next();
                return results.getString(1);
            }
        });
        assertTrue("The logMsg should not have changed.", !"newer logMsg".equals(newLogMsg));
        assertEquals("The logMsg should still be equal to the previous update.", "new logMsg", newLogMsg);

        
        //Duplicate the alarm with the default configuration and verify the logmsg has changed (as is the default behavior
        //for this field)
        sendNodeDownEvent(reductionKey, node1);
        newLogMsg = m_jdbcTemplate.query("select logmsg from alarms", new ResultSetExtractor<String>() {
            @Override
            public String extractData(ResultSet results) throws SQLException, DataAccessException {
                results.next();
                return results.getString(1);
            }
        });
        assertTrue("The logMsg should have changed.", !"new logMsg".equals(newLogMsg));
        assertEquals("The logMsg should new be the default logMsg.", newLogMsg, defaultLogMsg);
        
    }

