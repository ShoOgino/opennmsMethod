    @Test
    public void canDriveScenario() {
        if (scenario.getActions().size() == 0) {
            return;
        }

        final Map<Long,List<Action>> actionsByTick = scenario.getActions().stream()
                .collect(Collectors.groupingBy(a -> roundToTick(a.getTime())));

        final long start = Math.max(scenario.getActions().stream()
                .min(Comparator.comparing(Action::getTime))
                .map(e -> roundToTick(e.getTime()))
                .get() - tickLength, 0);
        final long end = scenario.getActions().stream()
                .max(Comparator.comparing(Action::getTime))
                .map(e -> roundToTick(e.getTime()))
                .get() + tickLength;

        if (start > 0) {
            // Tick
            m_droolsAlarmContext.getClock().advanceTime(tickLength, TimeUnit.MILLISECONDS);
            m_droolsAlarmContext.tick();
        }

        for (long now = start; now <= end; now += tickLength) {
            // Perform the actions
            final List<Action> actions = actionsByTick.get(now);
            if (actions != null) {
                for (Action  a : actions) {
                    a.visit(this);
                }
            }

            // Tick
            m_droolsAlarmContext.getClock().advanceTime(tickLength, TimeUnit.MILLISECONDS);
            m_droolsAlarmContext.tick();

            results.addAlarms(now, m_alarmDao.findAll());
        }

        // Tick every 5 minutes for the next 24 hours
        tickAtRateUntil(TimeUnit.MINUTES.toMillis(5),
                end,
                end + TimeUnit.DAYS.toMillis(1));

        // Tick every hour for the next week
        tickAtRateUntil(TimeUnit.HOURS.toMillis(1),
                end + TimeUnit.DAYS.toMillis(1),
                end + TimeUnit.DAYS.toMillis(8));
    }

