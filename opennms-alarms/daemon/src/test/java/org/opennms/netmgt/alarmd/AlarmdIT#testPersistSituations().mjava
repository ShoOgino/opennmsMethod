    @Test
    @Transactional
    public void testPersistSituations() throws Exception {
        final MockNode node = m_mockNetwork.getNode(1);

        //there should be no alarms in the alarms table
        assertEmptyAlarmTable();

        //there should be no alarms in the alarm_situations table
        assertEmptyAlarmSituationTable();

        //create 3 alarms to roll up into situation
        sendNodeDownEvent("Alarm1", node);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        assertEquals(1, m_alarmDao.findAll().size());

        sendNodeDownEvent("Alarm2", node);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        assertEquals(2, m_alarmDao.findAll().size());

        sendNodeDownEvent("Alarm3", node);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        assertEquals(3, m_alarmDao.findAll().size());

        //create situation rolling up the first 2 alarms
        List<String> reductionKeys = new ArrayList<>(Arrays.asList("Alarm1", "Alarm2"));
        sendSituationEvent("Situation1", node, reductionKeys);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        OnmsAlarm situation = m_alarmDao.findByReductionKey("Situation1");
        assertEquals(2, situation.getRelatedAlarms().size());

        //capture the current association time of the related alarms
        Map<Integer, Date> associationTimesByRelatedAlarmId = situation.getAssociatedAlarms().stream()
                .collect(Collectors.toMap(assoc -> assoc.getRelatedAlarm().getId(), AlarmAssociation::getMappedTime));

        //now trigger the same situation again
        sendSituationEvent("Situation1", node, reductionKeys);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        situation = m_alarmDao.findByReductionKey("Situation1");
        assertEquals(2, situation.getRelatedAlarms().size());

        //the association times should not have changed - gather them again and compare
        Map<Integer, Date> afterReduceAssociationTimesByRelatedAlarmId = situation.getAssociatedAlarms().stream()
                .collect(Collectors.toMap(assoc -> assoc.getRelatedAlarm().getId(), AlarmAssociation::getMappedTime));
        //make sure the two maps match
        assertThat(associationTimesByRelatedAlarmId.entrySet(), everyItem(isIn(afterReduceAssociationTimesByRelatedAlarmId.entrySet())));
        assertThat(afterReduceAssociationTimesByRelatedAlarmId.entrySet(), everyItem(isIn(associationTimesByRelatedAlarmId.entrySet())));

        //send situation in with 3rd alarm, should result in 1 situation with 1 alarm since the situation's related
        //alarms will be overwritten with this new related alarm
        List<String> newReductionKeys = new ArrayList<>(Arrays.asList("Alarm3"));
        sendSituationEvent("Situation1", node, newReductionKeys);
        await().atMost(1, SECONDS).until(allAnticipatedEventsWereReceived());
        situation = m_alarmDao.findByReductionKey("Situation1");
        assertEquals(1, situation.getRelatedAlarms().size());
    }

