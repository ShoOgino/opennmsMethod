    /**
     * This is an attempt at testing scheduled automations.
     * @throws InterruptedException
     */
    @Test(timeout=90000)
    @JUnitTemporaryDatabase(dirtiesContext=true,tempDbClass=MockDatabase.class)
    @Ignore // TODO Figure out how to make this test more reliable before enabling it
    public final void testConcurrency() throws InterruptedException {
        try {
        /*
         * Test status of threads
         */
        assertEquals(Fiber.START_PENDING, m_vacuumd.getStatus());
        assertEquals(Fiber.START_PENDING, m_vacuumd.getScheduler().getStatus());
        
        /*
         * Testing the start
         */
        m_vacuumd.start();
        assertTrue(m_vacuumd.getStatus() >= 1);
        while(m_vacuumd.getScheduler().getStatus() != PausableFiber.RUNNING) {
            Thread.sleep(20);
        }
        assertEquals(Fiber.RUNNING, m_vacuumd.getStatus());
        assertEquals(Fiber.RUNNING, m_vacuumd.getScheduler().getStatus());
        
        /*
         * Testing the pause
         */
        m_vacuumd.pause();
        while(m_vacuumd.getScheduler().getStatus() != PausableFiber.PAUSED) {
            Thread.sleep(20);
        }
        assertEquals(PausableFiber.PAUSED, m_vacuumd.getStatus());
        assertEquals(PausableFiber.PAUSED, m_vacuumd.getScheduler().getStatus());

        m_vacuumd.resume();
        while(m_vacuumd.getScheduler().getStatus() != PausableFiber.RUNNING) {
            Thread.sleep(20);
        }
        assertEquals(PausableFiber.RUNNING, m_vacuumd.getStatus());
        assertEquals(PausableFiber.RUNNING, m_vacuumd.getScheduler().getStatus());
        
        // Get an alarm in the DB
        bringNodeDownCreatingEvent(1);

        // There should be one node down alarm
        while(countAlarms() < 1) {
            Thread.sleep(20);
        }
        assertEquals("count of nodeDown events", 1, (int)m_jdbcTemplate.queryForObject("select count(*) from events where eventuei = '" + EventConstants.NODE_DOWN_EVENT_UEI + "'", Integer.class));
        assertEquals("alarm count", 1, countAlarms());
        assertEquals("counter in the alarm", 1, (int)m_jdbcTemplate.queryForObject("select counter from alarms where eventuei = '" + EventConstants.NODE_DOWN_EVENT_UEI + "'", Integer.class));
        // Fetch the initial severity of the alarm
        int currentSeverity = m_jdbcTemplate.queryForObject("select severity from alarms", Integer.class);
        assertEquals(OnmsSeverity.MAJOR.getId(), currentSeverity);

        // Create another node down event
        bringNodeDownCreatingEvent(1);
        while( m_jdbcTemplate.queryForObject("select counter from alarms", Integer.class) < 2) {
            Thread.sleep(20);
        }
        assertEquals("count of nodeDown events", 2, (int)m_jdbcTemplate.queryForObject("select count(*) from events where eventuei = '" + EventConstants.NODE_DOWN_EVENT_UEI + "'", Integer.class));
        // Make sure there's still one alarm...
        assertEquals("alarm count", 1, countAlarms());
        // ... with a counter value of 2
        assertEquals("counter in the alarm", 2, (int)m_jdbcTemplate.queryForObject("select counter from alarms", Integer.class));

        // Sleep long enough for the escalation automation to run, then check that it was escalated
        while(verifyAlarmEscalated() < (currentSeverity + 1)) {
            Thread.sleep(1000);
        }
        assertEquals("alarm severity wrong, should have been escalated", currentSeverity+1, verifyAlarmEscalated());
        } catch (Throwable e) {
            e.printStackTrace();
            fail("Unexpected exception caught: " + e.getMessage());
        } finally {
        // Stop what you start
        m_vacuumd.stop();
        }
    }

