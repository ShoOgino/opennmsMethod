	/**
	 * Run method loops until kill() called.
	 * It wakes up if sendAlarmList() is called and updates the alarmlist
	 * It wakes up if updateNodeCache() is called and updates the node list
	 * init() must be called before the run() method.
	 *
	 * @throws java.lang.IllegalStateException if any.
	 */
	public void run() throws IllegalStateException 	{
		ThreadCategory log = getLog();	
		//instance=this;
		boolean localupdateNCache=false;
		boolean localsendList=false;

		// if the init variable is false then the thread has not been initialised
		if(!init)
			throw new IllegalStateException("OpenNMSEventHandlerThread.run() - You must call init() before calling run()");

		while (runThread){
			synchronized(this) { 
				try{
					// test to see if there have been more requests to update the list while updating the list
					if ((sendList==false)&&(updateNCache==false)){
						if (log.isDebugEnabled()) log.debug("OpenNMSEventHandlerThread.run() thread waiting for interrupt");
						wait(); 
					}
				} catch ( InterruptedException e){
					if (log.isDebugEnabled()) log.debug("OpenNMSEventHandlerThread.run() thread woken up");
				}
				localupdateNCache=updateNCache;
				localsendList=sendList;
				updateNCache=false;
				sendList=false;
			}
			if (localupdateNCache) try {
				if (log.isDebugEnabled()) log.debug("OpenNMSEventHandlerThread.run() updating node list");
				ossDao.updateNodeCaches();
			} catch (Exception ex) {
				log.error("OpenNMSEventHandlerThread.run() Exception caught in ossDao.updateNodeCaches():", ex);
			}
			if (localsendList) try{
				if (log.isDebugEnabled()) log.debug("OpenNMSEventHandlerThread.run() updating and sending alarm list");
				ossDao.updateAlarmCacheAndSendAlarms();
			}
			catch (Exception ex) {
				log.error("OpenNMSEventHandlerThread.run() Exception caught in ossDao.updateAlarmCacheAndSendAlarms():", ex);
			}

		}
		if (log.isDebugEnabled()) log.debug("OpenNMSEventHandlerThread.run() STOPPED");

	}

