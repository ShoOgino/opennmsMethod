	/**
	 * {@inheritDoc}
	 *
	 * The OpenNMS event listener runs this routine when a
	 * new event is detected. This can be run on any event but only needs to run on
	 * uei.opennms.org/vacuumd/alarmListChanged
	 */
	public void onEvent(Event event) {

		ThreadCategory log = getLog();
		if (log.isDebugEnabled()) log.debug("Qosd.onEvent: OpenNMS Event Detected by QosD. uei '"+ event.getUei()+"' Dbid(): "+event.getDbid()+"  event.getTime(): " + event.getTime());

		String s = event.getUei();
		if (s==null) return;

		if (    "uei.opennms.org/nodes/nodeAdded".equals(s) ||
				"uei.opennms.org/nodes/nodeLabelChanged".equals(s) ||
				"uei.opennms.org/nodes/nodeDeleted".equals(s) ||
				"uei.opennms.org/nodes/assetInfoChanged".equals(s) ) {
			try {
				if (log.isDebugEnabled()) log.debug("QosD.onEvent Event causing update to node list");
				openNMSEventHandlerThread.updateNodeCache();
				return;
			} catch ( Exception ex){
				log.error("Qosd.onEvent. Problem calling openNMSEventHandlerThread.updateNodeCache(). Error:"+ ex);
				return;
			}
		} 

		if (event.getUei().equals("uei.opennms.org/vacuumd/alarmListChanged")) {
			if (log.isDebugEnabled()) log.debug("QosD.onEvent received 'uei.opennms.org/vacuumd/alarmListChanged' event; Updating alarm list");
		} else { 
			// used code from AlarmWriter.java Check value of <logmsg> attribute 'dest', if set to
			// "donotpersist" then simply return, the uei is not to be persisted to the database		
			// The uei.opennms.org/vacuumd/alarmListChanged event must be set to be reised
			// as auto-action from vacumd-configuration.xml and is called
			// when vacumd updates the current ( alarm not acknowledgd and cleared ) alarm list
			// note alarmListChanged event may be marked as 'donotpersist' so checked first
			try {
				// this section prints out events received which are not uei.opennms.org/vacuumd/alarmListChanged
				// return if a donotpersist event
				if (event.getLogmsg().getDest().equals("donotpersist")) {
					if (log.isDebugEnabled()) log.debug("QosD.onEvent Ignoring event marked as 'doNotPersist'. Event Uei:"+event.getUei());
					return;
				}				
				// AlarmData should not be null if QoSD-configuration.xml is set up only to receive raise 
				// and not clearing alarms
				if (event.getAlarmData().getAlarmType() == 2){
					if (log.isDebugEnabled()) log.debug("Qosd.onEvent: uei '"+ event.getUei()+"' Dbid(): "+event.getDbid()+" alarm type = 2 (clearing alarm) so ignoring.");
					return; 
				}
			} catch (NullPointerException e) {
				log.error("Qosd.onEvent: uei '" + event.getUei() +"' Dbid(): "+event.getDbid()+"' problem dealing with event. Check QoSD-configuration.xml.");
				return;
			} 
		}

		// This forces the ossDao to update it's list on this event and call back to sendAlarms() to send the
		// updated alarm list.
		try {
			if (log.isDebugEnabled()) log.debug("QosD.onEvent calling openNMSEventHandlerThread.sendAlarmList() to update list.");
			//ossDao.updateAlarmCacheAndSendAlarms();
			openNMSEventHandlerThread.sendAlarmList();
		} catch ( Exception ex){
			log.error("Qosd.onEvent. Problem calling openNMSEventHandlerThread.sendAlarmList(). Error:"+ ex);
		}
	}

