    /**
     * Get the operations for the next file that should be worked on.
     * 
     * @return a linkedList of oeprations to be processed all for the same file.
     */
    public LinkedList getNext() {
        LinkedList ops = null;
        synchronized (this) {

            // turn in our previous assignment
            completeAssignment();

            String newAssignment;
            // wait until there is work to do
            while ((newAssignment = selectNewAssignment()) == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }

            // initialize start time for stats
            if (updateStart == 0)
                updateStart = System.currentTimeMillis();

            // reserve the assignment and take work items
            ops = takeAssignment(newAssignment);

            // keep stats
            if (ops != null) {
                for (Iterator it = ops.iterator(); it.hasNext();) {
                    Operation op = (Operation) it.next();
                    totalOperationsPending -= op.getCount();
                    dequeuedOperations += op.getCount();
                    if (op.isSignificant()) {
                        significantOpsDequeued += op.getCount();
                    }
                }
                dequeuedItems++;
            }
        }

        return ops;

    }

