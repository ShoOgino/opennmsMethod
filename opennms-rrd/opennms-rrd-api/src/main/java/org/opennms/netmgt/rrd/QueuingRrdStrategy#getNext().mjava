    /**
     * Get the operations for the next file that should be worked on.
     * 
     * @return a linkedList of operations to be processed all for the same file.
     */
    public LinkedList<Operation> getNext() {
        LinkedList<Operation> ops = null;
        synchronized (this) {

            // turn in our previous assignment
            completeAssignment();

            String newAssignment;
            // wait until there is work to do
            while ((newAssignment = selectNewAssignment()) == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }

            // initialize start time for stats
            if (getStartTime() == 0)
                setStartTime(System.currentTimeMillis());

            // reserve the assignment and take work items
            ops = takeAssignment(newAssignment);

            // keep stats
            if (ops != null) {
                for(Operation op : ops) {
                    setTotalOperationsPending(getTotalOperationsPending()-op.getCount());
                    setDequeuedOperations(getDequeuedOperations() + op.getCount());
                    if (op.isSignificant()) {
                    	setSignificantOpsDequeued(getSignificantOpsDequeued() + op.getCount());
                    }
                }
                setDequeuedItems(getDequeuedItems() + 1);
            }
        }

        return ops;

    }

