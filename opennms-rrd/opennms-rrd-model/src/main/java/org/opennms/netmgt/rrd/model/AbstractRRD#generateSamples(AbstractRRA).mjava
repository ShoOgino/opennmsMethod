    /**
     * Generate raw samples.
     *
     * @param rra the source RRA to be used (it must have AVERAGE for its consolidation function)
     * @return the samples for the given RRA
     */
    public NavigableMap<Long, List<Double>> generateSamples(AbstractRRA rra) {
        long step = rra.getPdpPerRow() * getStep();
        long start = getStartTimestamp(rra);
        long end = getEndTimestamp(rra);

        // Initialize Values Map
        NavigableMap<Long, List<Double>> valuesMap = new TreeMap<>();
        for (long ts = start; ts <= end; ts+= step) {
            List<Double> values = new ArrayList<>();
            for (int i=0; i<getDataSources().size(); i++) {
                values.add(Double.NaN);
            }
            valuesMap.put(ts, values);
        }

        // Initialize Last Values
        List<Double> lastValues = new ArrayList<>();
        for (AbstractDS ds : getDataSources()) {
            Double v = ds.getLastDs() == null ? 0.0 : ds.getLastDs();
            lastValues.add(v - v % step);
        }

        // Set Last-Value for Counters
        for (int i = 0; i < getDataSources().size(); i++) {
            if (getDataSource(i).isCounter()) {
                valuesMap.get(end).set(i, lastValues.get(i));
            }
        }

        // Process
        // Counters must be processed in reverse order (from latest to oldest) in order to recreate the counter raw values
        // The first sample is processed separated because the lastValues must be updated after adding each sample.
        long ts = end - step;
        for (int j = rra.getRows().size() - 1; j >= 0; j--) {
            final Row row = rra.getRows().get(j);

            for (int i = 0; i < getDataSources().size(); i++) {
                if (getDataSource(i).isCounter()) {
                    if (j > 0) {
                        Double last = lastValues.get(i);
                        Double current = row.getValue(i).isNaN() ? 0 : row.getValue(i);
                        Double value = last - (current * step);
                        if (value < 0) { // Counter-Wrap emulation
                            value += Math.pow(2, 64);
                        }
                        lastValues.set(i, value);
                        if (!row.getValue(i).isNaN()) {
                            valuesMap.get(ts).set(i, value);
                        }
                    }
                } else {
                    if (!row.getValue(i).isNaN()) {
                        valuesMap.get(ts + step).set(i, row.getValue(i));
                    }
                }
            }

            ts -= step;
        }

        return valuesMap;
    }

